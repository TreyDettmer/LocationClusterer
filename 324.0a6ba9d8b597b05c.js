(()=>{var eV={1503:(ze,Fe,Y)=>{"use strict";var he=Y(3269);function ye(de){var Me=[1/0,1/0,-1/0,-1/0];return he.coordEach(de,function(H){Me[0]>H[0]&&(Me[0]=H[0]),Me[1]>H[1]&&(Me[1]=H[1]),Me[2]<H[0]&&(Me[2]=H[0]),Me[3]<H[1]&&(Me[3]=H[1])}),Me}ye.default=ye,Fe.Z=ye},8095:ze=>{"use strict";ze.exports={eudist:function(Y,te,he){for(var ye=Y.length,de=0,Me=0;Me<ye;Me++){var H=(Y[Me]||0)-(te[Me]||0);de+=H*H}return he?Math.sqrt(de):de},mandist:function(Y,te,he){for(var ye=Y.length,de=0,Me=0;Me<ye;Me++)de+=Math.abs((Y[Me]||0)-(te[Me]||0));return he?Math.sqrt(de):de},dist:function(Y,te,he){var ye=Math.abs(Y-te);return he?ye:ye*ye}}},945:(ze,Fe,Y)=>{"use strict";var te=Y(8095),he=te.eudist,ye=te.dist;ze.exports={kmrand:function(Me,H){for(var Ye={},Je=[],Ae=H<<2,Le=Me.length,re=Me[0].length>0;Je.length<H&&Ae-- >0;){var ae=Me[Math.floor(Math.random()*Le)],ie=re?ae.join("_"):""+ae;Ye[ie]||(Ye[ie]=!0,Je.push(ae))}if(Je.length<H)throw new Error("Error initializating clusters");return Je},kmpp:function(Me,H){var Ye=Me[0].length?he:ye,Je=[],Ae=Me.length,Le=Me[0].length>0,ae=Me[Math.floor(Math.random()*Ae)];for(Le&&ae.join("_"),Je.push(ae);Je.length<H;){for(var Ue=[],Q=Je.length,pe=0,le=[],xe=0;xe<Ae;xe++){for(var we=1/0,$e=0;$e<Q;$e++){var Ne=Ye(Me[xe],Je[$e]);Ne<=we&&(we=Ne)}Ue[xe]=we}for(var Se=0;Se<Ae;Se++)pe+=Ue[Se];for(var Pe=0;Pe<Ae;Pe++)le[Pe]={i:Pe,v:Me[Pe],pr:Ue[Pe]/pe,cs:0};le.sort(function(He,_e){return He.pr-_e.pr}),le[0].cs=le[0].pr;for(var Z=1;Z<Ae;Z++)le[Z].cs=le[Z-1].cs+le[Z].pr;for(var Be=Math.random(),ue=0;ue<Ae-1&&le[ue++].cs<Be;);Je.push(le[ue-1].v)}return Je}}},5331:(ze,Fe,Y)=>{"use strict";var te=Y(8095),he=Y(945),ye=te.eudist,H=he.kmrand,Ye=he.kmpp;function Ae(re,ae,ie){ie=ie||[];for(var Ue=0;Ue<re;Ue++)ie[Ue]=ae;return ie}ze.exports=function Le(re,ae,ie,Ue){var Q=[],pe=[],le=[],xe=[],we=!1,$e=Ue||1e4,Ne=re.length,Se=re[0].length,Pe=Se>0,Z=[];if(ie)Q="kmrand"==ie?H(re,ae):"kmpp"==ie?Ye(re,ae):ie;else for(var Be={};Q.length<ae;){var ue=Math.floor(Math.random()*Ne);Be[ue]||(Be[ue]=!0,Q.push(re[ue]))}do{Ae(ae,0,Z);for(var He=0;He<Ne;He++){for(var _e=1/0,kt=0,Ct=0;Ct<ae;Ct++)(xe=Pe?ye(re[He],Q[Ct]):Math.abs(re[He]-Q[Ct]))<=_e&&(_e=xe,kt=Ct);le[He]=kt,Z[kt]++}for(var Ke=[],et=(pe=[],0);et<ae;et++)Ke[et]=Pe?Ae(Se,0,Ke[et]):0,pe[et]=Q[et];if(Pe){for(var pt=0;pt<ae;pt++)Q[pt]=[];for(var dt=0;dt<Ne;dt++)for(var zt=Ke[le[dt]],$t=re[dt],tn=0;tn<Se;tn++)zt[tn]+=$t[tn];we=!0;for(var Gt=0;Gt<ae;Gt++){for(var Rn=Q[Gt],Bn=Ke[Gt],kn=pe[Gt],qn=Z[Gt],$n=0;$n<Se;$n++)Rn[$n]=Bn[$n]/qn||0;if(we)for(var Qe=0;Qe<Se;Qe++)if(kn[Qe]!=Rn[Qe]){we=!1;break}}}else{for(var Gi=0;Gi<Ne;Gi++)Ke[le[Gi]]+=re[Gi];for(var ri=0;ri<ae;ri++)Q[ri]=Ke[ri]/Z[ri]||0;we=!0;for(var Yn=0;Yn<ae;Yn++)if(pe[Yn]!=Q[Yn]){we=!1;break}}we=we||--$e<=0}while(!we);return{it:1e4-$e,k:ae,idxs:le,centroids:Q}}},8275:(ze,Fe)=>{"use strict";function Y(ue,He,_e){void 0===_e&&(_e={});var kt={type:"Feature"};return(0===_e.id||_e.id)&&(kt.id=_e.id),_e.bbox&&(kt.bbox=_e.bbox),kt.properties=He||{},kt.geometry=ue,kt}function he(ue,He,_e){if(void 0===_e&&(_e={}),!ue)throw new Error("coordinates is required");if(!Array.isArray(ue))throw new Error("coordinates must be an Array");if(ue.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!Se(ue[0])||!Se(ue[1]))throw new Error("coordinates must contain numbers");return Y({type:"Point",coordinates:ue},He,_e)}function de(ue,He,_e){void 0===_e&&(_e={});for(var kt=0,Ct=ue;kt<Ct.length;kt++){var Ke=Ct[kt];if(Ke.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");for(var rt=0;rt<Ke[Ke.length-1].length;rt++)if(Ke[Ke.length-1][rt]!==Ke[0][rt])throw new Error("First and last Position are not equivalent.")}return Y({type:"Polygon",coordinates:ue},He,_e)}function H(ue,He,_e){if(void 0===_e&&(_e={}),ue.length<2)throw new Error("coordinates must be an array of two or more positions");return Y({type:"LineString",coordinates:ue},He,_e)}function Je(ue,He){void 0===He&&(He={});var _e={type:"FeatureCollection"};return He.id&&(_e.id=He.id),He.bbox&&(_e.bbox=He.bbox),_e.features=ue,_e}function Ae(ue,He,_e){return void 0===_e&&(_e={}),Y({type:"MultiLineString",coordinates:ue},He,_e)}function Le(ue,He,_e){return void 0===_e&&(_e={}),Y({type:"MultiPoint",coordinates:ue},He,_e)}function re(ue,He,_e){return void 0===_e&&(_e={}),Y({type:"MultiPolygon",coordinates:ue},He,_e)}function Ue(ue,He){void 0===He&&(He="kilometers");var _e=Fe.factors[He];if(!_e)throw new Error(He+" units is invalid");return ue*_e}function Q(ue,He){void 0===He&&(He="kilometers");var _e=Fe.factors[He];if(!_e)throw new Error(He+" units is invalid");return ue/_e}function xe(ue){return ue%(2*Math.PI)*180/Math.PI}function Se(ue){return!isNaN(ue)&&null!==ue&&!Array.isArray(ue)}Object.defineProperty(Fe,"__esModule",{value:!0}),Fe.earthRadius=6371008.8,Fe.factors={centimeters:100*Fe.earthRadius,centimetres:100*Fe.earthRadius,degrees:Fe.earthRadius/111325,feet:3.28084*Fe.earthRadius,inches:39.37*Fe.earthRadius,kilometers:Fe.earthRadius/1e3,kilometres:Fe.earthRadius/1e3,meters:Fe.earthRadius,metres:Fe.earthRadius,miles:Fe.earthRadius/1609.344,millimeters:1e3*Fe.earthRadius,millimetres:1e3*Fe.earthRadius,nauticalmiles:Fe.earthRadius/1852,radians:1,yards:1.0936*Fe.earthRadius},Fe.unitsFactors={centimeters:100,centimetres:100,degrees:8982708286548395e-21,feet:3.28084,inches:39.37,kilometers:.001,kilometres:.001,meters:1,metres:1,miles:.0006213711922373339,millimeters:1e3,millimetres:1e3,nauticalmiles:.0005399568034557236,radians:1/Fe.earthRadius,yards:1.0936133},Fe.areaFactors={acres:247105e-9,centimeters:1e4,centimetres:1e4,feet:10.763910417,hectares:1e-4,inches:1550.003100006,kilometers:1e-6,kilometres:1e-6,meters:1,metres:1,miles:386e-9,millimeters:1e6,millimetres:1e6,yards:1.195990046},Fe.feature=Y,Fe.geometry=function te(ue,He,_e){switch(void 0===_e&&(_e={}),ue){case"Point":return he(He).geometry;case"LineString":return H(He).geometry;case"Polygon":return de(He).geometry;case"MultiPoint":return Le(He).geometry;case"MultiLineString":return Ae(He).geometry;case"MultiPolygon":return re(He).geometry;default:throw new Error(ue+" is invalid")}},Fe.point=he,Fe.points=function ye(ue,He,_e){return void 0===_e&&(_e={}),Je(ue.map(function(kt){return he(kt,He)}),_e)},Fe.polygon=de,Fe.polygons=function Me(ue,He,_e){return void 0===_e&&(_e={}),Je(ue.map(function(kt){return de(kt,He)}),_e)},Fe.lineString=H,Fe.lineStrings=function Ye(ue,He,_e){return void 0===_e&&(_e={}),Je(ue.map(function(kt){return H(kt,He)}),_e)},Fe.featureCollection=Je,Fe.multiLineString=Ae,Fe.multiPoint=Le,Fe.multiPolygon=re,Fe.geometryCollection=function ae(ue,He,_e){return void 0===_e&&(_e={}),Y({type:"GeometryCollection",geometries:ue},He,_e)},Fe.round=function ie(ue,He){if(void 0===He&&(He=0),He&&!(He>=0))throw new Error("precision must be a positive number");var _e=Math.pow(10,He||0);return Math.round(ue*_e)/_e},Fe.radiansToLength=Ue,Fe.lengthToRadians=Q,Fe.lengthToDegrees=function pe(ue,He){return xe(Q(ue,He))},Fe.bearingToAzimuth=function le(ue){var He=ue%360;return He<0&&(He+=360),He},Fe.radiansToDegrees=xe,Fe.degreesToRadians=function we(ue){return ue%360*Math.PI/180},Fe.convertLength=function $e(ue,He,_e){if(void 0===He&&(He="kilometers"),void 0===_e&&(_e="kilometers"),!(ue>=0))throw new Error("length must be a positive number");return Ue(Q(ue,He),_e)},Fe.convertArea=function Ne(ue,He,_e){if(void 0===He&&(He="meters"),void 0===_e&&(_e="kilometers"),!(ue>=0))throw new Error("area must be a positive number");var kt=Fe.areaFactors[He];if(!kt)throw new Error("invalid original units");var Ct=Fe.areaFactors[_e];if(!Ct)throw new Error("invalid final units");return ue/kt*Ct},Fe.isNumber=Se,Fe.isObject=function Pe(ue){return!!ue&&ue.constructor===Object},Fe.validateBBox=function Z(ue){if(!ue)throw new Error("bbox is required");if(!Array.isArray(ue))throw new Error("bbox must be an Array");if(4!==ue.length&&6!==ue.length)throw new Error("bbox must be an Array of 4 or 6 numbers");ue.forEach(function(He){if(!Se(He))throw new Error("bbox must only contain numbers")})},Fe.validateId=function Be(ue){if(!ue)throw new Error("id is required");if(-1===["string","number"].indexOf(typeof ue))throw new Error("id must be a number or a string")}},3269:(ze,Fe,Y)=>{"use strict";Object.defineProperty(Fe,"__esModule",{value:!0});var te=Y(8275);function he(we,$e,Ne){if(null!==we)for(var Se,Pe,Z,Be,ue,He,_e,Ke,kt=0,Ct=0,rt=we.type,et="FeatureCollection"===rt,pt="Feature"===rt,dt=et?we.features.length:1,je=0;je<dt;je++){ue=(Ke=!!(_e=et?we.features[je].geometry:pt?we.geometry:we)&&"GeometryCollection"===_e.type)?_e.geometries.length:1;for(var zt=0;zt<ue;zt++){var $t=0,tn=0;if(null!==(Be=Ke?_e.geometries[zt]:_e)){He=Be.coordinates;var Gt=Be.type;switch(kt=!Ne||"Polygon"!==Gt&&"MultiPolygon"!==Gt?0:1,Gt){case null:break;case"Point":if(!1===$e(He,Ct,je,$t,tn))return!1;Ct++,$t++;break;case"LineString":case"MultiPoint":for(Se=0;Se<He.length;Se++){if(!1===$e(He[Se],Ct,je,$t,tn))return!1;Ct++,"MultiPoint"===Gt&&$t++}"LineString"===Gt&&$t++;break;case"Polygon":case"MultiLineString":for(Se=0;Se<He.length;Se++){for(Pe=0;Pe<He[Se].length-kt;Pe++){if(!1===$e(He[Se][Pe],Ct,je,$t,tn))return!1;Ct++}"MultiLineString"===Gt&&$t++,"Polygon"===Gt&&tn++}"Polygon"===Gt&&$t++;break;case"MultiPolygon":for(Se=0;Se<He.length;Se++){for(tn=0,Pe=0;Pe<He[Se].length;Pe++){for(Z=0;Z<He[Se][Pe].length-kt;Z++){if(!1===$e(He[Se][Pe][Z],Ct,je,$t,tn))return!1;Ct++}tn++}$t++}break;case"GeometryCollection":for(Se=0;Se<Be.geometries.length;Se++)if(!1===he(Be.geometries[Se],$e,Ne))return!1;break;default:throw new Error("Unknown Geometry Type")}}}}}function de(we,$e){var Ne;switch(we.type){case"FeatureCollection":for(Ne=0;Ne<we.features.length&&!1!==$e(we.features[Ne].properties,Ne);Ne++);break;case"Feature":$e(we.properties,0)}}function H(we,$e){if("Feature"===we.type)$e(we,0);else if("FeatureCollection"===we.type)for(var Ne=0;Ne<we.features.length&&!1!==$e(we.features[Ne],Ne);Ne++);}function Ae(we,$e){var Ne,Se,Pe,Z,Be,ue,He,_e,kt,Ct,Ke=0,rt="FeatureCollection"===we.type,et="Feature"===we.type,pt=rt?we.features.length:1;for(Ne=0;Ne<pt;Ne++){for(_e=rt?we.features[Ne].properties:et?we.properties:{},kt=rt?we.features[Ne].bbox:et?we.bbox:void 0,Ct=rt?we.features[Ne].id:et?we.id:void 0,Be=(He=!!(ue=rt?we.features[Ne].geometry:et?we.geometry:we)&&"GeometryCollection"===ue.type)?ue.geometries.length:1,Pe=0;Pe<Be;Pe++)if(null!==(Z=He?ue.geometries[Pe]:ue))switch(Z.type){case"Point":case"LineString":case"MultiPoint":case"Polygon":case"MultiLineString":case"MultiPolygon":if(!1===$e(Z,Ke,_e,kt,Ct))return!1;break;case"GeometryCollection":for(Se=0;Se<Z.geometries.length;Se++)if(!1===$e(Z.geometries[Se],Ke,_e,kt,Ct))return!1;break;default:throw new Error("Unknown Geometry Type")}else if(!1===$e(null,Ke,_e,kt,Ct))return!1;Ke++}}function re(we,$e){Ae(we,function(Ne,Se,Pe,Z,Be){var He,ue=null===Ne?null:Ne.type;switch(ue){case null:case"Point":case"LineString":case"Polygon":return!1!==$e(te.feature(Ne,Pe,{bbox:Z,id:Be}),Se,0)&&void 0}switch(ue){case"MultiPoint":He="Point";break;case"MultiLineString":He="LineString";break;case"MultiPolygon":He="Polygon"}for(var _e=0;_e<Ne.coordinates.length;_e++)if(!1===$e(te.feature({type:He,coordinates:Ne.coordinates[_e]},Pe),Se,_e))return!1})}function ie(we,$e){re(we,function(Ne,Se,Pe){var Z=0;if(Ne.geometry){var Be=Ne.geometry.type;if("Point"!==Be&&"MultiPoint"!==Be){var ue,He=0,_e=0,kt=0;if(!1===he(Ne,function(Ct,Ke,rt,et,pt){if(void 0===ue||Se>He||et>_e||pt>kt)return ue=Ct,He=Se,_e=et,kt=pt,void(Z=0);var dt=te.lineString([ue,Ct],Ne.properties);if(!1===$e(dt,Se,Pe,pt,Z))return!1;Z++,ue=Ct}))return!1}}})}function Q(we,$e){if(!we)throw new Error("geojson is required");re(we,function(Ne,Se,Pe){if(null!==Ne.geometry){var Be=Ne.geometry.coordinates;switch(Ne.geometry.type){case"LineString":if(!1===$e(Ne,Se,Pe,0,0))return!1;break;case"Polygon":for(var ue=0;ue<Be.length;ue++)if(!1===$e(te.lineString(Be[ue],Ne.properties),Se,Pe,ue))return!1}}})}Fe.coordAll=function Je(we){var $e=[];return he(we,function(Ne){$e.push(Ne)}),$e},Fe.coordEach=he,Fe.coordReduce=function ye(we,$e,Ne,Se){var Pe=Ne;return he(we,function(Z,Be,ue,He,_e){Pe=0===Be&&void 0===Ne?Z:$e(Pe,Z,Be,ue,He,_e)},Se),Pe},Fe.featureEach=H,Fe.featureReduce=function Ye(we,$e,Ne){var Se=Ne;return H(we,function(Pe,Z){Se=0===Z&&void 0===Ne?Pe:$e(Se,Pe,Z)}),Se},Fe.findPoint=function xe(we,$e){if(!te.isObject($e=$e||{}))throw new Error("options is invalid");var ue,Ne=$e.featureIndex||0,Se=$e.multiFeatureIndex||0,Pe=$e.geometryIndex||0,Z=$e.coordIndex||0,Be=$e.properties;switch(we.type){case"FeatureCollection":Ne<0&&(Ne=we.features.length+Ne),Be=Be||we.features[Ne].properties,ue=we.features[Ne].geometry;break;case"Feature":Be=Be||we.properties,ue=we.geometry;break;case"Point":case"MultiPoint":return null;case"LineString":case"Polygon":case"MultiLineString":case"MultiPolygon":ue=we;break;default:throw new Error("geojson is invalid")}if(null===ue)return null;var He=ue.coordinates;switch(ue.type){case"Point":return te.point(He,Be,$e);case"MultiPoint":return Se<0&&(Se=He.length+Se),te.point(He[Se],Be,$e);case"LineString":return Z<0&&(Z=He.length+Z),te.point(He[Z],Be,$e);case"Polygon":return Pe<0&&(Pe=He.length+Pe),Z<0&&(Z=He[Pe].length+Z),te.point(He[Pe][Z],Be,$e);case"MultiLineString":return Se<0&&(Se=He.length+Se),Z<0&&(Z=He[Se].length+Z),te.point(He[Se][Z],Be,$e);case"MultiPolygon":return Se<0&&(Se=He.length+Se),Pe<0&&(Pe=He[Se].length+Pe),Z<0&&(Z=He[Se][Pe].length-Z),te.point(He[Se][Pe][Z],Be,$e)}throw new Error("geojson is invalid")},Fe.findSegment=function le(we,$e){if(!te.isObject($e=$e||{}))throw new Error("options is invalid");var ue,Ne=$e.featureIndex||0,Se=$e.multiFeatureIndex||0,Pe=$e.geometryIndex||0,Z=$e.segmentIndex||0,Be=$e.properties;switch(we.type){case"FeatureCollection":Ne<0&&(Ne=we.features.length+Ne),Be=Be||we.features[Ne].properties,ue=we.features[Ne].geometry;break;case"Feature":Be=Be||we.properties,ue=we.geometry;break;case"Point":case"MultiPoint":return null;case"LineString":case"Polygon":case"MultiLineString":case"MultiPolygon":ue=we;break;default:throw new Error("geojson is invalid")}if(null===ue)return null;var He=ue.coordinates;switch(ue.type){case"Point":case"MultiPoint":return null;case"LineString":return Z<0&&(Z=He.length+Z-1),te.lineString([He[Z],He[Z+1]],Be,$e);case"Polygon":return Pe<0&&(Pe=He.length+Pe),Z<0&&(Z=He[Pe].length+Z-1),te.lineString([He[Pe][Z],He[Pe][Z+1]],Be,$e);case"MultiLineString":return Se<0&&(Se=He.length+Se),Z<0&&(Z=He[Se].length+Z-1),te.lineString([He[Se][Z],He[Se][Z+1]],Be,$e);case"MultiPolygon":return Se<0&&(Se=He.length+Se),Pe<0&&(Pe=He[Se].length+Pe),Z<0&&(Z=He[Se][Pe].length-Z-1),te.lineString([He[Se][Pe][Z],He[Se][Pe][Z+1]],Be,$e)}throw new Error("geojson is invalid")},Fe.flattenEach=re,Fe.flattenReduce=function ae(we,$e,Ne){var Se=Ne;return re(we,function(Pe,Z,Be){Se=0===Z&&0===Be&&void 0===Ne?Pe:$e(Se,Pe,Z,Be)}),Se},Fe.geomEach=Ae,Fe.geomReduce=function Le(we,$e,Ne){var Se=Ne;return Ae(we,function(Pe,Z,Be,ue,He){Se=0===Z&&void 0===Ne?Pe:$e(Se,Pe,Z,Be,ue,He)}),Se},Fe.lineEach=Q,Fe.lineReduce=function pe(we,$e,Ne){var Se=Ne;return Q(we,function(Pe,Z,Be,ue){Se=0===Z&&void 0===Ne?Pe:$e(Se,Pe,Z,Be,ue)}),Se},Fe.propEach=de,Fe.propReduce=function Me(we,$e,Ne){var Se=Ne;return de(we,function(Pe,Z){Se=0===Z&&void 0===Ne?Pe:$e(Se,Pe,Z)}),Se},Fe.segmentEach=ie,Fe.segmentReduce=function Ue(we,$e,Ne){var Se=Ne,Pe=!1;return ie(we,function(Z,Be,ue,He,_e){Se=!1===Pe&&void 0===Ne?Z:$e(Se,Z,Be,ue,He,_e),Pe=!0}),Se}},5834:(ze,Fe,Y)=>{"use strict";var te=Y(5203),he=Y(5685),ye=he(te("String.prototype.indexOf"));ze.exports=function(Me,H){var Ye=te(Me,!!H);return"function"==typeof Ye&&ye(Me,".prototype.")>-1?he(Ye):Ye}},5685:(ze,Fe,Y)=>{"use strict";var te=Y(4444),he=Y(5203),ye=he("%Function.prototype.apply%"),de=he("%Function.prototype.call%"),Me=he("%Reflect.apply%",!0)||te.call(de,ye),H=he("%Object.getOwnPropertyDescriptor%",!0),Ye=he("%Object.defineProperty%",!0),Je=he("%Math.max%");if(Ye)try{Ye({},"a",{value:1})}catch{Ye=null}ze.exports=function(re){var ae=Me(te,de,arguments);return H&&Ye&&H(ae,"length").configurable&&Ye(ae,"length",{value:1+Je(0,re.length-(arguments.length-1))}),ae};var Ae=function(){return Me(te,ye,arguments)};Ye?Ye(ze.exports,"apply",{value:Ae}):ze.exports.apply=Ae},1006:function(ze,Fe){var te;!function(he){"use strict";var ye=Math.cosh||function(re){return Math.abs(re)<1e-9?1-re:.5*(Math.exp(re)+Math.exp(-re))},de=Math.sinh||function(re){return Math.abs(re)<1e-9?re:.5*(Math.exp(re)-Math.exp(-re))},Ye=function(){throw SyntaxError("Invalid Param")};function Je(re,ae){var ie=Math.abs(re),Ue=Math.abs(ae);return 0===re?Math.log(Ue):0===ae?Math.log(ie):ie<3e3&&Ue<3e3?.5*Math.log(re*re+ae*ae):(re/=2,ae/=2,.5*Math.log(re*re+ae*ae)+Math.LN2)}var Ae=function(re,ae){var ie={re:0,im:0};if(null==re)ie.re=ie.im=0;else if(void 0!==ae)ie.re=re,ie.im=ae;else switch(typeof re){case"object":if("im"in re&&"re"in re)ie.re=re.re,ie.im=re.im;else if("abs"in re&&"arg"in re){if(!Number.isFinite(re.abs)&&Number.isFinite(re.arg))return Le.INFINITY;ie.re=re.abs*Math.cos(re.arg),ie.im=re.abs*Math.sin(re.arg)}else if("r"in re&&"phi"in re){if(!Number.isFinite(re.r)&&Number.isFinite(re.phi))return Le.INFINITY;ie.re=re.r*Math.cos(re.phi),ie.im=re.r*Math.sin(re.phi)}else 2===re.length?(ie.re=re[0],ie.im=re[1]):Ye();break;case"string":ie.im=ie.re=0;var Ue=re.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g),Q=1,pe=0;null===Ue&&Ye();for(var le=0;le<Ue.length;le++){var xe=Ue[le];" "===xe||"\t"===xe||"\n"===xe||("+"===xe?Q++:"-"===xe?pe++:"i"===xe||"I"===xe?(Q+pe===0&&Ye()," "===Ue[le+1]||isNaN(Ue[le+1])?ie.im+=parseFloat((pe%2?"-":"")+"1"):(ie.im+=parseFloat((pe%2?"-":"")+Ue[le+1]),le++),Q=pe=0):((Q+pe===0||isNaN(xe))&&Ye(),"i"===Ue[le+1]||"I"===Ue[le+1]?(ie.im+=parseFloat((pe%2?"-":"")+xe),le++):ie.re+=parseFloat((pe%2?"-":"")+xe),Q=pe=0))}Q+pe>0&&Ye();break;case"number":ie.im=0,ie.re=re;break;default:Ye()}return isNaN(ie.re)||isNaN(ie.im),ie};function Le(re,ae){if(!(this instanceof Le))return new Le(re,ae);var ie=Ae(re,ae);this.re=ie.re,this.im=ie.im}Le.prototype={re:0,im:0,sign:function(){var re=this.abs();return new Le(this.re/re,this.im/re)},add:function(re,ae){var ie=new Le(re,ae);return this.isInfinite()&&ie.isInfinite()?Le.NAN:this.isInfinite()||ie.isInfinite()?Le.INFINITY:new Le(this.re+ie.re,this.im+ie.im)},sub:function(re,ae){var ie=new Le(re,ae);return this.isInfinite()&&ie.isInfinite()?Le.NAN:this.isInfinite()||ie.isInfinite()?Le.INFINITY:new Le(this.re-ie.re,this.im-ie.im)},mul:function(re,ae){var ie=new Le(re,ae);return this.isInfinite()&&ie.isZero()||this.isZero()&&ie.isInfinite()?Le.NAN:this.isInfinite()||ie.isInfinite()?Le.INFINITY:0===ie.im&&0===this.im?new Le(this.re*ie.re,0):new Le(this.re*ie.re-this.im*ie.im,this.re*ie.im+this.im*ie.re)},div:function(re,ae){var ie=new Le(re,ae);if(this.isZero()&&ie.isZero()||this.isInfinite()&&ie.isInfinite())return Le.NAN;if(this.isInfinite()||ie.isZero())return Le.INFINITY;if(this.isZero()||ie.isInfinite())return Le.ZERO;re=this.re,ae=this.im;var pe,le,Ue=ie.re,Q=ie.im;return 0===Q?new Le(re/Ue,ae/Ue):Math.abs(Ue)<Math.abs(Q)?new Le((re*(le=Ue/Q)+ae)/(pe=Ue*le+Q),(ae*le-re)/pe):new Le((re+ae*(le=Q/Ue))/(pe=Q*le+Ue),(ae-re*le)/pe)},pow:function(re,ae){var ie=new Le(re,ae);if(re=this.re,ae=this.im,ie.isZero())return Le.ONE;if(0===ie.im){if(0===ae&&re>0)return new Le(Math.pow(re,ie.re),0);if(0===re)switch((ie.re%4+4)%4){case 0:return new Le(Math.pow(ae,ie.re),0);case 1:return new Le(0,Math.pow(ae,ie.re));case 2:return new Le(-Math.pow(ae,ie.re),0);case 3:return new Le(0,-Math.pow(ae,ie.re))}}if(0===re&&0===ae&&ie.re>0&&ie.im>=0)return Le.ZERO;var Ue=Math.atan2(ae,re),Q=Je(re,ae);return re=Math.exp(ie.re*Q-ie.im*Ue),ae=ie.im*Q+ie.re*Ue,new Le(re*Math.cos(ae),re*Math.sin(ae))},sqrt:function(){var Ue,Q,re=this.re,ae=this.im,ie=this.abs();if(re>=0){if(0===ae)return new Le(Math.sqrt(re),0);Ue=.5*Math.sqrt(2*(ie+re))}else Ue=Math.abs(ae)/Math.sqrt(2*(ie-re));return Q=re<=0?.5*Math.sqrt(2*(ie-re)):Math.abs(ae)/Math.sqrt(2*(ie+re)),new Le(Ue,ae<0?-Q:Q)},exp:function(){var re=Math.exp(this.re);return new Le(re*Math.cos(this.im),re*Math.sin(this.im))},expm1:function(){var re=this.re,ae=this.im;return new Le(Math.expm1(re)*Math.cos(ae)+function(re){var ae=Math.PI/4;if(-ae>re||re>ae)return Math.cos(re)-1;var ie=re*re;return ie*(ie*(ie*(ie*(ie*(ie*(ie*(ie/20922789888e3-1/87178291200)+1/479001600)-1/3628800)+1/40320)-1/720)+1/24)-.5)}(ae),Math.exp(re)*Math.sin(ae))},log:function(){var re=this.re,ae=this.im;return new Le(Je(re,ae),Math.atan2(ae,re))},abs:function(){return re=this.re,ae=this.im,ie=Math.abs(re),Ue=Math.abs(ae),ie<3e3&&Ue<3e3?Math.sqrt(ie*ie+Ue*Ue):(ie<Ue?(ie=Ue,Ue=re/ae):Ue=ae/re,ie*Math.sqrt(1+Ue*Ue));var re,ae,ie,Ue},arg:function(){return Math.atan2(this.im,this.re)},sin:function(){var re=this.re,ae=this.im;return new Le(Math.sin(re)*ye(ae),Math.cos(re)*de(ae))},cos:function(){var re=this.re,ae=this.im;return new Le(Math.cos(re)*ye(ae),-Math.sin(re)*de(ae))},tan:function(){var re=2*this.re,ae=2*this.im,ie=Math.cos(re)+ye(ae);return new Le(Math.sin(re)/ie,de(ae)/ie)},cot:function(){var re=2*this.re,ae=2*this.im,ie=Math.cos(re)-ye(ae);return new Le(-Math.sin(re)/ie,de(ae)/ie)},sec:function(){var re=this.re,ae=this.im,ie=.5*ye(2*ae)+.5*Math.cos(2*re);return new Le(Math.cos(re)*ye(ae)/ie,Math.sin(re)*de(ae)/ie)},csc:function(){var re=this.re,ae=this.im,ie=.5*ye(2*ae)-.5*Math.cos(2*re);return new Le(Math.sin(re)*ye(ae)/ie,-Math.cos(re)*de(ae)/ie)},asin:function(){var re=this.re,ae=this.im,ie=new Le(ae*ae-re*re+1,-2*re*ae).sqrt(),Ue=new Le(ie.re-ae,ie.im+re).log();return new Le(Ue.im,-Ue.re)},acos:function(){var re=this.re,ae=this.im,ie=new Le(ae*ae-re*re+1,-2*re*ae).sqrt(),Ue=new Le(ie.re-ae,ie.im+re).log();return new Le(Math.PI/2-Ue.im,Ue.re)},atan:function(){var re=this.re,ae=this.im;if(0===re){if(1===ae)return new Le(0,1/0);if(-1===ae)return new Le(0,-1/0)}var ie=re*re+(1-ae)*(1-ae),Ue=new Le((1-ae*ae-re*re)/ie,-2*re/ie).log();return new Le(-.5*Ue.im,.5*Ue.re)},acot:function(){var re=this.re,ae=this.im;if(0===ae)return new Le(Math.atan2(1,re),0);var ie=re*re+ae*ae;return 0!==ie?new Le(re/ie,-ae/ie).atan():new Le(0!==re?re/0:0,0!==ae?-ae/0:0).atan()},asec:function(){var re=this.re,ae=this.im;if(0===re&&0===ae)return new Le(0,1/0);var ie=re*re+ae*ae;return 0!==ie?new Le(re/ie,-ae/ie).acos():new Le(0!==re?re/0:0,0!==ae?-ae/0:0).acos()},acsc:function(){var re=this.re,ae=this.im;if(0===re&&0===ae)return new Le(Math.PI/2,1/0);var ie=re*re+ae*ae;return 0!==ie?new Le(re/ie,-ae/ie).asin():new Le(0!==re?re/0:0,0!==ae?-ae/0:0).asin()},sinh:function(){var re=this.re,ae=this.im;return new Le(de(re)*Math.cos(ae),ye(re)*Math.sin(ae))},cosh:function(){var re=this.re,ae=this.im;return new Le(ye(re)*Math.cos(ae),de(re)*Math.sin(ae))},tanh:function(){var re=2*this.re,ae=2*this.im,ie=ye(re)+Math.cos(ae);return new Le(de(re)/ie,Math.sin(ae)/ie)},coth:function(){var re=2*this.re,ae=2*this.im,ie=ye(re)-Math.cos(ae);return new Le(de(re)/ie,-Math.sin(ae)/ie)},csch:function(){var re=this.re,ae=this.im,ie=Math.cos(2*ae)-ye(2*re);return new Le(-2*de(re)*Math.cos(ae)/ie,2*ye(re)*Math.sin(ae)/ie)},sech:function(){var re=this.re,ae=this.im,ie=Math.cos(2*ae)+ye(2*re);return new Le(2*ye(re)*Math.cos(ae)/ie,-2*de(re)*Math.sin(ae)/ie)},asinh:function(){var re=this.im;this.im=-this.re,this.re=re;var ae=this.asin();return this.re=-this.im,this.im=re,re=ae.re,ae.re=-ae.im,ae.im=re,ae},acosh:function(){var re=this.acos();if(re.im<=0){var ae=re.re;re.re=-re.im,re.im=ae}else ae=re.im,re.im=-re.re,re.re=ae;return re},atanh:function(){var re=this.re,ae=this.im,ie=re>1&&0===ae,Ue=1-re,Q=1+re,pe=Ue*Ue+ae*ae,le=0!==pe?new Le((Q*Ue-ae*ae)/pe,(ae*Ue+Q*ae)/pe):new Le(-1!==re?re/0:0,0!==ae?ae/0:0),xe=le.re;return le.re=Je(le.re,le.im)/2,le.im=Math.atan2(le.im,xe)/2,ie&&(le.im=-le.im),le},acoth:function(){var re=this.re,ae=this.im;if(0===re&&0===ae)return new Le(0,Math.PI/2);var ie=re*re+ae*ae;return 0!==ie?new Le(re/ie,-ae/ie).atanh():new Le(0!==re?re/0:0,0!==ae?-ae/0:0).atanh()},acsch:function(){var re=this.re,ae=this.im;if(0===ae)return new Le(0!==re?Math.log(re+Math.sqrt(re*re+1)):1/0,0);var ie=re*re+ae*ae;return 0!==ie?new Le(re/ie,-ae/ie).asinh():new Le(0!==re?re/0:0,0!==ae?-ae/0:0).asinh()},asech:function(){var re=this.re,ae=this.im;if(this.isZero())return Le.INFINITY;var ie=re*re+ae*ae;return 0!==ie?new Le(re/ie,-ae/ie).acosh():new Le(0!==re?re/0:0,0!==ae?-ae/0:0).acosh()},inverse:function(){if(this.isZero())return Le.INFINITY;if(this.isInfinite())return Le.ZERO;var re=this.re,ae=this.im,ie=re*re+ae*ae;return new Le(re/ie,-ae/ie)},conjugate:function(){return new Le(this.re,-this.im)},neg:function(){return new Le(-this.re,-this.im)},ceil:function(re){return re=Math.pow(10,re||0),new Le(Math.ceil(this.re*re)/re,Math.ceil(this.im*re)/re)},floor:function(re){return re=Math.pow(10,re||0),new Le(Math.floor(this.re*re)/re,Math.floor(this.im*re)/re)},round:function(re){return re=Math.pow(10,re||0),new Le(Math.round(this.re*re)/re,Math.round(this.im*re)/re)},equals:function(re,ae){var ie=new Le(re,ae);return Math.abs(ie.re-this.re)<=Le.EPSILON&&Math.abs(ie.im-this.im)<=Le.EPSILON},clone:function(){return new Le(this.re,this.im)},toString:function(){var re=this.re,ae=this.im,ie="";return this.isNaN()?"NaN":this.isInfinite()?"Infinity":(Math.abs(re)<Le.EPSILON&&(re=0),Math.abs(ae)<Le.EPSILON&&(ae=0),0===ae?ie+re:(0!==re?(ie+=re,ie+=" ",ae<0?(ae=-ae,ie+="-"):ie+="+",ie+=" "):ae<0&&(ae=-ae,ie+="-"),1!==ae&&(ie+=ae),ie+"i"))},toVector:function(){return[this.re,this.im]},valueOf:function(){return 0===this.im?this.re:null},isNaN:function(){return isNaN(this.re)||isNaN(this.im)},isZero:function(){return 0===this.im&&0===this.re},isFinite:function(){return isFinite(this.re)&&isFinite(this.im)},isInfinite:function(){return!(this.isNaN()||this.isFinite())}},Le.ZERO=new Le(0,0),Le.ONE=new Le(1,0),Le.I=new Le(0,1),Le.PI=new Le(Math.PI,0),Le.E=new Le(Math.E,0),Le.INFINITY=new Le(1/0,1/0),Le.NAN=new Le(NaN,NaN),Le.EPSILON=1e-15,void 0!==(te=function(){return Le}.apply(Fe,[]))&&(ze.exports=te)}()},1335:(ze,Fe,Y)=>{"use strict";var te=Y(3156),he=Y(7253),ye=Y(3870),de=Y(7563).orient2d;function Me(Ne,Se,Pe){Se=Math.max(0,void 0===Se?2:Se),Pe=Pe||0;var Z=function Ue(Ne){for(var Se=Ne[0],Pe=Ne[0],Z=Ne[0],Be=Ne[0],ue=0;ue<Ne.length;ue++){var He=Ne[ue];He[0]<Se[0]&&(Se=He),He[0]>Z[0]&&(Z=He),He[1]<Pe[1]&&(Pe=He),He[1]>Be[1]&&(Be=He)}var _e=[Se,Pe,Z,Be],kt=_e.slice();for(ue=0;ue<Ne.length;ue++)ye(Ne[ue],_e)||kt.push(Ne[ue]);return function $e(Ne){Ne.sort(we);for(var Se=[],Pe=0;Pe<Ne.length;Pe++){for(;Se.length>=2&&re(Se[Se.length-2],Se[Se.length-1],Ne[Pe])<=0;)Se.pop();Se.push(Ne[Pe])}for(var Z=[],Be=Ne.length-1;Be>=0;Be--){for(;Z.length>=2&&re(Z[Z.length-2],Z[Z.length-1],Ne[Be])<=0;)Z.pop();Z.push(Ne[Be])}return Z.pop(),Se.pop(),Se.concat(Z)}(kt)}(Ne),Be=new te(16);Be.toBBox=function(tn){return{minX:tn[0],minY:tn[1],maxX:tn[0],maxY:tn[1]}},Be.compareMinX=function(tn,Gt){return tn[0]-Gt[0]},Be.compareMinY=function(tn,Gt){return tn[1]-Gt[1]},Be.load(Ne);for(var _e,ue=[],He=0;He<Z.length;He++){var kt=Z[He];Be.remove(kt),_e=Q(kt,_e),ue.push(_e)}var Ct=new te(16);for(He=0;He<ue.length;He++)Ct.insert(ie(ue[He]));for(var Ke=Se*Se,rt=Pe*Pe;ue.length;){var et=ue.shift(),pt=et.p,dt=et.next.p,je=pe(pt,dt);if(!(je<rt)){var zt=je/Ke;(kt=H(Be,et.prev.p,pt,dt,et.next.next.p,zt,Ct))&&Math.min(pe(kt,pt),pe(kt,dt))<=zt&&(ue.push(et),ue.push(Q(kt,et)),Be.remove(kt),Ct.remove(et),Ct.insert(ie(et)),Ct.insert(ie(et.next)))}}et=_e;var $t=[];do{$t.push(et.p),et=et.next}while(et!==_e);return $t.push(et.p),$t}function H(Ne,Se,Pe,Z,Be,ue,He){for(var _e=new he([],Ye),kt=Ne.data;kt;){for(var Ct=0;Ct<kt.children.length;Ct++){var Ke=kt.children[Ct],rt=kt.leaf?le(Ke,Pe,Z):Je(Pe,Z,Ke);rt>ue||_e.push({node:Ke,dist:rt})}for(;_e.length&&!_e.peek().node.children;){var et=_e.pop(),pt=et.node,dt=le(pt,Se,Pe),je=le(pt,Z,Be);if(et.dist<dt&&et.dist<je&&Le(Pe,pt,He)&&Le(Z,pt,He))return pt}(kt=_e.pop())&&(kt=kt.node)}return null}function Ye(Ne,Se){return Ne.dist-Se.dist}function Je(Ne,Se,Pe){if(Ae(Ne,Pe)||Ae(Se,Pe))return 0;var Z=xe(Ne[0],Ne[1],Se[0],Se[1],Pe.minX,Pe.minY,Pe.maxX,Pe.minY);if(0===Z)return 0;var Be=xe(Ne[0],Ne[1],Se[0],Se[1],Pe.minX,Pe.minY,Pe.minX,Pe.maxY);if(0===Be)return 0;var ue=xe(Ne[0],Ne[1],Se[0],Se[1],Pe.maxX,Pe.minY,Pe.maxX,Pe.maxY);if(0===ue)return 0;var He=xe(Ne[0],Ne[1],Se[0],Se[1],Pe.minX,Pe.maxY,Pe.maxX,Pe.maxY);return 0===He?0:Math.min(Z,Be,ue,He)}function Ae(Ne,Se){return Ne[0]>=Se.minX&&Ne[0]<=Se.maxX&&Ne[1]>=Se.minY&&Ne[1]<=Se.maxY}function Le(Ne,Se,Pe){for(var Z=Math.min(Ne[0],Se[0]),Be=Math.min(Ne[1],Se[1]),ue=Math.max(Ne[0],Se[0]),He=Math.max(Ne[1],Se[1]),_e=Pe.search({minX:Z,minY:Be,maxX:ue,maxY:He}),kt=0;kt<_e.length;kt++)if(ae(_e[kt].p,_e[kt].next.p,Ne,Se))return!1;return!0}function re(Ne,Se,Pe){return de(Ne[0],Ne[1],Se[0],Se[1],Pe[0],Pe[1])}function ae(Ne,Se,Pe,Z){return Ne!==Z&&Se!==Pe&&re(Ne,Se,Pe)>0!=re(Ne,Se,Z)>0&&re(Pe,Z,Ne)>0!=re(Pe,Z,Se)>0}function ie(Ne){var Se=Ne.p,Pe=Ne.next.p;return Ne.minX=Math.min(Se[0],Pe[0]),Ne.minY=Math.min(Se[1],Pe[1]),Ne.maxX=Math.max(Se[0],Pe[0]),Ne.maxY=Math.max(Se[1],Pe[1]),Ne}function Q(Ne,Se){var Pe={p:Ne,prev:null,next:null,minX:0,minY:0,maxX:0,maxY:0};return Se?(Pe.next=Se.next,Pe.prev=Se,Se.next.prev=Pe,Se.next=Pe):(Pe.prev=Pe,Pe.next=Pe),Pe}function pe(Ne,Se){var Pe=Ne[0]-Se[0],Z=Ne[1]-Se[1];return Pe*Pe+Z*Z}function le(Ne,Se,Pe){var Z=Se[0],Be=Se[1],ue=Pe[0]-Z,He=Pe[1]-Be;if(0!==ue||0!==He){var _e=((Ne[0]-Z)*ue+(Ne[1]-Be)*He)/(ue*ue+He*He);_e>1?(Z=Pe[0],Be=Pe[1]):_e>0&&(Z+=ue*_e,Be+=He*_e)}return(ue=Ne[0]-Z)*ue+(He=Ne[1]-Be)*He}function xe(Ne,Se,Pe,Z,Be,ue,He,_e){var Rn,Bn,kn,qn,kt=Pe-Ne,Ct=Z-Se,Ke=He-Be,rt=_e-ue,et=Ne-Be,pt=Se-ue,dt=kt*kt+Ct*Ct,je=kt*Ke+Ct*rt,zt=Ke*Ke+rt*rt,$t=kt*et+Ct*pt,tn=Ke*et+rt*pt,Gt=dt*zt-je*je,$n=Gt,Qe=Gt;0===Gt?(Bn=0,$n=1,qn=tn,Qe=zt):(qn=dt*tn-je*$t,(Bn=je*tn-zt*$t)<0?(Bn=0,qn=tn,Qe=zt):Bn>$n&&(Bn=$n,qn=tn+je,Qe=zt)),qn<0?(qn=0,-$t<0?Bn=0:-$t>dt?Bn=$n:(Bn=-$t,$n=dt)):qn>Qe&&(qn=Qe,-$t+je<0?Bn=0:-$t+je>dt?Bn=$n:(Bn=-$t+je,$n=dt));var Vn=(1-(kn=0===qn?0:qn/Qe))*Be+kn*He-((1-(Rn=0===Bn?0:Bn/$n))*Ne+Rn*Pe),Tt=(1-kn)*ue+kn*_e-((1-Rn)*Se+Rn*Z);return Vn*Vn+Tt*Tt}function we(Ne,Se){return Ne[0]===Se[0]?Ne[1]-Se[1]:Ne[0]-Se[0]}he.default&&(he=he.default),ze.exports=Me,ze.exports.default=Me},3156:function(ze){ze.exports=function(){"use strict";function Fe(Q,pe,le,xe,we){!function $e(Ne,Se,Pe,Z,Be){for(;Z>Pe;){if(Z-Pe>600){var ue=Z-Pe+1,He=Se-Pe+1,_e=Math.log(ue),kt=.5*Math.exp(2*_e/3),Ct=.5*Math.sqrt(_e*kt*(ue-kt)/ue)*(He-ue/2<0?-1:1);$e(Ne,Se,Math.max(Pe,Math.floor(Se-He*kt/ue+Ct)),Math.min(Z,Math.floor(Se+(ue-He)*kt/ue+Ct)),Be)}var et=Ne[Se],pt=Pe,dt=Z;for(Y(Ne,Pe,Se),Be(Ne[Z],et)>0&&Y(Ne,Pe,Z);pt<dt;){for(Y(Ne,pt,dt),pt++,dt--;Be(Ne[pt],et)<0;)pt++;for(;Be(Ne[dt],et)>0;)dt--}0===Be(Ne[Pe],et)?Y(Ne,Pe,dt):Y(Ne,++dt,Z),dt<=Se&&(Pe=dt+1),Se<=dt&&(Z=dt-1)}}(Q,pe,le||0,xe||Q.length-1,we||te)}function Y(Q,pe,le){var xe=Q[pe];Q[pe]=Q[le],Q[le]=xe}function te(Q,pe){return Q<pe?-1:Q>pe?1:0}var he=function(Q){void 0===Q&&(Q=9),this._maxEntries=Math.max(4,Q),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function ye(Q,pe,le){if(!le)return pe.indexOf(Q);for(var xe=0;xe<pe.length;xe++)if(le(Q,pe[xe]))return xe;return-1}function de(Q,pe){Me(Q,0,Q.children.length,pe,Q)}function Me(Q,pe,le,xe,we){we||(we=ie(null)),we.minX=1/0,we.minY=1/0,we.maxX=-1/0,we.maxY=-1/0;for(var $e=pe;$e<le;$e++){var Ne=Q.children[$e];H(we,Q.leaf?xe(Ne):Ne)}return we}function H(Q,pe){return Q.minX=Math.min(Q.minX,pe.minX),Q.minY=Math.min(Q.minY,pe.minY),Q.maxX=Math.max(Q.maxX,pe.maxX),Q.maxY=Math.max(Q.maxY,pe.maxY),Q}function Ye(Q,pe){return Q.minX-pe.minX}function Je(Q,pe){return Q.minY-pe.minY}function Ae(Q){return(Q.maxX-Q.minX)*(Q.maxY-Q.minY)}function Le(Q){return Q.maxX-Q.minX+(Q.maxY-Q.minY)}function re(Q,pe){return Q.minX<=pe.minX&&Q.minY<=pe.minY&&pe.maxX<=Q.maxX&&pe.maxY<=Q.maxY}function ae(Q,pe){return pe.minX<=Q.maxX&&pe.minY<=Q.maxY&&pe.maxX>=Q.minX&&pe.maxY>=Q.minY}function ie(Q){return{children:Q,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function Ue(Q,pe,le,xe,we){for(var $e=[pe,le];$e.length;)if(!((le=$e.pop())-(pe=$e.pop())<=xe)){var Ne=pe+Math.ceil((le-pe)/xe/2)*xe;Fe(Q,Ne,pe,le,we),$e.push(pe,Ne,Ne,le)}}return he.prototype.all=function(){return this._all(this.data,[])},he.prototype.search=function(Q){var pe=this.data,le=[];if(!ae(Q,pe))return le;for(var xe=this.toBBox,we=[];pe;){for(var $e=0;$e<pe.children.length;$e++){var Ne=pe.children[$e],Se=pe.leaf?xe(Ne):Ne;ae(Q,Se)&&(pe.leaf?le.push(Ne):re(Q,Se)?this._all(Ne,le):we.push(Ne))}pe=we.pop()}return le},he.prototype.collides=function(Q){var pe=this.data;if(!ae(Q,pe))return!1;for(var le=[];pe;){for(var xe=0;xe<pe.children.length;xe++){var we=pe.children[xe],$e=pe.leaf?this.toBBox(we):we;if(ae(Q,$e)){if(pe.leaf||re(Q,$e))return!0;le.push(we)}}pe=le.pop()}return!1},he.prototype.load=function(Q){if(!Q||!Q.length)return this;if(Q.length<this._minEntries){for(var pe=0;pe<Q.length;pe++)this.insert(Q[pe]);return this}var le=this._build(Q.slice(),0,Q.length-1,0);if(this.data.children.length)if(this.data.height===le.height)this._splitRoot(this.data,le);else{if(this.data.height<le.height){var xe=this.data;this.data=le,le=xe}this._insert(le,this.data.height-le.height-1,!0)}else this.data=le;return this},he.prototype.insert=function(Q){return Q&&this._insert(Q,this.data.height-1),this},he.prototype.clear=function(){return this.data=ie([]),this},he.prototype.remove=function(Q,pe){if(!Q)return this;for(var le,xe,we,$e=this.data,Ne=this.toBBox(Q),Se=[],Pe=[];$e||Se.length;){if($e||($e=Se.pop(),xe=Se[Se.length-1],le=Pe.pop(),we=!0),$e.leaf){var Z=ye(Q,$e.children,pe);if(-1!==Z)return $e.children.splice(Z,1),Se.push($e),this._condense(Se),this}we||$e.leaf||!re($e,Ne)?xe?(le++,$e=xe.children[le],we=!1):$e=null:(Se.push($e),Pe.push(le),le=0,xe=$e,$e=$e.children[0])}return this},he.prototype.toBBox=function(Q){return Q},he.prototype.compareMinX=function(Q,pe){return Q.minX-pe.minX},he.prototype.compareMinY=function(Q,pe){return Q.minY-pe.minY},he.prototype.toJSON=function(){return this.data},he.prototype.fromJSON=function(Q){return this.data=Q,this},he.prototype._all=function(Q,pe){for(var le=[];Q;)Q.leaf?pe.push.apply(pe,Q.children):le.push.apply(le,Q.children),Q=le.pop();return pe},he.prototype._build=function(Q,pe,le,xe){var we,$e=le-pe+1,Ne=this._maxEntries;if($e<=Ne)return de(we=ie(Q.slice(pe,le+1)),this.toBBox),we;xe||(xe=Math.ceil(Math.log($e)/Math.log(Ne)),Ne=Math.ceil($e/Math.pow(Ne,xe-1))),(we=ie([])).leaf=!1,we.height=xe;var Se=Math.ceil($e/Ne),Pe=Se*Math.ceil(Math.sqrt(Ne));Ue(Q,pe,le,Pe,this.compareMinX);for(var Z=pe;Z<=le;Z+=Pe){var Be=Math.min(Z+Pe-1,le);Ue(Q,Z,Be,Se,this.compareMinY);for(var ue=Z;ue<=Be;ue+=Se){var He=Math.min(ue+Se-1,Be);we.children.push(this._build(Q,ue,He,xe-1))}}return de(we,this.toBBox),we},he.prototype._chooseSubtree=function(Q,pe,le,xe){for(;xe.push(pe),!pe.leaf&&xe.length-1!==le;){for(var we=1/0,$e=1/0,Ne=void 0,Se=0;Se<pe.children.length;Se++){var Pe=pe.children[Se],Z=Ae(Pe),Be=(ue=Q,He=Pe,(Math.max(He.maxX,ue.maxX)-Math.min(He.minX,ue.minX))*(Math.max(He.maxY,ue.maxY)-Math.min(He.minY,ue.minY))-Z);Be<$e?($e=Be,we=Z<we?Z:we,Ne=Pe):Be===$e&&Z<we&&(we=Z,Ne=Pe)}pe=Ne||pe.children[0]}var ue,He;return pe},he.prototype._insert=function(Q,pe,le){var xe=le?Q:this.toBBox(Q),we=[],$e=this._chooseSubtree(xe,this.data,pe,we);for($e.children.push(Q),H($e,xe);pe>=0&&we[pe].children.length>this._maxEntries;)this._split(we,pe),pe--;this._adjustParentBBoxes(xe,we,pe)},he.prototype._split=function(Q,pe){var le=Q[pe],xe=le.children.length,we=this._minEntries;this._chooseSplitAxis(le,we,xe);var $e=this._chooseSplitIndex(le,we,xe),Ne=ie(le.children.splice($e,le.children.length-$e));Ne.height=le.height,Ne.leaf=le.leaf,de(le,this.toBBox),de(Ne,this.toBBox),pe?Q[pe-1].children.push(Ne):this._splitRoot(le,Ne)},he.prototype._splitRoot=function(Q,pe){this.data=ie([Q,pe]),this.data.height=Q.height+1,this.data.leaf=!1,de(this.data,this.toBBox)},he.prototype._chooseSplitIndex=function(Q,pe,le){for(var xe,we,$e,Ne,Se,Pe,Z,Be=1/0,ue=1/0,He=pe;He<=le-pe;He++){var _e=Me(Q,0,He,this.toBBox),kt=Me(Q,He,le,this.toBBox),Ct=(we=_e,$e=kt,void 0,void 0,void 0,void 0,Ne=Math.max(we.minX,$e.minX),Se=Math.max(we.minY,$e.minY),Pe=Math.min(we.maxX,$e.maxX),Z=Math.min(we.maxY,$e.maxY),Math.max(0,Pe-Ne)*Math.max(0,Z-Se)),Ke=Ae(_e)+Ae(kt);Ct<Be?(Be=Ct,xe=He,ue=Ke<ue?Ke:ue):Ct===Be&&Ke<ue&&(ue=Ke,xe=He)}return xe||le-pe},he.prototype._chooseSplitAxis=function(Q,pe,le){var xe=Q.leaf?this.compareMinX:Ye,we=Q.leaf?this.compareMinY:Je;this._allDistMargin(Q,pe,le,xe)<this._allDistMargin(Q,pe,le,we)&&Q.children.sort(xe)},he.prototype._allDistMargin=function(Q,pe,le,xe){Q.children.sort(xe);for(var we=this.toBBox,$e=Me(Q,0,pe,we),Ne=Me(Q,le-pe,le,we),Se=Le($e)+Le(Ne),Pe=pe;Pe<le-pe;Pe++){var Z=Q.children[Pe];H($e,Q.leaf?we(Z):Z),Se+=Le($e)}for(var Be=le-pe-1;Be>=pe;Be--){var ue=Q.children[Be];H(Ne,Q.leaf?we(ue):ue),Se+=Le(Ne)}return Se},he.prototype._adjustParentBBoxes=function(Q,pe,le){for(var xe=le;xe>=0;xe--)H(pe[xe],Q)},he.prototype._condense=function(Q){for(var pe=Q.length-1,le=void 0;pe>=0;pe--)0===Q[pe].children.length?pe>0?(le=Q[pe-1].children).splice(le.indexOf(Q[pe]),1):this.clear():de(Q[pe],this.toBBox)},he}()},6952:(ze,Fe,Y)=>{var te=Y(1356),he=Y(3407),ye=Y(2e3),de=Y(2342),Me=Y(9235),H=Y(2374),Ye=Date.prototype.getTime;function Ae(ae){return null==ae}function Le(ae){return!(!ae||"object"!=typeof ae||"number"!=typeof ae.length||"function"!=typeof ae.copy||"function"!=typeof ae.slice||ae.length>0&&"number"!=typeof ae[0])}ze.exports=function Je(ae,ie,Ue){var Q=Ue||{};return!!(Q.strict?ye(ae,ie):ae===ie)||(!ae||!ie||"object"!=typeof ae&&"object"!=typeof ie?Q.strict?ye(ae,ie):ae==ie:function re(ae,ie,Ue){var Q,pe;if(typeof ae!=typeof ie||Ae(ae)||Ae(ie)||ae.prototype!==ie.prototype||he(ae)!==he(ie))return!1;var le=de(ae),xe=de(ie);if(le!==xe)return!1;if(le||xe)return ae.source===ie.source&&Me(ae)===Me(ie);if(H(ae)&&H(ie))return Ye.call(ae)===Ye.call(ie);var we=Le(ae),$e=Le(ie);if(we!==$e)return!1;if(we||$e){if(ae.length!==ie.length)return!1;for(Q=0;Q<ae.length;Q++)if(ae[Q]!==ie[Q])return!1;return!0}if(typeof ae!=typeof ie)return!1;try{var Ne=te(ae),Se=te(ie)}catch{return!1}if(Ne.length!==Se.length)return!1;for(Ne.sort(),Se.sort(),Q=Ne.length-1;Q>=0;Q--)if(Ne[Q]!=Se[Q])return!1;for(Q=Ne.length-1;Q>=0;Q--)if(!Je(ae[pe=Ne[Q]],ie[pe],Ue))return!1;return!0}(ae,ie,Q))}},2358:(ze,Fe,Y)=>{"use strict";var te=Y(1356),he="function"==typeof Symbol&&"symbol"==typeof Symbol("foo"),ye=Object.prototype.toString,de=Array.prototype.concat,Me=Object.defineProperty,Ye=Y(7027)(),Je=Me&&Ye,Ae=function(re,ae,ie,Ue){if(ae in re)if(!0===Ue){if(re[ae]===ie)return}else if(!function(re){return"function"==typeof re&&"[object Function]"===ye.call(re)}(Ue)||!Ue())return;Je?Me(re,ae,{configurable:!0,enumerable:!1,value:ie,writable:!0}):re[ae]=ie},Le=function(re,ae){var ie=arguments.length>2?arguments[2]:{},Ue=te(ae);he&&(Ue=de.call(Ue,Object.getOwnPropertySymbols(ae)));for(var Q=0;Q<Ue.length;Q+=1)Ae(re,Ue[Q],ae[Ue[Q]],ie[Ue[Q]])};Le.supportsDescriptors=!!Je,ze.exports=Le},1817:ze=>{function Fe(Y,te,he,ye){this.dataset=[],this.epsilon=1,this.minPts=2,this.distance=this._euclideanDistance,this.clusters=[],this.noise=[],this._visited=[],this._assigned=[],this._datasetLength=0,this._init(Y,te,he,ye)}Fe.prototype.run=function(Y,te,he,ye){this._init(Y,te,he,ye);for(var de=0;de<this._datasetLength;de++)if(1!==this._visited[de]){this._visited[de]=1;var Me=this._regionQuery(de);if(Me.length<this.minPts)this.noise.push(de);else{var H=this.clusters.length;this.clusters.push([]),this._addToCluster(de,H),this._expandCluster(H,Me)}}return this.clusters},Fe.prototype._init=function(Y,te,he,ye){if(Y){if(!(Y instanceof Array))throw Error("Dataset must be of type array, "+typeof Y+" given");this.dataset=Y,this.clusters=[],this.noise=[],this._datasetLength=Y.length,this._visited=new Array(this._datasetLength),this._assigned=new Array(this._datasetLength)}te&&(this.epsilon=te),he&&(this.minPts=he),ye&&(this.distance=ye)},Fe.prototype._expandCluster=function(Y,te){for(var he=0;he<te.length;he++){var ye=te[he];if(1!==this._visited[ye]){this._visited[ye]=1;var de=this._regionQuery(ye);de.length>=this.minPts&&(te=this._mergeArrays(te,de))}1!==this._assigned[ye]&&this._addToCluster(ye,Y)}},Fe.prototype._addToCluster=function(Y,te){this.clusters[te].push(Y),this._assigned[Y]=1},Fe.prototype._regionQuery=function(Y){for(var te=[],he=0;he<this._datasetLength;he++)this.distance(this.dataset[Y],this.dataset[he])<this.epsilon&&te.push(he);return te},Fe.prototype._mergeArrays=function(Y,te){for(var he=te.length,ye=0;ye<he;ye++){var de=te[ye];Y.indexOf(de)<0&&Y.push(de)}return Y},Fe.prototype._euclideanDistance=function(Y,te){for(var he=0,ye=Math.min(Y.length,te.length);ye--;)he+=(Y[ye]-te[ye])*(Y[ye]-te[ye]);return Math.sqrt(he)},ze.exports&&(ze.exports=Fe)},4273:ze=>{function Fe(Y,te,he){this.k=3,this.dataset=[],this.assignments=[],this.centroids=[],this.init(Y,te,he)}Fe.prototype.init=function(Y,te,he){this.assignments=[],this.centroids=[],typeof Y<"u"&&(this.dataset=Y),typeof te<"u"&&(this.k=te),typeof he<"u"&&(this.distance=he)},Fe.prototype.run=function(Y,te){this.init(Y,te);for(var he=this.dataset.length,ye=0;ye<this.k;ye++)this.centroids[ye]=this.randomCentroid();for(var de=!0;de;){de=this.assign();for(var Me=0;Me<this.k;Me++){for(var H=new Array(Le),Ye=0,Je=0;Je<Le;Je++)H[Je]=0;for(var Ae=0;Ae<he;Ae++){var Le=this.dataset[Ae].length;if(Me===this.assignments[Ae]){for(Je=0;Je<Le;Je++)H[Je]+=this.dataset[Ae][Je];Ye++}}if(Ye>0){for(Je=0;Je<Le;Je++)H[Je]/=Ye;this.centroids[Me]=H}else this.centroids[Me]=this.randomCentroid(),de=!0}}return this.getClusters()},Fe.prototype.randomCentroid=function(){var te,he,Y=this.dataset.length-1;do{he=Math.round(Math.random()*Y),te=this.dataset[he]}while(this.centroids.indexOf(te)>=0);return te},Fe.prototype.assign=function(){for(var he,Y=!1,te=this.dataset.length,ye=0;ye<te;ye++)(he=this.argmin(this.dataset[ye],this.centroids,this.distance))!=this.assignments[ye]&&(this.assignments[ye]=he,Y=!0);return Y},Fe.prototype.getClusters=function(){for(var te,Y=new Array(this.k),he=0;he<this.assignments.length;he++)typeof Y[te=this.assignments[he]]>"u"&&(Y[te]=[]),Y[te].push(he);return Y},Fe.prototype.argmin=function(Y,te,he){for(var H,ye=Number.MAX_VALUE,de=0,Me=te.length,Ye=0;Ye<Me;Ye++)(H=he(Y,te[Ye]))<ye&&(ye=H,de=Ye);return de},Fe.prototype.distance=function(Y,te){for(var he=0,ye=Math.min(Y.length,te.length);ye--;){var de=Y[ye]-te[ye];he+=de*de}return Math.sqrt(he)},ze.exports&&(ze.exports=Fe)},8680:(ze,Fe,Y)=>{if(ze.exports)var te=Y(8759);function he(ye,de,Me,H){this.epsilon=1,this.minPts=1,this.distance=this._euclideanDistance,this._reachability=[],this._processed=[],this._coreDistance=0,this._orderedList=[],this._init(ye,de,Me,H)}he.prototype.run=function(ye,de,Me,H){this._init(ye,de,Me,H);for(var Ye=0,Je=this.dataset.length;Ye<Je;Ye++)if(1!==this._processed[Ye]){this._processed[Ye]=1,this.clusters.push([Ye]);var Ae=this.clusters.length-1;this._orderedList.push(Ye);var Le=new te(null,null,"asc"),re=this._regionQuery(Ye);void 0!==this._distanceToCore(Ye)&&(this._updateQueue(Ye,re,Le),this._expandCluster(Ae,Le))}return this.clusters},he.prototype.getReachabilityPlot=function(){for(var ye=[],de=0,Me=this._orderedList.length;de<Me;de++){var H=this._orderedList[de];ye.push([H,this._reachability[H]])}return ye},he.prototype._init=function(ye,de,Me,H){if(ye){if(!(ye instanceof Array))throw Error("Dataset must be of type array, "+typeof ye+" given");this.dataset=ye,this.clusters=[],this._reachability=new Array(this.dataset.length),this._processed=new Array(this.dataset.length),this._coreDistance=0,this._orderedList=[]}de&&(this.epsilon=de),Me&&(this.minPts=Me),H&&(this.distance=H)},he.prototype._updateQueue=function(ye,de,Me){var H=this;this._coreDistance=this._distanceToCore(ye),de.forEach(function(Ye){if(void 0===H._processed[Ye]){var Je=H.distance(H.dataset[ye],H.dataset[Ye]),Ae=Math.max(H._coreDistance,Je);void 0===H._reachability[Ye]?(H._reachability[Ye]=Ae,Me.insert(Ye,Ae)):Ae<H._reachability[Ye]&&(H._reachability[Ye]=Ae,Me.remove(Ye),Me.insert(Ye,Ae))}})},he.prototype._expandCluster=function(ye,de){for(var Me=de.getElements(),H=0,Ye=Me.length;H<Ye;H++){var Je=Me[H];if(void 0===this._processed[Je]){var Ae=this._regionQuery(Je);this._processed[Je]=1,this.clusters[ye].push(Je),this._orderedList.push(Je),void 0!==this._distanceToCore(Je)&&(this._updateQueue(Je,Ae,de),this._expandCluster(ye,de))}}},he.prototype._distanceToCore=function(ye){for(var de=this.epsilon,Me=0;Me<de;Me++)if(this._regionQuery(ye,Me).length>=this.minPts)return Me},he.prototype._regionQuery=function(ye,de){de=de||this.epsilon;for(var Me=[],H=0,Ye=this.dataset.length;H<Ye;H++)this.distance(this.dataset[ye],this.dataset[H])<de&&Me.push(H);return Me},he.prototype._euclideanDistance=function(ye,de){for(var Me=0,H=Math.min(ye.length,de.length);H--;)Me+=(ye[H]-de[H])*(ye[H]-de[H]);return Math.sqrt(Me)},ze.exports&&(ze.exports=he)},8759:ze=>{function Fe(Y,te,he){this._queue=[],this._priorities=[],this._sorting="desc",this._init(Y,te,he)}Fe.prototype.insert=function(Y,te){for(var he=this._queue.length,ye=he;ye--;){var de=this._priorities[ye];"desc"===this._sorting?te>de&&(he=ye):te<de&&(he=ye)}this._insertAt(Y,te,he)},Fe.prototype.remove=function(Y){for(var te=this._queue.length;te--;)if(Y===this._queue[te]){this._queue.splice(te,1),this._priorities.splice(te,1);break}},Fe.prototype.forEach=function(Y){this._queue.forEach(Y)},Fe.prototype.getElements=function(){return this._queue},Fe.prototype.getElementPriority=function(Y){return this._priorities[Y]},Fe.prototype.getPriorities=function(){return this._priorities},Fe.prototype.getElementsWithPriorities=function(){for(var Y=[],te=0,he=this._queue.length;te<he;te++)Y.push([this._queue[te],this._priorities[te]]);return Y},Fe.prototype._init=function(Y,te,he){if(Y&&te){if(this._queue=[],this._priorities=[],Y.length!==te.length)throw new Error("Arrays must have the same length");for(var ye=0;ye<Y.length;ye++)this.insert(Y[ye],te[ye])}he&&(this._sorting=he)},Fe.prototype._insertAt=function(Y,te,he){this._queue.length===he?(this._queue.push(Y),this._priorities.push(te)):(this._queue.splice(he,0,Y),this._priorities.splice(he,0,te))},ze.exports&&(ze.exports=Fe)},7470:(ze,Fe,Y)=>{ze.exports&&(ze.exports={DBSCAN:Y(1817),KMEANS:Y(4273),OPTICS:Y(8680),PriorityQueue:Y(8759)})},5469:ze=>{"use strict";function Fe(Ke,rt,et){et=et||2;var $t,tn,Gt,Rn,Bn,kn,qn,pt=rt&&rt.length,dt=pt?rt[0]*et:Ke.length,je=Y(Ke,0,dt,et,!0),zt=[];if(!je||je.next===je.prev)return zt;if(pt&&(je=function Ye(Ke,rt,et,pt){var je,zt,Gt,dt=[];for(je=0,zt=rt.length;je<zt;je++)(Gt=Y(Ke,rt[je]*pt,je<zt-1?rt[je+1]*pt:Ke.length,pt,!1))===Gt.next&&(Gt.steiner=!0),dt.push(Q(Gt));for(dt.sort(Je),je=0;je<dt.length;je++)et=Ae(dt[je],et);return et}(Ke,rt,je,et)),Ke.length>80*et){$t=Gt=Ke[0],tn=Rn=Ke[1];for(var $n=et;$n<dt;$n+=et)(Bn=Ke[$n])<$t&&($t=Bn),(kn=Ke[$n+1])<tn&&(tn=kn),Bn>Gt&&(Gt=Bn),kn>Rn&&(Rn=kn);qn=0!==(qn=Math.max(Gt-$t,Rn-tn))?32767/qn:0}return he(je,zt,et,$t,tn,qn,0),zt}function Y(Ke,rt,et,pt,dt){var je,zt;if(dt===Ct(Ke,rt,et,pt)>0)for(je=rt;je<et;je+=pt)zt=He(je,Ke[je],Ke[je+1],zt);else for(je=et-pt;je>=rt;je-=pt)zt=He(je,Ke[je],Ke[je+1],zt);return zt&&we(zt,zt.next)&&(_e(zt),zt=zt.next),zt}function te(Ke,rt){if(!Ke)return Ke;rt||(rt=Ke);var pt,et=Ke;do{if(pt=!1,et.steiner||!we(et,et.next)&&0!==xe(et.prev,et,et.next))et=et.next;else{if(_e(et),(et=rt=et.prev)===et.next)break;pt=!0}}while(pt||et!==rt);return rt}function he(Ke,rt,et,pt,dt,je,zt){if(Ke){!zt&&je&&function ae(Ke,rt,et,pt){var dt=Ke;do{0===dt.z&&(dt.z=Ue(dt.x,dt.y,rt,et,pt)),dt.prevZ=dt.prev,dt.nextZ=dt.next,dt=dt.next}while(dt!==Ke);dt.prevZ.nextZ=null,dt.prevZ=null,function ie(Ke){var rt,et,pt,dt,je,zt,$t,tn,Gt=1;do{for(et=Ke,Ke=null,je=null,zt=0;et;){for(zt++,pt=et,$t=0,rt=0;rt<Gt&&($t++,pt=pt.nextZ);rt++);for(tn=Gt;$t>0||tn>0&&pt;)0!==$t&&(0===tn||!pt||et.z<=pt.z)?(dt=et,et=et.nextZ,$t--):(dt=pt,pt=pt.nextZ,tn--),je?je.nextZ=dt:Ke=dt,dt.prevZ=je,je=dt;et=pt}je.nextZ=null,Gt*=2}while(zt>1)}(dt)}(Ke,pt,dt,je);for(var tn,Gt,$t=Ke;Ke.prev!==Ke.next;)if(tn=Ke.prev,Gt=Ke.next,je?de(Ke,pt,dt,je):ye(Ke))rt.push(tn.i/et|0),rt.push(Ke.i/et|0),rt.push(Gt.i/et|0),_e(Ke),Ke=Gt.next,$t=Gt.next;else if((Ke=Gt)===$t){zt?1===zt?he(Ke=Me(te(Ke),rt,et),rt,et,pt,dt,je,2):2===zt&&H(Ke,rt,et,pt,dt,je):he(te(Ke),rt,et,pt,dt,je,1);break}}}function ye(Ke){var rt=Ke.prev,et=Ke,pt=Ke.next;if(xe(rt,et,pt)>=0)return!1;for(var dt=rt.x,je=et.x,zt=pt.x,$t=rt.y,tn=et.y,Gt=pt.y,Rn=dt<je?dt<zt?dt:zt:je<zt?je:zt,Bn=$t<tn?$t<Gt?$t:Gt:tn<Gt?tn:Gt,kn=dt>je?dt>zt?dt:zt:je>zt?je:zt,qn=$t>tn?$t>Gt?$t:Gt:tn>Gt?tn:Gt,$n=pt.next;$n!==rt;){if($n.x>=Rn&&$n.x<=kn&&$n.y>=Bn&&$n.y<=qn&&pe(dt,$t,je,tn,zt,Gt,$n.x,$n.y)&&xe($n.prev,$n,$n.next)>=0)return!1;$n=$n.next}return!0}function de(Ke,rt,et,pt){var dt=Ke.prev,je=Ke,zt=Ke.next;if(xe(dt,je,zt)>=0)return!1;for(var $t=dt.x,tn=je.x,Gt=zt.x,Rn=dt.y,Bn=je.y,kn=zt.y,qn=$t<tn?$t<Gt?$t:Gt:tn<Gt?tn:Gt,$n=Rn<Bn?Rn<kn?Rn:kn:Bn<kn?Bn:kn,Qe=$t>tn?$t>Gt?$t:Gt:tn>Gt?tn:Gt,Gi=Rn>Bn?Rn>kn?Rn:kn:Bn>kn?Bn:kn,Ir=Ue(qn,$n,rt,et,pt),ri=Ue(Qe,Gi,rt,et,pt),Yn=Ke.prevZ,Vn=Ke.nextZ;Yn&&Yn.z>=Ir&&Vn&&Vn.z<=ri;){if(Yn.x>=qn&&Yn.x<=Qe&&Yn.y>=$n&&Yn.y<=Gi&&Yn!==dt&&Yn!==zt&&pe($t,Rn,tn,Bn,Gt,kn,Yn.x,Yn.y)&&xe(Yn.prev,Yn,Yn.next)>=0||(Yn=Yn.prevZ,Vn.x>=qn&&Vn.x<=Qe&&Vn.y>=$n&&Vn.y<=Gi&&Vn!==dt&&Vn!==zt&&pe($t,Rn,tn,Bn,Gt,kn,Vn.x,Vn.y)&&xe(Vn.prev,Vn,Vn.next)>=0))return!1;Vn=Vn.nextZ}for(;Yn&&Yn.z>=Ir;){if(Yn.x>=qn&&Yn.x<=Qe&&Yn.y>=$n&&Yn.y<=Gi&&Yn!==dt&&Yn!==zt&&pe($t,Rn,tn,Bn,Gt,kn,Yn.x,Yn.y)&&xe(Yn.prev,Yn,Yn.next)>=0)return!1;Yn=Yn.prevZ}for(;Vn&&Vn.z<=ri;){if(Vn.x>=qn&&Vn.x<=Qe&&Vn.y>=$n&&Vn.y<=Gi&&Vn!==dt&&Vn!==zt&&pe($t,Rn,tn,Bn,Gt,kn,Vn.x,Vn.y)&&xe(Vn.prev,Vn,Vn.next)>=0)return!1;Vn=Vn.nextZ}return!0}function Me(Ke,rt,et){var pt=Ke;do{var dt=pt.prev,je=pt.next.next;!we(dt,je)&&$e(dt,pt,pt.next,je)&&Z(dt,je)&&Z(je,dt)&&(rt.push(dt.i/et|0),rt.push(pt.i/et|0),rt.push(je.i/et|0),_e(pt),_e(pt.next),pt=Ke=je),pt=pt.next}while(pt!==Ke);return te(pt)}function H(Ke,rt,et,pt,dt,je){var zt=Ke;do{for(var $t=zt.next.next;$t!==zt.prev;){if(zt.i!==$t.i&&le(zt,$t)){var tn=ue(zt,$t);return zt=te(zt,zt.next),tn=te(tn,tn.next),he(zt,rt,et,pt,dt,je,0),void he(tn,rt,et,pt,dt,je,0)}$t=$t.next}zt=zt.next}while(zt!==Ke)}function Je(Ke,rt){return Ke.x-rt.x}function Ae(Ke,rt){var et=function Le(Ke,rt){var zt,et=rt,pt=Ke.x,dt=Ke.y,je=-1/0;do{if(dt<=et.y&&dt>=et.next.y&&et.next.y!==et.y){var $t=et.x+(dt-et.y)*(et.next.x-et.x)/(et.next.y-et.y);if($t<=pt&&$t>je&&(je=$t,zt=et.x<et.next.x?et:et.next,$t===pt))return zt}et=et.next}while(et!==rt);if(!zt)return null;var kn,tn=zt,Gt=zt.x,Rn=zt.y,Bn=1/0;et=zt;do{pt>=et.x&&et.x>=Gt&&pt!==et.x&&pe(dt<Rn?pt:je,dt,Gt,Rn,dt<Rn?je:pt,dt,et.x,et.y)&&(kn=Math.abs(dt-et.y)/(pt-et.x),Z(et,Ke)&&(kn<Bn||kn===Bn&&(et.x>zt.x||et.x===zt.x&&re(zt,et)))&&(zt=et,Bn=kn)),et=et.next}while(et!==tn);return zt}(Ke,rt);if(!et)return rt;var pt=ue(et,Ke);return te(pt,pt.next),te(et,et.next)}function re(Ke,rt){return xe(Ke.prev,Ke,rt.prev)<0&&xe(rt.next,Ke,Ke.next)<0}function Ue(Ke,rt,et,pt,dt){return(Ke=1431655765&((Ke=858993459&((Ke=252645135&((Ke=16711935&((Ke=(Ke-et)*dt|0)|Ke<<8))|Ke<<4))|Ke<<2))|Ke<<1))|(rt=1431655765&((rt=858993459&((rt=252645135&((rt=16711935&((rt=(rt-pt)*dt|0)|rt<<8))|rt<<4))|rt<<2))|rt<<1))<<1}function Q(Ke){var rt=Ke,et=Ke;do{(rt.x<et.x||rt.x===et.x&&rt.y<et.y)&&(et=rt),rt=rt.next}while(rt!==Ke);return et}function pe(Ke,rt,et,pt,dt,je,zt,$t){return(dt-zt)*(rt-$t)>=(Ke-zt)*(je-$t)&&(Ke-zt)*(pt-$t)>=(et-zt)*(rt-$t)&&(et-zt)*(je-$t)>=(dt-zt)*(pt-$t)}function le(Ke,rt){return Ke.next.i!==rt.i&&Ke.prev.i!==rt.i&&!function Pe(Ke,rt){var et=Ke;do{if(et.i!==Ke.i&&et.next.i!==Ke.i&&et.i!==rt.i&&et.next.i!==rt.i&&$e(et,et.next,Ke,rt))return!0;et=et.next}while(et!==Ke);return!1}(Ke,rt)&&(Z(Ke,rt)&&Z(rt,Ke)&&function Be(Ke,rt){var et=Ke,pt=!1,dt=(Ke.x+rt.x)/2,je=(Ke.y+rt.y)/2;do{et.y>je!=et.next.y>je&&et.next.y!==et.y&&dt<(et.next.x-et.x)*(je-et.y)/(et.next.y-et.y)+et.x&&(pt=!pt),et=et.next}while(et!==Ke);return pt}(Ke,rt)&&(xe(Ke.prev,Ke,rt.prev)||xe(Ke,rt.prev,rt))||we(Ke,rt)&&xe(Ke.prev,Ke,Ke.next)>0&&xe(rt.prev,rt,rt.next)>0)}function xe(Ke,rt,et){return(rt.y-Ke.y)*(et.x-rt.x)-(rt.x-Ke.x)*(et.y-rt.y)}function we(Ke,rt){return Ke.x===rt.x&&Ke.y===rt.y}function $e(Ke,rt,et,pt){var dt=Se(xe(Ke,rt,et)),je=Se(xe(Ke,rt,pt)),zt=Se(xe(et,pt,Ke)),$t=Se(xe(et,pt,rt));return!!(dt!==je&&zt!==$t||0===dt&&Ne(Ke,et,rt)||0===je&&Ne(Ke,pt,rt)||0===zt&&Ne(et,Ke,pt)||0===$t&&Ne(et,rt,pt))}function Ne(Ke,rt,et){return rt.x<=Math.max(Ke.x,et.x)&&rt.x>=Math.min(Ke.x,et.x)&&rt.y<=Math.max(Ke.y,et.y)&&rt.y>=Math.min(Ke.y,et.y)}function Se(Ke){return Ke>0?1:Ke<0?-1:0}function Z(Ke,rt){return xe(Ke.prev,Ke,Ke.next)<0?xe(Ke,rt,Ke.next)>=0&&xe(Ke,Ke.prev,rt)>=0:xe(Ke,rt,Ke.prev)<0||xe(Ke,Ke.next,rt)<0}function ue(Ke,rt){var et=new kt(Ke.i,Ke.x,Ke.y),pt=new kt(rt.i,rt.x,rt.y),dt=Ke.next,je=rt.prev;return Ke.next=rt,rt.prev=Ke,et.next=dt,dt.prev=et,pt.next=et,et.prev=pt,je.next=pt,pt.prev=je,pt}function He(Ke,rt,et,pt){var dt=new kt(Ke,rt,et);return pt?(dt.next=pt.next,dt.prev=pt,pt.next.prev=dt,pt.next=dt):(dt.prev=dt,dt.next=dt),dt}function _e(Ke){Ke.next.prev=Ke.prev,Ke.prev.next=Ke.next,Ke.prevZ&&(Ke.prevZ.nextZ=Ke.nextZ),Ke.nextZ&&(Ke.nextZ.prevZ=Ke.prevZ)}function kt(Ke,rt,et){this.i=Ke,this.x=rt,this.y=et,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function Ct(Ke,rt,et,pt){for(var dt=0,je=rt,zt=et-pt;je<et;je+=pt)dt+=(Ke[zt]-Ke[je])*(Ke[je+1]+Ke[zt+1]),zt=je;return dt}ze.exports=Fe,ze.exports.default=Fe,Fe.deviation=function(Ke,rt,et,pt){var dt=rt&&rt.length,zt=Math.abs(Ct(Ke,0,dt?rt[0]*et:Ke.length,et));if(dt)for(var $t=0,tn=rt.length;$t<tn;$t++)zt-=Math.abs(Ct(Ke,rt[$t]*et,$t<tn-1?rt[$t+1]*et:Ke.length,et));var Bn=0;for($t=0;$t<pt.length;$t+=3){var kn=pt[$t]*et,qn=pt[$t+1]*et,$n=pt[$t+2]*et;Bn+=Math.abs((Ke[kn]-Ke[$n])*(Ke[qn+1]-Ke[kn+1])-(Ke[kn]-Ke[qn])*(Ke[$n+1]-Ke[kn+1]))}return 0===zt&&0===Bn?0:Math.abs((Bn-zt)/zt)},Fe.flatten=function(Ke){for(var rt=Ke[0][0].length,et={vertices:[],holes:[],dimensions:rt},pt=0,dt=0;dt<Ke.length;dt++){for(var je=0;je<Ke[dt].length;je++)for(var zt=0;zt<rt;zt++)et.vertices.push(Ke[dt][je][zt]);dt>0&&et.holes.push(pt+=Ke[dt-1].length)}return et}},4613:function(ze,Fe){var te;!function(he){"use strict";var de={s:1,n:0,d:1};function Me(Ue,Q){if(isNaN(Ue=parseInt(Ue,10)))throw ie.InvalidParameter;return Ue*Q}function H(Ue,Q){if(0===Q)throw ie.DivisionByZero;var pe=Object.create(ie.prototype);pe.s=Ue<0?-1:1;var le=ae(Ue=Ue<0?-Ue:Ue,Q);return pe.n=Ue/le,pe.d=Q/le,pe}function Ye(Ue){for(var Q={},pe=Ue,le=2,xe=4;xe<=pe;){for(;pe%le==0;)pe/=le,Q[le]=(Q[le]||0)+1;xe+=1+2*le++}return pe!==Ue?pe>1&&(Q[pe]=(Q[pe]||0)+1):Q[Ue]=(Q[Ue]||0)+1,Q}var Je=function(Ue,Q){var kt,pe=0,le=1,xe=1,we=0,$e=0,Ne=0,Se=1,Pe=1,Z=0,Be=1,ue=1,He=1,_e=1e7;if(null!=Ue)if(void 0!==Q){if(xe=(pe=Ue)*(le=Q),pe%1!=0||le%1!=0)throw ie.NonIntegerParameter}else switch(typeof Ue){case"object":if("d"in Ue&&"n"in Ue)pe=Ue.n,le=Ue.d,"s"in Ue&&(pe*=Ue.s);else{if(!(0 in Ue))throw ie.InvalidParameter;pe=Ue[0],1 in Ue&&(le=Ue[1])}xe=pe*le;break;case"number":if(Ue<0&&(xe=Ue,Ue=-Ue),Ue%1==0)pe=Ue;else if(Ue>0){for(Ue>=1&&(Ue/=Pe=Math.pow(10,Math.floor(1+Math.log(Ue)/Math.LN10)));Be<=_e&&He<=_e;){if(Ue===(kt=(Z+ue)/(Be+He))){Be+He<=_e?(pe=Z+ue,le=Be+He):He>Be?(pe=ue,le=He):(pe=Z,le=Be);break}Ue>kt?(Z+=ue,Be+=He):(ue+=Z,He+=Be),Be>_e?(pe=ue,le=He):(pe=Z,le=Be)}pe*=Pe}else(isNaN(Ue)||isNaN(Q))&&(le=pe=NaN);break;case"string":if(null===(Be=Ue.match(/\d+|./g)))throw ie.InvalidParameter;if("-"===Be[Z]?(xe=-1,Z++):"+"===Be[Z]&&Z++,Be.length===Z+1?$e=Me(Be[Z++],xe):"."===Be[Z+1]||"."===Be[Z]?("."!==Be[Z]&&(we=Me(Be[Z++],xe)),(1+ ++Z===Be.length||"("===Be[Z+1]&&")"===Be[Z+3]||"'"===Be[Z+1]&&"'"===Be[Z+3])&&($e=Me(Be[Z],xe),Se=Math.pow(10,Be[Z].length),Z++),("("===Be[Z]&&")"===Be[Z+2]||"'"===Be[Z]&&"'"===Be[Z+2])&&(Ne=Me(Be[Z+1],xe),Pe=Math.pow(10,Be[Z+1].length)-1,Z+=3)):"/"===Be[Z+1]||":"===Be[Z+1]?($e=Me(Be[Z],xe),Se=Me(Be[Z+2],1),Z+=3):"/"===Be[Z+3]&&" "===Be[Z+1]&&(we=Me(Be[Z],xe),$e=Me(Be[Z+2],xe),Se=Me(Be[Z+4],1),Z+=5),Be.length<=Z){xe=pe=Ne+(le=Se*Pe)*we+Pe*$e;break}default:throw ie.InvalidParameter}if(0===le)throw ie.DivisionByZero;de.s=xe<0?-1:1,de.n=Math.abs(pe),de.d=Math.abs(le)};function ae(Ue,Q){if(!Ue)return Q;if(!Q)return Ue;for(;;){if(!(Ue%=Q))return Q;if(!(Q%=Ue))return Ue}}function ie(Ue,Q){if(Je(Ue,Q),!(this instanceof ie))return H(de.s*de.n,de.d);Ue=ae(de.d,de.n),this.s=de.s,this.n=de.n/Ue,this.d=de.d/Ue}ie.DivisionByZero=new Error("Division by Zero"),ie.InvalidParameter=new Error("Invalid argument"),ie.NonIntegerParameter=new Error("Parameters must be integer"),ie.prototype={s:1,n:0,d:1,abs:function(){return H(this.n,this.d)},neg:function(){return H(-this.s*this.n,this.d)},add:function(Ue,Q){return Je(Ue,Q),H(this.s*this.n*de.d+de.s*this.d*de.n,this.d*de.d)},sub:function(Ue,Q){return Je(Ue,Q),H(this.s*this.n*de.d-de.s*this.d*de.n,this.d*de.d)},mul:function(Ue,Q){return Je(Ue,Q),H(this.s*de.s*this.n*de.n,this.d*de.d)},div:function(Ue,Q){return Je(Ue,Q),H(this.s*de.s*this.n*de.d,this.d*de.n)},clone:function(){return H(this.s*this.n,this.d)},mod:function(Ue,Q){if(isNaN(this.n)||isNaN(this.d))return new ie(NaN);if(void 0===Ue)return H(this.s*this.n%this.d,1);if(Je(Ue,Q),0===de.n&&0===this.d)throw ie.DivisionByZero;return H(this.s*(de.d*this.n)%(de.n*this.d),de.d*this.d)},gcd:function(Ue,Q){return Je(Ue,Q),H(ae(de.n,this.n)*ae(de.d,this.d),de.d*this.d)},lcm:function(Ue,Q){return Je(Ue,Q),0===de.n&&0===this.n?H(0,1):H(de.n*this.n,ae(de.n,this.n)*ae(de.d,this.d))},ceil:function(Ue){return Ue=Math.pow(10,Ue||0),isNaN(this.n)||isNaN(this.d)?new ie(NaN):H(Math.ceil(Ue*this.s*this.n/this.d),Ue)},floor:function(Ue){return Ue=Math.pow(10,Ue||0),isNaN(this.n)||isNaN(this.d)?new ie(NaN):H(Math.floor(Ue*this.s*this.n/this.d),Ue)},round:function(Ue){return Ue=Math.pow(10,Ue||0),isNaN(this.n)||isNaN(this.d)?new ie(NaN):H(Math.round(Ue*this.s*this.n/this.d),Ue)},inverse:function(){return H(this.s*this.d,this.n)},pow:function(Ue,Q){if(Je(Ue,Q),1===de.d)return de.s<0?H(Math.pow(this.s*this.d,de.n),Math.pow(this.n,de.n)):H(Math.pow(this.s*this.n,de.n),Math.pow(this.d,de.n));if(this.s<0)return null;var pe=Ye(this.n),le=Ye(this.d),xe=1,we=1;for(var $e in pe)if("1"!==$e){if("0"===$e){xe=0;break}if(pe[$e]*=de.n,pe[$e]%de.d!=0)return null;pe[$e]/=de.d,xe*=Math.pow($e,pe[$e])}for(var $e in le)if("1"!==$e){if(le[$e]*=de.n,le[$e]%de.d!=0)return null;le[$e]/=de.d,we*=Math.pow($e,le[$e])}return de.s<0?H(we,xe):H(xe,we)},equals:function(Ue,Q){return Je(Ue,Q),this.s*this.n*de.d==de.s*de.n*this.d},compare:function(Ue,Q){Je(Ue,Q);var pe=this.s*this.n*de.d-de.s*de.n*this.d;return(0<pe)-(pe<0)},simplify:function(Ue){if(isNaN(this.n)||isNaN(this.d))return this;Ue=Ue||.001;for(var Q=this.abs(),pe=Q.toContinued(),le=1;le<pe.length;le++){for(var xe=H(pe[le-1],1),we=le-2;we>=0;we--)xe=xe.inverse().add(pe[we]);if(xe.sub(Q).abs().valueOf()<Ue)return xe.mul(this.s)}return this},divisible:function(Ue,Q){return Je(Ue,Q),!(!(de.n*this.d)||this.n*de.d%(de.n*this.d))},valueOf:function(){return this.s*this.n/this.d},toFraction:function(Ue){var Q,pe="",le=this.n,xe=this.d;return this.s<0&&(pe+="-"),1===xe?pe+=le:(Ue&&(Q=Math.floor(le/xe))>0&&(pe+=Q,pe+=" ",le%=xe),pe+=le,pe+="/",pe+=xe),pe},toLatex:function(Ue){var Q,pe="",le=this.n,xe=this.d;return this.s<0&&(pe+="-"),1===xe?pe+=le:(Ue&&(Q=Math.floor(le/xe))>0&&(pe+=Q,le%=xe),pe+="\\frac{",pe+=le,pe+="}{",pe+=xe,pe+="}"),pe},toContinued:function(){var Ue,Q=this.n,pe=this.d,le=[];if(isNaN(Q)||isNaN(pe))return le;do{le.push(Math.floor(Q/pe)),Ue=Q%pe,Q=pe,pe=Ue}while(1!==Q);return le},toString:function(Ue){var Q=this.n,pe=this.d;if(isNaN(Q)||isNaN(pe))return"NaN";Ue=Ue||15;var le=function Le(Ue,Q){for(;Q%2==0;Q/=2);for(;Q%5==0;Q/=5);if(1===Q)return 0;for(var pe=10%Q,le=1;1!==pe;le++)if(pe=10*pe%Q,le>2e3)return 0;return le}(0,pe),xe=function re(Ue,Q,pe){for(var le=1,xe=function Ae(Ue,Q,pe){for(var le=1;Q>0;Ue=Ue*Ue%pe,Q>>=1)1&Q&&(le=le*Ue%pe);return le}(10,pe,Q),we=0;we<300;we++){if(le===xe)return we;le=10*le%Q,xe=10*xe%Q}return 0}(0,pe,le),we=this.s<0?"-":"";if(we+=Q/pe|0,Q%=pe,(Q*=10)&&(we+="."),le){for(var $e=xe;$e--;)we+=Q/pe|0,Q%=pe,Q*=10;for(we+="(",$e=le;$e--;)we+=Q/pe|0,Q%=pe,Q*=10;we+=")"}else for($e=Ue;Q&&$e--;)we+=Q/pe|0,Q%=pe,Q*=10;return we}},void 0!==(te=function(){return ie}.apply(Fe,[]))&&(ze.exports=te)}()},3457:ze=>{"use strict";var Fe="Function.prototype.bind called on incompatible ",Y=Array.prototype.slice,te=Object.prototype.toString,he="[object Function]";ze.exports=function(de){var Me=this;if("function"!=typeof Me||te.call(Me)!==he)throw new TypeError(Fe+Me);for(var Ye,H=Y.call(arguments,1),Ae=Math.max(0,Me.length-H.length),Le=[],re=0;re<Ae;re++)Le.push("$"+re);if(Ye=Function("binder","return function ("+Le.join(",")+"){ return binder.apply(this,arguments); }")(function(){if(this instanceof Ye){var ie=Me.apply(this,H.concat(Y.call(arguments)));return Object(ie)===ie?ie:this}return Me.apply(de,H.concat(Y.call(arguments)))}),Me.prototype){var ae=function(){};ae.prototype=Me.prototype,Ye.prototype=new ae,ae.prototype=null}return Ye}},4444:(ze,Fe,Y)=>{"use strict";var te=Y(3457);ze.exports=Function.prototype.bind||te},9582:ze=>{"use strict";var Fe=function(){return"string"==typeof function(){}.name},Y=Object.getOwnPropertyDescriptor;if(Y)try{Y([],"length")}catch{Y=null}Fe.functionsHaveConfigurableNames=function(){if(!Fe()||!Y)return!1;var ye=Y(function(){},"name");return!!ye&&!!ye.configurable};var te=Function.prototype.bind;Fe.boundFunctionsHaveNames=function(){return Fe()&&"function"==typeof te&&""!==function(){}.bind().name},ze.exports=Fe},5013:(ze,Fe,Y)=>{var te=Y(6952),he=function(H){this.precision=H&&H.precision?H.precision:17,this.direction=!(!H||!H.direction)&&H.direction,this.pseudoNode=!(!H||!H.pseudoNode)&&H.pseudoNode,this.objectComparator=H&&H.objectComparator?H.objectComparator:Me};function ye(H){return H.coordinates.map(function(Ye){return{type:H.type.replace("Multi",""),coordinates:Ye}})}function de(H,Ye){return H.hasOwnProperty("coordinates")?H.coordinates.length===Ye.coordinates.length:H.length===Ye.length}function Me(H,Ye){return te(H,Ye,{strict:!0})}he.prototype.compare=function(H,Ye){if(H.type!==Ye.type||!de(H,Ye))return!1;switch(H.type){case"Point":return this.compareCoord(H.coordinates,Ye.coordinates);case"LineString":return this.compareLine(H.coordinates,Ye.coordinates,0,!1);case"Polygon":return this.comparePolygon(H,Ye);case"Feature":return this.compareFeature(H,Ye);default:if(0===H.type.indexOf("Multi")){var Je=this,Ae=ye(H),Le=ye(Ye);return Ae.every(function(re){return this.some(function(ae){return Je.compare(re,ae)})},Le)}}return!1},he.prototype.compareCoord=function(H,Ye){if(H.length!==Ye.length)return!1;for(var Je=0;Je<H.length;Je++)if(H[Je].toFixed(this.precision)!==Ye[Je].toFixed(this.precision))return!1;return!0},he.prototype.compareLine=function(H,Ye,Je,Ae){if(!de(H,Ye))return!1;var Le=this.pseudoNode?H:this.removePseudo(H),re=this.pseudoNode?Ye:this.removePseudo(Ye);if(!Ae||this.compareCoord(Le[0],re[0])||(re=this.fixStartIndex(re,Le))){var ae=this.compareCoord(Le[Je],re[Je]);return this.direction||ae?this.comparePath(Le,re):!!this.compareCoord(Le[Je],re[re.length-(1+Je)])&&this.comparePath(Le.slice().reverse(),re)}},he.prototype.fixStartIndex=function(H,Ye){for(var Je,Ae=-1,Le=0;Le<H.length;Le++)if(this.compareCoord(H[Le],Ye[0])){Ae=Le;break}return Ae>=0&&(Je=[].concat(H.slice(Ae,H.length),H.slice(1,Ae+1))),Je},he.prototype.comparePath=function(H,Ye){var Je=this;return H.every(function(Ae,Le){return Je.compareCoord(Ae,this[Le])},Ye)},he.prototype.comparePolygon=function(H,Ye){if(this.compareLine(H.coordinates[0],Ye.coordinates[0],1,!0)){var Je=H.coordinates.slice(1,H.coordinates.length),Ae=Ye.coordinates.slice(1,Ye.coordinates.length),Le=this;return Je.every(function(re){return this.some(function(ae){return Le.compareLine(re,ae,1,!0)})},Ae)}return!1},he.prototype.compareFeature=function(H,Ye){return!(H.id!==Ye.id||!this.objectComparator(H.properties,Ye.properties)||!this.compareBBox(H,Ye))&&this.compare(H.geometry,Ye.geometry)},he.prototype.compareBBox=function(H,Ye){return!!(!H.bbox&&!Ye.bbox||H.bbox&&Ye.bbox&&this.compareCoord(H.bbox,Ye.bbox))},he.prototype.removePseudo=function(H){return H},ze.exports=he},5406:(ze,Fe,Y)=>{var te=Y(7192),he=Y(8275),ye=Y(3269),de=Y(1503).Z,Me=ye.featureEach,Je=he.featureCollection;function Ae(Le){var re=new te(Le);return re.insert=function(ae){if("Feature"!==ae.type)throw new Error("invalid feature");return ae.bbox=ae.bbox?ae.bbox:de(ae),te.prototype.insert.call(this,ae)},re.load=function(ae){var ie=[];return Array.isArray(ae)?ae.forEach(function(Ue){if("Feature"!==Ue.type)throw new Error("invalid features");Ue.bbox=Ue.bbox?Ue.bbox:de(Ue),ie.push(Ue)}):Me(ae,function(Ue){if("Feature"!==Ue.type)throw new Error("invalid features");Ue.bbox=Ue.bbox?Ue.bbox:de(Ue),ie.push(Ue)}),te.prototype.load.call(this,ie)},re.remove=function(ae,ie){if("Feature"!==ae.type)throw new Error("invalid feature");return ae.bbox=ae.bbox?ae.bbox:de(ae),te.prototype.remove.call(this,ae,ie)},re.clear=function(){return te.prototype.clear.call(this)},re.search=function(ae){var ie=te.prototype.search.call(this,this.toBBox(ae));return Je(ie)},re.collides=function(ae){return te.prototype.collides.call(this,this.toBBox(ae))},re.all=function(){var ae=te.prototype.all.call(this);return Je(ae)},re.toJSON=function(){return te.prototype.toJSON.call(this)},re.fromJSON=function(ae){return te.prototype.fromJSON.call(this,ae)},re.toBBox=function(ae){var ie;if(ae.bbox)ie=ae.bbox;else if(Array.isArray(ae)&&4===ae.length)ie=ae;else if(Array.isArray(ae)&&6===ae.length)ie=[ae[0],ae[1],ae[3],ae[4]];else if("Feature"===ae.type)ie=de(ae);else{if("FeatureCollection"!==ae.type)throw new Error("invalid geojson");ie=de(ae)}return{minX:ie[0],minY:ie[1],maxX:ie[2],maxY:ie[3]}},re}ze.exports=Ae,ze.exports.default=Ae},7192:function(ze){ze.exports=function(){"use strict";function Fe(Q,pe,le,xe,we){!function $e(Ne,Se,Pe,Z,Be){for(;Z>Pe;){if(Z-Pe>600){var ue=Z-Pe+1,He=Se-Pe+1,_e=Math.log(ue),kt=.5*Math.exp(2*_e/3),Ct=.5*Math.sqrt(_e*kt*(ue-kt)/ue)*(He-ue/2<0?-1:1);$e(Ne,Se,Math.max(Pe,Math.floor(Se-He*kt/ue+Ct)),Math.min(Z,Math.floor(Se+(ue-He)*kt/ue+Ct)),Be)}var et=Ne[Se],pt=Pe,dt=Z;for(Y(Ne,Pe,Se),Be(Ne[Z],et)>0&&Y(Ne,Pe,Z);pt<dt;){for(Y(Ne,pt,dt),pt++,dt--;Be(Ne[pt],et)<0;)pt++;for(;Be(Ne[dt],et)>0;)dt--}0===Be(Ne[Pe],et)?Y(Ne,Pe,dt):Y(Ne,++dt,Z),dt<=Se&&(Pe=dt+1),Se<=dt&&(Z=dt-1)}}(Q,pe,le||0,xe||Q.length-1,we||te)}function Y(Q,pe,le){var xe=Q[pe];Q[pe]=Q[le],Q[le]=xe}function te(Q,pe){return Q<pe?-1:Q>pe?1:0}var he=function(Q){void 0===Q&&(Q=9),this._maxEntries=Math.max(4,Q),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function ye(Q,pe,le){if(!le)return pe.indexOf(Q);for(var xe=0;xe<pe.length;xe++)if(le(Q,pe[xe]))return xe;return-1}function de(Q,pe){Me(Q,0,Q.children.length,pe,Q)}function Me(Q,pe,le,xe,we){we||(we=ie(null)),we.minX=1/0,we.minY=1/0,we.maxX=-1/0,we.maxY=-1/0;for(var $e=pe;$e<le;$e++){var Ne=Q.children[$e];H(we,Q.leaf?xe(Ne):Ne)}return we}function H(Q,pe){return Q.minX=Math.min(Q.minX,pe.minX),Q.minY=Math.min(Q.minY,pe.minY),Q.maxX=Math.max(Q.maxX,pe.maxX),Q.maxY=Math.max(Q.maxY,pe.maxY),Q}function Ye(Q,pe){return Q.minX-pe.minX}function Je(Q,pe){return Q.minY-pe.minY}function Ae(Q){return(Q.maxX-Q.minX)*(Q.maxY-Q.minY)}function Le(Q){return Q.maxX-Q.minX+(Q.maxY-Q.minY)}function re(Q,pe){return Q.minX<=pe.minX&&Q.minY<=pe.minY&&pe.maxX<=Q.maxX&&pe.maxY<=Q.maxY}function ae(Q,pe){return pe.minX<=Q.maxX&&pe.minY<=Q.maxY&&pe.maxX>=Q.minX&&pe.maxY>=Q.minY}function ie(Q){return{children:Q,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function Ue(Q,pe,le,xe,we){for(var $e=[pe,le];$e.length;)if(!((le=$e.pop())-(pe=$e.pop())<=xe)){var Ne=pe+Math.ceil((le-pe)/xe/2)*xe;Fe(Q,Ne,pe,le,we),$e.push(pe,Ne,Ne,le)}}return he.prototype.all=function(){return this._all(this.data,[])},he.prototype.search=function(Q){var pe=this.data,le=[];if(!ae(Q,pe))return le;for(var xe=this.toBBox,we=[];pe;){for(var $e=0;$e<pe.children.length;$e++){var Ne=pe.children[$e],Se=pe.leaf?xe(Ne):Ne;ae(Q,Se)&&(pe.leaf?le.push(Ne):re(Q,Se)?this._all(Ne,le):we.push(Ne))}pe=we.pop()}return le},he.prototype.collides=function(Q){var pe=this.data;if(!ae(Q,pe))return!1;for(var le=[];pe;){for(var xe=0;xe<pe.children.length;xe++){var we=pe.children[xe],$e=pe.leaf?this.toBBox(we):we;if(ae(Q,$e)){if(pe.leaf||re(Q,$e))return!0;le.push(we)}}pe=le.pop()}return!1},he.prototype.load=function(Q){if(!Q||!Q.length)return this;if(Q.length<this._minEntries){for(var pe=0;pe<Q.length;pe++)this.insert(Q[pe]);return this}var le=this._build(Q.slice(),0,Q.length-1,0);if(this.data.children.length)if(this.data.height===le.height)this._splitRoot(this.data,le);else{if(this.data.height<le.height){var xe=this.data;this.data=le,le=xe}this._insert(le,this.data.height-le.height-1,!0)}else this.data=le;return this},he.prototype.insert=function(Q){return Q&&this._insert(Q,this.data.height-1),this},he.prototype.clear=function(){return this.data=ie([]),this},he.prototype.remove=function(Q,pe){if(!Q)return this;for(var le,xe,we,$e=this.data,Ne=this.toBBox(Q),Se=[],Pe=[];$e||Se.length;){if($e||($e=Se.pop(),xe=Se[Se.length-1],le=Pe.pop(),we=!0),$e.leaf){var Z=ye(Q,$e.children,pe);if(-1!==Z)return $e.children.splice(Z,1),Se.push($e),this._condense(Se),this}we||$e.leaf||!re($e,Ne)?xe?(le++,$e=xe.children[le],we=!1):$e=null:(Se.push($e),Pe.push(le),le=0,xe=$e,$e=$e.children[0])}return this},he.prototype.toBBox=function(Q){return Q},he.prototype.compareMinX=function(Q,pe){return Q.minX-pe.minX},he.prototype.compareMinY=function(Q,pe){return Q.minY-pe.minY},he.prototype.toJSON=function(){return this.data},he.prototype.fromJSON=function(Q){return this.data=Q,this},he.prototype._all=function(Q,pe){for(var le=[];Q;)Q.leaf?pe.push.apply(pe,Q.children):le.push.apply(le,Q.children),Q=le.pop();return pe},he.prototype._build=function(Q,pe,le,xe){var we,$e=le-pe+1,Ne=this._maxEntries;if($e<=Ne)return de(we=ie(Q.slice(pe,le+1)),this.toBBox),we;xe||(xe=Math.ceil(Math.log($e)/Math.log(Ne)),Ne=Math.ceil($e/Math.pow(Ne,xe-1))),(we=ie([])).leaf=!1,we.height=xe;var Se=Math.ceil($e/Ne),Pe=Se*Math.ceil(Math.sqrt(Ne));Ue(Q,pe,le,Pe,this.compareMinX);for(var Z=pe;Z<=le;Z+=Pe){var Be=Math.min(Z+Pe-1,le);Ue(Q,Z,Be,Se,this.compareMinY);for(var ue=Z;ue<=Be;ue+=Se){var He=Math.min(ue+Se-1,Be);we.children.push(this._build(Q,ue,He,xe-1))}}return de(we,this.toBBox),we},he.prototype._chooseSubtree=function(Q,pe,le,xe){for(;xe.push(pe),!pe.leaf&&xe.length-1!==le;){for(var we=1/0,$e=1/0,Ne=void 0,Se=0;Se<pe.children.length;Se++){var Pe=pe.children[Se],Z=Ae(Pe),Be=(ue=Q,He=Pe,(Math.max(He.maxX,ue.maxX)-Math.min(He.minX,ue.minX))*(Math.max(He.maxY,ue.maxY)-Math.min(He.minY,ue.minY))-Z);Be<$e?($e=Be,we=Z<we?Z:we,Ne=Pe):Be===$e&&Z<we&&(we=Z,Ne=Pe)}pe=Ne||pe.children[0]}var ue,He;return pe},he.prototype._insert=function(Q,pe,le){var xe=le?Q:this.toBBox(Q),we=[],$e=this._chooseSubtree(xe,this.data,pe,we);for($e.children.push(Q),H($e,xe);pe>=0&&we[pe].children.length>this._maxEntries;)this._split(we,pe),pe--;this._adjustParentBBoxes(xe,we,pe)},he.prototype._split=function(Q,pe){var le=Q[pe],xe=le.children.length,we=this._minEntries;this._chooseSplitAxis(le,we,xe);var $e=this._chooseSplitIndex(le,we,xe),Ne=ie(le.children.splice($e,le.children.length-$e));Ne.height=le.height,Ne.leaf=le.leaf,de(le,this.toBBox),de(Ne,this.toBBox),pe?Q[pe-1].children.push(Ne):this._splitRoot(le,Ne)},he.prototype._splitRoot=function(Q,pe){this.data=ie([Q,pe]),this.data.height=Q.height+1,this.data.leaf=!1,de(this.data,this.toBBox)},he.prototype._chooseSplitIndex=function(Q,pe,le){for(var xe,we,$e,Ne,Se,Pe,Z,Be=1/0,ue=1/0,He=pe;He<=le-pe;He++){var _e=Me(Q,0,He,this.toBBox),kt=Me(Q,He,le,this.toBBox),Ct=(we=_e,$e=kt,void 0,void 0,void 0,void 0,Ne=Math.max(we.minX,$e.minX),Se=Math.max(we.minY,$e.minY),Pe=Math.min(we.maxX,$e.maxX),Z=Math.min(we.maxY,$e.maxY),Math.max(0,Pe-Ne)*Math.max(0,Z-Se)),Ke=Ae(_e)+Ae(kt);Ct<Be?(Be=Ct,xe=He,ue=Ke<ue?Ke:ue):Ct===Be&&Ke<ue&&(ue=Ke,xe=He)}return xe||le-pe},he.prototype._chooseSplitAxis=function(Q,pe,le){var xe=Q.leaf?this.compareMinX:Ye,we=Q.leaf?this.compareMinY:Je;this._allDistMargin(Q,pe,le,xe)<this._allDistMargin(Q,pe,le,we)&&Q.children.sort(xe)},he.prototype._allDistMargin=function(Q,pe,le,xe){Q.children.sort(xe);for(var we=this.toBBox,$e=Me(Q,0,pe,we),Ne=Me(Q,le-pe,le,we),Se=Le($e)+Le(Ne),Pe=pe;Pe<le-pe;Pe++){var Z=Q.children[Pe];H($e,Q.leaf?we(Z):Z),Se+=Le($e)}for(var Be=le-pe-1;Be>=pe;Be--){var ue=Q.children[Be];H(Ne,Q.leaf?we(ue):ue),Se+=Le(Ne)}return Se},he.prototype._adjustParentBBoxes=function(Q,pe,le){for(var xe=le;xe>=0;xe--)H(pe[xe],Q)},he.prototype._condense=function(Q){for(var pe=Q.length-1,le=void 0;pe>=0;pe--)0===Q[pe].children.length?pe>0?(le=Q[pe-1].children).splice(le.indexOf(Q[pe]),1):this.clear():de(Q[pe],this.toBBox)},he}()},5203:(ze,Fe,Y)=>{"use strict";var te,he=SyntaxError,ye=Function,de=TypeError,Me=function(_e){try{return ye('"use strict"; return ('+_e+").constructor;")()}catch{}},H=Object.getOwnPropertyDescriptor;if(H)try{H({},"")}catch{H=null}var Ye=function(){throw new de},Je=H?function(){try{return Ye}catch{try{return H(arguments,"callee").get}catch{return Ye}}}():Ye,Ae=Y(2969)(),Le=Object.getPrototypeOf||function(_e){return _e.__proto__},re={},ae=typeof Uint8Array>"u"?te:Le(Uint8Array),ie={"%AggregateError%":typeof AggregateError>"u"?te:AggregateError,"%Array%":Array,"%ArrayBuffer%":typeof ArrayBuffer>"u"?te:ArrayBuffer,"%ArrayIteratorPrototype%":Ae?Le([][Symbol.iterator]()):te,"%AsyncFromSyncIteratorPrototype%":te,"%AsyncFunction%":re,"%AsyncGenerator%":re,"%AsyncGeneratorFunction%":re,"%AsyncIteratorPrototype%":re,"%Atomics%":typeof Atomics>"u"?te:Atomics,"%BigInt%":typeof BigInt>"u"?te:BigInt,"%BigInt64Array%":typeof BigInt64Array>"u"?te:BigInt64Array,"%BigUint64Array%":typeof BigUint64Array>"u"?te:BigUint64Array,"%Boolean%":Boolean,"%DataView%":typeof DataView>"u"?te:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":Error,"%eval%":eval,"%EvalError%":EvalError,"%Float32Array%":typeof Float32Array>"u"?te:Float32Array,"%Float64Array%":typeof Float64Array>"u"?te:Float64Array,"%FinalizationRegistry%":typeof FinalizationRegistry>"u"?te:FinalizationRegistry,"%Function%":ye,"%GeneratorFunction%":re,"%Int8Array%":typeof Int8Array>"u"?te:Int8Array,"%Int16Array%":typeof Int16Array>"u"?te:Int16Array,"%Int32Array%":typeof Int32Array>"u"?te:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":Ae?Le(Le([][Symbol.iterator]())):te,"%JSON%":"object"==typeof JSON?JSON:te,"%Map%":typeof Map>"u"?te:Map,"%MapIteratorPrototype%":typeof Map>"u"||!Ae?te:Le((new Map)[Symbol.iterator]()),"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":typeof Promise>"u"?te:Promise,"%Proxy%":typeof Proxy>"u"?te:Proxy,"%RangeError%":RangeError,"%ReferenceError%":ReferenceError,"%Reflect%":typeof Reflect>"u"?te:Reflect,"%RegExp%":RegExp,"%Set%":typeof Set>"u"?te:Set,"%SetIteratorPrototype%":typeof Set>"u"||!Ae?te:Le((new Set)[Symbol.iterator]()),"%SharedArrayBuffer%":typeof SharedArrayBuffer>"u"?te:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":Ae?Le(""[Symbol.iterator]()):te,"%Symbol%":Ae?Symbol:te,"%SyntaxError%":he,"%ThrowTypeError%":Je,"%TypedArray%":ae,"%TypeError%":de,"%Uint8Array%":typeof Uint8Array>"u"?te:Uint8Array,"%Uint8ClampedArray%":typeof Uint8ClampedArray>"u"?te:Uint8ClampedArray,"%Uint16Array%":typeof Uint16Array>"u"?te:Uint16Array,"%Uint32Array%":typeof Uint32Array>"u"?te:Uint32Array,"%URIError%":URIError,"%WeakMap%":typeof WeakMap>"u"?te:WeakMap,"%WeakRef%":typeof WeakRef>"u"?te:WeakRef,"%WeakSet%":typeof WeakSet>"u"?te:WeakSet};try{null.error}catch(_e){var Ue=Le(Le(_e));ie["%Error.prototype%"]=Ue}var Q=function _e(kt){var Ct;if("%AsyncFunction%"===kt)Ct=Me("async function () {}");else if("%GeneratorFunction%"===kt)Ct=Me("function* () {}");else if("%AsyncGeneratorFunction%"===kt)Ct=Me("async function* () {}");else if("%AsyncGenerator%"===kt){var Ke=_e("%AsyncGeneratorFunction%");Ke&&(Ct=Ke.prototype)}else if("%AsyncIteratorPrototype%"===kt){var rt=_e("%AsyncGenerator%");rt&&(Ct=Le(rt.prototype))}return ie[kt]=Ct,Ct},pe={"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},le=Y(4444),xe=Y(3164),we=le.call(Function.call,Array.prototype.concat),$e=le.call(Function.apply,Array.prototype.splice),Ne=le.call(Function.call,String.prototype.replace),Se=le.call(Function.call,String.prototype.slice),Pe=le.call(Function.call,RegExp.prototype.exec),Z=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,Be=/\\(\\)?/g,ue=function(kt){var Ct=Se(kt,0,1),Ke=Se(kt,-1);if("%"===Ct&&"%"!==Ke)throw new he("invalid intrinsic syntax, expected closing `%`");if("%"===Ke&&"%"!==Ct)throw new he("invalid intrinsic syntax, expected opening `%`");var rt=[];return Ne(kt,Z,function(et,pt,dt,je){rt[rt.length]=dt?Ne(je,Be,"$1"):pt||et}),rt},He=function(kt,Ct){var rt,Ke=kt;if(xe(pe,Ke)&&(Ke="%"+(rt=pe[Ke])[0]+"%"),xe(ie,Ke)){var et=ie[Ke];if(et===re&&(et=Q(Ke)),typeof et>"u"&&!Ct)throw new de("intrinsic "+kt+" exists, but is not available. Please file an issue!");return{alias:rt,name:Ke,value:et}}throw new he("intrinsic "+kt+" does not exist!")};ze.exports=function(kt,Ct){if("string"!=typeof kt||0===kt.length)throw new de("intrinsic name must be a non-empty string");if(arguments.length>1&&"boolean"!=typeof Ct)throw new de('"allowMissing" argument must be a boolean');if(null===Pe(/^%?[^%]*%?$/,kt))throw new he("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var Ke=ue(kt),rt=Ke.length>0?Ke[0]:"",et=He("%"+rt+"%",Ct),pt=et.name,dt=et.value,je=!1,zt=et.alias;zt&&(rt=zt[0],$e(Ke,we([0,1],zt)));for(var $t=1,tn=!0;$t<Ke.length;$t+=1){var Gt=Ke[$t],Rn=Se(Gt,0,1),Bn=Se(Gt,-1);if(('"'===Rn||"'"===Rn||"`"===Rn||'"'===Bn||"'"===Bn||"`"===Bn)&&Rn!==Bn)throw new he("property names with quotes must have matching quotes");if(("constructor"===Gt||!tn)&&(je=!0),xe(ie,pt="%"+(rt+="."+Gt)+"%"))dt=ie[pt];else if(null!=dt){if(!(Gt in dt)){if(!Ct)throw new de("base intrinsic for "+kt+" exists, but the property is not available.");return}if(H&&$t+1>=Ke.length){var kn=H(dt,Gt);dt=(tn=!!kn)&&"get"in kn&&!("originalValue"in kn.get)?kn.get:dt[Gt]}else tn=xe(dt,Gt),dt=dt[Gt];tn&&!je&&(ie[pt]=dt)}}return dt}},7027:(ze,Fe,Y)=>{"use strict";var he=Y(5203)("%Object.defineProperty%",!0),ye=function(){if(he)try{return he({},"a",{value:1}),!0}catch{return!1}return!1};ye.hasArrayLengthDefineBug=function(){if(!ye())return null;try{return 1!==he([],"length",{value:1}).length}catch{return!0}},ze.exports=ye},2969:(ze,Fe,Y)=>{"use strict";var te=typeof Symbol<"u"&&Symbol,he=Y(1983);ze.exports=function(){return"function"==typeof te&&"function"==typeof Symbol&&"symbol"==typeof te("foo")&&"symbol"==typeof Symbol("bar")&&he()}},1983:ze=>{"use strict";ze.exports=function(){if("function"!=typeof Symbol||"function"!=typeof Object.getOwnPropertySymbols)return!1;if("symbol"==typeof Symbol.iterator)return!0;var Y={},te=Symbol("test"),he=Object(te);if("string"==typeof te||"[object Symbol]"!==Object.prototype.toString.call(te)||"[object Symbol]"!==Object.prototype.toString.call(he))return!1;for(te in Y[te]=42,Y)return!1;if("function"==typeof Object.keys&&0!==Object.keys(Y).length||"function"==typeof Object.getOwnPropertyNames&&0!==Object.getOwnPropertyNames(Y).length)return!1;var de=Object.getOwnPropertySymbols(Y);if(1!==de.length||de[0]!==te||!Object.prototype.propertyIsEnumerable.call(Y,te))return!1;if("function"==typeof Object.getOwnPropertyDescriptor){var Me=Object.getOwnPropertyDescriptor(Y,te);if(42!==Me.value||!0!==Me.enumerable)return!1}return!0}},6259:(ze,Fe,Y)=>{"use strict";var te=Y(1983);ze.exports=function(){return te()&&!!Symbol.toStringTag}},3164:(ze,Fe,Y)=>{"use strict";var te=Y(4444);ze.exports=te.call(Function.call,Object.prototype.hasOwnProperty)},3407:(ze,Fe,Y)=>{"use strict";var te=Y(6259)(),ye=Y(5834)("Object.prototype.toString"),de=function(Je){return!(te&&Je&&"object"==typeof Je&&Symbol.toStringTag in Je)&&"[object Arguments]"===ye(Je)},Me=function(Je){return!!de(Je)||null!==Je&&"object"==typeof Je&&"number"==typeof Je.length&&Je.length>=0&&"[object Array]"!==ye(Je)&&"[object Function]"===ye(Je.callee)},H=function(){return de(arguments)}();de.isLegacyArguments=Me,ze.exports=H?de:Me},2374:(ze,Fe,Y)=>{"use strict";var te=Date.prototype.getDay,ye=Object.prototype.toString,Me=Y(6259)();ze.exports=function(Ye){return"object"==typeof Ye&&null!==Ye&&(Me?function(Ye){try{return te.call(Ye),!0}catch{return!1}}(Ye):"[object Date]"===ye.call(Ye))}},2342:(ze,Fe,Y)=>{"use strict";var ye,de,Me,H,te=Y(5834),he=Y(6259)();if(he){ye=te("Object.prototype.hasOwnProperty"),de=te("RegExp.prototype.exec"),Me={};var Ye=function(){throw Me};H={toString:Ye,valueOf:Ye},"symbol"==typeof Symbol.toPrimitive&&(H[Symbol.toPrimitive]=Ye)}var Je=te("Object.prototype.toString"),Ae=Object.getOwnPropertyDescriptor;ze.exports=he?function(ae){if(!ae||"object"!=typeof ae)return!1;var ie=Ae(ae,"lastIndex");if(!ie||!ye(ie,"value"))return!1;try{de(ae,H)}catch(Q){return Q===Me}}:function(ae){return!(!ae||"object"!=typeof ae&&"function"!=typeof ae)&&"[object RegExp]"===Je(ae)}},9286:ze=>{ze.exports=function Fe(Y,te){"use strict";var Ue,Q,he=/(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi,ye=/(^[ ]*|[ ]*$)/g,de=/(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,Me=/^0x[0-9a-f]+$/i,H=/^0/,Ye=function(xe){return Fe.insensitive&&(""+xe).toLowerCase()||""+xe},Je=Ye(Y).replace(ye,"")||"",Ae=Ye(te).replace(ye,"")||"",Le=Je.replace(he,"\0$1\0").replace(/\0$/,"").replace(/^\0/,"").split("\0"),re=Ae.replace(he,"\0$1\0").replace(/\0$/,"").replace(/^\0/,"").split("\0"),ae=parseInt(Je.match(Me),16)||1!==Le.length&&Je.match(de)&&Date.parse(Je),ie=parseInt(Ae.match(Me),16)||ae&&Ae.match(de)&&Date.parse(Ae)||null;if(ie){if(ae<ie)return-1;if(ae>ie)return 1}for(var pe=0,le=Math.max(Le.length,re.length);pe<le;pe++){if(Ue=!(Le[pe]||"").match(H)&&parseFloat(Le[pe])||Le[pe]||0,Q=!(re[pe]||"").match(H)&&parseFloat(re[pe])||re[pe]||0,isNaN(Ue)!==isNaN(Q))return isNaN(Ue)?1:-1;if(typeof Ue!=typeof Q&&(Ue+="",Q+=""),Ue<Q)return-1;if(Ue>Q)return 1}return 0}},4994:(ze,Fe,Y)=>{var te=Y(4312),he=Y(6421),ye=Y(5764),de=Y(8685),Me=Y(6676);function H(Ye){var Je=-1,Ae=null==Ye?0:Ye.length;for(this.clear();++Je<Ae;){var Le=Ye[Je];this.set(Le[0],Le[1])}}H.prototype.clear=te,H.prototype.delete=he,H.prototype.get=ye,H.prototype.has=de,H.prototype.set=Me,ze.exports=H},9215:(ze,Fe,Y)=>{var te=Y(1840),he=Y(4378),ye=Y(4981),de=Y(7343),Me=Y(8895);function H(Ye){var Je=-1,Ae=null==Ye?0:Ye.length;for(this.clear();++Je<Ae;){var Le=Ye[Je];this.set(Le[0],Le[1])}}H.prototype.clear=te,H.prototype.delete=he,H.prototype.get=ye,H.prototype.has=de,H.prototype.set=Me,ze.exports=H},1501:(ze,Fe,Y)=>{var ye=Y(3436)(Y(2119),"Map");ze.exports=ye},9850:(ze,Fe,Y)=>{var te=Y(638),he=Y(1184),ye=Y(866),de=Y(3771),Me=Y(1772);function H(Ye){var Je=-1,Ae=null==Ye?0:Ye.length;for(this.clear();++Je<Ae;){var Le=Ye[Je];this.set(Le[0],Le[1])}}H.prototype.clear=te,H.prototype.delete=he,H.prototype.get=ye,H.prototype.has=de,H.prototype.set=Me,ze.exports=H},6323:(ze,Fe,Y)=>{var ye=Y(3436)(Y(2119),"Set");ze.exports=ye},8849:(ze,Fe,Y)=>{var te=Y(9850),he=Y(4600),ye=Y(1387);function de(Me){var H=-1,Ye=null==Me?0:Me.length;for(this.__data__=new te;++H<Ye;)this.add(Me[H])}de.prototype.add=de.prototype.push=he,de.prototype.has=ye,ze.exports=de},443:(ze,Fe,Y)=>{var te=Y(2119);ze.exports=te.Symbol},1253:(ze,Fe,Y)=>{var te=Y(4164);ze.exports=function he(ye,de){return!(null==ye||!ye.length)&&te(ye,de,0)>-1}},7609:ze=>{ze.exports=function Fe(Y,te,he){for(var ye=-1,de=null==Y?0:Y.length;++ye<de;)if(he(te,Y[ye]))return!0;return!1}},2271:(ze,Fe,Y)=>{var te=Y(5334),he=Y(7151),ye=Y(9460),de=Y(891),Me=Y(8442),H=Y(8159),Je=Object.prototype.hasOwnProperty;ze.exports=function Ae(Le,re){var ae=ye(Le),ie=!ae&&he(Le),Ue=!ae&&!ie&&de(Le),Q=!ae&&!ie&&!Ue&&H(Le),pe=ae||ie||Ue||Q,le=pe?te(Le.length,String):[],xe=le.length;for(var we in Le)(re||Je.call(Le,we))&&(!pe||!("length"==we||Ue&&("offset"==we||"parent"==we)||Q&&("buffer"==we||"byteLength"==we||"byteOffset"==we)||Me(we,xe)))&&le.push(we);return le}},4633:ze=>{ze.exports=function Fe(Y,te){for(var he=-1,ye=null==Y?0:Y.length,de=Array(ye);++he<ye;)de[he]=te(Y[he],he,Y);return de}},4125:(ze,Fe,Y)=>{var te=Y(8826);ze.exports=function he(ye){var de=ye.length;return de?ye[te(0,de-1)]:void 0}},8906:(ze,Fe,Y)=>{var te=Y(9454),he=Y(9905);ze.exports=function ye(de){return he(te(de))}},3503:(ze,Fe,Y)=>{var te=Y(217);ze.exports=function he(ye,de){for(var Me=ye.length;Me--;)if(te(ye[Me][0],de))return Me;return-1}},5317:ze=>{ze.exports=function Fe(Y,te,he,ye){for(var de=Y.length,Me=he+(ye?1:-1);ye?Me--:++Me<de;)if(te(Y[Me],Me,Y))return Me;return-1}},3337:(ze,Fe,Y)=>{var te=Y(443),he=Y(1318),ye=Y(2902),H=te?te.toStringTag:void 0;ze.exports=function Ye(Je){return null==Je?void 0===Je?"[object Undefined]":"[object Null]":H&&H in Object(Je)?he(Je):ye(Je)}},4164:(ze,Fe,Y)=>{var te=Y(5317),he=Y(968),ye=Y(4977);ze.exports=function de(Me,H,Ye){return H==H?ye(Me,H,Ye):te(Me,he,Ye)}},186:(ze,Fe,Y)=>{var te=Y(3337),he=Y(2671);ze.exports=function de(Me){return he(Me)&&"[object Arguments]"==te(Me)}},968:ze=>{ze.exports=function Fe(Y){return Y!=Y}},7304:(ze,Fe,Y)=>{var te=Y(5946),he=Y(1943),ye=Y(5940),de=Y(2827),H=/^\[object .+?Constructor\]$/,re=RegExp("^"+Function.prototype.toString.call(Object.prototype.hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");ze.exports=function ae(ie){return!(!ye(ie)||he(ie))&&(te(ie)?re:H).test(de(ie))}},1083:(ze,Fe,Y)=>{var te=Y(3337),he=Y(6231),ye=Y(2671),_e={};_e["[object Float32Array]"]=_e["[object Float64Array]"]=_e["[object Int8Array]"]=_e["[object Int16Array]"]=_e["[object Int32Array]"]=_e["[object Uint8Array]"]=_e["[object Uint8ClampedArray]"]=_e["[object Uint16Array]"]=_e["[object Uint32Array]"]=!0,_e["[object Arguments]"]=_e["[object Array]"]=_e["[object ArrayBuffer]"]=_e["[object Boolean]"]=_e["[object DataView]"]=_e["[object Date]"]=_e["[object Error]"]=_e["[object Function]"]=_e["[object Map]"]=_e["[object Number]"]=_e["[object Object]"]=_e["[object RegExp]"]=_e["[object Set]"]=_e["[object String]"]=_e["[object WeakMap]"]=!1,ze.exports=function kt(Ct){return ye(Ct)&&he(Ct.length)&&!!_e[te(Ct)]}},1172:(ze,Fe,Y)=>{var te=Y(5488),he=Y(5491),de=Object.prototype.hasOwnProperty;ze.exports=function Me(H){if(!te(H))return he(H);var Ye=[];for(var Je in Object(H))de.call(H,Je)&&"constructor"!=Je&&Ye.push(Je);return Ye}},8826:ze=>{var Fe=Math.floor,Y=Math.random;ze.exports=function te(he,ye){return he+Fe(Y()*(ye-he+1))}},1435:(ze,Fe,Y)=>{var te=Y(4125),he=Y(377);ze.exports=function ye(de){return te(he(de))}},7522:(ze,Fe,Y)=>{var te=Y(9905),he=Y(377);ze.exports=function ye(de){return te(he(de))}},5334:ze=>{ze.exports=function Fe(Y,te){for(var he=-1,ye=Array(Y);++he<Y;)ye[he]=te(he);return ye}},5647:ze=>{ze.exports=function Fe(Y){return function(te){return Y(te)}}},707:(ze,Fe,Y)=>{var te=Y(8849),he=Y(1253),ye=Y(7609),de=Y(5972),Me=Y(4575),H=Y(4174);ze.exports=function Je(Ae,Le,re){var ae=-1,ie=he,Ue=Ae.length,Q=!0,pe=[],le=pe;if(re)Q=!1,ie=ye;else if(Ue>=200){var xe=Le?null:Me(Ae);if(xe)return H(xe);Q=!1,ie=de,le=new te}else le=Le?[]:pe;e:for(;++ae<Ue;){var we=Ae[ae],$e=Le?Le(we):we;if(we=re||0!==we?we:0,Q&&$e==$e){for(var Ne=le.length;Ne--;)if(le[Ne]===$e)continue e;Le&&le.push($e),pe.push(we)}else ie(le,$e,re)||(le!==pe&&le.push($e),pe.push(we))}return pe}},9179:(ze,Fe,Y)=>{var te=Y(4633);ze.exports=function he(ye,de){return te(de,function(Me){return ye[Me]})}},5972:ze=>{ze.exports=function Fe(Y,te){return Y.has(te)}},9454:ze=>{ze.exports=function Fe(Y,te){var he=-1,ye=Y.length;for(te||(te=Array(ye));++he<ye;)te[he]=Y[he];return te}},4610:(ze,Fe,Y)=>{var te=Y(2119);ze.exports=te["__core-js_shared__"]},4575:(ze,Fe,Y)=>{var te=Y(6323),he=Y(2552),ye=Y(4174),Me=te&&1/ye(new te([,-0]))[1]==1/0?function(H){return new te(H)}:he;ze.exports=Me},9122:ze=>{var Fe="object"==typeof global&&global&&global.Object===Object&&global;ze.exports=Fe},4537:(ze,Fe,Y)=>{var te=Y(3819);ze.exports=function he(ye,de){var Me=ye.__data__;return te(de)?Me["string"==typeof de?"string":"hash"]:Me.map}},3436:(ze,Fe,Y)=>{var te=Y(7304),he=Y(1990);ze.exports=function ye(de,Me){var H=he(de,Me);return te(H)?H:void 0}},1318:(ze,Fe,Y)=>{var te=Y(443),he=Object.prototype,ye=he.hasOwnProperty,de=he.toString,Me=te?te.toStringTag:void 0;ze.exports=function H(Ye){var Je=ye.call(Ye,Me),Ae=Ye[Me];try{Ye[Me]=void 0;var Le=!0}catch{}var re=de.call(Ye);return Le&&(Je?Ye[Me]=Ae:delete Ye[Me]),re}},1990:ze=>{ze.exports=function Fe(Y,te){return Y?.[te]}},4312:(ze,Fe,Y)=>{var te=Y(862);ze.exports=function he(){this.__data__=te?te(null):{},this.size=0}},6421:ze=>{ze.exports=function Fe(Y){var te=this.has(Y)&&delete this.__data__[Y];return this.size-=te?1:0,te}},5764:(ze,Fe,Y)=>{var te=Y(862),de=Object.prototype.hasOwnProperty;ze.exports=function Me(H){var Ye=this.__data__;if(te){var Je=Ye[H];return"__lodash_hash_undefined__"===Je?void 0:Je}return de.call(Ye,H)?Ye[H]:void 0}},8685:(ze,Fe,Y)=>{var te=Y(862),ye=Object.prototype.hasOwnProperty;ze.exports=function de(Me){var H=this.__data__;return te?void 0!==H[Me]:ye.call(H,Me)}},6676:(ze,Fe,Y)=>{var te=Y(862);ze.exports=function ye(de,Me){var H=this.__data__;return this.size+=this.has(de)?0:1,H[de]=te&&void 0===Me?"__lodash_hash_undefined__":Me,this}},8442:ze=>{var Y=/^(?:0|[1-9]\d*)$/;ze.exports=function te(he,ye){var de=typeof he;return!!(ye=ye??9007199254740991)&&("number"==de||"symbol"!=de&&Y.test(he))&&he>-1&&he%1==0&&he<ye}},3819:ze=>{ze.exports=function Fe(Y){var te=typeof Y;return"string"==te||"number"==te||"symbol"==te||"boolean"==te?"__proto__"!==Y:null===Y}},1943:(ze,Fe,Y)=>{var de,te=Y(4610),he=(de=/[^.]+$/.exec(te&&te.keys&&te.keys.IE_PROTO||""))?"Symbol(src)_1."+de:"";ze.exports=function ye(de){return!!he&&he in de}},5488:ze=>{var Fe=Object.prototype;ze.exports=function Y(te){var he=te&&te.constructor;return te===("function"==typeof he&&he.prototype||Fe)}},1840:ze=>{ze.exports=function Fe(){this.__data__=[],this.size=0}},4378:(ze,Fe,Y)=>{var te=Y(3503),ye=Array.prototype.splice;ze.exports=function de(Me){var H=this.__data__,Ye=te(H,Me);return!(Ye<0||(Ye==H.length-1?H.pop():ye.call(H,Ye,1),--this.size,0))}},4981:(ze,Fe,Y)=>{var te=Y(3503);ze.exports=function he(ye){var de=this.__data__,Me=te(de,ye);return Me<0?void 0:de[Me][1]}},7343:(ze,Fe,Y)=>{var te=Y(3503);ze.exports=function he(ye){return te(this.__data__,ye)>-1}},8895:(ze,Fe,Y)=>{var te=Y(3503);ze.exports=function he(ye,de){var Me=this.__data__,H=te(Me,ye);return H<0?(++this.size,Me.push([ye,de])):Me[H][1]=de,this}},638:(ze,Fe,Y)=>{var te=Y(4994),he=Y(9215),ye=Y(1501);ze.exports=function de(){this.size=0,this.__data__={hash:new te,map:new(ye||he),string:new te}}},1184:(ze,Fe,Y)=>{var te=Y(4537);ze.exports=function he(ye){var de=te(this,ye).delete(ye);return this.size-=de?1:0,de}},866:(ze,Fe,Y)=>{var te=Y(4537);ze.exports=function he(ye){return te(this,ye).get(ye)}},3771:(ze,Fe,Y)=>{var te=Y(4537);ze.exports=function he(ye){return te(this,ye).has(ye)}},1772:(ze,Fe,Y)=>{var te=Y(4537);ze.exports=function he(ye,de){var Me=te(this,ye),H=Me.size;return Me.set(ye,de),this.size+=Me.size==H?0:1,this}},862:(ze,Fe,Y)=>{var he=Y(3436)(Object,"create");ze.exports=he},5491:(ze,Fe,Y)=>{var he=Y(9385)(Object.keys,Object);ze.exports=he},3597:(ze,Fe,Y)=>{ze=Y.nmd(ze);var te=Y(9122),he=Fe&&!Fe.nodeType&&Fe,ye=he&&ze&&!ze.nodeType&&ze,Me=ye&&ye.exports===he&&te.process,H=function(){try{return ye&&ye.require&&ye.require("util").types||Me&&Me.binding&&Me.binding("util")}catch{}}();ze.exports=H},2902:ze=>{var Y=Object.prototype.toString;ze.exports=function te(he){return Y.call(he)}},9385:ze=>{ze.exports=function Fe(Y,te){return function(he){return Y(te(he))}}},2119:(ze,Fe,Y)=>{var te=Y(9122),he="object"==typeof self&&self&&self.Object===Object&&self,ye=te||he||Function("return this")();ze.exports=ye},4600:ze=>{ze.exports=function Y(te){return this.__data__.set(te,"__lodash_hash_undefined__"),this}},1387:ze=>{ze.exports=function Fe(Y){return this.__data__.has(Y)}},4174:ze=>{ze.exports=function Fe(Y){var te=-1,he=Array(Y.size);return Y.forEach(function(ye){he[++te]=ye}),he}},9905:(ze,Fe,Y)=>{var te=Y(8826);ze.exports=function he(ye,de){var Me=-1,H=ye.length,Ye=H-1;for(de=void 0===de?H:de;++Me<de;){var Je=te(Me,Ye),Ae=ye[Je];ye[Je]=ye[Me],ye[Me]=Ae}return ye.length=de,ye}},4977:ze=>{ze.exports=function Fe(Y,te,he){for(var ye=he-1,de=Y.length;++ye<de;)if(Y[ye]===te)return ye;return-1}},2827:ze=>{var Y=Function.prototype.toString;ze.exports=function te(he){if(null!=he){try{return Y.call(he)}catch{}try{return he+""}catch{}}return""}},217:ze=>{ze.exports=function Fe(Y,te){return Y===te||Y!=Y&&te!=te}},7151:(ze,Fe,Y)=>{var te=Y(186),he=Y(2671),ye=Object.prototype,de=ye.hasOwnProperty,Me=ye.propertyIsEnumerable,H=te(function(){return arguments}())?te:function(Ye){return he(Ye)&&de.call(Ye,"callee")&&!Me.call(Ye,"callee")};ze.exports=H},9460:ze=>{ze.exports=Array.isArray},6507:(ze,Fe,Y)=>{var te=Y(5946),he=Y(6231);ze.exports=function ye(de){return null!=de&&he(de.length)&&!te(de)}},891:(ze,Fe,Y)=>{ze=Y.nmd(ze);var te=Y(2119),he=Y(3580),ye=Fe&&!Fe.nodeType&&Fe,de=ye&&ze&&!ze.nodeType&&ze,H=de&&de.exports===ye?te.Buffer:void 0;ze.exports=(H?H.isBuffer:void 0)||he},5946:(ze,Fe,Y)=>{var te=Y(3337),he=Y(5940);ze.exports=function Ye(Je){if(!he(Je))return!1;var Ae=te(Je);return"[object Function]"==Ae||"[object GeneratorFunction]"==Ae||"[object AsyncFunction]"==Ae||"[object Proxy]"==Ae}},6231:ze=>{ze.exports=function Y(te){return"number"==typeof te&&te>-1&&te%1==0&&te<=9007199254740991}},5940:ze=>{ze.exports=function Fe(Y){var te=typeof Y;return null!=Y&&("object"==te||"function"==te)}},2671:ze=>{ze.exports=function Fe(Y){return null!=Y&&"object"==typeof Y}},8159:(ze,Fe,Y)=>{var te=Y(1083),he=Y(5647),ye=Y(3597),de=ye&&ye.isTypedArray,Me=de?he(de):te;ze.exports=Me},118:(ze,Fe,Y)=>{var te=Y(2271),he=Y(1172),ye=Y(6507);ze.exports=function de(Me){return ye(Me)?te(Me):he(Me)}},2552:ze=>{ze.exports=function Fe(){}},8799:(ze,Fe,Y)=>{var te=Y(4125),he=Y(1435),ye=Y(9460);ze.exports=function de(Me){return(ye(Me)?te:he)(Me)}},9336:(ze,Fe,Y)=>{var te=Y(8906),he=Y(7522),ye=Y(9460);ze.exports=function de(Me){return(ye(Me)?te:he)(Me)}},3580:ze=>{ze.exports=function Fe(){return!1}},836:(ze,Fe,Y)=>{var te=Y(707);ze.exports=function he(ye){return ye&&ye.length?te(ye):[]}},377:(ze,Fe,Y)=>{var te=Y(9179),he=Y(118);ze.exports=function ye(de){return null==de?[]:te(de,he(de))}},7658:ze=>{ze.exports=Y;var Fe=null;try{Fe=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Y(Be,ue,He){this.low=0|Be,this.high=0|ue,this.unsigned=!!He}function te(Be){return!0===(Be&&Be.__isLong__)}Object.defineProperty(Y.prototype,"__isLong__",{value:!0}),Y.isLong=te;var he={},ye={};function de(Be,ue){var He,_e,kt;return ue?(kt=0<=(Be>>>=0)&&Be<256)&&(_e=ye[Be])?_e:(He=H(Be,(0|Be)<0?-1:0,!0),kt&&(ye[Be]=He),He):(kt=-128<=(Be|=0)&&Be<128)&&(_e=he[Be])?_e:(He=H(Be,Be<0?-1:0,!1),kt&&(he[Be]=He),He)}function Me(Be,ue){if(isNaN(Be))return ue?le:pe;if(ue){if(Be<0)return le;if(Be>=ie)return Se}else{if(Be<=-Ue)return Pe;if(Be+1>=Ue)return Ne}return Be<0?Me(-Be,ue).neg():H(Be%ae|0,Be/ae|0,ue)}function H(Be,ue,He){return new Y(Be,ue,He)}Y.fromInt=de,Y.fromNumber=Me,Y.fromBits=H;var Ye=Math.pow;function Je(Be,ue,He){if(0===Be.length)throw Error("empty string");if("NaN"===Be||"Infinity"===Be||"+Infinity"===Be||"-Infinity"===Be)return pe;if("number"==typeof ue?(He=ue,ue=!1):ue=!!ue,(He=He||10)<2||36<He)throw RangeError("radix");var _e;if((_e=Be.indexOf("-"))>0)throw Error("interior hyphen");if(0===_e)return Je(Be.substring(1),ue,He).neg();for(var kt=Me(Ye(He,8)),Ct=pe,Ke=0;Ke<Be.length;Ke+=8){var rt=Math.min(8,Be.length-Ke),et=parseInt(Be.substring(Ke,Ke+rt),He);if(rt<8){var pt=Me(Ye(He,rt));Ct=Ct.mul(pt).add(Me(et))}else Ct=(Ct=Ct.mul(kt)).add(Me(et))}return Ct.unsigned=ue,Ct}function Ae(Be,ue){return"number"==typeof Be?Me(Be,ue):"string"==typeof Be?Je(Be,ue):H(Be.low,Be.high,"boolean"==typeof ue?ue:Be.unsigned)}Y.fromString=Je,Y.fromValue=Ae;var ae=4294967296,ie=ae*ae,Ue=ie/2,Q=de(1<<24),pe=de(0);Y.ZERO=pe;var le=de(0,!0);Y.UZERO=le;var xe=de(1);Y.ONE=xe;var we=de(1,!0);Y.UONE=we;var $e=de(-1);Y.NEG_ONE=$e;var Ne=H(-1,2147483647,!1);Y.MAX_VALUE=Ne;var Se=H(-1,-1,!0);Y.MAX_UNSIGNED_VALUE=Se;var Pe=H(0,-2147483648,!1);Y.MIN_VALUE=Pe;var Z=Y.prototype;Z.toInt=function(){return this.unsigned?this.low>>>0:this.low},Z.toNumber=function(){return this.unsigned?(this.high>>>0)*ae+(this.low>>>0):this.high*ae+(this.low>>>0)},Z.toString=function(ue){if((ue=ue||10)<2||36<ue)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(Pe)){var He=Me(ue),_e=this.div(He),kt=_e.mul(He).sub(this);return _e.toString(ue)+kt.toInt().toString(ue)}return"-"+this.neg().toString(ue)}for(var Ct=Me(Ye(ue,6),this.unsigned),Ke=this,rt="";;){var et=Ke.div(Ct),dt=(Ke.sub(et.mul(Ct)).toInt()>>>0).toString(ue);if((Ke=et).isZero())return dt+rt;for(;dt.length<6;)dt="0"+dt;rt=""+dt+rt}},Z.getHighBits=function(){return this.high},Z.getHighBitsUnsigned=function(){return this.high>>>0},Z.getLowBits=function(){return this.low},Z.getLowBitsUnsigned=function(){return this.low>>>0},Z.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Pe)?64:this.neg().getNumBitsAbs();for(var ue=0!=this.high?this.high:this.low,He=31;He>0&&!(ue&1<<He);He--);return 0!=this.high?He+33:He+1},Z.isZero=function(){return 0===this.high&&0===this.low},Z.eqz=Z.isZero,Z.isNegative=function(){return!this.unsigned&&this.high<0},Z.isPositive=function(){return this.unsigned||this.high>=0},Z.isOdd=function(){return 1==(1&this.low)},Z.isEven=function(){return 0==(1&this.low)},Z.equals=function(ue){return te(ue)||(ue=Ae(ue)),(this.unsigned===ue.unsigned||this.high>>>31!=1||ue.high>>>31!=1)&&this.high===ue.high&&this.low===ue.low},Z.eq=Z.equals,Z.notEquals=function(ue){return!this.eq(ue)},Z.neq=Z.notEquals,Z.ne=Z.notEquals,Z.lessThan=function(ue){return this.comp(ue)<0},Z.lt=Z.lessThan,Z.lessThanOrEqual=function(ue){return this.comp(ue)<=0},Z.lte=Z.lessThanOrEqual,Z.le=Z.lessThanOrEqual,Z.greaterThan=function(ue){return this.comp(ue)>0},Z.gt=Z.greaterThan,Z.greaterThanOrEqual=function(ue){return this.comp(ue)>=0},Z.gte=Z.greaterThanOrEqual,Z.ge=Z.greaterThanOrEqual,Z.compare=function(ue){if(te(ue)||(ue=Ae(ue)),this.eq(ue))return 0;var He=this.isNegative(),_e=ue.isNegative();return He&&!_e?-1:!He&&_e?1:this.unsigned?ue.high>>>0>this.high>>>0||ue.high===this.high&&ue.low>>>0>this.low>>>0?-1:1:this.sub(ue).isNegative()?-1:1},Z.comp=Z.compare,Z.negate=function(){return!this.unsigned&&this.eq(Pe)?Pe:this.not().add(xe)},Z.neg=Z.negate,Z.add=function(ue){te(ue)||(ue=Ae(ue));var dt=0,je=0,zt=0,$t=0;return zt+=($t+=(65535&this.low)+(65535&ue.low))>>>16,je+=(zt+=(this.low>>>16)+(ue.low>>>16))>>>16,dt+=(je+=(65535&this.high)+(65535&ue.high))>>>16,dt+=(this.high>>>16)+(ue.high>>>16),H((zt&=65535)<<16|($t&=65535),(dt&=65535)<<16|(je&=65535),this.unsigned)},Z.subtract=function(ue){return te(ue)||(ue=Ae(ue)),this.add(ue.neg())},Z.sub=Z.subtract,Z.multiply=function(ue){if(this.isZero())return pe;if(te(ue)||(ue=Ae(ue)),Fe)return H(Fe.mul(this.low,this.high,ue.low,ue.high),Fe.get_high(),this.unsigned);if(ue.isZero())return pe;if(this.eq(Pe))return ue.isOdd()?Pe:pe;if(ue.eq(Pe))return this.isOdd()?Pe:pe;if(this.isNegative())return ue.isNegative()?this.neg().mul(ue.neg()):this.neg().mul(ue).neg();if(ue.isNegative())return this.mul(ue.neg()).neg();if(this.lt(Q)&&ue.lt(Q))return Me(this.toNumber()*ue.toNumber(),this.unsigned);var kt=65535&this.high,Ct=this.low>>>16,Ke=65535&this.low,et=65535&ue.high,pt=ue.low>>>16,dt=65535&ue.low,je=0,zt=0,$t=0,tn=0;return $t+=(tn+=Ke*dt)>>>16,zt+=($t+=Ct*dt)>>>16,$t&=65535,zt+=($t+=Ke*pt)>>>16,je+=(zt+=kt*dt)>>>16,zt&=65535,je+=(zt+=Ct*pt)>>>16,zt&=65535,je+=(zt+=Ke*et)>>>16,je+=(this.high>>>16)*dt+kt*pt+Ct*et+Ke*(ue.high>>>16),H(($t&=65535)<<16|(tn&=65535),(je&=65535)<<16|(zt&=65535),this.unsigned)},Z.mul=Z.multiply,Z.divide=function(ue){if(te(ue)||(ue=Ae(ue)),ue.isZero())throw Error("division by zero");var _e,kt,Ct;if(Fe)return this.unsigned||-2147483648!==this.high||-1!==ue.low||-1!==ue.high?H((this.unsigned?Fe.div_u:Fe.div_s)(this.low,this.high,ue.low,ue.high),Fe.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?le:pe;if(this.unsigned){if(ue.unsigned||(ue=ue.toUnsigned()),ue.gt(this))return le;if(ue.gt(this.shru(1)))return we;Ct=le}else{if(this.eq(Pe))return ue.eq(xe)||ue.eq($e)?Pe:ue.eq(Pe)?xe:(_e=this.shr(1).div(ue).shl(1)).eq(pe)?ue.isNegative()?xe:$e:(kt=this.sub(ue.mul(_e)),Ct=_e.add(kt.div(ue)));if(ue.eq(Pe))return this.unsigned?le:pe;if(this.isNegative())return ue.isNegative()?this.neg().div(ue.neg()):this.neg().div(ue).neg();if(ue.isNegative())return this.div(ue.neg()).neg();Ct=pe}for(kt=this;kt.gte(ue);){_e=Math.max(1,Math.floor(kt.toNumber()/ue.toNumber()));for(var rt=Math.ceil(Math.log(_e)/Math.LN2),et=rt<=48?1:Ye(2,rt-48),pt=Me(_e),dt=pt.mul(ue);dt.isNegative()||dt.gt(kt);)dt=(pt=Me(_e-=et,this.unsigned)).mul(ue);pt.isZero()&&(pt=xe),Ct=Ct.add(pt),kt=kt.sub(dt)}return Ct},Z.div=Z.divide,Z.modulo=function(ue){return te(ue)||(ue=Ae(ue)),Fe?H((this.unsigned?Fe.rem_u:Fe.rem_s)(this.low,this.high,ue.low,ue.high),Fe.get_high(),this.unsigned):this.sub(this.div(ue).mul(ue))},Z.mod=Z.modulo,Z.rem=Z.modulo,Z.not=function(){return H(~this.low,~this.high,this.unsigned)},Z.and=function(ue){return te(ue)||(ue=Ae(ue)),H(this.low&ue.low,this.high&ue.high,this.unsigned)},Z.or=function(ue){return te(ue)||(ue=Ae(ue)),H(this.low|ue.low,this.high|ue.high,this.unsigned)},Z.xor=function(ue){return te(ue)||(ue=Ae(ue)),H(this.low^ue.low,this.high^ue.high,this.unsigned)},Z.shiftLeft=function(ue){return te(ue)&&(ue=ue.toInt()),0==(ue&=63)?this:ue<32?H(this.low<<ue,this.high<<ue|this.low>>>32-ue,this.unsigned):H(0,this.low<<ue-32,this.unsigned)},Z.shl=Z.shiftLeft,Z.shiftRight=function(ue){return te(ue)&&(ue=ue.toInt()),0==(ue&=63)?this:ue<32?H(this.low>>>ue|this.high<<32-ue,this.high>>ue,this.unsigned):H(this.high>>ue-32,this.high>=0?0:-1,this.unsigned)},Z.shr=Z.shiftRight,Z.shiftRightUnsigned=function(ue){if(te(ue)&&(ue=ue.toInt()),0==(ue&=63))return this;var He=this.high;return ue<32?H(this.low>>>ue|He<<32-ue,He>>>ue,this.unsigned):H(32===ue?He:He>>>ue-32,0,this.unsigned)},Z.shru=Z.shiftRightUnsigned,Z.shr_u=Z.shiftRightUnsigned,Z.toSigned=function(){return this.unsigned?H(this.low,this.high,!1):this},Z.toUnsigned=function(){return this.unsigned?this:H(this.low,this.high,!0)},Z.toBytes=function(ue){return ue?this.toBytesLE():this.toBytesBE()},Z.toBytesLE=function(){var ue=this.high,He=this.low;return[255&He,He>>>8&255,He>>>16&255,He>>>24,255&ue,ue>>>8&255,ue>>>16&255,ue>>>24]},Z.toBytesBE=function(){var ue=this.high,He=this.low;return[ue>>>24,ue>>>16&255,ue>>>8&255,255&ue,He>>>24,He>>>16&255,He>>>8&255,255&He]},Y.fromBytes=function(ue,He,_e){return _e?Y.fromBytesLE(ue,He):Y.fromBytesBE(ue,He)},Y.fromBytesLE=function(ue,He){return new Y(ue[0]|ue[1]<<8|ue[2]<<16|ue[3]<<24,ue[4]|ue[5]<<8|ue[6]<<16|ue[7]<<24,He)},Y.fromBytesBE=function(ue,He){return new Y(ue[4]<<24|ue[5]<<16|ue[6]<<8|ue[7],ue[0]<<24|ue[1]<<16|ue[2]<<8|ue[3],He)}},5943:ze=>{"use strict";var Fe=Object.getOwnPropertySymbols,Y=Object.prototype.hasOwnProperty,te=Object.prototype.propertyIsEnumerable;ze.exports=function ye(){try{if(!Object.assign)return!1;var de=new String("abc");if(de[5]="de","5"===Object.getOwnPropertyNames(de)[0])return!1;for(var Me={},H=0;H<10;H++)Me["_"+String.fromCharCode(H)]=H;if("0123456789"!==Object.getOwnPropertyNames(Me).map(function(Ae){return Me[Ae]}).join(""))return!1;var Je={};return"abcdefghijklmnopqrst".split("").forEach(function(Ae){Je[Ae]=Ae}),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},Je)).join("")}catch{return!1}}()?Object.assign:function(de,Me){for(var H,Je,Ye=function he(de){if(null==de)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(de)}(de),Ae=1;Ae<arguments.length;Ae++){for(var Le in H=Object(arguments[Ae]))Y.call(H,Le)&&(Ye[Le]=H[Le]);if(Fe){Je=Fe(H);for(var re=0;re<Je.length;re++)te.call(H,Je[re])&&(Ye[Je[re]]=H[Je[re]])}}return Ye}},1175:ze=>{"use strict";var Fe=function(Y){return Y!=Y};ze.exports=function(te,he){return 0===te&&0===he?1/te==1/he:!!(te===he||Fe(te)&&Fe(he))}},2e3:(ze,Fe,Y)=>{"use strict";var te=Y(2358),he=Y(5685),ye=Y(1175),de=Y(6305),Me=Y(3859),H=he(de(),Object);te(H,{getPolyfill:de,implementation:ye,shim:Me}),ze.exports=H},6305:(ze,Fe,Y)=>{"use strict";var te=Y(1175);ze.exports=function(){return"function"==typeof Object.is?Object.is:te}},3859:(ze,Fe,Y)=>{"use strict";var te=Y(6305),he=Y(2358);ze.exports=function(){var de=te();return he(Object,{is:de},{is:function(){return Object.is!==de}}),de}},2450:(ze,Fe,Y)=>{"use strict";var te;if(!Object.keys){var he=Object.prototype.hasOwnProperty,ye=Object.prototype.toString,de=Y(9978),Me=Object.prototype.propertyIsEnumerable,H=!Me.call({toString:null},"toString"),Ye=Me.call(function(){},"prototype"),Je=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],Ae=function(ie){var Ue=ie.constructor;return Ue&&Ue.prototype===ie},Le={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},re=function(){if(typeof window>"u")return!1;for(var ie in window)try{if(!Le["$"+ie]&&he.call(window,ie)&&null!==window[ie]&&"object"==typeof window[ie])try{Ae(window[ie])}catch{return!0}}catch{return!0}return!1}();te=function(Ue){var Q=null!==Ue&&"object"==typeof Ue,pe="[object Function]"===ye.call(Ue),le=de(Ue),xe=Q&&"[object String]"===ye.call(Ue),we=[];if(!Q&&!pe&&!le)throw new TypeError("Object.keys called on a non-object");var $e=Ye&&pe;if(xe&&Ue.length>0&&!he.call(Ue,0))for(var Ne=0;Ne<Ue.length;++Ne)we.push(String(Ne));if(le&&Ue.length>0)for(var Se=0;Se<Ue.length;++Se)we.push(String(Se));else for(var Pe in Ue)(!$e||"prototype"!==Pe)&&he.call(Ue,Pe)&&we.push(String(Pe));if(H)for(var Z=function(ie){if(typeof window>"u"||!re)return Ae(ie);try{return Ae(ie)}catch{return!1}}(Ue),Be=0;Be<Je.length;++Be)(!Z||"constructor"!==Je[Be])&&he.call(Ue,Je[Be])&&we.push(Je[Be]);return we}}ze.exports=te},1356:(ze,Fe,Y)=>{"use strict";var te=Array.prototype.slice,he=Y(9978),ye=Object.keys,de=ye?function(Ye){return ye(Ye)}:Y(2450),Me=Object.keys;de.shim=function(){if(Object.keys){var Ye=function(){var Je=Object.keys(arguments);return Je&&Je.length===arguments.length}(1,2);Ye||(Object.keys=function(Ae){return he(Ae)?Me(te.call(Ae)):Me(Ae)})}else Object.keys=de;return Object.keys||de},ze.exports=de},9978:ze=>{"use strict";var Fe=Object.prototype.toString;ze.exports=function(te){var he=Fe.call(te),ye="[object Arguments]"===he;return ye||(ye="[object Array]"!==he&&null!==te&&"object"==typeof te&&"number"==typeof te.length&&te.length>=0&&"[object Function]"===Fe.call(te.callee)),ye}},1766:ze=>{ze.exports=function(Y,te,he,ye){var de=Y[0],Me=Y[1],H=!1;void 0===he&&(he=0),void 0===ye&&(ye=te.length);for(var Ye=(ye-he)/2,Je=0,Ae=Ye-1;Je<Ye;Ae=Je++){var Le=te[he+2*Je+0],re=te[he+2*Je+1],ie=te[he+2*Ae+1];re>Me!=ie>Me&&de<(te[he+2*Ae+0]-Le)*(Me-re)/(ie-re)+Le&&(H=!H)}return H}},3870:(ze,Fe,Y)=>{var te=Y(1766),he=Y(2260);ze.exports=function(de,Me,H,Ye){return Me.length>0&&Array.isArray(Me[0])?he(de,Me,H,Ye):te(de,Me,H,Ye)},ze.exports.nested=he,ze.exports.flat=te},2260:ze=>{ze.exports=function(Y,te,he,ye){var de=Y[0],Me=Y[1],H=!1;void 0===he&&(he=0),void 0===ye&&(ye=te.length);for(var Ye=ye-he,Je=0,Ae=Ye-1;Je<Ye;Ae=Je++){var Le=te[Je+he][0],re=te[Je+he][1],ie=te[Ae+he][1];re>Me!=ie>Me&&de<(te[Ae+he][0]-Le)*(Me-re)/(ie-re)+Le&&(H=!H)}return H}},9855:function(ze){ze.exports=function(){"use strict";function Fe(Tt,We){if(!(Tt instanceof We))throw new TypeError("Cannot call a class as a function")}function Y(Tt,We){for(var Oe=0;Oe<We.length;Oe++){var De=We[Oe];De.enumerable=De.enumerable||!1,De.configurable=!0,"value"in De&&(De.writable=!0),Object.defineProperty(Tt,De.key,De)}}function te(Tt,We,Oe){return We&&Y(Tt.prototype,We),Oe&&Y(Tt,Oe),Tt}var he=function Tt(We,Oe){this.next=null,this.key=We,this.data=Oe,this.left=null,this.right=null};function ye(Tt,We){return Tt>We?1:Tt<We?-1:0}function de(Tt,We,Oe){for(var De=new he(null,null),nt=De,Te=De;;){var tt=Oe(Tt,We.key);if(tt<0){if(null===We.left)break;if(Oe(Tt,We.left.key)<0&&(We.left=(mt=We.left).right,mt.right=We,null===(We=mt).left))break;Te.left=We,Te=We,We=We.left}else{if(!(tt>0))break;if(null===We.right)break;var mt;if(Oe(Tt,We.right.key)>0&&(We.right=(mt=We.right).left,mt.left=We,null===(We=mt).right))break;nt.right=We,nt=We,We=We.right}}return nt.right=We.left,Te.left=We.right,We.left=De.right,We.right=De.left,We}function Me(Tt,We,Oe,De){var nt=new he(Tt,We);if(null===Oe)return nt.left=nt.right=null,nt;var Te=De(Tt,(Oe=de(Tt,Oe,De)).key);return Te<0?(nt.left=Oe.left,nt.right=Oe,Oe.left=null):Te>=0&&(nt.right=Oe.right,nt.left=Oe,Oe.right=null),nt}function H(Tt,We,Oe){var De=null,nt=null;if(We){var Te=Oe((We=de(Tt,We,Oe)).key,Tt);0===Te?(De=We.left,nt=We.right):Te<0?(nt=We.right,We.right=null,De=We):(De=We.left,We.left=null,nt=We)}return{left:De,right:nt}}function Je(Tt,We,Oe,De,nt){if(Tt){De(We+(Oe?"\u2514\u2500\u2500 ":"\u251c\u2500\u2500 ")+nt(Tt)+"\n");var Te=We+(Oe?"    ":"\u2502   ");Tt.left&&Je(Tt.left,Te,!1,De,nt),Tt.right&&Je(Tt.right,Te,!0,De,nt)}}var Ae=function(){function Tt(We){void 0===We&&(We=ye),this._root=null,this._size=0,this._comparator=We}return Tt.prototype.insert=function(We,Oe){return this._size++,this._root=Me(We,Oe,this._root,this._comparator)},Tt.prototype.add=function(We,Oe){var De=new he(We,Oe);null===this._root&&(De.left=De.right=null,this._size++,this._root=De);var nt=this._comparator,Te=de(We,this._root,nt),tt=nt(We,Te.key);return 0===tt?this._root=Te:(tt<0?(De.left=Te.left,De.right=Te,Te.left=null):tt>0&&(De.right=Te.right,De.left=Te,Te.right=null),this._size++,this._root=De),this._root},Tt.prototype.remove=function(We){this._root=this._remove(We,this._root,this._comparator)},Tt.prototype._remove=function(We,Oe,De){var nt;return null===Oe?null:0===De(We,(Oe=de(We,Oe,De)).key)?(null===Oe.left?nt=Oe.right:(nt=de(We,Oe.left,De)).right=Oe.right,this._size--,nt):Oe},Tt.prototype.pop=function(){var We=this._root;if(We){for(;We.left;)We=We.left;return this._root=de(We.key,this._root,this._comparator),this._root=this._remove(We.key,this._root,this._comparator),{key:We.key,data:We.data}}return null},Tt.prototype.findStatic=function(We){for(var Oe=this._root,De=this._comparator;Oe;){var nt=De(We,Oe.key);if(0===nt)return Oe;Oe=nt<0?Oe.left:Oe.right}return null},Tt.prototype.find=function(We){return this._root&&(this._root=de(We,this._root,this._comparator),0!==this._comparator(We,this._root.key))?null:this._root},Tt.prototype.contains=function(We){for(var Oe=this._root,De=this._comparator;Oe;){var nt=De(We,Oe.key);if(0===nt)return!0;Oe=nt<0?Oe.left:Oe.right}return!1},Tt.prototype.forEach=function(We,Oe){for(var De=this._root,nt=[],Te=!1;!Te;)null!==De?(nt.push(De),De=De.left):0!==nt.length?(De=nt.pop(),We.call(Oe,De),De=De.right):Te=!0;return this},Tt.prototype.range=function(We,Oe,De,nt){for(var Te=[],tt=this._comparator,mt=this._root;0!==Te.length||mt;)if(mt)Te.push(mt),mt=mt.left;else{if(tt((mt=Te.pop()).key,Oe)>0)break;if(tt(mt.key,We)>=0&&De.call(nt,mt))return this;mt=mt.right}return this},Tt.prototype.keys=function(){var We=[];return this.forEach(function(Oe){return We.push(Oe.key)}),We},Tt.prototype.values=function(){var We=[];return this.forEach(function(Oe){return We.push(Oe.data)}),We},Tt.prototype.min=function(){return this._root?this.minNode(this._root).key:null},Tt.prototype.max=function(){return this._root?this.maxNode(this._root).key:null},Tt.prototype.minNode=function(We){if(void 0===We&&(We=this._root),We)for(;We.left;)We=We.left;return We},Tt.prototype.maxNode=function(We){if(void 0===We&&(We=this._root),We)for(;We.right;)We=We.right;return We},Tt.prototype.at=function(We){for(var Oe=this._root,De=!1,nt=0,Te=[];!De;)if(Oe)Te.push(Oe),Oe=Oe.left;else if(Te.length>0){if(Oe=Te.pop(),nt===We)return Oe;nt++,Oe=Oe.right}else De=!0;return null},Tt.prototype.next=function(We){var Oe=this._root,De=null;if(We.right){for(De=We.right;De.left;)De=De.left;return De}for(var nt=this._comparator;Oe;){var Te=nt(We.key,Oe.key);if(0===Te)break;Te<0?(De=Oe,Oe=Oe.left):Oe=Oe.right}return De},Tt.prototype.prev=function(We){var Oe=this._root,De=null;if(null!==We.left){for(De=We.left;De.right;)De=De.right;return De}for(var nt=this._comparator;Oe;){var Te=nt(We.key,Oe.key);if(0===Te)break;Te<0?Oe=Oe.left:(De=Oe,Oe=Oe.right)}return De},Tt.prototype.clear=function(){return this._root=null,this._size=0,this},Tt.prototype.toList=function(){return function ae(Tt){for(var We=Tt,Oe=[],De=!1,nt=new he(null,null),Te=nt;!De;)We?(Oe.push(We),We=We.left):Oe.length>0?We=(We=Te=Te.next=Oe.pop()).right:De=!0;return Te.next=null,nt.next}(this._root)},Tt.prototype.load=function(We,Oe,De){void 0===Oe&&(Oe=[]),void 0===De&&(De=!1);var nt=We.length,Te=this._comparator;if(De&&Q(We,Oe,0,nt-1,Te),null===this._root)this._root=Le(We,Oe,0,nt),this._size=nt;else{var tt=function Ue(Tt,We,Oe){for(var De=new he(null,null),nt=De,Te=Tt,tt=We;null!==Te&&null!==tt;)Oe(Te.key,tt.key)<0?(nt.next=Te,Te=Te.next):(nt.next=tt,tt=tt.next),nt=nt.next;return null!==Te?nt.next=Te:null!==tt&&(nt.next=tt),De.next}(this.toList(),function re(Tt,We){for(var Oe=new he(null,null),De=Oe,nt=0;nt<Tt.length;nt++)De=De.next=new he(Tt[nt],We[nt]);return De.next=null,Oe.next}(We,Oe),Te);this._root=ie({head:tt},0,nt=this._size+nt)}return this},Tt.prototype.isEmpty=function(){return null===this._root},Object.defineProperty(Tt.prototype,"size",{get:function(){return this._size},enumerable:!0,configurable:!0}),Object.defineProperty(Tt.prototype,"root",{get:function(){return this._root},enumerable:!0,configurable:!0}),Tt.prototype.toString=function(We){void 0===We&&(We=function(nt){return String(nt.key)});var Oe=[];return Je(this._root,"",!0,function(De){return Oe.push(De)},We),Oe.join("")},Tt.prototype.update=function(We,Oe,De){var nt=this._comparator,Te=H(We,this._root,nt),tt=Te.left,mt=Te.right;nt(We,Oe)<0?mt=Me(Oe,De,mt,nt):tt=Me(Oe,De,tt,nt),this._root=function Ye(Tt,We,Oe){return null===We?Tt:(null===Tt||((We=de(Tt.key,We,Oe)).left=Tt),We)}(tt,mt,nt)},Tt.prototype.split=function(We){return H(We,this._root,this._comparator)},Tt}();function Le(Tt,We,Oe,De){var nt=De-Oe;if(nt>0){var Te=Oe+Math.floor(nt/2),K=new he(Tt[Te],We[Te]);return K.left=Le(Tt,We,Oe,Te),K.right=Le(Tt,We,Te+1,De),K}return null}function ie(Tt,We,Oe){var De=Oe-We;if(De>0){var nt=We+Math.floor(De/2),Te=ie(Tt,We,nt),tt=Tt.head;return tt.left=Te,Tt.head=Tt.head.next,tt.right=ie(Tt,nt+1,Oe),tt}return null}function Q(Tt,We,Oe,De,nt){if(!(Oe>=De)){for(var Te=Tt[Oe+De>>1],tt=Oe-1,mt=De+1;;){do{tt++}while(nt(Tt[tt],Te)<0);do{mt--}while(nt(Tt[mt],Te)>0);if(tt>=mt)break;var K=Tt[tt];Tt[tt]=Tt[mt],Tt[mt]=K,K=We[tt],We[tt]=We[mt],We[mt]=K}Q(Tt,We,Oe,mt,nt),Q(Tt,We,mt+1,De,nt)}}var pe=function(We,Oe){return We.ll.x<=Oe.x&&Oe.x<=We.ur.x&&We.ll.y<=Oe.y&&Oe.y<=We.ur.y},le=function(We,Oe){return Oe.ur.x<We.ll.x||We.ur.x<Oe.ll.x||Oe.ur.y<We.ll.y||We.ur.y<Oe.ll.y?null:{ll:{x:We.ll.x<Oe.ll.x?Oe.ll.x:We.ll.x,y:We.ll.y<Oe.ll.y?Oe.ll.y:We.ll.y},ur:{x:We.ur.x<Oe.ur.x?We.ur.x:Oe.ur.x,y:We.ur.y<Oe.ur.y?We.ur.y:Oe.ur.y}}},xe=Number.EPSILON;void 0===xe&&(xe=Math.pow(2,-52));var we=xe*xe,$e=function(We,Oe){if(-xe<We&&We<xe&&-xe<Oe&&Oe<xe)return 0;var De=We-Oe;return De*De<we*We*Oe?0:We<Oe?-1:1},Ne=function(){function Tt(){Fe(this,Tt),this.reset()}return te(Tt,[{key:"reset",value:function(){this.xRounder=new Se,this.yRounder=new Se}},{key:"round",value:function(Oe,De){return{x:this.xRounder.round(Oe),y:this.yRounder.round(De)}}}]),Tt}(),Se=function(){function Tt(){Fe(this,Tt),this.tree=new Ae,this.round(0)}return te(Tt,[{key:"round",value:function(Oe){var De=this.tree.add(Oe),nt=this.tree.prev(De);if(null!==nt&&0===$e(De.key,nt.key))return this.tree.remove(Oe),nt.key;var Te=this.tree.next(De);return null!==Te&&0===$e(De.key,Te.key)?(this.tree.remove(Oe),Te.key):Oe}}]),Tt}(),Pe=new Ne,Z=function(We,Oe){return We.x*Oe.y-We.y*Oe.x},Be=function(We,Oe){return We.x*Oe.x+We.y*Oe.y},ue=function(We,Oe,De){var tt=Z({x:Oe.x-We.x,y:Oe.y-We.y},{x:De.x-We.x,y:De.y-We.y});return $e(tt,0)},He=function(We){return Math.sqrt(Be(We,We))},_e=function(We,Oe,De){var nt={x:Oe.x-We.x,y:Oe.y-We.y},Te={x:De.x-We.x,y:De.y-We.y};return Z(Te,nt)/He(Te)/He(nt)},kt=function(We,Oe,De){var nt={x:Oe.x-We.x,y:Oe.y-We.y},Te={x:De.x-We.x,y:De.y-We.y};return Be(Te,nt)/He(Te)/He(nt)},Ct=function(We,Oe,De){return 0===Oe.y?null:{x:We.x+Oe.x/Oe.y*(De-We.y),y:De}},Ke=function(We,Oe,De){return 0===Oe.x?null:{x:De,y:We.y+Oe.y/Oe.x*(De-We.x)}},et=function(){function Tt(We,Oe){Fe(this,Tt),void 0===We.events?We.events=[this]:We.events.push(this),this.point=We,this.isLeft=Oe}return te(Tt,null,[{key:"compare",value:function(Oe,De){var nt=Tt.comparePoints(Oe.point,De.point);return 0!==nt?nt:(Oe.point!==De.point&&Oe.link(De),Oe.isLeft!==De.isLeft?Oe.isLeft?1:-1:dt.compare(Oe.segment,De.segment))}},{key:"comparePoints",value:function(Oe,De){return Oe.x<De.x?-1:Oe.x>De.x?1:Oe.y<De.y?-1:Oe.y>De.y?1:0}}]),te(Tt,[{key:"link",value:function(Oe){if(Oe.point===this.point)throw new Error("Tried to link already linked events");for(var De=Oe.point.events,nt=0,Te=De.length;nt<Te;nt++){var tt=De[nt];this.point.events.push(tt),tt.point=this.point}this.checkForConsuming()}},{key:"checkForConsuming",value:function(){for(var Oe=this.point.events.length,De=0;De<Oe;De++){var nt=this.point.events[De];if(void 0===nt.segment.consumedBy)for(var Te=De+1;Te<Oe;Te++){var tt=this.point.events[Te];void 0===tt.consumedBy&&nt.otherSE.point.events===tt.otherSE.point.events&&nt.segment.consume(tt.segment)}}}},{key:"getAvailableLinkedEvents",value:function(){for(var Oe=[],De=0,nt=this.point.events.length;De<nt;De++){var Te=this.point.events[De];Te!==this&&!Te.segment.ringOut&&Te.segment.isInResult()&&Oe.push(Te)}return Oe}},{key:"getLeftmostComparator",value:function(Oe){var De=this,nt=new Map,Te=function(mt){var K=mt.otherSE;nt.set(mt,{sine:_e(De.point,Oe.point,K.point),cosine:kt(De.point,Oe.point,K.point)})};return function(tt,mt){nt.has(tt)||Te(tt),nt.has(mt)||Te(mt);var K=nt.get(tt),xt=K.sine,on=K.cosine,ft=nt.get(mt),Xt=ft.sine,Kt=ft.cosine;return xt>=0&&Xt>=0?on<Kt?1:on>Kt?-1:0:xt<0&&Xt<0?on<Kt?-1:on>Kt?1:0:Xt<xt?-1:Xt>xt?1:0}}}]),Tt}(),pt=0,dt=function(){function Tt(We,Oe,De,nt){Fe(this,Tt),this.id=++pt,this.leftSE=We,We.segment=this,We.otherSE=Oe,this.rightSE=Oe,Oe.segment=this,Oe.otherSE=We,this.rings=De,this.windings=nt}return te(Tt,null,[{key:"compare",value:function(Oe,De){var nt=Oe.leftSE.point.x,Te=De.leftSE.point.x,tt=Oe.rightSE.point.x,mt=De.rightSE.point.x;if(mt<nt)return 1;if(tt<Te)return-1;var K=Oe.leftSE.point.y,xt=De.leftSE.point.y,on=Oe.rightSE.point.y,ft=De.rightSE.point.y;if(nt<Te){if(xt<K&&xt<on)return 1;if(xt>K&&xt>on)return-1;var Xt=Oe.comparePoint(De.leftSE.point);if(Xt<0)return 1;if(Xt>0)return-1;var Kt=De.comparePoint(Oe.rightSE.point);return 0!==Kt?Kt:-1}if(nt>Te){if(K<xt&&K<ft)return-1;if(K>xt&&K>ft)return 1;var Pn=De.comparePoint(Oe.leftSE.point);if(0!==Pn)return Pn;var xr=Oe.comparePoint(De.rightSE.point);return xr<0?1:xr>0?-1:1}if(K<xt)return-1;if(K>xt)return 1;if(tt<mt){var br=De.comparePoint(Oe.rightSE.point);if(0!==br)return br}if(tt>mt){var oi=Oe.comparePoint(De.rightSE.point);if(oi<0)return 1;if(oi>0)return-1}if(tt!==mt){var qi=on-K,ks=tt-nt,ls=ft-xt,ar=mt-Te;if(qi>ks&&ls<ar)return 1;if(qi<ks&&ls>ar)return-1}return tt>mt?1:tt<mt||on<ft?-1:on>ft?1:Oe.id<De.id?-1:Oe.id>De.id?1:0}}]),te(Tt,[{key:"replaceRightSE",value:function(Oe){this.rightSE=Oe,this.rightSE.segment=this,this.rightSE.otherSE=this.leftSE,this.leftSE.otherSE=this.rightSE}},{key:"bbox",value:function(){var Oe=this.leftSE.point.y,De=this.rightSE.point.y;return{ll:{x:this.leftSE.point.x,y:Oe<De?Oe:De},ur:{x:this.rightSE.point.x,y:Oe>De?Oe:De}}}},{key:"vector",value:function(){return{x:this.rightSE.point.x-this.leftSE.point.x,y:this.rightSE.point.y-this.leftSE.point.y}}},{key:"isAnEndpoint",value:function(Oe){return Oe.x===this.leftSE.point.x&&Oe.y===this.leftSE.point.y||Oe.x===this.rightSE.point.x&&Oe.y===this.rightSE.point.y}},{key:"comparePoint",value:function(Oe){if(this.isAnEndpoint(Oe))return 0;var De=this.leftSE.point,nt=this.rightSE.point,Te=this.vector();if(De.x===nt.x)return Oe.x===De.x?0:Oe.x<De.x?1:-1;if(Oe.x===De.x+(Oe.y-De.y)/Te.y*Te.x)return 0;var xt=De.y+(Oe.x-De.x)/Te.x*Te.y;return Oe.y===xt?0:Oe.y<xt?-1:1}},{key:"getIntersection",value:function(Oe){var De=this.bbox(),nt=Oe.bbox(),Te=le(De,nt);if(null===Te)return null;var tt=this.leftSE.point,mt=this.rightSE.point,K=Oe.leftSE.point,xt=Oe.rightSE.point,on=pe(De,K)&&0===this.comparePoint(K),ft=pe(nt,tt)&&0===Oe.comparePoint(tt),Xt=pe(De,xt)&&0===this.comparePoint(xt),Kt=pe(nt,mt)&&0===Oe.comparePoint(mt);if(ft&&on)return Kt&&!Xt?mt:!Kt&&Xt?xt:null;if(ft)return Xt&&tt.x===xt.x&&tt.y===xt.y?null:tt;if(on)return Kt&&mt.x===K.x&&mt.y===K.y?null:K;if(Kt&&Xt)return null;if(Kt)return mt;if(Xt)return xt;var Pn=function(We,Oe,De,nt){if(0===Oe.x)return Ke(De,nt,We.x);if(0===nt.x)return Ke(We,Oe,De.x);if(0===Oe.y)return Ct(De,nt,We.y);if(0===nt.y)return Ct(We,Oe,De.y);var Te=Z(Oe,nt);if(0==Te)return null;var tt={x:De.x-We.x,y:De.y-We.y},mt=Z(tt,Oe)/Te,K=Z(tt,nt)/Te;return{x:(We.x+K*Oe.x+(De.x+mt*nt.x))/2,y:(We.y+K*Oe.y+(De.y+mt*nt.y))/2}}(tt,this.vector(),K,Oe.vector());return null!==Pn&&pe(Te,Pn)?Pe.round(Pn.x,Pn.y):null}},{key:"split",value:function(Oe){var De=[],nt=void 0!==Oe.events,Te=new et(Oe,!0),tt=new et(Oe,!1),mt=this.rightSE;this.replaceRightSE(tt),De.push(tt),De.push(Te);var K=new Tt(Te,mt,this.rings.slice(),this.windings.slice());return et.comparePoints(K.leftSE.point,K.rightSE.point)>0&&K.swapEvents(),et.comparePoints(this.leftSE.point,this.rightSE.point)>0&&this.swapEvents(),nt&&(Te.checkForConsuming(),tt.checkForConsuming()),De}},{key:"swapEvents",value:function(){var Oe=this.rightSE;this.rightSE=this.leftSE,this.leftSE=Oe,this.leftSE.isLeft=!0,this.rightSE.isLeft=!1;for(var De=0,nt=this.windings.length;De<nt;De++)this.windings[De]*=-1}},{key:"consume",value:function(Oe){for(var De=this,nt=Oe;De.consumedBy;)De=De.consumedBy;for(;nt.consumedBy;)nt=nt.consumedBy;var Te=Tt.compare(De,nt);if(0!==Te){if(Te>0){var tt=De;De=nt,nt=tt}if(De.prev===nt){var mt=De;De=nt,nt=mt}for(var K=0,xt=nt.rings.length;K<xt;K++){var on=nt.rings[K],ft=nt.windings[K],Xt=De.rings.indexOf(on);-1===Xt?(De.rings.push(on),De.windings.push(ft)):De.windings[Xt]+=ft}nt.rings=null,nt.windings=null,nt.consumedBy=De,nt.leftSE.consumedBy=De.leftSE,nt.rightSE.consumedBy=De.rightSE}}},{key:"prevInResult",value:function(){return void 0!==this._prevInResult||(this._prevInResult=this.prev?this.prev.isInResult()?this.prev:this.prev.prevInResult():null),this._prevInResult}},{key:"beforeState",value:function(){return void 0!==this._beforeState||(this._beforeState=this.prev?(this.prev.consumedBy||this.prev).afterState():{rings:[],windings:[],multiPolys:[]}),this._beforeState}},{key:"afterState",value:function(){if(void 0!==this._afterState)return this._afterState;var Oe=this.beforeState();this._afterState={rings:Oe.rings.slice(0),windings:Oe.windings.slice(0),multiPolys:[]};for(var De=this._afterState.rings,nt=this._afterState.windings,Te=this._afterState.multiPolys,tt=0,mt=this.rings.length;tt<mt;tt++){var K=this.rings[tt],xt=this.windings[tt],on=De.indexOf(K);-1===on?(De.push(K),nt.push(xt)):nt[on]+=xt}for(var ft=[],Xt=[],Kt=0,Pn=De.length;Kt<Pn;Kt++)if(0!==nt[Kt]){var xr=De[Kt],br=xr.poly;if(-1===Xt.indexOf(br))if(xr.isExterior)ft.push(br);else{-1===Xt.indexOf(br)&&Xt.push(br);var oi=ft.indexOf(xr.poly);-1!==oi&&ft.splice(oi,1)}}for(var qi=0,ks=ft.length;qi<ks;qi++){var ls=ft[qi].multiPoly;-1===Te.indexOf(ls)&&Te.push(ls)}return this._afterState}},{key:"isInResult",value:function(){if(this.consumedBy)return!1;if(void 0!==this._isInResult)return this._isInResult;var Oe=this.beforeState().multiPolys,De=this.afterState().multiPolys;switch(Qe.type){case"union":this._isInResult=0===Oe.length!=(0===De.length);break;case"intersection":var tt,mt;Oe.length<De.length?(tt=Oe.length,mt=De.length):(tt=De.length,mt=Oe.length),this._isInResult=mt===Qe.numMultiPolys&&tt<mt;break;case"xor":var K=Math.abs(Oe.length-De.length);this._isInResult=K%2==1;break;case"difference":var xt=function(ft){return 1===ft.length&&ft[0].isSubject};this._isInResult=xt(Oe)!==xt(De);break;default:throw new Error("Unrecognized operation type found ".concat(Qe.type))}return this._isInResult}}],[{key:"fromRing",value:function(Oe,De,nt){var Te,tt,mt,K=et.comparePoints(Oe,De);if(K<0)Te=Oe,tt=De,mt=1;else{if(!(K>0))throw new Error("Tried to create degenerate segment at [".concat(Oe.x,", ").concat(Oe.y,"]"));Te=De,tt=Oe,mt=-1}return new Tt(new et(Te,!0),new et(tt,!1),[nt],[mt])}}]),Tt}(),je=function(){function Tt(We,Oe,De){if(Fe(this,Tt),!Array.isArray(We)||0===We.length)throw new Error("Input geometry is not a valid Polygon or MultiPolygon");if(this.poly=Oe,this.isExterior=De,this.segments=[],"number"!=typeof We[0][0]||"number"!=typeof We[0][1])throw new Error("Input geometry is not a valid Polygon or MultiPolygon");var nt=Pe.round(We[0][0],We[0][1]);this.bbox={ll:{x:nt.x,y:nt.y},ur:{x:nt.x,y:nt.y}};for(var Te=nt,tt=1,mt=We.length;tt<mt;tt++){if("number"!=typeof We[tt][0]||"number"!=typeof We[tt][1])throw new Error("Input geometry is not a valid Polygon or MultiPolygon");var K=Pe.round(We[tt][0],We[tt][1]);K.x===Te.x&&K.y===Te.y||(this.segments.push(dt.fromRing(Te,K,this)),K.x<this.bbox.ll.x&&(this.bbox.ll.x=K.x),K.y<this.bbox.ll.y&&(this.bbox.ll.y=K.y),K.x>this.bbox.ur.x&&(this.bbox.ur.x=K.x),K.y>this.bbox.ur.y&&(this.bbox.ur.y=K.y),Te=K)}(nt.x!==Te.x||nt.y!==Te.y)&&this.segments.push(dt.fromRing(Te,nt,this))}return te(Tt,[{key:"getSweepEvents",value:function(){for(var Oe=[],De=0,nt=this.segments.length;De<nt;De++){var Te=this.segments[De];Oe.push(Te.leftSE),Oe.push(Te.rightSE)}return Oe}}]),Tt}(),zt=function(){function Tt(We,Oe){if(Fe(this,Tt),!Array.isArray(We))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");this.exteriorRing=new je(We[0],this,!0),this.bbox={ll:{x:this.exteriorRing.bbox.ll.x,y:this.exteriorRing.bbox.ll.y},ur:{x:this.exteriorRing.bbox.ur.x,y:this.exteriorRing.bbox.ur.y}},this.interiorRings=[];for(var De=1,nt=We.length;De<nt;De++){var Te=new je(We[De],this,!1);Te.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=Te.bbox.ll.x),Te.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=Te.bbox.ll.y),Te.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=Te.bbox.ur.x),Te.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=Te.bbox.ur.y),this.interiorRings.push(Te)}this.multiPoly=Oe}return te(Tt,[{key:"getSweepEvents",value:function(){for(var Oe=this.exteriorRing.getSweepEvents(),De=0,nt=this.interiorRings.length;De<nt;De++)for(var Te=this.interiorRings[De].getSweepEvents(),tt=0,mt=Te.length;tt<mt;tt++)Oe.push(Te[tt]);return Oe}}]),Tt}(),$t=function(){function Tt(We,Oe){if(Fe(this,Tt),!Array.isArray(We))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");try{"number"==typeof We[0][0][0]&&(We=[We])}catch{}this.polys=[],this.bbox={ll:{x:Number.POSITIVE_INFINITY,y:Number.POSITIVE_INFINITY},ur:{x:Number.NEGATIVE_INFINITY,y:Number.NEGATIVE_INFINITY}};for(var De=0,nt=We.length;De<nt;De++){var Te=new zt(We[De],this);Te.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=Te.bbox.ll.x),Te.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=Te.bbox.ll.y),Te.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=Te.bbox.ur.x),Te.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=Te.bbox.ur.y),this.polys.push(Te)}this.isSubject=Oe}return te(Tt,[{key:"getSweepEvents",value:function(){for(var Oe=[],De=0,nt=this.polys.length;De<nt;De++)for(var Te=this.polys[De].getSweepEvents(),tt=0,mt=Te.length;tt<mt;tt++)Oe.push(Te[tt]);return Oe}}]),Tt}(),tn=function(){function Tt(We){Fe(this,Tt),this.events=We;for(var Oe=0,De=We.length;Oe<De;Oe++)We[Oe].segment.ringOut=this;this.poly=null}return te(Tt,null,[{key:"factory",value:function(Oe){for(var De=[],nt=0,Te=Oe.length;nt<Te;nt++){var tt=Oe[nt];if(tt.isInResult()&&!tt.ringOut){for(var mt=null,K=tt.leftSE,xt=tt.rightSE,on=[K],ft=K.point,Xt=[];mt=K,on.push(K=xt),K.point!==ft;)for(;;){var Kt=K.getAvailableLinkedEvents();if(0===Kt.length){var Pn=on[0].point,xr=on[on.length-1].point;throw new Error("Unable to complete output ring starting at [".concat(Pn.x,",")+" ".concat(Pn.y,"]. Last matching segment found ends at")+" [".concat(xr.x,", ").concat(xr.y,"]."))}if(1===Kt.length){xt=Kt[0].otherSE;break}for(var br=null,oi=0,qi=Xt.length;oi<qi;oi++)if(Xt[oi].point===K.point){br=oi;break}if(null===br){Xt.push({index:on.length,point:K.point});var ar=K.getLeftmostComparator(mt);xt=Kt.sort(ar)[0].otherSE;break}var ks=Xt.splice(br)[0],ls=on.splice(ks.index);ls.unshift(ls[0].otherSE),De.push(new Tt(ls.reverse()))}De.push(new Tt(on))}}return De}}]),te(Tt,[{key:"getGeom",value:function(){for(var Oe=this.events[0].point,De=[Oe],nt=1,Te=this.events.length-1;nt<Te;nt++){var tt=this.events[nt].point;0!==ue(tt,Oe,this.events[nt+1].point)&&(De.push(tt),Oe=tt)}if(1===De.length)return null;0===ue(De[0],Oe,De[1])&&De.shift(),De.push(De[0]);for(var on=this.isExteriorRing()?1:-1,ft=this.isExteriorRing()?0:De.length-1,Xt=this.isExteriorRing()?De.length:-1,Kt=[],Pn=ft;Pn!=Xt;Pn+=on)Kt.push([De[Pn].x,De[Pn].y]);return Kt}},{key:"isExteriorRing",value:function(){if(void 0===this._isExteriorRing){var Oe=this.enclosingRing();this._isExteriorRing=!Oe||!Oe.isExteriorRing()}return this._isExteriorRing}},{key:"enclosingRing",value:function(){return void 0===this._enclosingRing&&(this._enclosingRing=this._calcEnclosingRing()),this._enclosingRing}},{key:"_calcEnclosingRing",value:function(){for(var Oe=this.events[0],De=1,nt=this.events.length;De<nt;De++){var Te=this.events[De];et.compare(Oe,Te)>0&&(Oe=Te)}for(var tt=Oe.segment.prevInResult(),mt=tt?tt.prevInResult():null;;){if(!tt)return null;if(!mt)return tt.ringOut;if(mt.ringOut!==tt.ringOut)return mt.ringOut.enclosingRing()!==tt.ringOut?tt.ringOut:tt.ringOut.enclosingRing();tt=mt.prevInResult(),mt=tt?tt.prevInResult():null}}}]),Tt}(),Gt=function(){function Tt(We){Fe(this,Tt),this.exteriorRing=We,We.poly=this,this.interiorRings=[]}return te(Tt,[{key:"addInterior",value:function(Oe){this.interiorRings.push(Oe),Oe.poly=this}},{key:"getGeom",value:function(){var Oe=[this.exteriorRing.getGeom()];if(null===Oe[0])return null;for(var De=0,nt=this.interiorRings.length;De<nt;De++){var Te=this.interiorRings[De].getGeom();null!==Te&&Oe.push(Te)}return Oe}}]),Tt}(),Rn=function(){function Tt(We){Fe(this,Tt),this.rings=We,this.polys=this._composePolys(We)}return te(Tt,[{key:"getGeom",value:function(){for(var Oe=[],De=0,nt=this.polys.length;De<nt;De++){var Te=this.polys[De].getGeom();null!==Te&&Oe.push(Te)}return Oe}},{key:"_composePolys",value:function(Oe){for(var De=[],nt=0,Te=Oe.length;nt<Te;nt++){var tt=Oe[nt];if(!tt.poly)if(tt.isExteriorRing())De.push(new Gt(tt));else{var mt=tt.enclosingRing();mt.poly||De.push(new Gt(mt)),mt.poly.addInterior(tt)}}return De}}]),Tt}(),Bn=function(){function Tt(We){var Oe=arguments.length>1&&void 0!==arguments[1]?arguments[1]:dt.compare;Fe(this,Tt),this.queue=We,this.tree=new Ae(Oe),this.segments=[]}return te(Tt,[{key:"process",value:function(Oe){var De=Oe.segment,nt=[];if(Oe.consumedBy)return Oe.isLeft?this.queue.remove(Oe.otherSE):this.tree.remove(De),nt;var Te=Oe.isLeft?this.tree.insert(De):this.tree.find(De);if(!Te)throw new Error("Unable to find segment #".concat(De.id," ")+"[".concat(De.leftSE.point.x,", ").concat(De.leftSE.point.y,"] -> ")+"[".concat(De.rightSE.point.x,", ").concat(De.rightSE.point.y,"] ")+"in SweepLine tree. Please submit a bug report.");for(var tt=Te,mt=Te,K=void 0,xt=void 0;void 0===K;)null===(tt=this.tree.prev(tt))?K=null:void 0===tt.key.consumedBy&&(K=tt.key);for(;void 0===xt;)null===(mt=this.tree.next(mt))?xt=null:void 0===mt.key.consumedBy&&(xt=mt.key);if(Oe.isLeft){var on=null;if(K){var ft=K.getIntersection(De);if(null!==ft&&(De.isAnEndpoint(ft)||(on=ft),!K.isAnEndpoint(ft)))for(var Xt=this._splitSafely(K,ft),Kt=0,Pn=Xt.length;Kt<Pn;Kt++)nt.push(Xt[Kt])}var xr=null;if(xt){var br=xt.getIntersection(De);if(null!==br&&(De.isAnEndpoint(br)||(xr=br),!xt.isAnEndpoint(br)))for(var oi=this._splitSafely(xt,br),qi=0,ks=oi.length;qi<ks;qi++)nt.push(oi[qi])}if(null!==on||null!==xr){var ls;ls=null===on?xr:null===xr||et.comparePoints(on,xr)<=0?on:xr,this.queue.remove(De.rightSE),nt.push(De.rightSE);for(var Kr=De.split(ls),hi=0,Dr=Kr.length;hi<Dr;hi++)nt.push(Kr[hi])}nt.length>0?(this.tree.remove(De),nt.push(Oe)):(this.segments.push(De),De.prev=K)}else{if(K&&xt){var pn=K.getIntersection(xt);if(null!==pn){if(!K.isAnEndpoint(pn))for(var Yu=this._splitSafely(K,pn),co=0,Zn=Yu.length;co<Zn;co++)nt.push(Yu[co]);if(!xt.isAnEndpoint(pn))for(var Cs=this._splitSafely(xt,pn),da=0,Wo=Cs.length;da<Wo;da++)nt.push(Cs[da])}}this.tree.remove(De)}return nt}},{key:"_splitSafely",value:function(Oe,De){this.tree.remove(Oe);var nt=Oe.rightSE;this.queue.remove(nt);var Te=Oe.split(De);return Te.push(nt),void 0===Oe.consumedBy&&this.tree.insert(Oe),Te}}]),Tt}(),kn=typeof process<"u"&&process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE||1e6,qn=typeof process<"u"&&process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS||1e6,Qe=new(function(){function Tt(){Fe(this,Tt)}return te(Tt,[{key:"run",value:function(Oe,De,nt){Qe.type=Oe,Pe.reset();for(var Te=[new $t(De,!0)],tt=0,mt=nt.length;tt<mt;tt++)Te.push(new $t(nt[tt],!1));if(Qe.numMultiPolys=Te.length,"difference"===Qe.type)for(var K=Te[0],xt=1;xt<Te.length;)null!==le(Te[xt].bbox,K.bbox)?xt++:Te.splice(xt,1);if("intersection"===Qe.type)for(var on=0,ft=Te.length;on<ft;on++)for(var Xt=Te[on],Kt=on+1,Pn=Te.length;Kt<Pn;Kt++)if(null===le(Xt.bbox,Te[Kt].bbox))return[];for(var xr=new Ae(et.compare),br=0,oi=Te.length;br<oi;br++)for(var qi=Te[br].getSweepEvents(),ks=0,ls=qi.length;ks<ls;ks++)if(xr.insert(qi[ks]),xr.size>kn)throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report.");for(var ar=new Bn(xr),Kr=xr.size,hi=xr.pop();hi;){var Dr=hi.key;if(xr.size===Kr){var pn=Dr.segment;throw new Error("Unable to pop() ".concat(Dr.isLeft?"left":"right"," SweepEvent ")+"[".concat(Dr.point.x,", ").concat(Dr.point.y,"] from segment #").concat(pn.id," ")+"[".concat(pn.leftSE.point.x,", ").concat(pn.leftSE.point.y,"] -> ")+"[".concat(pn.rightSE.point.x,", ").concat(pn.rightSE.point.y,"] from queue. ")+"Please file a bug report.")}if(xr.size>kn)throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report.");if(ar.segments.length>qn)throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report.");for(var Yu=ar.process(Dr),co=0,Zn=Yu.length;co<Zn;co++){var Cs=Yu[co];void 0===Cs.consumedBy&&xr.insert(Cs)}Kr=xr.size,hi=xr.pop()}Pe.reset();var da=tn.factory(ar.segments);return new Rn(da).getGeom()}}]),Tt}());return{union:function(We){for(var Oe=arguments.length,De=new Array(Oe>1?Oe-1:0),nt=1;nt<Oe;nt++)De[nt-1]=arguments[nt];return Qe.run("union",We,De)},intersection:function(We){for(var Oe=arguments.length,De=new Array(Oe>1?Oe-1:0),nt=1;nt<Oe;nt++)De[nt-1]=arguments[nt];return Qe.run("intersection",We,De)},xor:function(We){for(var Oe=arguments.length,De=new Array(Oe>1?Oe-1:0),nt=1;nt<Oe;nt++)De[nt-1]=arguments[nt];return Qe.run("xor",We,De)},difference:function(We){for(var Oe=arguments.length,De=new Array(Oe>1?Oe-1:0),nt=1;nt<Oe;nt++)De[nt-1]=arguments[nt];return Qe.run("difference",We,De)}}}()},4678:function(ze){ze.exports=function(){"use strict";function Y(ye,de,Me,H,Ye){for(;H>Me;){if(H-Me>600){var Je=H-Me+1,Ae=de-Me+1,Le=Math.log(Je),re=.5*Math.exp(2*Le/3),ae=.5*Math.sqrt(Le*re*(Je-re)/Je)*(Ae-Je/2<0?-1:1);Y(ye,de,Math.max(Me,Math.floor(de-Ae*re/Je+ae)),Math.min(H,Math.floor(de+(Je-Ae)*re/Je+ae)),Ye)}var Q=ye[de],pe=Me,le=H;for(te(ye,Me,de),Ye(ye[H],Q)>0&&te(ye,Me,H);pe<le;){for(te(ye,pe,le),pe++,le--;Ye(ye[pe],Q)<0;)pe++;for(;Ye(ye[le],Q)>0;)le--}0===Ye(ye[Me],Q)?te(ye,Me,le):te(ye,++le,H),le<=de&&(Me=le+1),de<=le&&(H=le-1)}}function te(ye,de,Me){var H=ye[de];ye[de]=ye[Me],ye[Me]=H}function he(ye,de){return ye<de?-1:ye>de?1:0}return function Fe(ye,de,Me,H,Ye){Y(ye,de,Me||0,H||ye.length-1,Ye||he)}}()},3544:(ze,Fe,Y)=>{"use strict";ze.exports=he,ze.exports.default=he;var te=Y(4678);function he(le,xe){if(!(this instanceof he))return new he(le,xe);this._maxEntries=Math.max(4,le||9),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),xe&&this._initFormat(xe),this.clear()}function ye(le,xe,we){if(!we)return xe.indexOf(le);for(var $e=0;$e<xe.length;$e++)if(we(le,xe[$e]))return $e;return-1}function de(le,xe){Me(le,0,le.children.length,xe,le)}function Me(le,xe,we,$e,Ne){Ne||(Ne=Q(null)),Ne.minX=1/0,Ne.minY=1/0,Ne.maxX=-1/0,Ne.maxY=-1/0;for(var Pe,Se=xe;Se<we;Se++)Pe=le.children[Se],H(Ne,le.leaf?$e(Pe):Pe);return Ne}function H(le,xe){return le.minX=Math.min(le.minX,xe.minX),le.minY=Math.min(le.minY,xe.minY),le.maxX=Math.max(le.maxX,xe.maxX),le.maxY=Math.max(le.maxY,xe.maxY),le}function Ye(le,xe){return le.minX-xe.minX}function Je(le,xe){return le.minY-xe.minY}function Ae(le){return(le.maxX-le.minX)*(le.maxY-le.minY)}function Le(le){return le.maxX-le.minX+(le.maxY-le.minY)}function re(le,xe){return(Math.max(xe.maxX,le.maxX)-Math.min(xe.minX,le.minX))*(Math.max(xe.maxY,le.maxY)-Math.min(xe.minY,le.minY))}function ae(le,xe){var we=Math.max(le.minX,xe.minX),$e=Math.max(le.minY,xe.minY),Ne=Math.min(le.maxX,xe.maxX),Se=Math.min(le.maxY,xe.maxY);return Math.max(0,Ne-we)*Math.max(0,Se-$e)}function ie(le,xe){return le.minX<=xe.minX&&le.minY<=xe.minY&&xe.maxX<=le.maxX&&xe.maxY<=le.maxY}function Ue(le,xe){return xe.minX<=le.maxX&&xe.minY<=le.maxY&&xe.maxX>=le.minX&&xe.maxY>=le.minY}function Q(le){return{children:le,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function pe(le,xe,we,$e,Ne){for(var Pe,Se=[xe,we];Se.length;)!((we=Se.pop())-(xe=Se.pop())<=$e)&&(Pe=xe+Math.ceil((we-xe)/$e/2)*$e,te(le,Pe,xe,we,Ne),Se.push(xe,Pe,Pe,we))}he.prototype={all:function(){return this._all(this.data,[])},search:function(le){var xe=this.data,we=[],$e=this.toBBox;if(!Ue(le,xe))return we;for(var Se,Pe,Z,Be,Ne=[];xe;){for(Se=0,Pe=xe.children.length;Se<Pe;Se++)Z=xe.children[Se],Ue(le,Be=xe.leaf?$e(Z):Z)&&(xe.leaf?we.push(Z):ie(le,Be)?this._all(Z,we):Ne.push(Z));xe=Ne.pop()}return we},collides:function(le){var xe=this.data,we=this.toBBox;if(!Ue(le,xe))return!1;for(var Ne,Se,Pe,Z,$e=[];xe;){for(Ne=0,Se=xe.children.length;Ne<Se;Ne++)if(Pe=xe.children[Ne],Ue(le,Z=xe.leaf?we(Pe):Pe)){if(xe.leaf||ie(le,Z))return!0;$e.push(Pe)}xe=$e.pop()}return!1},load:function(le){if(!le||!le.length)return this;if(le.length<this._minEntries){for(var xe=0,we=le.length;xe<we;xe++)this.insert(le[xe]);return this}var $e=this._build(le.slice(),0,le.length-1,0);if(this.data.children.length)if(this.data.height===$e.height)this._splitRoot(this.data,$e);else{if(this.data.height<$e.height){var Ne=this.data;this.data=$e,$e=Ne}this._insert($e,this.data.height-$e.height-1,!0)}else this.data=$e;return this},insert:function(le){return le&&this._insert(le,this.data.height-1),this},clear:function(){return this.data=Q([]),this},remove:function(le,xe){if(!le)return this;for(var Pe,Z,Be,ue,we=this.data,$e=this.toBBox(le),Ne=[],Se=[];we||Ne.length;){if(we||(we=Ne.pop(),Z=Ne[Ne.length-1],Pe=Se.pop(),ue=!0),we.leaf&&-1!==(Be=ye(le,we.children,xe)))return we.children.splice(Be,1),Ne.push(we),this._condense(Ne),this;ue||we.leaf||!ie(we,$e)?Z?(Pe++,we=Z.children[Pe],ue=!1):we=null:(Ne.push(we),Se.push(Pe),Pe=0,Z=we,we=we.children[0])}return this},toBBox:function(le){return le},compareMinX:Ye,compareMinY:Je,toJSON:function(){return this.data},fromJSON:function(le){return this.data=le,this},_all:function(le,xe){for(var we=[];le;)le.leaf?xe.push.apply(xe,le.children):we.push.apply(we,le.children),le=we.pop();return xe},_build:function(le,xe,we,$e){var Pe,Ne=we-xe+1,Se=this._maxEntries;if(Ne<=Se)return de(Pe=Q(le.slice(xe,we+1)),this.toBBox),Pe;$e||($e=Math.ceil(Math.log(Ne)/Math.log(Se)),Se=Math.ceil(Ne/Math.pow(Se,$e-1))),(Pe=Q([])).leaf=!1,Pe.height=$e;var ue,He,_e,kt,Z=Math.ceil(Ne/Se),Be=Z*Math.ceil(Math.sqrt(Se));for(pe(le,xe,we,Be,this.compareMinX),ue=xe;ue<=we;ue+=Be)for(pe(le,ue,_e=Math.min(ue+Be-1,we),Z,this.compareMinY),He=ue;He<=_e;He+=Z)kt=Math.min(He+Z-1,_e),Pe.children.push(this._build(le,He,kt,$e-1));return de(Pe,this.toBBox),Pe},_chooseSubtree:function(le,xe,we,$e){for(var Ne,Se,Pe,Z,Be,ue,He,_e;$e.push(xe),!xe.leaf&&$e.length-1!==we;){for(He=_e=1/0,Ne=0,Se=xe.children.length;Ne<Se;Ne++)Be=Ae(Pe=xe.children[Ne]),(ue=re(le,Pe)-Be)<_e?(_e=ue,He=Be<He?Be:He,Z=Pe):ue===_e&&Be<He&&(He=Be,Z=Pe);xe=Z||xe.children[0]}return xe},_insert:function(le,xe,we){var Ne=we?le:(0,this.toBBox)(le),Se=[],Pe=this._chooseSubtree(Ne,this.data,xe,Se);for(Pe.children.push(le),H(Pe,Ne);xe>=0&&Se[xe].children.length>this._maxEntries;)this._split(Se,xe),xe--;this._adjustParentBBoxes(Ne,Se,xe)},_split:function(le,xe){var we=le[xe],$e=we.children.length,Ne=this._minEntries;this._chooseSplitAxis(we,Ne,$e);var Se=this._chooseSplitIndex(we,Ne,$e),Pe=Q(we.children.splice(Se,we.children.length-Se));Pe.height=we.height,Pe.leaf=we.leaf,de(we,this.toBBox),de(Pe,this.toBBox),xe?le[xe-1].children.push(Pe):this._splitRoot(we,Pe)},_splitRoot:function(le,xe){this.data=Q([le,xe]),this.data.height=le.height+1,this.data.leaf=!1,de(this.data,this.toBBox)},_chooseSplitIndex:function(le,xe,we){var $e,Ne,Se,Pe,Z,Be,ue,He;for(Be=ue=1/0,$e=xe;$e<=we-xe;$e++)Pe=ae(Ne=Me(le,0,$e,this.toBBox),Se=Me(le,$e,we,this.toBBox)),Z=Ae(Ne)+Ae(Se),Pe<Be?(Be=Pe,He=$e,ue=Z<ue?Z:ue):Pe===Be&&Z<ue&&(ue=Z,He=$e);return He},_chooseSplitAxis:function(le,xe,we){var $e=le.leaf?this.compareMinX:Ye,Ne=le.leaf?this.compareMinY:Je;this._allDistMargin(le,xe,we,$e)<this._allDistMargin(le,xe,we,Ne)&&le.children.sort($e)},_allDistMargin:function(le,xe,we,$e){le.children.sort($e);var Be,ue,Ne=this.toBBox,Se=Me(le,0,xe,Ne),Pe=Me(le,we-xe,we,Ne),Z=Le(Se)+Le(Pe);for(Be=xe;Be<we-xe;Be++)ue=le.children[Be],H(Se,le.leaf?Ne(ue):ue),Z+=Le(Se);for(Be=we-xe-1;Be>=xe;Be--)ue=le.children[Be],H(Pe,le.leaf?Ne(ue):ue),Z+=Le(Pe);return Z},_adjustParentBBoxes:function(le,xe,we){for(var $e=we;$e>=0;$e--)H(xe[$e],le)},_condense:function(le){for(var we,xe=le.length-1;xe>=0;xe--)0===le[xe].children.length?xe>0?(we=le[xe-1].children).splice(we.indexOf(le[xe]),1):this.clear():de(le[xe],this.toBBox)},_initFormat:function(le){var xe=["return a"," - b",";"];this.compareMinX=new Function("a","b",xe.join(le[0])),this.compareMinY=new Function("a","b",xe.join(le[1])),this.toBBox=new Function("a","return {minX: a"+le[0]+", minY: a"+le[1]+", maxX: a"+le[2]+", maxY: a"+le[3]+"};")}}},4468:(ze,Fe,Y)=>{"use strict";var te=Y(9582).functionsHaveConfigurableNames(),he=Object,ye=TypeError;ze.exports=function(){if(null!=this&&this!==he(this))throw new ye("RegExp.prototype.flags getter called on non-object");var Me="";return this.hasIndices&&(Me+="d"),this.global&&(Me+="g"),this.ignoreCase&&(Me+="i"),this.multiline&&(Me+="m"),this.dotAll&&(Me+="s"),this.unicode&&(Me+="u"),this.unicodeSets&&(Me+="v"),this.sticky&&(Me+="y"),Me},te&&Object.defineProperty&&Object.defineProperty(ze.exports,"name",{value:"get flags"})},9235:(ze,Fe,Y)=>{"use strict";var te=Y(2358),he=Y(5685),ye=Y(4468),de=Y(6343),Me=Y(1956),H=he(de());te(H,{getPolyfill:de,implementation:ye,shim:Me}),ze.exports=H},6343:(ze,Fe,Y)=>{"use strict";var te=Y(4468),he=Y(2358).supportsDescriptors,ye=Object.getOwnPropertyDescriptor;ze.exports=function(){if(he&&"gim"===/a/gim.flags){var Me=ye(RegExp.prototype,"flags");if(Me&&"function"==typeof Me.get&&"boolean"==typeof RegExp.prototype.dotAll&&"boolean"==typeof RegExp.prototype.hasIndices){var H="",Ye={};if(Object.defineProperty(Ye,"hasIndices",{get:function(){H+="d"}}),Object.defineProperty(Ye,"sticky",{get:function(){H+="y"}}),"dy"===H)return Me.get}}return te}},1956:(ze,Fe,Y)=>{"use strict";var te=Y(2358).supportsDescriptors,he=Y(6343),ye=Object.getOwnPropertyDescriptor,de=Object.defineProperty,Me=TypeError,H=Object.getPrototypeOf,Ye=/a/;ze.exports=function(){if(!te||!H)throw new Me("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");var Ae=he(),Le=H(Ye),re=ye(Le,"flags");return(!re||re.get!==Ae)&&de(Le,"flags",{configurable:!0,enumerable:!1,get:Ae}),Ae}},7563:function(ze,Fe){!function(Y){"use strict";function ye(ie,Ue,Q,pe,le){let xe,we,$e,Ne,Se=Ue[0],Pe=pe[0],Z=0,Be=0;Pe>Se==Pe>-Se?(xe=Se,Se=Ue[++Z]):(xe=Pe,Pe=pe[++Be]);let ue=0;if(Z<ie&&Be<Q)for(Pe>Se==Pe>-Se?($e=xe-((we=Se+xe)-Se),Se=Ue[++Z]):($e=xe-((we=Pe+xe)-Pe),Pe=pe[++Be]),xe=we,0!==$e&&(le[ue++]=$e);Z<ie&&Be<Q;)Pe>Se==Pe>-Se?($e=xe-((we=xe+Se)-(Ne=we-xe))+(Se-Ne),Se=Ue[++Z]):($e=xe-((we=xe+Pe)-(Ne=we-xe))+(Pe-Ne),Pe=pe[++Be]),xe=we,0!==$e&&(le[ue++]=$e);for(;Z<ie;)$e=xe-((we=xe+Se)-(Ne=we-xe))+(Se-Ne),Se=Ue[++Z],xe=we,0!==$e&&(le[ue++]=$e);for(;Be<Q;)$e=xe-((we=xe+Pe)-(Ne=we-xe))+(Pe-Ne),Pe=pe[++Be],xe=we,0!==$e&&(le[ue++]=$e);return 0===xe&&0!==ue||(le[ue++]=xe),ue}function de(ie){return new Float64Array(ie)}const Je=de(4),Ae=de(8),Le=de(12),re=de(16),ae=de(4);Y.orient2d=function(ie,Ue,Q,pe,le,xe){const we=(Ue-xe)*(Q-le),$e=(ie-le)*(pe-xe),Ne=we-$e;if(0===we||0===$e||we>0!=$e>0)return Ne;const Se=Math.abs(we+$e);return Math.abs(Ne)>=33306690738754716e-32*Se?Ne:-function(Pe,Z,Be,ue,He,_e,kt){let Ct,Ke,rt,et,pt,dt,je,zt,$t,tn,Gt,Rn,Bn,kn,qn,$n,Qe,Gi;const Ir=Pe-He,ri=Be-He,Yn=Z-_e,Vn=ue-_e;pt=(qn=(zt=Ir-(je=(dt=134217729*Ir)-(dt-Ir)))*(tn=Vn-($t=(dt=134217729*Vn)-(dt-Vn)))-((kn=Ir*Vn)-je*$t-zt*$t-je*tn))-(Gt=qn-(Qe=(zt=Yn-(je=(dt=134217729*Yn)-(dt-Yn)))*(tn=ri-($t=(dt=134217729*ri)-(dt-ri)))-(($n=Yn*ri)-je*$t-zt*$t-je*tn))),Je[0]=qn-(Gt+pt)+(pt-Qe),pt=(Bn=kn-((Rn=kn+Gt)-(pt=Rn-kn))+(Gt-pt))-(Gt=Bn-$n),Je[1]=Bn-(Gt+pt)+(pt-$n),pt=(Gi=Rn+Gt)-Rn,Je[2]=Rn-(Gi-pt)+(Gt-pt),Je[3]=Gi;let Tt=function(Te,tt){let mt=tt[0];for(let K=1;K<4;K++)mt+=tt[K];return mt}(0,Je),We=22204460492503146e-32*kt;if(Tt>=We||-Tt>=We||(Ct=Pe-(Ir+(pt=Pe-Ir))+(pt-He),rt=Be-(ri+(pt=Be-ri))+(pt-He),Ke=Z-(Yn+(pt=Z-Yn))+(pt-_e),et=ue-(Vn+(pt=ue-Vn))+(pt-_e),0===Ct&&0===Ke&&0===rt&&0===et)||(We=11093356479670487e-47*kt+33306690738754706e-32*Math.abs(Tt),(Tt+=Ir*et+Vn*Ct-(Yn*rt+ri*Ke))>=We||-Tt>=We))return Tt;pt=(qn=(zt=Ct-(je=(dt=134217729*Ct)-(dt-Ct)))*(tn=Vn-($t=(dt=134217729*Vn)-(dt-Vn)))-((kn=Ct*Vn)-je*$t-zt*$t-je*tn))-(Gt=qn-(Qe=(zt=Ke-(je=(dt=134217729*Ke)-(dt-Ke)))*(tn=ri-($t=(dt=134217729*ri)-(dt-ri)))-(($n=Ke*ri)-je*$t-zt*$t-je*tn))),ae[0]=qn-(Gt+pt)+(pt-Qe),pt=(Bn=kn-((Rn=kn+Gt)-(pt=Rn-kn))+(Gt-pt))-(Gt=Bn-$n),ae[1]=Bn-(Gt+pt)+(pt-$n),pt=(Gi=Rn+Gt)-Rn,ae[2]=Rn-(Gi-pt)+(Gt-pt),ae[3]=Gi;const Oe=ye(4,Je,4,ae,Ae);pt=(qn=(zt=Ir-(je=(dt=134217729*Ir)-(dt-Ir)))*(tn=et-($t=(dt=134217729*et)-(dt-et)))-((kn=Ir*et)-je*$t-zt*$t-je*tn))-(Gt=qn-(Qe=(zt=Yn-(je=(dt=134217729*Yn)-(dt-Yn)))*(tn=rt-($t=(dt=134217729*rt)-(dt-rt)))-(($n=Yn*rt)-je*$t-zt*$t-je*tn))),ae[0]=qn-(Gt+pt)+(pt-Qe),pt=(Bn=kn-((Rn=kn+Gt)-(pt=Rn-kn))+(Gt-pt))-(Gt=Bn-$n),ae[1]=Bn-(Gt+pt)+(pt-$n),pt=(Gi=Rn+Gt)-Rn,ae[2]=Rn-(Gi-pt)+(Gt-pt),ae[3]=Gi;const De=ye(Oe,Ae,4,ae,Le);pt=(qn=(zt=Ct-(je=(dt=134217729*Ct)-(dt-Ct)))*(tn=et-($t=(dt=134217729*et)-(dt-et)))-((kn=Ct*et)-je*$t-zt*$t-je*tn))-(Gt=qn-(Qe=(zt=Ke-(je=(dt=134217729*Ke)-(dt-Ke)))*(tn=rt-($t=(dt=134217729*rt)-(dt-rt)))-(($n=Ke*rt)-je*$t-zt*$t-je*tn))),ae[0]=qn-(Gt+pt)+(pt-Qe),pt=(Bn=kn-((Rn=kn+Gt)-(pt=Rn-kn))+(Gt-pt))-(Gt=Bn-$n),ae[1]=Bn-(Gt+pt)+(pt-$n),pt=(Gi=Rn+Gt)-Rn,ae[2]=Rn-(Gi-pt)+(Gt-pt),ae[3]=Gi;const nt=ye(De,Le,4,ae,re);return re[nt-1]}(ie,Ue,Q,pe,le,xe,Se)},Y.orient2dfast=function(ie,Ue,Q,pe,le,xe){return(Ue-xe)*(Q-le)-(ie-le)*(pe-xe)},Object.defineProperty(Y,"__esModule",{value:!0})}(Fe)},4291:(ze,Fe,Y)=>{"use strict";Y.r(Fe),Y.d(Fe,{ClassificationCriterion:()=>by,ColumnTransformer:()=>KI,DecisionTree:()=>mC,DecisionTreeBase:()=>yb,DecisionTreeClassifier:()=>xP,DecisionTreeRegressor:()=>bP,DummyClassifier:()=>_$,DummyRegressor:()=>Bm,ElasticNet:()=>Za,GaussianNB:()=>pP,KFold:()=>yC,KMeans:()=>jI,KNeighborsClassifier:()=>lP,KNeighborsRegressor:()=>oP,LabelEncoder:()=>gy,LassoRegression:()=>zn,LinearRegression:()=>oh,LinearSVC:()=>cP,LinearSVR:()=>fP,LogisticRegression:()=>Ki,MaxAbsScaler:()=>S$,MinMaxScaler:()=>GI,Normalizer:()=>HI,OneHotEncoder:()=>Zu,OrdinalEncoder:()=>WI,Pipeline:()=>ub,RegressionCriterion:()=>wy,RidgeRegression:()=>Xc,RobustScaler:()=>ZI,Serialize:()=>Zn,SimpleImputer:()=>my,Splitter:()=>dC,StandardScaler:()=>qI,VotingClassifier:()=>hb,VotingRegressor:()=>fb,crossValScore:()=>NP,dataUrls:()=>JI,fromJSON:()=>pn,fromObject:()=>hi,getBackend:()=>Ae,makeLowRankMatrix:()=>gC,makePipeline:()=>XI,makeRegression:()=>wP,makeVotingClassifier:()=>eC,makeVotingRegressor:()=>QI,metrics:()=>te,setBackend:()=>Je,trainTestSplit:()=>vb});var te={};Y.r(te),Y.d(te,{accuracyScore:()=>ri,confusionMatrix:()=>K,hingeLoss:()=>nt,huberLoss:()=>Te,logLoss:()=>tt,meanAbsoluteError:()=>We,meanSquaredError:()=>Oe,meanSquaredLogError:()=>De,precisionScore:()=>Yn,r2Score:()=>Tt,recallScore:()=>Vn,rocAucScore:()=>xt,zeroOneLoss:()=>mt});var he=Y(5861);function ye(c){return(ye="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(f){return typeof f}:function(f){return f&&"function"==typeof Symbol&&f.constructor===Symbol&&f!==Symbol.prototype?"symbol":typeof f})(c)}function H(c,f,d){return(f=function Me(c){var f=function de(c,f){if("object"!==ye(c)||null===c)return c;var d=c[Symbol.toPrimitive];if(void 0!==d){var m=d.call(c,f||"default");if("object"!==ye(m))return m;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===f?String:Number)(c)}(c,"string");return"symbol"===ye(f)?f:String(f)}(f))in c?Object.defineProperty(c,f,{value:d,enumerable:!0,configurable:!0,writable:!0}):c[f]=d,c}let Ye=null;function Je(c){Ye=c}function Ae(){if(null===Ye)throw Error("\n============================\nHowdy \u{1f44b}\u{1f44b}. Looks like you are running scikit but you haven't set a Tensorflow backend. \nTo do so, simply import (or require) your tensorflow library, and call setBackend like so,\n\nimport * as tf from '@tensorflow/tfjs'\nimport * as sk from 'scikitjs'\nsk.setBackend(tf)\n\nThat will let scikit know you wish to use a tensorflow library to perform your calculations.\n============================\n    ");return Ye}function ie(c,f){if(!c)throw new Error(f)}function Ue(c,f){let d=c;if(le(c))return"string"===f?[]:[c.length];if(!Array.isArray(c))return[];const m=[];for(;Array.isArray(d)||le(d)&&"string"!==f;)m.push(d.length),d=d[0];return Array.isArray(c)&&Q(c,m,[]),m}function Q(c,f,d){if(d=d||[],!Array.isArray(c)&&!le(c))return void ie(0===f.length,`Element arr[${d.join("][")}] is a primitive, but should be an array/TypedArray of ${f[0]} elements`);ie(f.length>0,`Element arr[${d.join("][")}] should be a primitive, but is an array of ${c.length} elements`),ie(c.length===f[0],`Element arr[${d.join("][")}] should have ${f[0]} elements, but has ${c.length} elements`);const m=f.slice(1);for(let y=0;y<c.length;++y)Q(c[y],m,d.concat(y))}function pe(c){return Array.isArray(c)?pe(c[0]):c instanceof Float32Array?"float32":c instanceof Int32Array||c instanceof Uint8Array?"int32":function ae(c){return"number"==typeof c}(c)?"float32":function Le(c){return"string"==typeof c||c instanceof String}(c)?"string":function re(c){return"boolean"==typeof c}(c)?"bool":null}function le(c){return c instanceof Float32Array||c instanceof Int32Array||c instanceof Uint8Array}function $e(c){return c instanceof Ae().Tensor}function Ne(c){return"object"==typeof c&&!(!c||!c.iloc||c.applyMap)}function Se(c){return"object"==typeof c&&!!(c&&c.iloc&&c.applyMap)}function Pe(c){return!!Ne(c)||($e(c)?1===c.rank:function xe(c){const f=Ue(c),d=pe(c);return 1===f.length&&null!==d}(c))}function Z(c){return!!Se(c)||($e(c)?2===c.rank:function we(c){const f=Ue(c),d=pe(c);return 2===f.length&&null!==d}(c))}function _e(c,f){let d=Ae();if(Ne(c))return f?c.tensor.asType(f):c.tensor;if($e(c)){if(1===c.shape.length)return f&&c.dtype!=f?c.asType(f):c;throw new Error("ParamError: if data is a Tensor it must be a Tensor1D. If you really meant to reshape this tensor than use tf.reshape")}return f?d.tensor1d(c,f):d.tensor1d(c)}function kt(c,f){const d=_e(c,f);if("string"===d.dtype)throw new Error("ParamError: data has string dtype, can't convert to numeric Tensor");return d}function Ct(c,f){let d=Ae();if(Se(c))return f?c.tensor.asType(f):c.tensor;if($e(c)){if(2===c.shape.length)return f&&c.dtype!=f?c.asType(f):c;throw new Error("ParamError: if data is a Tensor it must be a Tensor2D. If you really meant to reshape this tensor than use tf.reshape")}if(Array.isArray(c)&&le(c[0])){const m=Ue(c),y=c.map(b=>Array.from(b));return f?d.tensor2d(y,m,f):d.tensor2d(y,m)}return f?d.tensor2d(c,void 0,f):d.tensor2d(c,void 0)}function rt(c,f){const d=Ct(c,f);if("string"===d.dtype)throw new Error("ParamError: data has string dtype, can't convert to numeric Tensor");return d}function et(c,f){const d=function Ke(c,f){try{return _e(c,f)}catch{try{return Ct(c,f)}catch{throw new Error('ParamError: Can"t convert data into 1D or 2D tensor')}}}(c,f);if("string"===d.dtype)throw new Error("ParamError: data has string dtype, can't convert to numeric Tensor");return d}function $t(c){return Se(c)?c.values:$e(c)?c.arraySync():c}function tn(c){return Ne(c)?c.values:$e(c)?c.arraySync():c}function Rn(c){return ie(function Be(c){return Pe(c)||Z(c)}(c),"X isn't a Scikit2D or Scikit1D object"),$e(c)?c.shape[0]:Se(c)||Ne(c)?c.size:c.length}function Bn(c,f,d){let m=Ae(),y=new Map,b=[],I=m.randomUniform([f],0,c,"float32",d).dataSync();for(let C=0;C<I.length;C++){I[C]=I[C]*(c-C)/c;let A=Math.floor(I[C]),T=c-C-1;void 0===y.get(A)&&y.set(A,A),void 0===y.get(T)&&y.set(T,T);let E=y.get(T);y.set(T,y.get(A)),y.set(A,E),b.push(y.get(T))}return b}var Qe=Y(836),Gi=Y.n(Qe);function Ir(c,f){ie(Pe(c),"Labels can't be converted to a 1D Tensor"),ie(Pe(f),"Predictions can't be converted to a 1D Tensor");let d=kt(c),m=kt(f);return ie(d.size>0,"Must have 1 label or more"),ie(m.size>0,"Must have 1 prediction or more"),ie(d.size===m.size,"Not the same size arrays"),{labelsT:d,predictionsT:m}}function ri(c,f){const{labelsT:d,predictionsT:m}=Ir(c,f);return d.equal(m).sum().div(d.size).dataSync()[0]}function Yn(c,f){let d=Ae();const{labelsT:m,predictionsT:y}=Ir(c,f);return d.metrics.precision(m,y).dataSync()[0]}function Vn(c,f){let d=Ae();const{labelsT:m,predictionsT:y}=Ir(c,f);return d.metrics.recall(m,y).dataSync()[0]}function Tt(c,f){let d=Ae();const{labelsT:m,predictionsT:y}=Ir(c,f),b=d.metrics.meanSquaredError(m,y),I=d.metrics.meanSquaredError(m,m.mean());return d.sub(1,b.div(I)).dataSync()[0]}function We(c,f){let d=Ae();const{labelsT:m,predictionsT:y}=Ir(c,f);return d.metrics.meanAbsoluteError(m,y).dataSync()[0]}function Oe(c,f){let d=Ae();const{labelsT:m,predictionsT:y}=Ir(c,f);return d.metrics.meanSquaredError(m,y).dataSync()[0]}function De(c,f){let d=Ae();const{labelsT:m,predictionsT:y}=Ir(c,f);return d.square(m.log1p().sub(y.log1p())).sum().div(m.size).dataSync()[0]}function nt(c,f){let d=Ae();const{labelsT:m,predictionsT:y}=Ir(c,f);return d.losses.hingeLoss(m,y).dataSync()[0]}function Te(c,f){let d=Ae();const{labelsT:m,predictionsT:y}=Ir(c,f);return d.losses.huberLoss(m,y).dataSync()[0]}function tt(c,f){let d=Ae();const{labelsT:m,predictionsT:y}=Ir(c,f);return d.losses.logLoss(m,y).dataSync()[0]}function mt(c,f){let d=Ae();const{labelsT:m,predictionsT:y}=Ir(c,f);return d.sub(1,ri(m,y)).dataSync()[0]}function K(c,f){let d=Ae();const{labelsT:m,predictionsT:y}=Ir(c,f),b=Gi()(m.dataSync());return d.math.confusionMatrix(m,y,b.length).arraySync()}function xt(c,f){const{labelsT:d,predictionsT:m}=Ir(c,f);let y=d.arraySync(),b=m.arraySync();y.push(1),b.push(1);let I=0;for(let C=0;C<y.length-1;C++)I+=y[C]*b[C+1]-y[C+1]*b[C];return I-=1,Math.abs(I)/2}for(var on="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",ft=typeof Uint8Array>"u"?[]:new Uint8Array(256),Xt=0;Xt<on.length;Xt++)ft[on.charCodeAt(Xt)]=Xt;const xr=["KNeighborsRegressor","LinearRegression","LassoRegression","RidgeRegression","ElasticNet","LogisticRegression","DummyRegressor","DummyClassifier","MinMaxScaler","StandardScaler","MaxAbsScaler","SimpleImputer","OneHotEncoder","LabelEncoder","OrdinalEncoder","Normalizer","Pipeline","ColumnTransformer","RobustScaler","KMeans","VotingRegressor","VotingClassifier","LinearSVC","LinearSVR","GaussianNB","DecisionTreeClassifier","DecisionTreeRegressor","ClassificationCriterion","RegressionCriterion","Splitter","DecisionTreeBase","DecisionTree"];let br="abcdefghijklmnopqrstuvwxy";function oi(c){let f="";for(let d=0;d<c;d++){let m=Math.floor(Math.random()*br.length);f+=br[m]}return f}class qi{constructor(f){H(this,"savedArtifacts",void 0),this.savedArtifacts=f||null}save(f){var d=this;return(0,he.Z)(function*(){f.weightData=function(c){var d,f=new Uint8Array(c),m=f.length,y="";for(d=0;d<m;d+=3)y+=on[f[d]>>2],y+=on[(3&f[d])<<4|f[d+1]>>4],y+=on[(15&f[d+1])<<2|f[d+2]>>6],y+=on[63&f[d+2]];return m%3==2?y=y.substring(0,y.length-1)+"=":m%3==1&&(y=y.substring(0,y.length-2)+"=="),y}(f.weightData);let m={};for(let y=0;y<f.modelTopology.config.layers.length;y++){let b=f.modelTopology.config.layers[y],I=oi(6);m[b.config.name]=I,b.config.name=I}for(let y=0;y<f.weightSpecs.length;y++){let b=f.weightSpecs[y];Object.keys(m).forEach(C=>{b.name.includes(C)&&(b.name=b.name.replace(C,m[C]))})}return d.savedArtifacts=f,{modelArtifactsInfo:{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:JSON.stringify(f.modelTopology).length,weightSpecsBytes:JSON.stringify(f.weightSpecs).length,weightDataBytes:f.weightData.byteLength}}})()}load(){var f=this;return(0,he.Z)(function*(){return f.savedArtifacts.weightData=function(c){var m,b,I,C,A,f=.75*c.length,d=c.length,y=0;"="===c[c.length-1]&&(f--,"="===c[c.length-2]&&f--);var T=new ArrayBuffer(f),E=new Uint8Array(T);for(m=0;m<d;m+=4)b=ft[c.charCodeAt(m)],I=ft[c.charCodeAt(m+1)],C=ft[c.charCodeAt(m+2)],A=ft[c.charCodeAt(m+3)],E[y++]=b<<2|I>>4,E[y++]=(15&I)<<4|C>>2,E[y++]=(3&C)<<6|63&A;return T}(f.savedArtifacts.weightData),f.savedArtifacts})()}}function ks(c){return ls.apply(this,arguments)}function ls(){return ls=(0,he.Z)(function*(c,f=[]){let d=Ae();if(["number","string","undefined","boolean"].includes(typeof c))return c;if("function"==typeof c&&(console.warn(`warning: Serializing function ${c}. Not going to be able to deserialize this later.`),c.name))return c.name;if("object"==typeof c){if(null===c)return null;if(Array.isArray(c))return yield Promise.all(c.map(function(){var y=(0,he.Z)(function*(b){return yield ks(b,f)});return function(b){return y.apply(this,arguments)}}()));if(c instanceof d.Tensor)return{name:"Tensor",value:c.arraySync()};if(c instanceof Int32Array)return{name:"Int32Array",value:Array.from(c)};if(c instanceof Float32Array)return{name:"Float32Array",value:Array.from(c)};if(c instanceof d.Sequential){let y=new qi;return yield c.save(y),{name:"Sequential",artifacts:y.savedArtifacts}}if(c.ENV&&c.AdadeltaOptimizer&&c.version)return{name:"TF",version:c.version.tfjs};let m={};for(let y of Object.keys(c))f.includes(y)||(m[y]=yield ks(c[y],f));return m}}),ls.apply(this,arguments)}function ar(c){return Kr.apply(this,arguments)}function Kr(){return Kr=(0,he.Z)(function*(c){let f=Ae();if("object"!=typeof c)return c;if(null===c)return null;if("Tensor"===c.name)return f.tensor(c.value);if("Sequential"===c.name){let d=new qi(c.artifacts);return yield f.loadLayersModel(d)}if("Int32Array"===c.name)return new Int32Array(c.value);if("Float32Array"===c.name)return new Float32Array(c.value);if("TF"===c.name)return f;if(Array.isArray(c))return yield Promise.all(c.map(function(){var d=(0,he.Z)(function*(m){return yield ar(m)});return function(m){return d.apply(this,arguments)}}()));for(let d of Object.keys(c))c[d]=yield ar(c[d]);if(xr.includes(c.name)){let y=new(0,(yield Promise.resolve().then(Y.bind(Y,4291)))[c.name])(c);for(let b of Object.keys(c))y[b]=c[b];return y}return c}),Kr.apply(this,arguments)}function hi(c){return Dr.apply(this,arguments)}function Dr(){return(Dr=(0,he.Z)(function*(c){try{return yield ar(c)}catch(f){console.error(f)}})).apply(this,arguments)}function pn(c){return Yu.apply(this,arguments)}function Yu(){return(Yu=(0,he.Z)(function*(c){return yield hi(JSON.parse(c))})).apply(this,arguments)}let co=["modelCompileArgs","modelFitArgs","denseLayerArgs"];class Zn{toObject(){var f=this;return(0,he.Z)(function*(){return yield ks(f,co)})()}toJSON(){var f=this;return(0,he.Z)(function*(){return JSON.stringify(yield f.toObject())})()}}class Cs extends Zn{fitTransform(f){return this.fit(f).transform(f)}}class Wo extends Zn{constructor(...f){super(...f),H(this,"EstimatorType","regressor")}score(f,d){return Tt(d,this.predict(f))}}class fu extends Zn{constructor(...f){super(...f),H(this,"EstimatorType","classifier")}score(f,d){const m=this.predict(f),y=et(d);return ie(m.shape.length===y.shape.length,"The shape of the model output doesn't match the shape of the actual y values"),Z(d)?ri(y.argMax(1),m.argMax(1)):ri(d,m)}}class Ao extends Wo{constructor({modelFitArgs:f,modelCompileArgs:d,denseLayerArgs:m,optimizerType:y,lossType:b}){super(),H(this,"model",void 0),H(this,"modelFitArgs",void 0),H(this,"modelCompileArgs",void 0),H(this,"denseLayerArgs",void 0),H(this,"isMultiOutput",void 0),H(this,"optimizerType",void 0),H(this,"lossType",void 0),this.tf=Ae(),this.model=this.tf.sequential(),this.modelFitArgs=f,this.modelCompileArgs=d,this.denseLayerArgs=m,this.isMultiOutput=!1,this.optimizerType=y,this.lossType=b}initializeModel(f,d,m=[]){this.denseLayerArgs.units=1===d.shape.length?1:d.shape[1];const y=this.tf.sequential();y.add(this.tf.layers.dense({inputShape:[f.shape[1]],...this.denseLayerArgs})),y.compile(this.modelCompileArgs),m?.length&&y.setWeights(m),this.model=y}fit(f,d){var m=this;return(0,he.Z)(function*(){let y=rt(f),b=et(d);return b.shape.length>1&&(m.isMultiOutput=!0),0===m.model.layers.length&&m.initializeModel(y,b),yield m.model.fit(y,b,{...m.modelFitArgs}),m})()}importModel(f){let d=this.tf.tensor2d(f.coef,[f.coef.length,1],"float32"),m=this.tf.tensor1d([f.intercept],"float32");return this.initializeModel(d,m,[d,m]),this}getParams(){return{modelFitArgs:this.modelFitArgs,modelCompileArgs:this.modelCompileArgs,denseLayerArgs:this.denseLayerArgs,optimizerType:this.optimizerType,lossType:this.lossType}}setParams(f){return this.modelCompileArgs=f.modelCompileArgs,this.modelFitArgs=f.modelFitArgs,this.denseLayerArgs=f.denseLayerArgs,this}predict(f){let d=rt(f);if(0===this.model.layers.length)throw new RangeError('Need to call "fit" before "predict"');const m=this.model.predict(d);return this.isMultiOutput?m:m.reshape([-1])}get coef(){const f=this.model.getWeights();if(0===f.length)return this.tf.tensor2d([]);let d=f[0];return 1===d.shape[1]?d.reshape([d.shape[0]]):d}get intercept(){const f=this.model.getWeights();if(f.length<2)return 0;let d=f[1];return 1===d.size?d.arraySync()[0]:d}}class oh extends Ao{constructor({fitIntercept:f=!0,modelFitOptions:d}={}){let m=Ae();super({modelCompileArgs:{optimizer:m.train.adam(.1),loss:m.losses.meanSquaredError,metrics:["mse"]},modelFitArgs:{batchSize:32,epochs:1e3,verbose:0,callbacks:[m.callbacks.earlyStopping({monitor:"mse",patience:30})],...d},denseLayerArgs:{units:1,useBias:Boolean(f)},optimizerType:"adam",lossType:"meanSquaredError"}),this.name="LinearRegression"}}class zn extends Ao{constructor({fitIntercept:f=!0,alpha:d=1}={}){let m=Ae();super({modelCompileArgs:{optimizer:m.train.adam(.1),loss:m.losses.meanSquaredError,metrics:["mse"]},modelFitArgs:{batchSize:32,epochs:1e3,verbose:0,callbacks:[m.callbacks.earlyStopping({monitor:"mse",patience:50})]},denseLayerArgs:{units:1,kernelRegularizer:m.regularizers.l1({l1:d}),useBias:Boolean(f)},optimizerType:"adam",lossType:"meanSquaredError"}),this.name="LassoRegression"}}class Xc extends Ao{constructor({fitIntercept:f=!0,alpha:d=.01}={}){let m=Ae();super({modelCompileArgs:{optimizer:m.train.adam(.1),loss:m.losses.meanSquaredError,metrics:["mse"]},modelFitArgs:{batchSize:32,epochs:1e3,verbose:0,callbacks:[m.callbacks.earlyStopping({monitor:"mse",patience:50})]},denseLayerArgs:{units:1,kernelRegularizer:m.regularizers.l2({l2:d}),useBias:Boolean(f)},optimizerType:"adam",lossType:"meanSquaredError"}),this.name="RidgeRegression"}}class Za extends Ao{constructor({alpha:f=1,l1Ratio:d=.5,fitIntercept:m=!0}={}){let y=Ae();super({modelCompileArgs:{optimizer:y.train.adam(.1),loss:y.losses.meanSquaredError,metrics:["mse"]},modelFitArgs:{batchSize:32,epochs:1e3,verbose:0,callbacks:[y.callbacks.earlyStopping({monitor:"mse",patience:50})]},denseLayerArgs:{units:1,kernelRegularizer:y.regularizers.l1l2({l1:f*d,l2:.5*f*(1-d)}),useBias:Boolean(m)},optimizerType:"adam",lossType:"meanSquaredError"}),this.name="ElasticNet"}}class Zu extends Cs{constructor({categories:f="auto",handleUnknown:d="error",drop:m}={}){super(),H(this,"categories",void 0),H(this,"handleUnknown",void 0),H(this,"categoriesParam",void 0),H(this,"drop",void 0),H(this,"nFeaturesIn",void 0),H(this,"featureNamesIn",void 0),H(this,"name","OneHotEncoder"),this.tf=Ae(),this.categoriesParam=f,this.categories=[],this.handleUnknown=d,this.nFeaturesIn=0,this.featureNamesIn=[],this.drop=m}classesToMapping(f){const d=new Map;return f.forEach((m,y)=>{d.set(m,y)}),d}loopOver2DArrayToSetLabels(f){for(let d=0;d<f[0].length;d++){let m=new Set;for(let b=0;b<f.length;b++)m.add(f[b][d]);let y=Array.from(m);this.categories.push(y)}}fit(f,d){const m=$t(f);return"auto"===this.categoriesParam?(this.loopOver2DArrayToSetLabels(m),this):(this.categories=this.categoriesParam,this.nFeaturesIn=0===m.length?0:m[0].length||0,Se(f)&&(this.featureNamesIn=[...f.columns]),this)}loopOver2DArrayToUseLabels(f){let d=this.categories.map(y=>this.classesToMapping(y)),m=[];for(let y=0;y<f.length;y++){let b=[];for(let I=0;I<f[0].length;I++){let C=f[y][I],A=d[I].get(C);if(void 0===A){if("error"===this.handleUnknown)throw new Error(`Unknown value ${C} encountered while transforming. Not encountered in training data`);A=-1}"first"===this.drop&&(A-=1),b.push(A)}m.push(b)}return m}convertToOneHot(f,d){return d>=2?this.tf.oneHot(f,d):1===d?(f=this.tf.where(f.equal(0),this.tf.ones(f.shape,"int32"),this.tf.zeros(f.shape,"int32"))).reshape([-1,1]):this.tf.tensor2d([])}transform(f,d){const m=$t(f),y=this.loopOver2DArrayToUseLabels(m),b=this.tf.tensor2d(y,void 0,"int32");return this.tf.concat(b.unstack(1).map((I,C)=>{let A=this.categories[C].length;return this.convertToOneHot(I,"first"===this.drop?A-1:A)}),1)}inverseTransform(f){let d=this.classesToMapping(this.categories[0]);const m=f.argMax(1),y=new Map(Array.from(d,I=>I.reverse()));return m.arraySync().map(I=>void 0===y.get(I)?null:y.get(I))}}class Ur extends fu{constructor({modelFitArgs:f,modelCompileArgs:d,denseLayerArgs:m,optimizerType:y,lossType:b}){super(),H(this,"model",void 0),H(this,"modelFitArgs",void 0),H(this,"modelCompileArgs",void 0),H(this,"denseLayerArgs",void 0),H(this,"optimizerType",void 0),H(this,"lossType",void 0),H(this,"oneHot",void 0),H(this,"tf",void 0),H(this,"isMultiOutput",void 0),this.tf=Ae(),this.model=this.tf.sequential(),this.modelFitArgs=f,this.modelCompileArgs=d,this.denseLayerArgs=m,this.optimizerType=y,this.lossType=b,this.isMultiOutput=!1,this.oneHot=new Zu}initializeModelForClassification(f){let d=f.toInt();if(2===d.shape.length)return this.modelCompileArgs.loss=this.tf.losses.softmaxCrossEntropy,d;{const m=f.reshape([-1,1]),y=this.oneHot.fitTransform(m);return this.modelCompileArgs.loss=this.oneHot.categories[0].length>2?this.tf.losses.softmaxCrossEntropy:this.tf.losses.sigmoidCrossEntropy,y}}initializeModel(f,d,m=[]){this.denseLayerArgs.units=1===d.shape.length?1:d.shape[1];const y=this.tf.sequential();y.add(this.tf.layers.dense({inputShape:[f.shape[1]],...this.denseLayerArgs})),y.compile(this.modelCompileArgs),m?.length&&y.setWeights(m),this.model=y}fit(f,d){var m=this;return(0,he.Z)(function*(){let y=rt(f),b=et(d);const I=m.initializeModelForClassification(b);return b.shape.length>1&&(m.isMultiOutput=!0),0===m.model.layers.length&&m.initializeModel(y,I),yield m.model.fit(y,I,{...m.modelFitArgs}),m})()}importModel(f){let d=this.tf.tensor2d(f.coef,[f.coef.length,1],"float32"),m=this.tf.tensor1d([f.intercept],"float32");return this.initializeModel(d,m,[d,m]),this}getParams(){return{modelFitArgs:this.modelFitArgs,modelCompileArgs:this.modelCompileArgs,denseLayerArgs:this.denseLayerArgs,optimizerType:this.optimizerType,lossType:this.lossType}}setParams(f){return this.modelCompileArgs=f.modelCompileArgs,this.modelFitArgs=f.modelFitArgs,this.denseLayerArgs=f.denseLayerArgs,this}predictProba(f){ie(this.model.layers.length>0,'Need to call "fit" before "predict"');let d=rt(f);return this.model.predict(d)}predict(f){ie(this.model.layers.length>0,'Need to call "fit" before "predict"');const d=this.predictProba(f);return this.isMultiOutput?this.tf.oneHot(d.argMax(1),d.shape[1]):this.tf.tensor1d(this.oneHot.inverseTransform(d))}get coef(){const f=this.model.getWeights();if(0===f.length)return this.tf.tensor2d([]);let d=f[0];return 1===d.shape[1]?d.reshape([d.shape[0]]):d}get intercept(){const f=this.model.getWeights();if(f.length<2)return 0;let d=f[1];return 1===d.size?d.arraySync()[0]:d}}class Ki extends Ur{constructor({penalty:f="l2",C:d=1,fitIntercept:m=!0,modelFitOptions:y}={}){let b=Ae();super({modelCompileArgs:{optimizer:b.train.adam(.1),loss:b.losses.softmaxCrossEntropy,metrics:["accuracy"]},modelFitArgs:{batchSize:32,epochs:1e3,verbose:0,callbacks:[b.callbacks.earlyStopping({monitor:"loss",patience:50})],...y},denseLayerArgs:{units:1,useBias:Boolean(m),activation:"softmax",kernelInitializer:b.initializers.zeros(),biasInitializer:b.initializers.zeros(),kernelRegularizer:"l2"===f?b.regularizers.l2({l2:d}):"l1"===f?b.regularizers.l1({l1:d}):void 0},isClassification:!0,optimizerType:"adam",lossType:"softmaxCrossEntropy"}),this.name="LogisticRegression"}}function oa(){return oa=Object.assign?Object.assign.bind():function(c){for(var f=1;f<arguments.length;f++){var d=arguments[f];for(var m in d)Object.prototype.hasOwnProperty.call(d,m)&&(c[m]=d[m])}return c},oa.apply(this,arguments)}var cs={epsilon:1e-12,matrix:"Matrix",number:"number",precision:64,predictable:!1,randomSeed:null},fn=function(f){if(f)throw new Error("The global config is readonly. \nPlease create a mathjs instance if you want to change the default configuration. \nExample:\n\n  import { create, all } from 'mathjs';\n  const mathjs = create(all);\n  mathjs.config({ number: 'BigNumber' });\n");return Object.freeze(cs)};oa(fn,cs,{MATRIX_OPTIONS:["Matrix","Array"],NUMBER_OPTIONS:["number","BigNumber","Fraction"]});var Kc,Ba,is=9e15,Wi=1e9,Pt="0123456789abcdef",ma="2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",ju="3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",Ns={precision:20,rounding:4,modulo:1,toExpNeg:-7,toExpPos:21,minE:-is,maxE:is,crypto:!1},fr=!0,ga="[DecimalError] ",To=ga+"Invalid argument: ",ml=ga+"Precision limit exceeded",Ju=ga+"crypto unavailable",kl="[object Decimal]",Vr=Math.floor,Ks=Math.pow,Ho=/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,Af=/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,Tf=/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,Gr=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,ja=1e7,jn=7,Mr=ma.length-1,Mf=ju.length-1,hn={toStringTag:kl};function Ys(c){var f,d,m,y=c.length-1,b="",I=c[0];if(y>0){for(b+=I,f=1;f<y;f++)(d=jn-(m=c[f]+"").length)&&(b+=kr(d)),b+=m;(d=jn-(m=(I=c[f])+"").length)&&(b+=kr(d))}else if(0===I)return"0";for(;I%10==0;)I/=10;return b+I}function fs(c,f,d){if(c!==~~c||c<f||c>d)throw Error(To+c)}function Ja(c,f,d,m){var y,b,I,C;for(b=c[0];b>=10;b/=10)--f;return--f<0?(f+=jn,y=0):(y=Math.ceil((f+1)/jn),f%=jn),b=Ks(10,jn-f),C=c[y]%b|0,null==m?f<3?(0==f?C=C/100|0:1==f&&(C=C/10|0),I=d<4&&99999==C||d>3&&49999==C||5e4==C||0==C):I=(d<4&&C+1==b||d>3&&C+1==b/2)&&(c[y+1]/b/100|0)==Ks(10,f-2)-1||(C==b/2||0==C)&&0==(c[y+1]/b/100|0):f<4?(0==f?C=C/1e3|0:1==f?C=C/100|0:2==f&&(C=C/10|0),I=(m||d<4)&&9999==C||!m&&d>3&&4999==C):I=((m||d<4)&&C+1==b||!m&&d>3&&C+1==b/2)&&(c[y+1]/b/1e3|0)==Ks(10,f-3)-1,I}function mc(c,f,d){for(var m,b,y=[0],I=0,C=c.length;I<C;){for(b=y.length;b--;)y[b]*=f;for(y[0]+=Pt.indexOf(c.charAt(I++)),m=0;m<y.length;m++)y[m]>d-1&&(void 0===y[m+1]&&(y[m+1]=0),y[m+1]+=y[m]/d|0,y[m]%=d)}return y.reverse()}hn.absoluteValue=hn.abs=function(){var c=new this.constructor(this);return c.s<0&&(c.s=1),rr(c)},hn.ceil=function(){return rr(new this.constructor(this),this.e+1,2)},hn.clampedTo=hn.clamp=function(c,f){var m=this,y=m.constructor;if(c=new y(c),f=new y(f),!c.s||!f.s)return new y(NaN);if(c.gt(f))throw Error(To+f);return m.cmp(c)<0?c:m.cmp(f)>0?f:new y(m)},hn.comparedTo=hn.cmp=function(c){var f,d,m,y,b=this,I=b.d,C=(c=new b.constructor(c)).d,A=b.s,T=c.s;if(!I||!C)return A&&T?A!==T?A:I===C?0:!I^A<0?1:-1:NaN;if(!I[0]||!C[0])return I[0]?A:C[0]?-T:0;if(A!==T)return A;if(b.e!==c.e)return b.e>c.e^A<0?1:-1;for(f=0,d=(m=I.length)<(y=C.length)?m:y;f<d;++f)if(I[f]!==C[f])return I[f]>C[f]^A<0?1:-1;return m===y?0:m>y^A<0?1:-1},hn.cosine=hn.cos=function(){var c,f,d=this,m=d.constructor;return d.d?d.d[0]?(f=m.rounding,m.precision=(c=m.precision)+Math.max(d.e,d.sd())+jn,m.rounding=1,d=function Bd(c,f){var d,m,y;if(f.isZero())return f;(m=f.d.length)<32?y=(1/Qu(4,d=Math.ceil(m/3))).toString():(d=16,y="2.3283064365386962890625e-10"),c.precision+=d,f=gl(c,1,f.times(y),new c(1));for(var b=d;b--;){var I=f.times(f);f=I.times(I).minus(I).times(8).plus(1)}return c.precision-=d,f}(m,Qi(m,d)),m.precision=c,m.rounding=f,rr(2==Ba||3==Ba?d.neg():d,c,f,!0)):new m(1):new m(NaN)},hn.cubeRoot=hn.cbrt=function(){var c,f,d,m,y,b,I,C,A,T,E=this,S=E.constructor;if(!E.isFinite()||E.isZero())return new S(E);for(fr=!1,(b=E.s*Ks(E.s*E,.3333333333333333))&&Math.abs(b)!=1/0?m=new S(b.toString()):(d=Ys(E.d),(b=((c=E.e)-d.length+1)%3)&&(d+=1==b||-2==b?"0":"00"),b=Ks(d,.3333333333333333),c=Vr((c+1)/3)-(c%3==(c<0?-1:2)),(m=new S(d=b==1/0?"5e"+c:(d=b.toExponential()).slice(0,d.indexOf("e")+1)+c)).s=E.s),I=(c=S.precision)+3;;)if(T=(A=(C=m).times(C).times(C)).plus(E),m=en(T.plus(E).times(C),T.plus(A),I+2,1),Ys(C.d).slice(0,I)===(d=Ys(m.d)).slice(0,I)){if("9999"!=(d=d.slice(I-3,I+1))&&(y||"4999"!=d)){(!+d||!+d.slice(1)&&"5"==d.charAt(0))&&(rr(m,c+1,1),f=!m.times(m).times(m).eq(E));break}if(!y&&(rr(C,c+1,0),C.times(C).times(C).eq(E))){m=C;break}I+=4,y=1}return fr=!0,rr(m,c,S.rounding,f)},hn.decimalPlaces=hn.dp=function(){var c,f=this.d,d=NaN;if(f){if(d=((c=f.length-1)-Vr(this.e/jn))*jn,c=f[c])for(;c%10==0;c/=10)d--;d<0&&(d=0)}return d},hn.dividedBy=hn.div=function(c){return en(this,new this.constructor(c))},hn.dividedToIntegerBy=hn.divToInt=function(c){var d=this.constructor;return rr(en(this,new d(c),0,1,1),d.precision,d.rounding)},hn.equals=hn.eq=function(c){return 0===this.cmp(c)},hn.floor=function(){return rr(new this.constructor(this),this.e+1,3)},hn.greaterThan=hn.gt=function(c){return this.cmp(c)>0},hn.greaterThanOrEqualTo=hn.gte=function(c){var f=this.cmp(c);return 1==f||0===f},hn.hyperbolicCosine=hn.cosh=function(){var c,f,d,m,y,b=this,I=b.constructor,C=new I(1);if(!b.isFinite())return new I(b.s?1/0:NaN);if(b.isZero())return C;m=I.rounding,I.precision=(d=I.precision)+Math.max(b.e,b.sd())+4,I.rounding=1,(y=b.d.length)<32?f=(1/Qu(4,c=Math.ceil(y/3))).toString():(c=16,f="2.3283064365386962890625e-10"),b=gl(I,1,b.times(f),new I(1),!0);for(var A,T=c,E=new I(8);T--;)A=b.times(b),b=C.minus(A.times(E.minus(A.times(E))));return rr(b,I.precision=d,I.rounding=m,!0)},hn.hyperbolicSine=hn.sinh=function(){var c,f,d,m,y=this,b=y.constructor;if(!y.isFinite()||y.isZero())return new b(y);if(d=b.rounding,b.precision=(f=b.precision)+Math.max(y.e,y.sd())+4,b.rounding=1,(m=y.d.length)<3)y=gl(b,2,y,y,!0);else{c=1.4*Math.sqrt(m),y=gl(b,2,y=y.times(1/Qu(5,c=c>16?16:0|c)),y,!0);for(var I,C=new b(5),A=new b(16),T=new b(20);c--;)I=y.times(y),y=y.times(C.plus(I.times(A.times(I).plus(T))))}return b.precision=f,b.rounding=d,rr(y,f,d,!0)},hn.hyperbolicTangent=hn.tanh=function(){var c,f,d=this,m=d.constructor;return d.isFinite()?d.isZero()?new m(d):(f=m.rounding,m.precision=(c=m.precision)+7,m.rounding=1,en(d.sinh(),d.cosh(),m.precision=c,m.rounding=f)):new m(d.s)},hn.inverseCosine=hn.acos=function(){var c,f=this,d=f.constructor,m=f.abs().cmp(1),y=d.precision,b=d.rounding;return-1!==m?0===m?f.isNeg()?Zi(d,y,b):new d(0):new d(NaN):f.isZero()?Zi(d,y+4,b).times(.5):(d.precision=y+6,d.rounding=1,f=f.asin(),c=Zi(d,y+4,b).times(.5),d.precision=y,d.rounding=b,c.minus(f))},hn.inverseHyperbolicCosine=hn.acosh=function(){var c,f,d=this,m=d.constructor;return d.lte(1)?new m(d.eq(1)?0:NaN):d.isFinite()?(f=m.rounding,m.precision=(c=m.precision)+Math.max(Math.abs(d.e),d.sd())+4,m.rounding=1,fr=!1,d=d.times(d).minus(1).sqrt().plus(d),fr=!0,m.precision=c,m.rounding=f,d.ln()):new m(d)},hn.inverseHyperbolicSine=hn.asinh=function(){var c,f,d=this,m=d.constructor;return!d.isFinite()||d.isZero()?new m(d):(f=m.rounding,m.precision=(c=m.precision)+2*Math.max(Math.abs(d.e),d.sd())+6,m.rounding=1,fr=!1,d=d.times(d).plus(1).sqrt().plus(d),fr=!0,m.precision=c,m.rounding=f,d.ln())},hn.inverseHyperbolicTangent=hn.atanh=function(){var c,f,d,m,y=this,b=y.constructor;return y.isFinite()?y.e>=0?new b(y.abs().eq(1)?y.s/0:y.isZero()?y:NaN):(c=b.precision,f=b.rounding,m=y.sd(),Math.max(m,c)<2*-y.e-1?rr(new b(y),c,f,!0):(b.precision=d=m-y.e,y=en(y.plus(1),new b(1).minus(y),d+c,1),b.precision=c+4,b.rounding=1,y=y.ln(),b.precision=c,b.rounding=f,y.times(.5))):new b(NaN)},hn.inverseSine=hn.asin=function(){var c,f,d,m,y=this,b=y.constructor;return y.isZero()?new b(y):(f=y.abs().cmp(1),d=b.precision,m=b.rounding,-1!==f?0===f?((c=Zi(b,d+4,m).times(.5)).s=y.s,c):new b(NaN):(b.precision=d+6,b.rounding=1,y=y.div(new b(1).minus(y.times(y)).sqrt().plus(1)).atan(),b.precision=d,b.rounding=m,y.times(2)))},hn.inverseTangent=hn.atan=function(){var c,f,d,m,y,b,I,C,A,T=this,E=T.constructor,S=E.precision,R=E.rounding;if(T.isFinite()){if(T.isZero())return new E(T);if(T.abs().eq(1)&&S+4<=Mf)return(I=Zi(E,S+4,R).times(.25)).s=T.s,I}else{if(!T.s)return new E(NaN);if(S+4<=Mf)return(I=Zi(E,S+4,R).times(.5)).s=T.s,I}for(E.precision=C=S+10,E.rounding=1,c=d=Math.min(28,C/jn+2|0);c;--c)T=T.div(T.times(T).plus(1).sqrt().plus(1));for(fr=!1,f=Math.ceil(C/jn),m=1,A=T.times(T),I=new E(T),y=T;-1!==c;)if(y=y.times(A),b=I.minus(y.div(m+=2)),y=y.times(A),void 0!==(I=b.plus(y.div(m+=2))).d[f])for(c=f;I.d[c]===b.d[c]&&c--;);return d&&(I=I.times(2<<d-1)),fr=!0,rr(I,E.precision=S,E.rounding=R,!0)},hn.isFinite=function(){return!!this.d},hn.isInteger=hn.isInt=function(){return!!this.d&&Vr(this.e/jn)>this.d.length-2},hn.isNaN=function(){return!this.s},hn.isNegative=hn.isNeg=function(){return this.s<0},hn.isPositive=hn.isPos=function(){return this.s>0},hn.isZero=function(){return!!this.d&&0===this.d[0]},hn.lessThan=hn.lt=function(c){return this.cmp(c)<0},hn.lessThanOrEqualTo=hn.lte=function(c){return this.cmp(c)<1},hn.logarithm=hn.log=function(c){var f,d,m,y,b,I,C,A,T=this,E=T.constructor,S=E.precision,R=E.rounding;if(null==c)c=new E(10),f=!0;else{if(d=(c=new E(c)).d,c.s<0||!d||!d[0]||c.eq(1))return new E(NaN);f=c.eq(10)}if(d=T.d,T.s<0||!d||!d[0]||T.eq(1))return new E(d&&!d[0]?-1/0:1!=T.s?NaN:d?0:1/0);if(f)if(d.length>1)b=!0;else{for(y=d[0];y%10==0;)y/=10;b=1!==y}if(fr=!1,I=hu(T,C=S+5),m=f?Pl(E,C+10):hu(c,C),Ja((A=en(I,m,C,1)).d,y=S,R))do{if(I=hu(T,C+=10),m=f?Pl(E,C+10):hu(c,C),A=en(I,m,C,1),!b){+Ys(A.d).slice(y+1,y+15)+1==1e14&&(A=rr(A,S+1,0));break}}while(Ja(A.d,y+=10,R));return fr=!0,rr(A,S,R)},hn.minus=hn.sub=function(c){var f,d,m,y,b,I,C,A,T,E,S,R,P=this,F=P.constructor;if(c=new F(c),!P.d||!c.d)return P.s&&c.s?P.d?c.s=-c.s:c=new F(c.d||P.s!==c.s?P:NaN):c=new F(NaN),c;if(P.s!=c.s)return c.s=-c.s,P.plus(c);if(R=c.d,C=F.precision,A=F.rounding,!(T=P.d)[0]||!R[0]){if(R[0])c.s=-c.s;else{if(!T[0])return new F(3===A?-0:0);c=new F(P)}return fr?rr(c,C,A):c}if(d=Vr(c.e/jn),E=Vr(P.e/jn),T=T.slice(),b=E-d){for((S=b<0)?(f=T,b=-b,I=R.length):(f=R,d=E,I=T.length),b>(m=Math.max(Math.ceil(C/jn),I)+2)&&(b=m,f.length=1),f.reverse(),m=b;m--;)f.push(0);f.reverse()}else{for((S=(m=T.length)<(I=R.length))&&(I=m),m=0;m<I;m++)if(T[m]!=R[m]){S=T[m]<R[m];break}b=0}for(S&&(f=T,T=R,R=f,c.s=-c.s),m=R.length-(I=T.length);m>0;--m)T[I++]=0;for(m=R.length;m>b;){if(T[--m]<R[m]){for(y=m;y&&0===T[--y];)T[y]=ja-1;--T[y],T[m]+=ja}T[m]-=R[m]}for(;0===T[--I];)T.pop();for(;0===T[0];T.shift())--d;return T[0]?(c.d=T,c.e=Qa(T,d),fr?rr(c,C,A):c):new F(3===A?-0:0)},hn.modulo=hn.mod=function(c){var f,d=this,m=d.constructor;return c=new m(c),!d.d||!c.s||c.d&&!c.d[0]?new m(NaN):!c.d||d.d&&!d.d[0]?rr(new m(d),m.precision,m.rounding):(fr=!1,9==m.modulo?(f=en(d,c.abs(),0,3,1)).s*=c.s:f=en(d,c,0,m.modulo,1),f=f.times(c),fr=!0,d.minus(f))},hn.naturalExponential=hn.exp=function(){return Ca(this)},hn.naturalLogarithm=hn.ln=function(){return hu(this)},hn.negated=hn.neg=function(){var c=new this.constructor(this);return c.s=-c.s,rr(c)},hn.plus=hn.add=function(c){var f,d,m,y,b,I,C,A,T,E,S=this,R=S.constructor;if(c=new R(c),!S.d||!c.d)return S.s&&c.s?S.d||(c=new R(c.d||S.s===c.s?S:NaN)):c=new R(NaN),c;if(S.s!=c.s)return c.s=-c.s,S.minus(c);if(E=c.d,C=R.precision,A=R.rounding,!(T=S.d)[0]||!E[0])return E[0]||(c=new R(S)),fr?rr(c,C,A):c;if(b=Vr(S.e/jn),m=Vr(c.e/jn),T=T.slice(),y=b-m){for(y<0?(d=T,y=-y,I=E.length):(d=E,m=b,I=T.length),y>(I=(b=Math.ceil(C/jn))>I?b+1:I+1)&&(y=I,d.length=1),d.reverse();y--;)d.push(0);d.reverse()}for((I=T.length)-(y=E.length)<0&&(y=I,d=E,E=T,T=d),f=0;y;)f=(T[--y]=T[y]+E[y]+f)/ja|0,T[y]%=ja;for(f&&(T.unshift(f),++m),I=T.length;0==T[--I];)T.pop();return c.d=T,c.e=Qa(T,m),fr?rr(c,C,A):c},hn.precision=hn.sd=function(c){var f,d=this;if(void 0!==c&&c!==!!c&&1!==c&&0!==c)throw Error(To+c);return d.d?(f=ci(d.d),c&&d.e+1>f&&(f=d.e+1)):f=NaN,f},hn.round=function(){var c=this,f=c.constructor;return rr(new f(c),c.e+1,f.rounding)},hn.sine=hn.sin=function(){var c,f,d=this,m=d.constructor;return d.isFinite()?d.isZero()?new m(d):(f=m.rounding,m.precision=(c=m.precision)+Math.max(d.e,d.sd())+jn,m.rounding=1,d=function Zs(c,f){var d,m=f.d.length;if(m<3)return f.isZero()?f:gl(c,2,f,f);d=1.4*Math.sqrt(m),f=gl(c,2,f=f.times(1/Qu(5,d=d>16?16:0|d)),f);for(var y,b=new c(5),I=new c(16),C=new c(20);d--;)y=f.times(f),f=f.times(b.plus(y.times(I.times(y).minus(C))));return f}(m,Qi(m,d)),m.precision=c,m.rounding=f,rr(Ba>2?d.neg():d,c,f,!0)):new m(NaN)},hn.squareRoot=hn.sqrt=function(){var c,f,d,m,y,b,I=this,C=I.d,A=I.e,T=I.s,E=I.constructor;if(1!==T||!C||!C[0])return new E(!T||T<0&&(!C||C[0])?NaN:C?I:1/0);for(fr=!1,0==(T=Math.sqrt(+I))||T==1/0?(((f=Ys(C)).length+A)%2==0&&(f+="0"),T=Math.sqrt(f),A=Vr((A+1)/2)-(A<0||A%2),m=new E(f=T==1/0?"5e"+A:(f=T.toExponential()).slice(0,f.indexOf("e")+1)+A)):m=new E(T.toString()),d=(A=E.precision)+3;;)if(m=(b=m).plus(en(I,b,d+2,1)).times(.5),Ys(b.d).slice(0,d)===(f=Ys(m.d)).slice(0,d)){if("9999"!=(f=f.slice(d-3,d+1))&&(y||"4999"!=f)){(!+f||!+f.slice(1)&&"5"==f.charAt(0))&&(rr(m,A+1,1),c=!m.times(m).eq(I));break}if(!y&&(rr(b,A+1,0),b.times(b).eq(I))){m=b;break}d+=4,y=1}return fr=!0,rr(m,A,E.rounding,c)},hn.tangent=hn.tan=function(){var c,f,d=this,m=d.constructor;return d.isFinite()?d.isZero()?new m(d):(f=m.rounding,m.precision=(c=m.precision)+10,m.rounding=1,(d=d.sin()).s=1,d=en(d,new m(1).minus(d.times(d)).sqrt(),c+10,0),m.precision=c,m.rounding=f,rr(2==Ba||4==Ba?d.neg():d,c,f,!0)):new m(NaN)},hn.times=hn.mul=function(c){var f,d,m,y,b,I,C,A,T,E=this,S=E.constructor,R=E.d,P=(c=new S(c)).d;if(c.s*=E.s,!(R&&R[0]&&P&&P[0]))return new S(!c.s||R&&!R[0]&&!P||P&&!P[0]&&!R?NaN:R&&P?0*c.s:c.s/0);for(d=Vr(E.e/jn)+Vr(c.e/jn),(A=R.length)<(T=P.length)&&(b=R,R=P,P=b,I=A,A=T,T=I),b=[],m=I=A+T;m--;)b.push(0);for(m=T;--m>=0;){for(f=0,y=A+m;y>m;)C=b[y]+P[m]*R[y-m-1]+f,b[y--]=C%ja|0,f=C/ja|0;b[y]=(b[y]+f)%ja|0}for(;!b[--I];)b.pop();return f?++d:b.shift(),c.d=b,c.e=Qa(b,d),fr?rr(c,S.precision,S.rounding):c},hn.toBinary=function(c,f){return la(this,2,c,f)},hn.toDecimalPlaces=hn.toDP=function(c,f){var d=this,m=d.constructor;return d=new m(d),void 0===c?d:(fs(c,0,Wi),void 0===f?f=m.rounding:fs(f,0,8),rr(d,c+d.e+1,f))},hn.toExponential=function(c,f){var d,m=this,y=m.constructor;return void 0===c?d=As(m,!0):(fs(c,0,Wi),void 0===f?f=y.rounding:fs(f,0,8),d=As(m=rr(new y(m),c+1,f),!0,c+1)),m.isNeg()&&!m.isZero()?"-"+d:d},hn.toFixed=function(c,f){var d,m,y=this,b=y.constructor;return void 0===c?d=As(y):(fs(c,0,Wi),void 0===f?f=b.rounding:fs(f,0,8),d=As(m=rr(new b(y),c+y.e+1,f),!1,c+m.e+1)),y.isNeg()&&!y.isZero()?"-"+d:d},hn.toFraction=function(c){var f,d,m,y,b,I,C,A,T,E,S,R,P=this,F=P.d,B=P.constructor;if(!F)return new B(P);if(T=d=new B(1),m=A=new B(0),b=(f=new B(m)).e=ci(F)-P.e-1,f.d[0]=Ks(10,(I=b%jn)<0?jn+I:I),null==c)c=b>0?f:T;else{if(!(C=new B(c)).isInt()||C.lt(T))throw Error(To+C);c=C.gt(f)?b>0?f:T:C}for(fr=!1,C=new B(Ys(F)),E=B.precision,B.precision=b=F.length*jn*2;S=en(C,f,0,1,1),1!=(y=d.plus(S.times(m))).cmp(c);)d=m,m=y,T=A.plus(S.times(y=T)),A=y,f=C.minus(S.times(y=f)),C=y;return y=en(c.minus(d),m,0,1,1),A=A.plus(y.times(T)),d=d.plus(y.times(m)),A.s=T.s=P.s,R=en(T,m,b,1).minus(P).abs().cmp(en(A,d,b,1).minus(P).abs())<1?[T,m]:[A,d],B.precision=E,fr=!0,R},hn.toHexadecimal=hn.toHex=function(c,f){return la(this,16,c,f)},hn.toNearest=function(c,f){var d=this,m=d.constructor;if(d=new m(d),null==c){if(!d.d)return d;c=new m(1),f=m.rounding}else{if(c=new m(c),void 0===f?f=m.rounding:fs(f,0,8),!d.d)return c.s?d:c;if(!c.d)return c.s&&(c.s=d.s),c}return c.d[0]?(fr=!1,d=en(d,c,0,f,1).times(c),fr=!0,rr(d)):(c.s=d.s,d=c),d},hn.toNumber=function(){return+this},hn.toOctal=function(c,f){return la(this,8,c,f)},hn.toPower=hn.pow=function(c){var f,d,m,y,b,I,C=this,A=C.constructor,T=+(c=new A(c));if(!(C.d&&c.d&&C.d[0]&&c.d[0]))return new A(Ks(+C,T));if((C=new A(C)).eq(1))return C;if(m=A.precision,b=A.rounding,c.eq(1))return rr(C,m,b);if((f=Vr(c.e/jn))>=c.d.length-1&&(d=T<0?-T:T)<=9007199254740991)return y=ys(A,C,d,m),c.s<0?new A(1).div(y):rr(y,m,b);if((I=C.s)<0){if(f<c.d.length-1)return new A(NaN);if(1&c.d[f]||(I=1),0==C.e&&1==C.d[0]&&1==C.d.length)return C.s=I,C}return(f=0!=(d=Ks(+C,T))&&isFinite(d)?new A(d+"").e:Vr(T*(Math.log("0."+Ys(C.d))/Math.LN10+C.e+1)))>A.maxE+1||f<A.minE-1?new A(f>0?I/0:0):(fr=!1,A.rounding=C.s=1,d=Math.min(12,(f+"").length),(y=Ca(c.times(hu(C,m+d)),m)).d&&Ja((y=rr(y,m+5,1)).d,m,b)&&+Ys((y=rr(Ca(c.times(hu(C,(f=m+10)+d)),f),f+5,1)).d).slice(m+1,m+15)+1==1e14&&(y=rr(y,m+1,0)),y.s=I,fr=!0,A.rounding=b,rr(y,m,b))},hn.toPrecision=function(c,f){var d,m=this,y=m.constructor;return void 0===c?d=As(m,m.e<=y.toExpNeg||m.e>=y.toExpPos):(fs(c,1,Wi),void 0===f?f=y.rounding:fs(f,0,8),d=As(m=rr(new y(m),c,f),c<=m.e||m.e<=y.toExpNeg,c)),m.isNeg()&&!m.isZero()?"-"+d:d},hn.toSignificantDigits=hn.toSD=function(c,f){var m=this.constructor;return void 0===c?(c=m.precision,f=m.rounding):(fs(c,1,Wi),void 0===f?f=m.rounding:fs(f,0,8)),rr(new m(this),c,f)},hn.toString=function(){var c=this,f=c.constructor,d=As(c,c.e<=f.toExpNeg||c.e>=f.toExpPos);return c.isNeg()&&!c.isZero()?"-"+d:d},hn.truncated=hn.trunc=function(){return rr(new this.constructor(this),this.e+1,1)},hn.valueOf=hn.toJSON=function(){var c=this,f=c.constructor,d=As(c,c.e<=f.toExpNeg||c.e>=f.toExpPos);return c.isNeg()?"-"+d:d};var en=function(){function c(m,y,b){var I,C=0,A=m.length;for(m=m.slice();A--;)m[A]=(I=m[A]*y+C)%b|0,C=I/b|0;return C&&m.unshift(C),m}function f(m,y,b,I){var C,A;if(b!=I)A=b>I?1:-1;else for(C=A=0;C<b;C++)if(m[C]!=y[C]){A=m[C]>y[C]?1:-1;break}return A}function d(m,y,b,I){for(var C=0;b--;)m[b]-=C,m[b]=(C=m[b]<y[b]?1:0)*I+m[b]-y[b];for(;!m[0]&&m.length>1;)m.shift()}return function(m,y,b,I,C,A){var T,E,S,R,P,F,B,J,j,oe,G,ee,ne,X,be,Ie,Ce,fe,Ve,qe,at=m.constructor,ht=m.s==y.s?1:-1,bt=m.d,ct=y.d;if(!(bt&&bt[0]&&ct&&ct[0]))return new at(m.s&&y.s&&(bt?!ct||bt[0]!=ct[0]:ct)?bt&&0==bt[0]||!ct?0*ht:ht/0:NaN);for(A?(P=1,E=m.e-y.e):(A=ja,E=Vr(m.e/(P=jn))-Vr(y.e/P)),Ve=ct.length,Ce=bt.length,oe=(j=new at(ht)).d=[],S=0;ct[S]==(bt[S]||0);S++);if(ct[S]>(bt[S]||0)&&E--,null==b?(X=b=at.precision,I=at.rounding):X=C?b+(m.e-y.e)+1:b,X<0)oe.push(1),F=!0;else{if(X=X/P+2|0,S=0,1==Ve){for(R=0,ct=ct[0],X++;(S<Ce||R)&&X--;S++)oe[S]=(be=R*A+(bt[S]||0))/ct|0,R=be%ct|0;F=R||S<Ce}else{for((R=A/(ct[0]+1)|0)>1&&(ct=c(ct,R,A),bt=c(bt,R,A),Ve=ct.length,Ce=bt.length),Ie=Ve,ee=(G=bt.slice(0,Ve)).length;ee<Ve;)G[ee++]=0;(qe=ct.slice()).unshift(0),fe=ct[0],ct[1]>=A/2&&++fe;do{R=0,(T=f(ct,G,Ve,ee))<0?(ne=G[0],Ve!=ee&&(ne=ne*A+(G[1]||0)),(R=ne/fe|0)>1?(R>=A&&(R=A-1),1==(T=f(B=c(ct,R,A),G,J=B.length,ee=G.length))&&(R--,d(B,Ve<J?qe:ct,J,A))):(0==R&&(T=R=1),B=ct.slice()),(J=B.length)<ee&&B.unshift(0),d(G,B,ee,A),-1==T&&(T=f(ct,G,Ve,ee=G.length))<1&&(R++,d(G,Ve<ee?qe:ct,ee,A)),ee=G.length):0===T&&(R++,G=[0]),oe[S++]=R,T&&G[0]?G[ee++]=bt[Ie]||0:(G=[bt[Ie]],ee=1)}while((Ie++<Ce||void 0!==G[0])&&X--);F=void 0!==G[0]}oe[0]||oe.shift()}if(1==P)j.e=E,Kc=F;else{for(S=1,R=oe[0];R>=10;R/=10)S++;j.e=S+E*P-1,rr(j,C?b+j.e+1:b,I,F)}return j}}();function rr(c,f,d,m){var y,b,I,C,A,T,E,S,R,P=c.constructor;e:if(null!=f){if(!(S=c.d))return c;for(y=1,C=S[0];C>=10;C/=10)y++;if((b=f-y)<0)b+=jn,A=(E=S[R=0])/Ks(10,y-(I=f)-1)%10|0;else if((R=Math.ceil((b+1)/jn))>=(C=S.length)){if(!m)break e;for(;C++<=R;)S.push(0);E=A=0,y=1,I=(b%=jn)-jn+1}else{for(E=C=S[R],y=1;C>=10;C/=10)y++;A=(I=(b%=jn)-jn+y)<0?0:E/Ks(10,y-I-1)%10|0}if(m=m||f<0||void 0!==S[R+1]||(I<0?E:E%Ks(10,y-I-1)),T=d<4?(A||m)&&(0==d||d==(c.s<0?3:2)):A>5||5==A&&(4==d||m||6==d&&(b>0?I>0?E/Ks(10,y-I):0:S[R-1])%10&1||d==(c.s<0?8:7)),f<1||!S[0])return S.length=0,T?(S[0]=Ks(10,(jn-(f-=c.e+1)%jn)%jn),c.e=-f||0):S[0]=c.e=0,c;if(0==b?(S.length=R,C=1,R--):(S.length=R+1,C=Ks(10,jn-b),S[R]=I>0?(E/Ks(10,y-I)%Ks(10,I)|0)*C:0),T)for(;;){if(0==R){for(b=1,I=S[0];I>=10;I/=10)b++;for(I=S[0]+=C,C=1;I>=10;I/=10)C++;b!=C&&(c.e++,S[0]==ja&&(S[0]=1));break}if(S[R]+=C,S[R]!=ja)break;S[R--]=0,C=1}for(b=S.length;0===S[--b];)S.pop()}return fr&&(c.e>P.maxE?(c.d=null,c.e=NaN):c.e<P.minE&&(c.e=0,c.d=[0])),c}function As(c,f,d){if(!c.isFinite())return eo(c);var m,y=c.e,b=Ys(c.d),I=b.length;return f?(d&&(m=d-I)>0?b=b.charAt(0)+"."+b.slice(1)+kr(m):I>1&&(b=b.charAt(0)+"."+b.slice(1)),b=b+(c.e<0?"e":"e+")+c.e):y<0?(b="0."+kr(-y-1)+b,d&&(m=d-I)>0&&(b+=kr(m))):y>=I?(b+=kr(y+1-I),d&&(m=d-y-1)>0&&(b=b+"."+kr(m))):((m=y+1)<I&&(b=b.slice(0,m)+"."+b.slice(m)),d&&(m=d-I)>0&&(y+1===I&&(b+="."),b+=kr(m))),b}function Qa(c,f){var d=c[0];for(f*=jn;d>=10;d/=10)f++;return f}function Pl(c,f,d){if(f>Mr)throw fr=!0,d&&(c.precision=d),Error(ml);return rr(new c(ma),f,1,!0)}function Zi(c,f,d){if(f>Mf)throw Error(ml);return rr(new c(ju),f,d,!0)}function ci(c){var f=c.length-1,d=f*jn+1;if(f=c[f]){for(;f%10==0;f/=10)d--;for(f=c[0];f>=10;f/=10)d++}return d}function kr(c){for(var f="";c--;)f+="0";return f}function ys(c,f,d,m){var y,b=new c(1),I=Math.ceil(m/jn+4);for(fr=!1;;){if(d%2&&Fl((b=b.times(f)).d,I)&&(y=!0),0===(d=Vr(d/2))){d=b.d.length-1,y&&0===b.d[d]&&++b.d[d];break}Fl((f=f.times(f)).d,I)}return fr=!0,b}function uh(c){return 1&c.d[c.d.length-1]}function lh(c,f,d){for(var m,y=new c(f[0]),b=0;++b<f.length;){if(!(m=new c(f[b])).s){y=m;break}y[d](m)&&(y=m)}return y}function Ca(c,f){var d,m,y,b,I,C,A,T=0,E=0,S=0,R=c.constructor,P=R.rounding,F=R.precision;if(!c.d||!c.d[0]||c.e>17)return new R(c.d?c.d[0]?c.s<0?0:1/0:1:c.s?c.s<0?0:c:NaN);for(null==f?(fr=!1,A=F):A=f,C=new R(.03125);c.e>-2;)c=c.times(C),S+=5;for(A+=m=Math.log(Ks(2,S))/Math.LN10*2+5|0,d=b=I=new R(1),R.precision=A;;){if(b=rr(b.times(c),A,1),d=d.times(++E),Ys((C=I.plus(en(b,d,A,1))).d).slice(0,A)===Ys(I.d).slice(0,A)){for(y=S;y--;)I=rr(I.times(I),A,1);if(null!=f)return R.precision=F,I;if(!(T<3&&Ja(I.d,A-m,P,T)))return rr(I,R.precision=F,P,fr=!0);R.precision=A+=10,d=b=C=new R(1),E=0,T++}I=C}}function hu(c,f){var d,m,y,b,I,C,A,T,E,S,R,P=1,B=c,J=B.d,j=B.constructor,oe=j.rounding,G=j.precision;if(B.s<0||!J||!J[0]||!B.e&&1==J[0]&&1==J.length)return new j(J&&!J[0]?-1/0:1!=B.s?NaN:J?0:B);if(null==f?(fr=!1,E=G):E=f,j.precision=E+=10,m=(d=Ys(J)).charAt(0),!(Math.abs(b=B.e)<15e14))return T=Pl(j,E+2,G).times(b+""),B=hu(new j(m+"."+d.slice(1)),E-10).plus(T),j.precision=G,null==f?rr(B,G,oe,fr=!0):B;for(;m<7&&1!=m||1==m&&d.charAt(1)>3;)m=(d=Ys((B=B.times(c)).d)).charAt(0),P++;for(b=B.e,m>1?(B=new j("0."+d),b++):B=new j(m+"."+d.slice(1)),S=B,A=I=B=en(B.minus(1),B.plus(1),E,1),R=rr(B.times(B),E,1),y=3;;){if(I=rr(I.times(R),E,1),Ys((T=A.plus(en(I,new j(y),E,1))).d).slice(0,E)===Ys(A.d).slice(0,E)){if(A=A.times(2),0!==b&&(A=A.plus(Pl(j,E+2,G).times(b+""))),A=en(A,new j(P),E,1),null!=f)return j.precision=G,A;if(!Ja(A.d,E-10,oe,C))return rr(A,j.precision=G,oe,fr=!0);j.precision=E+=10,T=I=B=en(S.minus(1),S.plus(1),E,1),R=rr(B.times(B),E,1),y=C=1}A=T,y+=2}}function eo(c){return String(c.s*c.s/0)}function Jr(c,f){var d,m,y;for((d=f.indexOf("."))>-1&&(f=f.replace(".","")),(m=f.search(/e/i))>0?(d<0&&(d=m),d+=+f.slice(m+1),f=f.substring(0,m)):d<0&&(d=f.length),m=0;48===f.charCodeAt(m);m++);for(y=f.length;48===f.charCodeAt(y-1);--y);if(f=f.slice(m,y)){if(y-=m,c.e=d=d-m-1,c.d=[],m=(d+1)%jn,d<0&&(m+=jn),m<y){for(m&&c.d.push(+f.slice(0,m)),y-=jn;m<y;)c.d.push(+f.slice(m,m+=jn));f=f.slice(m),m=jn-f.length}else m-=y;for(;m--;)f+="0";c.d.push(+f),fr&&(c.e>c.constructor.maxE?(c.d=null,c.e=NaN):c.e<c.constructor.minE&&(c.e=0,c.d=[0]))}else c.e=0,c.d=[0];return c}function gl(c,f,d,m,y){var b,I,C,A,E=c.precision,S=Math.ceil(E/jn);for(fr=!1,A=d.times(d),C=new c(m);;){if(I=en(C.times(A),new c(f++*f++),E,1),C=y?m.plus(I):m.minus(I),m=en(I.times(A),new c(f++*f++),E,1),void 0!==(I=C.plus(m)).d[S]){for(b=S;I.d[b]===C.d[b]&&b--;);if(-1==b)break}b=C,C=m,m=I,I=b}return fr=!0,I.d.length=S+1,I}function Qu(c,f){for(var d=c;--f;)d*=c;return d}function Qi(c,f){var d,m=f.s<0,y=Zi(c,c.precision,1),b=y.times(.5);if((f=f.abs()).lte(b))return Ba=m?4:1,f;if((d=f.divToInt(y)).isZero())Ba=m?3:2;else{if((f=f.minus(d.times(y))).lte(b))return Ba=uh(d)?m?2:3:m?4:1,f;Ba=uh(d)?m?1:4:m?3:2}return f.minus(y).abs()}function la(c,f,d,m){var y,b,I,C,A,T,E,S,R,P=c.constructor,F=void 0!==d;if(F?(fs(d,1,Wi),void 0===m?m=P.rounding:fs(m,0,8)):(d=P.precision,m=P.rounding),c.isFinite()){for(F?(y=2,16==f?d=4*d-3:8==f&&(d=3*d-2)):y=f,(I=(E=As(c)).indexOf("."))>=0&&(E=E.replace(".",""),(R=new P(1)).e=E.length-I,R.d=mc(As(R),10,y),R.e=R.d.length),b=A=(S=mc(E,10,y)).length;0==S[--A];)S.pop();if(S[0]){if(I<0?b--:((c=new P(c)).d=S,c.e=b,S=(c=en(c,R,d,m,0,y)).d,b=c.e,T=Kc),I=S[d],C=y/2,T=T||void 0!==S[d+1],T=m<4?(void 0!==I||T)&&(0===m||m===(c.s<0?3:2)):I>C||I===C&&(4===m||T||6===m&&1&S[d-1]||m===(c.s<0?8:7)),S.length=d,T)for(;++S[--d]>y-1;)S[d]=0,d||(++b,S.unshift(1));for(A=S.length;!S[A-1];--A);for(I=0,E="";I<A;I++)E+=Pt.charAt(S[I]);if(F){if(A>1)if(16==f||8==f){for(I=16==f?4:3,--A;A%I;A++)E+="0";for(A=(S=mc(E,y,f)).length;!S[A-1];--A);for(I=1,E="1.";I<A;I++)E+=Pt.charAt(S[I])}else E=E.charAt(0)+"."+E.slice(1);E=E+(b<0?"p":"p+")+b}else if(b<0){for(;++b;)E="0"+E;E="0."+E}else if(++b>A)for(b-=A;b--;)E+="0";else b<A&&(E=E.slice(0,b)+"."+E.slice(b))}else E=F?"0p+0":"0";E=(16==f?"0x":2==f?"0b":8==f?"0o":"")+E}else E=eo(c);return c.s<0?"-"+E:E}function Fl(c,f){if(c.length>f)return c.length=f,!0}function Mo(c){return new this(c).abs()}function Tu(c){return new this(c).acos()}function Mu(c){return new this(c).acosh()}function Ll(c,f){return new this(c).plus(f)}function Ts(c){return new this(c).asin()}function Rf(c){return new this(c).asinh()}function Ro(c){return new this(c).atan()}function hs(c){return new this(c).atanh()}function Gs(c,f){c=new this(c),f=new this(f);var d,m=this.precision,y=this.rounding,b=m+4;return c.s&&f.s?c.d||f.d?!f.d||c.isZero()?(d=f.s<0?Zi(this,m,y):new this(0)).s=c.s:!c.d||f.isZero()?(d=Zi(this,b,1).times(.5)).s=c.s:f.s<0?(this.precision=b,this.rounding=1,d=this.atan(en(c,f,b,1)),f=Zi(this,b,1),this.precision=m,this.rounding=y,d=c.s<0?d.minus(f):d.plus(f)):d=this.atan(en(c,f,b,1)):(d=Zi(this,b,1).times(f.s>0?.25:.75)).s=c.s:d=new this(NaN),d}function gc(c){return new this(c).cbrt()}function Hh(c){return rr(c=new this(c),c.e+1,2)}function yl(c,f,d){return new this(c).clamp(f,d)}function ch(c){if(!c||"object"!=typeof c)throw Error(ga+"Object expected");var f,d,m,y=!0===c.defaults,b=["precision",1,Wi,"rounding",0,8,"toExpNeg",-is,0,"toExpPos",0,is,"maxE",0,is,"minE",-is,0,"modulo",0,9];for(f=0;f<b.length;f+=3)if(d=b[f],y&&(this[d]=Ns[d]),void 0!==(m=c[d])){if(!(Vr(m)===m&&m>=b[f+1]&&m<=b[f+2]))throw Error(To+d+": "+m);this[d]=m}if(d="crypto",y&&(this[d]=Ns[d]),void 0!==(m=c[d])){if(!0!==m&&!1!==m&&0!==m&&1!==m)throw Error(To+d+": "+m);if(m){if(!(typeof crypto<"u"&&crypto&&(crypto.getRandomValues||crypto.randomBytes)))throw Error(Ju);this[d]=!0}else this[d]=!1}return this}function Df(c){return new this(c).cos()}function Aa(c){return new this(c).cosh()}function ya(c,f){return new this(c).div(f)}function el(c){return new this(c).exp()}function Do(c){return rr(c=new this(c),c.e+1,3)}function yc(){var c,f,d=new this(0);for(fr=!1,c=0;c<arguments.length;)if((f=new this(arguments[c++])).d)d.d&&(d=d.plus(f.times(f)));else{if(f.s)return fr=!0,new this(1/0);d=f}return fr=!0,d.sqrt()}function ss(c){return c instanceof bl||c&&c.toStringTag===kl||!1}function Wn(c){return new this(c).ln()}function fh(c,f){return new this(c).log(f)}function $l(c){return new this(c).log(2)}function va(c){return new this(c).log(10)}function Xo(){return lh(this,arguments,"lt")}function vl(){return lh(this,arguments,"gt")}function Bl(c,f){return new this(c).mod(f)}function jc(c,f){return new this(c).mul(f)}function Of(c,f){return new this(c).pow(f)}function Yr(c){var f,d,m,y,b=0,I=new this(1),C=[];if(void 0===c?c=this.precision:fs(c,1,Wi),m=Math.ceil(c/jn),this.crypto)if(crypto.getRandomValues)for(f=crypto.getRandomValues(new Uint32Array(m));b<m;)(y=f[b])>=429e7?f[b]=crypto.getRandomValues(new Uint32Array(1))[0]:C[b++]=y%1e7;else{if(!crypto.randomBytes)throw Error(Ju);for(f=crypto.randomBytes(m*=4);b<m;)(y=f[b]+(f[b+1]<<8)+(f[b+2]<<16)+((127&f[b+3])<<24))>=214e7?crypto.randomBytes(4).copy(f,b):(C.push(y%1e7),b+=4);b=m/4}else for(;b<m;)C[b++]=1e7*Math.random()|0;for(m=C[--b],c%=jn,m&&c&&(y=Ks(10,jn-c),C[b]=(m/y|0)*y);0===C[b];b--)C.pop();if(b<0)d=0,C=[0];else{for(d=-1;0===C[0];d-=jn)C.shift();for(m=1,y=C[0];y>=10;y/=10)m++;m<jn&&(d-=jn-m)}return I.e=d,I.d=C,I}function pu(c){return rr(c=new this(c),c.e+1,this.rounding)}function as(c){return(c=new this(c)).d?c.d[0]?c.s:0*c.s:c.s||NaN}function Jc(c){return new this(c).sin()}function Ta(c){return new this(c).sinh()}function kf(c){return new this(c).sqrt()}function Fr(c,f){return new this(c).sub(f)}function xl(){var c=0,f=arguments,d=new this(f[c]);for(fr=!1;d.s&&++c<f.length;)d=d.plus(f[c]);return fr=!0,rr(d,this.precision,this.rounding)}function Hi(c){return new this(c).tan()}function Xh(c){return new this(c).tanh()}function to(c){return rr(c=new this(c),c.e+1,1)}hn[Symbol.for("nodejs.util.inspect.custom")]=hn.toString,hn[Symbol.toStringTag]="Decimal";var bl=hn.constructor=function Ru(c){var f,d,m;function y(b){var I,C,A,T=this;if(!(T instanceof y))return new y(b);if(T.constructor=y,ss(b))return T.s=b.s,void(fr?!b.d||b.e>y.maxE?(T.e=NaN,T.d=null):b.e<y.minE?(T.e=0,T.d=[0]):(T.e=b.e,T.d=b.d.slice()):(T.e=b.e,T.d=b.d?b.d.slice():b.d));if("number"==(A=typeof b)){if(0===b)return T.s=1/b<0?-1:1,T.e=0,void(T.d=[0]);if(b<0?(b=-b,T.s=-1):T.s=1,b===~~b&&b<1e7){for(I=0,C=b;C>=10;C/=10)I++;return void(fr?I>y.maxE?(T.e=NaN,T.d=null):I<y.minE?(T.e=0,T.d=[0]):(T.e=I,T.d=[b]):(T.e=I,T.d=[b]))}return 0*b!=0?(b||(T.s=NaN),T.e=NaN,void(T.d=null)):Jr(T,b.toString())}if("string"!==A)throw Error(To+b);return 45===(C=b.charCodeAt(0))?(b=b.slice(1),T.s=-1):(43===C&&(b=b.slice(1)),T.s=1),Gr.test(b)?Jr(T,b):function Zc(c,f){var d,m,y,b,I,C,A,T,E;if(f.indexOf("_")>-1){if(f=f.replace(/(\d)_(?=\d)/g,"$1"),Gr.test(f))return Jr(c,f)}else if("Infinity"===f||"NaN"===f)return+f||(c.s=NaN),c.e=NaN,c.d=null,c;if(Af.test(f))d=16,f=f.toLowerCase();else if(Ho.test(f))d=2;else{if(!Tf.test(f))throw Error(To+f);d=8}for((b=f.search(/p/i))>0?(A=+f.slice(b+1),f=f.substring(2,b)):f=f.slice(2),b=f.indexOf("."),m=c.constructor,(I=b>=0)&&(b=(C=(f=f.replace(".","")).length)-b,y=ys(m,new m(d),b,2*b)),b=E=(T=mc(f,d,ja)).length-1;0===T[b];--b)T.pop();return b<0?new m(0*c.s):(c.e=Qa(T,E),c.d=T,fr=!1,I&&(c=en(c,y,4*C)),A&&(c=c.times(Math.abs(A)<54?Ks(2,A):bl.pow(2,A))),fr=!0,c)}(T,b)}if(y.prototype=hn,y.ROUND_UP=0,y.ROUND_DOWN=1,y.ROUND_CEIL=2,y.ROUND_FLOOR=3,y.ROUND_HALF_UP=4,y.ROUND_HALF_DOWN=5,y.ROUND_HALF_EVEN=6,y.ROUND_HALF_CEIL=7,y.ROUND_HALF_FLOOR=8,y.EUCLID=9,y.config=y.set=ch,y.clone=Ru,y.isDecimal=ss,y.abs=Mo,y.acos=Tu,y.acosh=Mu,y.add=Ll,y.asin=Ts,y.asinh=Rf,y.atan=Ro,y.atanh=hs,y.atan2=Gs,y.cbrt=gc,y.ceil=Hh,y.clamp=yl,y.cos=Df,y.cosh=Aa,y.div=ya,y.exp=el,y.floor=Do,y.hypot=yc,y.ln=Wn,y.log=fh,y.log10=va,y.log2=$l,y.max=Xo,y.min=vl,y.mod=Bl,y.mul=jc,y.pow=Of,y.random=Yr,y.round=pu,y.sign=as,y.sin=Jc,y.sinh=Ta,y.sqrt=kf,y.sub=Fr,y.sum=xl,y.tan=Hi,y.tanh=Xh,y.trunc=to,void 0===c&&(c={}),c&&!0!==c.defaults)for(m=["precision","rounding","toExpNeg","toExpPos","maxE","minE","modulo","crypto"],f=0;f<m.length;)c.hasOwnProperty(d=m[f++])||(c[d]=this[d]);return y.config(c),y}(Ns);ma=new bl(ma),ju=new bl(ju);const vc=bl;function Qr(c){return"number"==typeof c}function Gn(c){return!(!c||"object"!=typeof c||"function"!=typeof c.constructor)&&(!0===c.isBigNumber&&"object"==typeof c.constructor.prototype&&!0===c.constructor.prototype.isBigNumber||"function"==typeof c.constructor.isDecimal&&!0===c.constructor.isDecimal(c))}function Ps(c){return c&&"object"==typeof c&&!0===Object.getPrototypeOf(c).isComplex||!1}function Ko(c){return c&&"object"==typeof c&&!0===Object.getPrototypeOf(c).isFraction||!1}function no(c){return c&&!0===c.constructor.prototype.isUnit||!1}function os(c){return"string"==typeof c}var _r=Array.isArray;function Cr(c){return c&&!0===c.constructor.prototype.isMatrix||!1}function Qc(c){return Array.isArray(c)||Cr(c)}function Oo(c){return c&&c.isDenseMatrix&&!0===c.constructor.prototype.isMatrix||!1}function js(c){return c&&c.isSparseMatrix&&!0===c.constructor.prototype.isMatrix||!1}function Yo(c){return c&&!0===c.constructor.prototype.isRange||!1}function Js(c){return c&&!0===c.constructor.prototype.isIndex||!1}function fo(c){return"boolean"==typeof c}function Zo(c){return c&&!0===c.constructor.prototype.isResultSet||!1}function du(c){return c&&!0===c.constructor.prototype.isHelp||!1}function mu(c){return"function"==typeof c}function qs(c){return c instanceof Date}function Kh(c){return c instanceof RegExp}function Pf(c){return!(!c||"object"!=typeof c||c.constructor!==Object||Ps(c)||Ko(c))}function xa(c){return null===c}function Du(c){return void 0===c}function ko(c){return c&&!0===c.isAccessorNode&&!0===c.constructor.prototype.isNode||!1}function hh(c){return c&&!0===c.isArrayNode&&!0===c.constructor.prototype.isNode||!1}function ba(c){return c&&!0===c.isAssignmentNode&&!0===c.constructor.prototype.isNode||!1}function fg(c){return c&&!0===c.isBlockNode&&!0===c.constructor.prototype.isNode||!1}function zl(c){return c&&!0===c.isConditionalNode&&!0===c.constructor.prototype.isNode||!1}function Ul(c){return c&&!0===c.isConstantNode&&!0===c.constructor.prototype.isNode||!1}function ph(c){return c&&!0===c.isFunctionAssignmentNode&&!0===c.constructor.prototype.isNode||!1}function Yh(c){return c&&!0===c.isFunctionNode&&!0===c.constructor.prototype.isNode||!1}function Vl(c){return c&&!0===c.isIndexNode&&!0===c.constructor.prototype.isNode||!1}function jo(c){return c&&!0===c.isNode&&!0===c.constructor.prototype.isNode||!1}function Qs(c){return c&&!0===c.isObjectNode&&!0===c.constructor.prototype.isNode||!1}function xc(c){return c&&!0===c.isOperatorNode&&!0===c.constructor.prototype.isNode||!1}function ea(c){return c&&!0===c.isParenthesisNode&&!0===c.constructor.prototype.isNode||!1}function Po(c){return c&&!0===c.isRangeNode&&!0===c.constructor.prototype.isNode||!1}function tl(c){return c&&!0===c.isSymbolNode&&!0===c.constructor.prototype.isNode||!1}function ef(c){return c&&!0===c.constructor.prototype.isChain||!1}function es(c){var f=typeof c;return"object"===f?null===c?"null":Array.isArray(c)?"Array":c instanceof Date?"Date":c instanceof RegExp?"RegExp":Gn(c)?"BigNumber":Ps(c)?"Complex":Ko(c)?"Fraction":Cr(c)?"Matrix":no(c)?"Unit":Js(c)?"Index":Yo(c)?"Range":Zo(c)?"ResultSet":jo(c)?c.type:ef(c)?"Chain":du(c)?"Help":"Object":"function"===f?"Function":f}function ir(c){var f=typeof c;if("number"===f||"string"===f||"boolean"===f||null==c)return c;if("function"==typeof c.clone)return c.clone();if(Array.isArray(c))return c.map(function(d){return ir(d)});if(c instanceof Date)return new Date(c.valueOf());if(Gn(c))return c;if(c instanceof RegExp)throw new TypeError("Cannot clone "+c);return function Ou(c,f){var d={};for(var m in c)Pr(c,m)&&(d[m]=f(c[m]));return d}(c,ir)}function Ss(c,f){for(var d in f)Pr(f,d)&&(c[d]=f[d]);return c}function Ms(c,f){var d,m,y;if(Array.isArray(c)){if(!Array.isArray(f)||c.length!==f.length)return!1;for(m=0,y=c.length;m<y;m++)if(!Ms(c[m],f[m]))return!1;return!0}if("function"==typeof c)return c===f;if(c instanceof Object){if(Array.isArray(f)||!(f instanceof Object))return!1;for(d in c)if(!(d in f)||!Ms(c[d],f[d]))return!1;for(d in f)if(!(d in c))return!1;return!0}return c===f}function Pr(c,f){return c&&Object.hasOwnProperty.call(c,f)}function ot(c,f,d,m){function y(b){var I=function wa(c,f){for(var d={},m=0;m<f.length;m++){var y=f[m],b=c[y];void 0!==b&&(d[y]=b)}return d}(b,f.map(Jo));return function wl(c,f,d){var m=f.filter(b=>!function Gl(c){return c&&"?"===c[0]}(b)).every(b=>void 0!==d[b]);if(!m){var y=f.filter(b=>void 0===d[b]);throw new Error('Cannot create function "'.concat(c,'", ')+"some dependencies are missing: ".concat(y.map(b=>'"'.concat(b,'"')).join(", "),"."))}}(c,f,b),d(I)}return y.isFactory=!0,y.fn=c,y.dependencies=f.slice().sort(),m&&(y.meta=m),y}function Jo(c){return c&&"?"===c[0]?c.slice(1):c}var Lo=ot("BigNumber",["?on","config"],c=>{var{on:f,config:d}=c,m=vc.clone({precision:d.precision,modulo:vc.EUCLID});return m.prototype=Object.create(m.prototype),m.prototype.type="BigNumber",m.prototype.isBigNumber=!0,m.prototype.toJSON=function(){return{mathjs:"BigNumber",value:this.toString()}},m.fromJSON=function(y){return new m(y.value)},f&&f("config",function(y,b){y.precision!==b.precision&&m.config({precision:y.precision})}),m},{isClass:!0}),Zr=Y(1006);function Qn(c){return"boolean"==typeof c||!!isFinite(c)&&c===Math.round(c)}Math,Math,Math,Math,Math,Math;function vs(c,f,d){var y={2:"0b",8:"0o",16:"0x"}[f],b="";if(d){if(d<1)throw new Error("size must be in greater than 0");if(!Qn(d))throw new Error("size must be an integer");if(c>2**(d-1)-1||c<-(2**(d-1)))throw new Error("Value must be in range [-2^".concat(d-1,", 2^").concat(d-1,"-1]"));if(!Qn(c))throw new Error("Value must be an integer");c<0&&(c+=2**d),b="i".concat(d)}var I="";return c<0&&(c=-c,I="-"),"".concat(I).concat(y).concat(c.toString(f)).concat(b)}function ps(c,f){if("function"==typeof f)return f(c);if(c===1/0)return"Infinity";if(c===-1/0)return"-Infinity";if(isNaN(c))return"NaN";var m,y,d="auto";if(f&&(f.notation&&(d=f.notation),Qr(f)?m=f:Qr(f.precision)&&(m=f.precision),f.wordSize&&"number"!=typeof(y=f.wordSize)))throw new Error('Option "wordSize" must be a number');switch(d){case"fixed":return function Wl(c,f){if(isNaN(c)||!isFinite(c))return String(c);var d=_l(c),m="number"==typeof f?nf(d,d.exponent+1+f):d,y=m.coefficients,b=m.exponent+1,I=b+(f||0);return y.length<I&&(y=y.concat($o(I-y.length))),b<0&&(y=$o(1-b).concat(y),b=1),b<y.length&&y.splice(b,0,0===b?"0.":"."),m.sign+y.join("")}(c,m);case"exponential":return tf(c,m);case"engineering":return function Ua(c,f){if(isNaN(c)||!isFinite(c))return String(c);var m=nf(_l(c),f),y=m.exponent,b=m.coefficients,I=y%3==0?y:y<0?y-3-y%3:y-y%3;if(Qr(f))for(;f>b.length||y-I+1>b.length;)b.push(0);else for(var C=Math.abs(y-I)-(b.length-1),A=0;A<C;A++)b.push(0);for(var T=Math.abs(y-I),E=1;T>0;)E++,T--;var S=b.slice(E).join(""),R=Qr(f)&&S.length||S.match(/[1-9]/)?"."+S:"",P=b.slice(0,E).join("")+R+"e"+(y>=0?"+":"")+I.toString();return m.sign+P}(c,m);case"bin":return vs(c,2,y);case"oct":return vs(c,8,y);case"hex":return vs(c,16,y);case"auto":return function Hs(c,f,d){if(isNaN(c)||!isFinite(c))return String(c);var m=d&&void 0!==d.lowerExp?d.lowerExp:-3,y=d&&void 0!==d.upperExp?d.upperExp:5,b=_l(c),I=f?nf(b,f):b;if(I.exponent<m||I.exponent>=y)return tf(c,f);var C=I.coefficients,A=I.exponent;C.length<f&&(C=C.concat($o(f-C.length))),C=C.concat($o(A-C.length+1+(C.length<f?f-C.length:0)));var T=A>0?A:0;return T<(C=$o(-A).concat(C)).length-1&&C.splice(T+1,0,"."),I.sign+C.join("")}(c,m,f&&f).replace(/((\.\d*?)(0+))($|e)/,function(){var b=arguments[2],I=arguments[4];return"."!==b?b+I:I});default:throw new Error('Unknown notation "'+d+'". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.')}}function _l(c){var f=String(c).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);if(!f)throw new SyntaxError("Invalid number "+c);var d=f[1],m=f[2],y=parseFloat(f[4]||"0"),b=m.indexOf(".");y+=-1!==b?b-1:m.length-1;var I=m.replace(".","").replace(/^0*/,function(C){return y-=C.length,""}).replace(/0*$/,"").split("").map(function(C){return parseInt(C)});return 0===I.length&&(I.push(0),y++),{sign:d,coefficients:I,exponent:y}}function tf(c,f){if(isNaN(c)||!isFinite(c))return String(c);var d=_l(c),m=f?nf(d,f):d,y=m.coefficients,b=m.exponent;y.length<f&&(y=y.concat($o(f-y.length)));var I=y.shift();return m.sign+I+(y.length>0?"."+y.join(""):"")+"e"+(b>=0?"+":"")+b}function nf(c,f){for(var d={sign:c.sign,coefficients:c.coefficients,exponent:c.exponent},m=d.coefficients;f<=0;)m.unshift(0),d.exponent++,f++;if(m.length>f&&m.splice(f,m.length-f)[0]>=5){var b=f-1;for(m[b]++;10===m[b];)m.pop(),0===b&&(m.unshift(0),d.exponent++,b++),m[--b]++}return d}function $o(c){for(var f=[],d=0;d<c;d++)f.push(0);return f}var Hl=Number.EPSILON||2220446049250313e-31;function Bo(c,f,d){if(null==d)return c===f;if(c===f)return!0;if(isNaN(c)||isNaN(f))return!1;if(isFinite(c)&&isFinite(f)){var m=Math.abs(c-f);return m<Hl||m<=Math.max(Math.abs(c),Math.abs(f))*d}return!1}Math,Math,Math,Math,Math;Math;var Kl=ot("Complex",[],()=>(Zr.prototype.type="Complex",Zr.prototype.isComplex=!0,Zr.prototype.toJSON=function(){return{mathjs:"Complex",re:this.re,im:this.im}},Zr.prototype.toPolar=function(){return{r:this.abs(),phi:this.arg()}},Zr.prototype.format=function(c){var d=this.im,m=this.re,y=ps(this.re,c),b=ps(this.im,c),I=Qr(c)?c:c?c.precision:null;if(null!==I){var C=Math.pow(10,-I);Math.abs(m/d)<C&&(m=0),Math.abs(d/m)<C&&(d=0)}return 0===d?y:0===m?1===d?"i":-1===d?"-i":b+"i":d<0?-1===d?y+" - i":y+" - "+b.substring(1)+"i":1===d?y+" + i":y+" + "+b+"i"},Zr.fromPolar=function(c){switch(arguments.length){case 1:var f=arguments[0];if("object"==typeof f)return Zr(f);throw new TypeError("Input has to be an object with r and phi keys.");case 2:var d=arguments[0],m=arguments[1];if(Qr(d)){if(no(m)&&m.hasBase("ANGLE")&&(m=m.toNumber("rad")),Qr(m))return new Zr({r:d,phi:m});throw new TypeError("Phi is not a number nor an angle unit.")}throw new TypeError("Radius r is not a number.");default:throw new SyntaxError("Wrong number of arguments in function fromPolar")}},Zr.prototype.valueOf=Zr.prototype.toString,Zr.fromJSON=function(c){return new Zr(c)},Zr.compare=function(c,f){return c.re>f.re?1:c.re<f.re?-1:c.im>f.im?1:c.im<f.im?-1:0},Zr),{isClass:!0});function sl(c){var f=0,d=1,m=Object.create(null),y=Object.create(null),b=0,I=function(A){var T=y[A];if(T&&(delete m[T],delete y[A],--f,d===T)){if(!f)return b=0,void(d=1);for(;!hasOwnProperty.call(m,++d););}};return c=Math.abs(c),{hit:function(A){var T=y[A],E=++b;if(m[E]=A,y[A]=E,!T)return++f<=c?void 0:(I(A=m[d]),A);if(delete m[T],d===T)for(;!hasOwnProperty.call(m,++d););},delete:I,clear:function(){f=b=0,d=1,m=Object.create(null),y=Object.create(null)}}}function Sl(c){var{hasher:f,limit:d}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return d=d??Number.POSITIVE_INFINITY,f=f??JSON.stringify,function m(){"object"!=typeof m.cache&&(m.cache={values:new Map,lru:sl(d||Number.POSITIVE_INFINITY)});for(var y=[],b=0;b<arguments.length;b++)y[b]=arguments[b];var I=f(y);if(m.cache.values.has(I))return m.cache.lru.hit(I),m.cache.values.get(I);var C=c.apply(c,y);return m.cache.values.set(I,C),m.cache.values.delete(m.cache.lru.hit(I)),C}}Sl(function(c){return new c(1).exp()},{hasher:rf}),Sl(function(c){return new c(1).plus(new c(5).sqrt()).div(2)},{hasher:rf});var Es=Sl(function(c){return c.acos(-1)},{hasher:rf});function rf(c){return c[0].precision}function Pp(c,f){return ot(c,["config","BigNumber"],m=>{var{config:y,BigNumber:b}=m;return"BigNumber"===y.number?new b(f):f})}Sl(function(c){return Es(c).times(2)},{hasher:rf}),Math,Math,Math,Pp("fineStructure",.0072973525693),Pp("weakMixingAngle",.2229),Pp("efimovFactor",22.7),Pp("sackurTetrode",-1.16487052358);var gh=Y(4613),vw=ot("Fraction",[],()=>(gh.prototype.type="Fraction",gh.prototype.isFraction=!0,gh.prototype.toJSON=function(){return{mathjs:"Fraction",n:this.s*this.n,d:this.d}},gh.fromJSON=function(c){return new gh(c)},gh),{isClass:!0}),Wd=ot("Matrix",[],()=>{function c(){if(!(this instanceof c))throw new SyntaxError("Constructor must be called with the new operator")}return c.prototype.type="Matrix",c.prototype.isMatrix=!0,c.prototype.storage=function(){throw new Error("Cannot invoke storage on a Matrix interface")},c.prototype.datatype=function(){throw new Error("Cannot invoke datatype on a Matrix interface")},c.prototype.create=function(f,d){throw new Error("Cannot invoke create on a Matrix interface")},c.prototype.subset=function(f,d,m){throw new Error("Cannot invoke subset on a Matrix interface")},c.prototype.get=function(f){throw new Error("Cannot invoke get on a Matrix interface")},c.prototype.set=function(f,d,m){throw new Error("Cannot invoke set on a Matrix interface")},c.prototype.resize=function(f,d){throw new Error("Cannot invoke resize on a Matrix interface")},c.prototype.reshape=function(f,d){throw new Error("Cannot invoke reshape on a Matrix interface")},c.prototype.clone=function(){throw new Error("Cannot invoke clone on a Matrix interface")},c.prototype.size=function(){throw new Error("Cannot invoke size on a Matrix interface")},c.prototype.map=function(f,d){throw new Error("Cannot invoke map on a Matrix interface")},c.prototype.forEach=function(f){throw new Error("Cannot invoke forEach on a Matrix interface")},c.prototype[Symbol.iterator]=function(){throw new Error("Cannot iterate a Matrix interface")},c.prototype.toArray=function(){throw new Error("Cannot invoke toArray on a Matrix interface")},c.prototype.valueOf=function(){throw new Error("Cannot invoke valueOf on a Matrix interface")},c.prototype.format=function(f){throw new Error("Cannot invoke format on a Matrix interface")},c.prototype.toString=function(){throw new Error("Cannot invoke toString on a Matrix interface")},c},{isClass:!0});function Hd(c,f,d){var y=new(0,c.constructor)(2),b="";if(d){if(d<1)throw new Error("size must be in greater than 0");if(!Qn(d))throw new Error("size must be an integer");if(c.greaterThan(y.pow(d-1).sub(1))||c.lessThan(y.pow(d-1).mul(-1)))throw new Error("Value must be in range [-2^".concat(d-1,", 2^").concat(d-1,"-1]"));if(!c.isInteger())throw new Error("Value must be an integer");c.lessThan(0)&&(c=c.add(y.pow(d))),b="i".concat(d)}switch(f){case 2:return"".concat(c.toBinary()).concat(b);case 8:return"".concat(c.toOctal()).concat(b);case 16:return"".concat(c.toHexadecimal()).concat(b);default:throw new Error("Base ".concat(f," not supported "))}}function Ng(c,f){return void 0!==f?c.toExponential(f-1):c.toExponential()}function ii(c,f){var d=function bw(c,f){return"number"==typeof c?ps(c,f):Gn(c)?function _g(c,f){if("function"==typeof f)return f(c);if(!c.isFinite())return c.isNaN()?"NaN":c.gt(0)?"Infinity":"-Infinity";var m,y,d="auto";if(void 0!==f&&(f.notation&&(d=f.notation),"number"==typeof f?m=f:f.precision&&(m=f.precision),f.wordSize&&"number"!=typeof(y=f.wordSize)))throw new Error('Option "wordSize" must be a number');switch(d){case"fixed":return function nv(c,f){return c.toFixed(f)}(c,m);case"exponential":return Ng(c,m);case"engineering":return function tv(c,f){var d=c.e,m=d%3==0?d:d<0?d-3-d%3:d-d%3,y=c.mul(Math.pow(10,-m)),b=y.toPrecision(f);return-1!==b.indexOf("e")&&(b=y.toString()),b+"e"+(d>=0?"+":"")+m.toString()}(c,m);case"bin":return Hd(c,2,y);case"oct":return Hd(c,8,y);case"hex":return Hd(c,16,y);case"auto":var b=f&&void 0!==f.lowerExp?f.lowerExp:-3,I=f&&void 0!==f.upperExp?f.upperExp:5;if(c.isZero())return"0";var A=c.toSignificantDigits(m),T=A.e;return(T>=b&&T<I?A.toFixed():Ng(c,m)).replace(/((\.\d*?)(0+))($|e)/,function(){var E=arguments[2],S=arguments[4];return"."!==E?E+S:S});default:throw new Error('Unknown notation "'+d+'". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.')}}(c,f):function ww(c){return c&&"object"==typeof c&&"number"==typeof c.s&&"number"==typeof c.n&&"number"==typeof c.d||!1}(c)?f&&"decimal"===f.fraction?c.toString():c.s*c.n+"/"+c.d:Array.isArray(c)?Xd(c,f):os(c)?'"'+c+'"':"function"==typeof c?c.syntax?String(c.syntax):"function":c&&"object"==typeof c?"function"==typeof c.format?c.format(f):c&&c.toString(f)!=={}.toString()?c.toString(f):"{"+Object.keys(c).map(m=>'"'+m+'": '+ii(c[m],f)).join(", ")+"}":String(c)}(c,f);return f&&"object"==typeof f&&"truncate"in f&&d.length>f.truncate?d.substring(0,f.truncate-3)+"...":d}function Xd(c,f){if(Array.isArray(c)){for(var d="[",m=c.length,y=0;y<m;y++)0!==y&&(d+=", "),d+=Xd(c[y],f);return d+"]"}return ii(c,f)}function Hr(c,f,d){if(!(this instanceof Hr))throw new SyntaxError("Constructor must be called with the new operator");this.actual=c,this.expected=f,this.relation=d,this.message="Dimension mismatch ("+(Array.isArray(c)?"["+c.join(", ")+"]":c)+" "+(this.relation||"!=")+" "+(Array.isArray(f)?"["+f.join(", ")+"]":f)+")",this.stack=(new Error).stack}function Yl(c,f,d){if(!(this instanceof Yl))throw new SyntaxError("Constructor must be called with the new operator");this.index=c,arguments.length<3?(this.min=0,this.max=f):(this.min=f,this.max=d),this.message=void 0!==this.min&&this.index<this.min?"Index out of range ("+this.index+" < "+this.min+")":void 0!==this.max&&this.index>=this.max?"Index out of range ("+this.index+" > "+(this.max-1)+")":"Index out of range ("+this.index+")",this.stack=(new Error).stack}function ei(c){for(var f=[];Array.isArray(c);)f.push(c.length),c=c[0];return f}function Fp(c,f,d){var m,y=c.length;if(y!==f[d])throw new Hr(y,f[d]);if(d<f.length-1){var b=d+1;for(m=0;m<y;m++){if(!Array.isArray(c[m]))throw new Hr(f.length-1,f.length,"<");Fp(c[m],f,b)}}else for(m=0;m<y;m++)if(Array.isArray(c[m]))throw new Hr(f.length+1,f.length,">")}function Sg(c,f){if(0===f.length){if(Array.isArray(c))throw new Hr(c.length,0)}else Fp(c,f,0)}function Is(c,f){if(!Qr(c)||!Qn(c))throw new TypeError("Index must be an integer (value: "+c+")");if(c<0||"number"==typeof f&&c>=f)throw new Yl(c,f)}function Lp(c,f,d){if(!Array.isArray(c)||!Array.isArray(f))throw new TypeError("Array expected");if(0===f.length)throw new Error("Resizing to scalar is not supported");return f.forEach(function(y){if(!Qr(y)||!Qn(y)||y<0)throw new TypeError("Invalid size, must contain positive integers (size: "+ii(f)+")")}),rv(c,f,0,void 0!==d?d:0),c}function rv(c,f,d,m){var y,b,C=f[d],A=Math.min(c.length,C);if(c.length=C,d<f.length-1){var T=d+1;for(y=0;y<A;y++)b=c[y],Array.isArray(b)||(c[y]=b=[b]),rv(b,f,T,m);for(y=A;y<C;y++)c[y]=b=[],rv(b,f,T,m)}else{for(y=0;y<A;y++)for(;Array.isArray(c[y]);)c[y]=c[y][0];for(y=A;y<C;y++)c[y]=m}}function Xs(c,f){var d=Nw(c),m=c.slice(),b=c.indexOf(-1);if(c.indexOf(-1,b+1)>=0)throw new Error("More than one wildcard in sizes");if(b>=0){if(f%d!=0)throw new Error("Could not replace wildcard, since "+f+" is no multiple of "+-d);m[b]=-f/d}return m}function Nw(c){return c.reduce((f,d)=>f*d,1)}function Yd(c,f,d,m){var y=m||ei(c);if(d)for(var b=0;b<d;b++)c=[c],y.unshift(1);for(c=Eg(c,f,0);y.length<f;)y.push(1);return c}function Eg(c,f,d){var m,y;if(Array.isArray(c)){var b=d+1;for(m=0,y=c.length;m<y;m++)c[m]=Eg(c[m],f,b)}else for(var I=d;I<f;I++)c=[c];return c}function ti(c){if(!Array.isArray(c))return c;var f=[];return c.forEach(function d(m){Array.isArray(m)?m.forEach(d):f.push(m)}),f}function jd(c,f){for(var d,m=0,y=0;y<c.length;y++){var b=c[y],I=Array.isArray(b);if(0===y&&I&&(m=b.length),I&&b.length!==m)return;var C=I?jd(b,f):f(b);if(void 0===d)d=C;else if(d!==C)return"mixed"}return d}(Hr.prototype=new RangeError).constructor=RangeError,Hr.prototype.name="DimensionError",Hr.prototype.isDimensionError=!0,(Yl.prototype=new RangeError).constructor=RangeError,Yl.prototype.name="IndexError",Yl.prototype.isIndexError=!0;var tA=ot("DenseMatrix",["Matrix"],c=>{var{Matrix:f}=c;function d(E,S){if(!(this instanceof d))throw new SyntaxError("Constructor must be called with the new operator");if(S&&!os(S))throw new Error("Invalid datatype: "+S);if(Cr(E))"DenseMatrix"===E.type?(this._data=ir(E._data),this._size=ir(E._size),this._datatype=S||E._datatype):(this._data=E.toArray(),this._size=E.size(),this._datatype=S||E._datatype);else if(E&&_r(E.data)&&_r(E.size))this._data=E.data,this._size=E.size,Sg(this._data,this._size),this._datatype=S||E.datatype;else if(_r(E))this._data=T(E),this._size=ei(this._data),Sg(this._data,this._size),this._datatype=S;else{if(E)throw new TypeError("Unsupported type of data ("+es(E)+")");this._data=[],this._size=[0],this._datatype=S}}function y(E,S,R,P){var F=P===R-1,B=S.dimension(P);return F?B.map(function(J){return Is(J,E.length),E[J]}).valueOf():B.map(function(J){return Is(J,E.length),y(E[J],S,R,P+1)}).valueOf()}function I(E,S,R,P,F){var B=F===P-1;S.dimension(F).forEach(B?function(j,oe){Is(j),E[j]=R[oe[0]]}:function(j,oe){Is(j),I(E[j],S,R[oe[0]],P,F+1)})}function C(E,S,R){if(0===S.length){for(var P=E._data;_r(P);)P=P[0];return P}return E._size=S.slice(0),E._data=Lp(E._data,E._size,R),E}function A(E,S,R){for(var P=E._size.slice(0),F=!1;P.length<S.length;)P.push(0),F=!0;for(var B=0,J=S.length;B<J;B++)S[B]>P[B]&&(P[B]=S[B],F=!0);F&&C(E,P,R)}function T(E){for(var S=0,R=E.length;S<R;S++){var P=E[S];_r(P)?E[S]=T(P):P&&!0===P.isMatrix&&(E[S]=T(P.valueOf()))}return E}return(d.prototype=new f).createDenseMatrix=function(E,S){return new d(E,S)},d.prototype.type="DenseMatrix",d.prototype.isDenseMatrix=!0,d.prototype.getDataType=function(){return jd(this._data,es)},d.prototype.storage=function(){return"dense"},d.prototype.datatype=function(){return this._datatype},d.prototype.create=function(E,S){return new d(E,S)},d.prototype.subset=function(E,S,R){switch(arguments.length){case 1:return function m(E,S){if(!Js(S))throw new TypeError("Invalid index");if(S.isScalar())return E.get(S.min());var P=S.size();if(P.length!==E._size.length)throw new Hr(P.length,E._size.length);for(var F=S.min(),B=S.max(),J=0,j=E._size.length;J<j;J++)Is(F[J],E._size[J]),Is(B[J],E._size[J]);return new d(y(E._data,S,P.length,0),E._datatype)}(this,E);case 2:case 3:return function b(E,S,R,P){if(!S||!0!==S.isIndex)throw new TypeError("Invalid index");var J,F=S.size(),B=S.isScalar();if(Cr(R)?(J=R.size(),R=R.valueOf()):J=ei(R),B){if(0!==J.length)throw new TypeError("Scalar expected");E.set(S.min(),R,P)}else{if(F.length<E._size.length)throw new Hr(F.length,E._size.length,"<");if(J.length<F.length){for(var j=0,oe=0;1===F[j]&&1===J[j];)j++;for(;1===F[j];)oe++,j++;R=Yd(R,F.length,oe,J)}if(!Ms(F,J))throw new Hr(F,J,">");A(E,S.max().map(function(X){return X+1}),P),I(E._data,S,R,F.length,0)}return E}(this,E,S,R);default:throw new SyntaxError("Wrong number of arguments")}},d.prototype.get=function(E){if(!_r(E))throw new TypeError("Array expected");if(E.length!==this._size.length)throw new Hr(E.length,this._size.length);for(var S=0;S<E.length;S++)Is(E[S],this._size[S]);for(var R=this._data,P=0,F=E.length;P<F;P++){var B=E[P];Is(B,R.length),R=R[B]}return R},d.prototype.set=function(E,S,R){if(!_r(E))throw new TypeError("Array expected");if(E.length<this._size.length)throw new Hr(E.length,this._size.length,"<");var P,F,B;A(this,E.map(function(oe){return oe+1}),R);var j=this._data;for(P=0,F=E.length-1;P<F;P++)Is(B=E[P],j.length),j=j[B];return Is(B=E[E.length-1],j.length),j[B]=S,this},d.prototype.resize=function(E,S,R){if(!Qc(E))throw new TypeError("Array or Matrix expected");var P=E.valueOf().map(B=>Array.isArray(B)&&1===B.length?B[0]:B);return C(R?this.clone():this,P,S)},d.prototype.reshape=function(E,S){var R=S?this.clone():this;R._data=function _w(c,f){var d=ti(c),m=d.length;if(!Array.isArray(c)||!Array.isArray(f))throw new TypeError("Array expected");if(0===f.length)throw new Hr(0,m,"!=");var y=Nw(f=Xs(f,m));if(m!==y)throw new Hr(y,m,"!=");try{return function eA(c,f){for(var m,d=c,y=f.length-1;y>0;y--){var b=f[y];m=[];for(var I=d.length/b,C=0;C<I;C++)m.push(d.slice(C*b,(C+1)*b));d=m}return d}(d,f)}catch(b){throw b instanceof Hr?new Hr(y,m,"!="):b}}(R._data,E);var P=R._size.reduce((F,B)=>F*B);return R._size=Xs(E,P),R},d.prototype.clone=function(){return new d({data:ir(this._data),size:ir(this._size),datatype:this._datatype})},d.prototype.size=function(){return this._size.slice(0)},d.prototype.map=function(E){var S=this,P=function B(J,j){return _r(J)?J.map(function(oe,G){return B(oe,j.concat(G))}):E(J,j,S)}(this._data,[]);return new d(P,void 0!==this._datatype?jd(P,es):void 0)},d.prototype.forEach=function(E){var S=this;!function P(F,B){_r(F)?F.forEach(function(J,j){P(J,B.concat(j))}):E(F,B,S)}(this._data,[])},d.prototype[Symbol.iterator]=function*(){yield*function*S(R,P){if(_r(R))for(var F=0;F<R.length;F++)yield*S(R[F],P.concat(F));else yield{value:R,index:P}}(this._data,[])},d.prototype.rows=function(){var E=[];if(2!==this.size().length)throw new TypeError("Rows can only be returned for a 2D matrix.");var R=this._data;for(var P of R)E.push(new d([P],this._datatype));return E},d.prototype.columns=function(){var E=this,S=[],R=this.size();if(2!==R.length)throw new TypeError("Rows can only be returned for a 2D matrix.");for(var P=this._data,F=function(j){var oe=P.map(G=>[G[j]]);S.push(new d(oe,E._datatype))},B=0;B<R[1];B++)F(B);return S},d.prototype.toArray=function(){return ir(this._data)},d.prototype.valueOf=function(){return this._data},d.prototype.format=function(E){return ii(this._data,E)},d.prototype.toString=function(){return ii(this._data)},d.prototype.toJSON=function(){return{mathjs:"DenseMatrix",data:this._data,size:this._size,datatype:this._datatype}},d.prototype.diagonal=function(E){if(E){if(Gn(E)&&(E=E.toNumber()),!Qr(E)||!Qn(E))throw new TypeError("The parameter k must be an integer number")}else E=0;for(var S=E>0?E:0,R=E<0?-E:0,B=Math.min(this._size[0]-R,this._size[1]-S),J=[],j=0;j<B;j++)J[j]=this._data[j+R][j+S];return new d({data:J,size:[B],datatype:this._datatype})},d.diagonal=function(E,S,R,P){if(!_r(E))throw new TypeError("Array expected, size parameter");if(2!==E.length)throw new Error("Only two dimensions matrix are supported");if(E=E.map(function(be){if(Gn(be)&&(be=be.toNumber()),!Qr(be)||!Qn(be)||be<1)throw new Error("Size values must be positive integers");return be}),R){if(Gn(R)&&(R=R.toNumber()),!Qr(R)||!Qn(R))throw new TypeError("The parameter k must be an integer number")}else R=0;var G,F=R>0?R:0,B=R<0?-R:0,J=E[0],j=E[1],oe=Math.min(J-B,j-F);if(_r(S)){if(S.length!==oe)throw new Error("Invalid value array length");G=function(Ie){return S[Ie]}}else if(Cr(S)){var ee=S.size();if(1!==ee.length||ee[0]!==oe)throw new Error("Invalid matrix length");G=function(Ie){return S.get([Ie])}}else G=function(){return S};P||(P=Gn(G(0))?G(0).mul(0):0);var ne=[];if(E.length>0){ne=Lp(ne,E,P);for(var X=0;X<oe;X++)ne[X+B][X+F]=G(X)}return new d({data:ne,size:[J,j]})},d.fromJSON=function(E){return new d(E)},d.prototype.swapRows=function(E,S){if(!(Qr(E)&&Qn(E)&&Qr(S)&&Qn(S)))throw new Error("Row index must be positive integers");if(2!==this._size.length)throw new Error("Only two dimensional matrix is supported");return Is(E,this._size[0]),Is(S,this._size[0]),d._swapRows(E,S,this._data),this},d._swapRows=function(E,S,R){var P=R[E];R[E]=R[S],R[S]=P},d},{isClass:!0}),sA=Y(1977);function av(c,f){if(Cw(c)&&Qh(c,f))return c[f];throw"function"==typeof c[f]&&function Iw(c,f){return!(null==c||"function"!=typeof c[f]||Pr(c,f)&&Object.getPrototypeOf&&f in Object.getPrototypeOf(c)||!Pr(yu,f)&&(f in Object.prototype||f in Function.prototype))}(c,f)?new Error('Cannot access method "'+f+'" as a property'):new Error('No access to property "'+f+'"')}function Qh(c,f){return!(!c||"object"!=typeof c||!Pr($p,f)&&(f in Object.prototype||f in Function.prototype))}function Cw(c){return"object"==typeof c&&c&&c.constructor===Object}var $p={length:!0,name:!0},yu={toString:!0,valueOf:!0,toLocaleString:!0};class Bp{constructor(f){this.wrappedObject=f}keys(){return Object.keys(this.wrappedObject)}get(f){return av(this.wrappedObject,f)}set(f,d){return function ov(c,f,d){if(Cw(c)&&Qh(c,f))return c[f]=d,d;throw new Error('No access to property "'+f+'"')}(this.wrappedObject,f,d),this}has(f){return function oA(c,f){return f in c}(this.wrappedObject,f)}}function Jd(c){return!!c&&(c instanceof Map||c instanceof Bp||"function"==typeof c.set&&"function"==typeof c.get&&"function"==typeof c.keys&&"function"==typeof c.has)}var Cg=function(){return Cg=sA.create,sA},uv=ot("typed",["?BigNumber","?Complex","?DenseMatrix","?Fraction"],function(f){var{BigNumber:d,Complex:m,DenseMatrix:y,Fraction:b}=f,I=Cg();return I.types=[{name:"number",test:Qr},{name:"Complex",test:Ps},{name:"BigNumber",test:Gn},{name:"Fraction",test:Ko},{name:"Unit",test:no},{name:"string",test:os},{name:"Chain",test:ef},{name:"Array",test:_r},{name:"Matrix",test:Cr},{name:"DenseMatrix",test:Oo},{name:"SparseMatrix",test:js},{name:"Range",test:Yo},{name:"Index",test:Js},{name:"boolean",test:fo},{name:"ResultSet",test:Zo},{name:"Help",test:du},{name:"function",test:mu},{name:"Date",test:qs},{name:"RegExp",test:Kh},{name:"null",test:xa},{name:"undefined",test:Du},{name:"AccessorNode",test:ko},{name:"ArrayNode",test:hh},{name:"AssignmentNode",test:ba},{name:"BlockNode",test:fg},{name:"ConditionalNode",test:zl},{name:"ConstantNode",test:Ul},{name:"FunctionNode",test:Yh},{name:"FunctionAssignmentNode",test:ph},{name:"IndexNode",test:Vl},{name:"Node",test:jo},{name:"ObjectNode",test:Qs},{name:"OperatorNode",test:xc},{name:"ParenthesisNode",test:ea},{name:"RangeNode",test:Po},{name:"SymbolNode",test:tl},{name:"Map",test:Jd},{name:"Object",test:Pf}],I.conversions=[{from:"number",to:"BigNumber",convert:function(A){if(d||lv(A),function mh(c){return c.toExponential().replace(/e.*$/,"").replace(/^0\.?0*|\./,"").length}(A)>15)throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: "+A+"). Use function bignumber(x) to convert to BigNumber.");return new d(A)}},{from:"number",to:"Complex",convert:function(A){return m||zp(A),new m(A,0)}},{from:"number",to:"string",convert:function(A){return A+""}},{from:"BigNumber",to:"Complex",convert:function(A){return m||zp(A),new m(A.toNumber(),0)}},{from:"Fraction",to:"BigNumber",convert:function(A){throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.")}},{from:"Fraction",to:"Complex",convert:function(A){return m||zp(A),new m(A.valueOf(),0)}},{from:"number",to:"Fraction",convert:function(A){b||cv(A);var T=new b(A);if(T.valueOf()!==A)throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: "+A+"). Use function fraction(x) to convert to Fraction.");return T}},{from:"string",to:"number",convert:function(A){var T=Number(A);if(isNaN(T))throw new Error('Cannot convert "'+A+'" to a number');return T}},{from:"string",to:"BigNumber",convert:function(A){d||lv(A);try{return new d(A)}catch{throw new Error('Cannot convert "'+A+'" to BigNumber')}}},{from:"string",to:"Fraction",convert:function(A){b||cv(A);try{return new b(A)}catch{throw new Error('Cannot convert "'+A+'" to Fraction')}}},{from:"string",to:"Complex",convert:function(A){m||zp(A);try{return new m(A)}catch{throw new Error('Cannot convert "'+A+'" to Complex')}}},{from:"boolean",to:"number",convert:function(A){return+A}},{from:"boolean",to:"BigNumber",convert:function(A){return d||lv(A),new d(+A)}},{from:"boolean",to:"Fraction",convert:function(A){return b||cv(A),new b(+A)}},{from:"boolean",to:"string",convert:function(A){return String(A)}},{from:"Array",to:"Matrix",convert:function(A){return y||function cA(){throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided")}(),new y(A)}},{from:"Matrix",to:"Array",convert:function(A){return A.valueOf()}}],I});function lv(c){throw new Error("Cannot convert value ".concat(c," into a BigNumber: no class 'BigNumber' provided"))}function zp(c){throw new Error("Cannot convert value ".concat(c," into a Complex number: no class 'Complex' provided"))}function cv(c){throw new Error("Cannot convert value ".concat(c," into a Fraction, no class 'Fraction' provided."))}function Jn(c,f,d){return c&&"function"==typeof c.map?c.map(function(m){return Jn(m,f,d)}):f(c)}var _n="number",Gf="number, number";function Ic(c){return Math.abs(c)}function Tg(c,f){return c+f}function Rw(c,f){return c*f}function Dw(c){return-c}Ic.signature=_n,Tg.signature=Gf,Rw.signature=Gf,Dw.signature=_n;var _t=ot("abs",["typed"],c=>{var{typed:f}=c;return f("abs",{number:Ic,Complex:function(m){return m.abs()},BigNumber:function(m){return m.abs()},Fraction:function(m){return m.abs()},"Array | Matrix":function(m){return Jn(m,this,!0)},Unit:function(m){return m.abs()}})});var Fg="addScalar",wA=ot(Fg,["typed"],c=>{var{typed:f}=c;return f(Fg,{"number, number":Tg,"Complex, Complex":function(m,y){return m.add(y)},"BigNumber, BigNumber":function(m,y){return m.plus(y)},"Fraction, Fraction":function(m,y){return m.add(y)},"Unit, Unit":function(m,y){if(null==m.value)throw new Error("Parameter x contains a unit with undefined value");if(null==y.value)throw new Error("Parameter y contains a unit with undefined value");if(!m.equalBase(y))throw new Error("Units do not match");var b=m.clone();return b.value=this(b.value,y.value),b.fixPrefix=!1,b}})}),Jw=ot("bignumber",["typed","BigNumber"],c=>{var{typed:f,BigNumber:d}=c;return f("bignumber",{"":function(){return new d(0)},number:function(y){return new d(y+"")},string:function(y){var b=y.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);if(b){var I=b[2],C=d(b[1]),A=new d(2).pow(Number(I));if(C.gt(A.sub(1)))throw new SyntaxError('String "'.concat(y,'" is out of range'));var T=new d(2).pow(Number(I)-1);return C.gte(T)?C.sub(A):C}return new d(y)},BigNumber:function(y){return y},Fraction:function(y){return new d(y.n).div(y.d).times(y.s)},null:function(y){return new d(0)},"Array | Matrix":function(y){return Jn(y,this)}})});var l_=ot("conj",["typed"],c=>{var{typed:f}=c;return f("conj",{number:function(m){return m},BigNumber:function(m){return m},Complex:function(m){return m.conjugate()},"Array | Matrix":function(m){return Jn(m,this)}})});function ff(c,f,d){if(null==d)return c.eq(f);if(c.eq(f))return!0;if(c.isNaN()||f.isNaN())return!1;if(c.isFinite()&&f.isFinite()){var m=c.minus(f).abs();if(m.isZero())return!0;var y=c.constructor.max(c.abs(),f.abs());return m.lte(y.times(d))}return!1}var am="equalScalar",d_=ot(am,["typed","config"],c=>{var{typed:f,config:d}=c;return f(am,{"boolean, boolean":function(y,b){return y===b},"number, number":function(y,b){return Bo(y,b,d.epsilon)},"BigNumber, BigNumber":function(y,b){return y.eq(b)||ff(y,b,d.epsilon)},"Fraction, Fraction":function(y,b){return y.equals(b)},"Complex, Complex":function(y,b){return function h_(c,f,d){return Bo(c.re,f.re,d)&&Bo(c.im,f.im,d)}(y,b,d.epsilon)},"Unit, Unit":function(y,b){if(!y.equalBase(b))throw new Error("Cannot compare units with different base");return this(y.value,b.value)}})});ot(am,["typed","config"],c=>{var{typed:f,config:d}=c;return f(am,{"number, number":function(y,b){return Bo(y,b,d.epsilon)}})}),Math.pow(2,53),ot("hex",["typed","format"],c=>{var{typed:f,format:d}=c;return f("hex",{"number | BigNumber":function(y){return d(y,{notation:"hex"})},"number | BigNumber, number":function(y,b){return d(y,{notation:"hex",wordSize:b})}})});var um="number";function N_(c){return 0===c}function Vg(c){return Number.isNaN(c)}N_.signature=um,Vg.signature=um;var _h=ot("isZero",["typed"],c=>{var{typed:f}=c;return f("isZero",{number:N_,BigNumber:function(m){return m.isZero()},Complex:function(m){return 0===m.re&&0===m.im},Fraction:function(m){return 1===m.d&&0===m.n},Unit:function(m){return this(m.value)},"Array | Matrix":function(m){return Jn(m,this)}})});var Tc=ot("multiplyScalar",["typed"],c=>{var{typed:f}=c;return f("multiplyScalar",{"number, number":Rw,"Complex, Complex":function(m,y){return m.mul(y)},"BigNumber, BigNumber":function(m,y){return m.times(y)},"Fraction, Fraction":function(m,y){return m.mul(y)},"number | Fraction | BigNumber | Complex, Unit":function(m,y){var b=y.clone();return b.value=null===b.value?b._normalize(m):this(b.value,m),b},"Unit, number | Fraction | BigNumber | Complex":function(m,y){var b=m.clone();return b.value=null===b.value?b._normalize(y):this(b.value,y),b},"Unit, Unit":function(m,y){return m.multiply(y)}})});var cT=ot("number",["typed"],c=>{var{typed:f}=c,d=f("number",{"":function(){return 0},number:function(y){return y},string:function(y){if("NaN"===y)return NaN;var b=function lT(c){var f=c.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);return f?{input:c,radix:{"0b":2,"0o":8,"0x":16}[f[1]],integerPart:f[2],fractionalPart:f[3]}:null}(y);if(b)return function Yv(c){for(var f=parseInt(c.integerPart,c.radix),d=0,m=0;m<c.fractionalPart.length;m++)d+=parseInt(c.fractionalPart[m],c.radix)/Math.pow(c.radix,m+1);var b=f+d;if(isNaN(b))throw new SyntaxError('String "'+c.input+'" is no valid number');return b}(b);var I=0,C=y.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);C&&(I=Number(C[2]),y=C[1]);var A=Number(y);if(isNaN(A))throw new SyntaxError('String "'+y+'" is no valid number');if(C){if(A>2**I-1)throw new SyntaxError('String "'.concat(y,'" is out of range'));A>=2**(I-1)&&(A-=2**I)}return A},BigNumber:function(y){return y.toNumber()},Fraction:function(y){return y.valueOf()},Unit:function(y){throw new Error("Second argument with valueless unit expected")},null:function(y){return 0},"Unit, string | Unit":function(y,b){return y.toNumber(b)},"Array | Matrix":function(y){return Jn(y,this)}});return d.fromJSON=function(m){return parseFloat(m.value)},d});ot("oct",["typed","format"],c=>{var{typed:f,format:d}=c;return f("oct",{"number | BigNumber":function(y){return d(y,{notation:"oct"})},"number | BigNumber, number":function(y,b){return d(y,{notation:"oct",wordSize:b})}})}),Y(340);Date.now();var P_=ot("SparseMatrix",["typed","equalScalar","Matrix"],c=>{var{typed:f,equalScalar:d,Matrix:m}=c;function y(B,J){if(!(this instanceof y))throw new SyntaxError("Constructor must be called with the new operator");if(J&&!os(J))throw new Error("Invalid datatype: "+J);if(Cr(B))!function b(B,J,j){"SparseMatrix"===J.type?(B._values=J._values?ir(J._values):void 0,B._index=ir(J._index),B._ptr=ir(J._ptr),B._size=ir(J._size),B._datatype=j||J._datatype):I(B,J.valueOf(),j||J._datatype)}(this,B,J);else if(B&&_r(B.index)&&_r(B.ptr)&&_r(B.size))this._values=B.values,this._index=B.index,this._ptr=B.ptr,this._size=B.size,this._datatype=J||B.datatype;else if(_r(B))I(this,B,J);else{if(B)throw new TypeError("Unsupported type of data ("+es(B)+")");this._values=[],this._index=[],this._ptr=[0],this._size=[0,0],this._datatype=J}}function I(B,J,j){B._values=[],B._index=[],B._ptr=[],B._datatype=j;var oe=J.length,G=0,ee=d,ne=0;if(os(j)&&(ee=f.find(d,[j,j])||d,ne=f.convert(0,j)),oe>0){var X=0;do{B._ptr.push(B._index.length);for(var be=0;be<oe;be++){var Ie=J[be];if(_r(Ie)){if(0===X&&G<Ie.length&&(G=Ie.length),X<Ie.length){var Ce=Ie[X];ee(Ce,ne)||(B._values.push(Ce),B._index.push(be))}}else 0===X&&G<1&&(G=1),ee(Ie,ne)||(B._values.push(Ie),B._index.push(be))}X++}while(X<G)}B._ptr.push(B._index.length),B._size=[oe,G]}function T(B,J,j,oe){if(j-J==0)return j;for(var G=J;G<j;G++)if(oe[G]===B)return G;return J}function S(B,J,j,oe,G,ee,ne){G.splice(B,0,oe),ee.splice(B,0,J);for(var X=j+1;X<ne.length;X++)ne[X]++}function R(B,J,j,oe){var G=oe||0,ee=d,ne=0;os(B._datatype)&&(ee=f.find(d,[B._datatype,B._datatype])||d,ne=f.convert(0,B._datatype),G=f.convert(G,B._datatype));var Ce,fe,Ve,X=!ee(G,ne),be=B._size[0],Ie=B._size[1];if(j>Ie){for(fe=Ie;fe<j;fe++)if(B._ptr[fe]=B._values.length,X)for(Ce=0;Ce<be;Ce++)B._values.push(G),B._index.push(Ce);B._ptr[j]=B._values.length}else j<Ie&&(B._ptr.splice(j+1,Ie-j),B._values.splice(B._ptr[j],B._values.length),B._index.splice(B._ptr[j],B._index.length));if(Ie=j,J>be){if(X){var qe=0;for(fe=0;fe<Ie;fe++){B._ptr[fe]=B._ptr[fe]+qe,Ve=B._ptr[fe+1]+qe;var at=0;for(Ce=be;Ce<J;Ce++,at++)B._values.splice(Ve+at,0,G),B._index.splice(Ve+at,0,Ce),qe++}B._ptr[Ie]=B._values.length}}else if(J<be){var ht=0;for(fe=0;fe<Ie;fe++){B._ptr[fe]=B._ptr[fe]-ht;var ct=B._ptr[fe+1]-ht;for(Ve=B._ptr[fe];Ve<ct;Ve++)(Ce=B._index[Ve])>J-1&&(B._values.splice(Ve,1),B._index.splice(Ve,1),ht++)}B._ptr[fe]=B._values.length}return B._size[0]=J,B._size[1]=j,B}function F(B,J,j,oe,G){var be,Ie,ee=oe[0],ne=oe[1],X=[];for(be=0;be<ee;be++)for(X[be]=[],Ie=0;Ie<ne;Ie++)X[be][Ie]=0;for(Ie=0;Ie<ne;Ie++)for(var fe=j[Ie+1],Ve=j[Ie];Ve<fe;Ve++)X[be=J[Ve]][Ie]=B?G?ir(B[Ve]):B[Ve]:1;return X}return(y.prototype=new m).createSparseMatrix=function(B,J){return new y(B,J)},y.prototype.type="SparseMatrix",y.prototype.isSparseMatrix=!0,y.prototype.getDataType=function(){return jd(this._values,es)},y.prototype.storage=function(){return"sparse"},y.prototype.datatype=function(){return this._datatype},y.prototype.create=function(B,J){return new y(B,J)},y.prototype.density=function(){var B=this._size[0],J=this._size[1];return 0!==B&&0!==J?this._index.length/(B*J):0},y.prototype.subset=function(B,J,j){if(!this._values)throw new Error("Cannot invoke subset on a Pattern only matrix");switch(arguments.length){case 1:return function C(B,J){if(!Js(J))throw new TypeError("Invalid index");if(J.isScalar())return B.get(J.min());var oe=J.size();if(oe.length!==B._size.length)throw new Hr(oe.length,B._size.length);var G,ee,ne,X,be=J.min(),Ie=J.max();for(G=0,ee=B._size.length;G<ee;G++)Is(be[G],B._size[G]),Is(Ie[G],B._size[G]);var Ce=B._values,fe=B._index,Ve=B._ptr,qe=J.dimension(0),at=J.dimension(1),ht=[],bt=[];qe.forEach(function(Re,Nt){bt[Re]=Nt[0],ht[Re]=!0});var ct=Ce?[]:void 0,Ge=[],Ft=[];return at.forEach(function(Re){for(Ft.push(Ge.length),ne=Ve[Re],X=Ve[Re+1];ne<X;ne++)!0===ht[G=fe[ne]]&&(Ge.push(bt[G]),ct&&ct.push(Ce[ne]))}),Ft.push(Ge.length),new y({values:ct,index:Ge,ptr:Ft,size:oe,datatype:B._datatype})}(this,B);case 2:case 3:return function A(B,J,j,oe){if(!J||!0!==J.isIndex)throw new TypeError("Invalid index");var ne,G=J.size(),ee=J.isScalar();if(Cr(j)?(ne=j.size(),j=j.toArray()):ne=ei(j),ee){if(0!==ne.length)throw new TypeError("Scalar expected");B.set(J.min(),j,oe)}else{if(1!==G.length&&2!==G.length)throw new Hr(G.length,B._size.length,"<");if(ne.length<G.length){for(var X=0,be=0;1===G[X]&&1===ne[X];)X++;for(;1===G[X];)be++,X++;j=Yd(j,G.length,be,ne)}if(!Ms(G,ne))throw new Hr(G,ne,">");if(1===G.length)J.dimension(0).forEach(function(Ve,qe){Is(Ve),B.set([Ve,0],j[qe[0]],oe)});else{var Ce=J.dimension(0),fe=J.dimension(1);Ce.forEach(function(Ve,qe){Is(Ve),fe.forEach(function(at,ht){Is(at),B.set([Ve,at],j[qe[0]][ht[0]],oe)})})}}return B}(this,B,J,j);default:throw new SyntaxError("Wrong number of arguments")}},y.prototype.get=function(B){if(!_r(B))throw new TypeError("Array expected");if(B.length!==this._size.length)throw new Hr(B.length,this._size.length);if(!this._values)throw new Error("Cannot invoke get on a Pattern only matrix");var J=B[0],j=B[1];Is(J,this._size[0]),Is(j,this._size[1]);var oe=T(J,this._ptr[j],this._ptr[j+1],this._index);return oe<this._ptr[j+1]&&this._index[oe]===J?this._values[oe]:0},y.prototype.set=function(B,J,j){if(!_r(B))throw new TypeError("Array expected");if(B.length!==this._size.length)throw new Hr(B.length,this._size.length);if(!this._values)throw new Error("Cannot invoke set on a Pattern only matrix");var oe=B[0],G=B[1],ee=this._size[0],ne=this._size[1],X=d,be=0;os(this._datatype)&&(X=f.find(d,[this._datatype,this._datatype])||d,be=f.convert(0,this._datatype)),(oe>ee-1||G>ne-1)&&(R(this,Math.max(oe+1,ee),Math.max(G+1,ne),j),ee=this._size[0],ne=this._size[1]),Is(oe,ee),Is(G,ne);var Ie=T(oe,this._ptr[G],this._ptr[G+1],this._index);return Ie<this._ptr[G+1]&&this._index[Ie]===oe?X(J,be)?function E(B,J,j,oe,G){j.splice(B,1),oe.splice(B,1);for(var ee=J+1;ee<G.length;ee++)G[ee]--}(Ie,G,this._values,this._index,this._ptr):this._values[Ie]=J:S(Ie,oe,G,J,this._values,this._index,this._ptr),this},y.prototype.resize=function(B,J,j){if(!Qc(B))throw new TypeError("Array or Matrix expected");var oe=B.valueOf().map(ee=>Array.isArray(ee)&&1===ee.length?ee[0]:ee);if(2!==oe.length)throw new Error("Only two dimensions matrix are supported");return oe.forEach(function(ee){if(!Qr(ee)||!Qn(ee)||ee<0)throw new TypeError("Invalid size, must contain positive integers (size: "+ii(oe)+")")}),R(j?this.clone():this,oe[0],oe[1],J)},y.prototype.reshape=function(B,J){if(!_r(B))throw new TypeError("Array expected");if(2!==B.length)throw new Error("Sparse matrices can only be reshaped in two dimensions");B.forEach(function(Re){if(!Qr(Re)||!Qn(Re)||Re<=-2||0===Re)throw new TypeError("Invalid size, must contain positive integers or -1 (size: "+ii(B)+")")});var j=this._size[0]*this._size[1];if(j!==(B=Xs(B,j))[0]*B[1])throw new Error("Reshaping sparse matrix will result in the wrong number of elements");var G=J?this.clone():this;if(this._size[0]===B[0]&&this._size[1]===B[1])return G;for(var ee=[],ne=0;ne<G._ptr.length;ne++)for(var X=0;X<G._ptr[ne+1]-G._ptr[ne];X++)ee.push(ne);for(var be=G._values.slice(),Ie=G._index.slice(),Ce=0;Ce<G._index.length;Ce++){var qe=Ie[Ce]*G._size[1]+ee[Ce];ee[Ce]=qe%B[1],Ie[Ce]=Math.floor(qe/B[1])}G._values.length=0,G._index.length=0,G._ptr.length=B[1]+1,G._size=B.slice();for(var at=0;at<G._ptr.length;at++)G._ptr[at]=0;for(var ht=0;ht<be.length;ht++){var bt=Ie[ht],ct=ee[ht],Ge=be[ht];S(T(bt,G._ptr[ct],G._ptr[ct+1],G._index),bt,ct,Ge,G._values,G._index,G._ptr)}return G},y.prototype.clone=function(){return new y({values:this._values?ir(this._values):void 0,index:ir(this._index),ptr:ir(this._ptr),size:ir(this._size),datatype:this._datatype})},y.prototype.size=function(){return this._size.slice(0)},y.prototype.map=function(B,J){if(!this._values)throw new Error("Cannot invoke map on a Pattern only matrix");var j=this;return function P(B,J,j,oe,G,ee,ne){var X=[],be=[],Ie=[],Ce=d,fe=0;os(B._datatype)&&(Ce=f.find(d,[B._datatype,B._datatype])||d,fe=f.convert(0,B._datatype));for(var Ve=function(At,qt,an){At=ee(At,qt,an),Ce(At,fe)||(X.push(At),be.push(qt))},qe=oe;qe<=G;qe++){Ie.push(X.length);var at=B._ptr[qe],ht=B._ptr[qe+1];if(ne)for(var bt=at;bt<ht;bt++){var ct=B._index[bt];ct>=J&&ct<=j&&Ve(B._values[bt],ct-J,qe-oe)}else{for(var Ge={},Ft=at;Ft<ht;Ft++)Ge[B._index[Ft]]=B._values[Ft];for(var Nt=J;Nt<=j;Nt++)Ve(Nt in Ge?Ge[Nt]:0,Nt-J,qe-oe)}}return Ie.push(X.length),new y({values:X,index:be,ptr:Ie,size:[j-J+1,G-oe+1]})}(this,0,this._size[0]-1,0,this._size[1]-1,function(X,be,Ie){return B(X,[be,Ie],j)},J)},y.prototype.forEach=function(B,J){if(!this._values)throw new Error("Cannot invoke forEach on a Pattern only matrix");for(var oe=this._size[0],G=this._size[1],ee=0;ee<G;ee++){var ne=this._ptr[ee],X=this._ptr[ee+1];if(J)for(var be=ne;be<X;be++)B(this._values[be],[this._index[be],ee],this);else{for(var Ce={},fe=ne;fe<X;fe++)Ce[this._index[fe]]=this._values[fe];for(var qe=0;qe<oe;qe++)B(qe in Ce?Ce[qe]:0,[qe,ee],this)}}},y.prototype[Symbol.iterator]=function*(){if(!this._values)throw new Error("Cannot iterate a Pattern only matrix");for(var B=this._size[1],J=0;J<B;J++)for(var oe=this._ptr[J+1],G=this._ptr[J];G<oe;G++){var ee=this._index[G];yield{value:this._values[G],index:[ee,J]}}},y.prototype.toArray=function(){return F(this._values,this._index,this._ptr,this._size,!0)},y.prototype.valueOf=function(){return F(this._values,this._index,this._ptr,this._size,!1)},y.prototype.format=function(B){for(var J=this._size[0],j=this._size[1],oe=this.density(),G="Sparse Matrix ["+ii(J,B)+" x "+ii(j,B)+"] density: "+ii(oe,B)+"\n",ee=0;ee<j;ee++)for(var X=this._ptr[ee+1],be=this._ptr[ee];be<X;be++)G+="\n    ("+ii(this._index[be],B)+", "+ii(ee,B)+") ==> "+(this._values?ii(this._values[be],B):"X");return G},y.prototype.toString=function(){return ii(this.toArray())},y.prototype.toJSON=function(){return{mathjs:"SparseMatrix",values:this._values,index:this._index,ptr:this._ptr,size:this._size,datatype:this._datatype}},y.prototype.diagonal=function(B){if(B){if(Gn(B)&&(B=B.toNumber()),!Qr(B)||!Qn(B))throw new TypeError("The parameter k must be an integer number")}else B=0;var J=B>0?B:0,j=B<0?-B:0,G=this._size[1],ee=Math.min(this._size[0]-j,G-J),ne=[],X=[],be=[];be[0]=0;for(var Ie=J;Ie<G&&ne.length<ee;Ie++)for(var fe=this._ptr[Ie+1],Ve=this._ptr[Ie];Ve<fe;Ve++){var qe=this._index[Ve];if(qe===Ie-J+j){ne.push(this._values[Ve]),X[ne.length-1]=qe-j;break}}return be.push(ne.length),new y({values:ne,index:X,ptr:be,size:[ee,1]})},y.fromJSON=function(B){return new y(B)},y.diagonal=function(B,J,j,oe,G){if(!_r(B))throw new TypeError("Array expected, size parameter");if(2!==B.length)throw new Error("Only two dimensions matrix are supported");if(B=B.map(function(Re){if(Gn(Re)&&(Re=Re.toNumber()),!Qr(Re)||!Qn(Re)||Re<1)throw new Error("Size values must be positive integers");return Re}),j){if(Gn(j)&&(j=j.toNumber()),!Qr(j)||!Qn(j))throw new TypeError("The parameter k must be an integer number")}else j=0;var ee=d,ne=0;os(G)&&(ee=f.find(d,[G,G])||d,ne=f.convert(0,G));var Ve,X=j>0?j:0,be=j<0?-j:0,Ie=B[0],Ce=B[1],fe=Math.min(Ie-be,Ce-X);if(_r(J)){if(J.length!==fe)throw new Error("Invalid value array length");Ve=function(Nt){return J[Nt]}}else if(Cr(J)){var qe=J.size();if(1!==qe.length||qe[0]!==fe)throw new Error("Invalid matrix length");Ve=function(Nt){return J.get([Nt])}}else Ve=function(){return J};for(var at=[],ht=[],bt=[],ct=0;ct<Ce;ct++){bt.push(at.length);var Ge=ct-X;if(Ge>=0&&Ge<fe){var Ft=Ve(Ge);ee(Ft,ne)||(ht.push(Ge+be),at.push(Ft))}}return bt.push(at.length),new y({values:at,index:ht,ptr:bt,size:[Ie,Ce]})},y.prototype.swapRows=function(B,J){if(!(Qr(B)&&Qn(B)&&Qr(J)&&Qn(J)))throw new Error("Row index must be positive integers");if(2!==this._size.length)throw new Error("Only two dimensional matrix is supported");return Is(B,this._size[0]),Is(J,this._size[0]),y._swapRows(B,J,this._size[1],this._values,this._index,this._ptr),this},y._forEachRow=function(B,J,j,oe,G){for(var ne=oe[B+1],X=oe[B];X<ne;X++)G(j[X],J[X])},y._swapRows=function(B,J,j,oe,G,ee){for(var ne=0;ne<j;ne++){var X=ee[ne],be=ee[ne+1],Ie=T(B,X,be,G),Ce=T(J,X,be,G);if(Ie<be&&Ce<be&&G[Ie]===B&&G[Ce]===J){if(oe){var fe=oe[Ie];oe[Ie]=oe[Ce],oe[Ce]=fe}}else if(Ie<be&&G[Ie]===B&&(Ce>=be||G[Ce]!==J)){var Ve=oe?oe[Ie]:void 0;G.splice(Ce,0,J),oe&&oe.splice(Ce,0,Ve),G.splice(Ce<=Ie?Ie+1:Ie,1),oe&&oe.splice(Ce<=Ie?Ie+1:Ie,1)}else if(Ce<be&&G[Ce]===J&&(Ie>=be||G[Ie]!==B)){var qe=oe?oe[Ce]:void 0;G.splice(Ie,0,B),oe&&oe.splice(Ie,0,qe),G.splice(Ie<=Ce?Ce+1:Ce,1),oe&&oe.splice(Ie<=Ce?Ce+1:Ce,1)}}},y},{isClass:!0});ot("bin",["typed","format"],c=>{var{typed:f,format:d}=c;return f("bin",{"number | BigNumber":function(y){return d(y,{notation:"bin"})},"number | BigNumber, number":function(y,b){return d(y,{notation:"bin",wordSize:b})}})});var MT=ot("isNaN",["typed"],c=>{var{typed:f}=c;return f("isNaN",{number:Vg,BigNumber:function(m){return m.isNaN()},Fraction:function(m){return!1},Complex:function(m){return m.isNaN()},Unit:function(m){return Number.isNaN(m.value)},"Array | Matrix":function(m){return Jn(m,Number.isNaN)}})}),up="unaryMinus",bu=ot(up,["typed"],c=>{var{typed:f}=c;return f(up,{number:Dw,Complex:function(m){return m.neg()},BigNumber:function(m){return m.neg()},Fraction:function(m){return m.neg()},Unit:function(m){var y=m.clone();return y.value=this(m.value),y},"Array | Matrix":function(m){return Jn(m,this,!0)}})}),VT=ot("fraction",["typed","Fraction"],c=>{var{typed:f,Fraction:d}=c;return f("fraction",{number:function(y){if(!isFinite(y)||isNaN(y))throw new Error(y+" cannot be represented as a fraction");return new d(y)},string:function(y){return new d(y)},"number, number":function(y,b){return new d(y,b)},null:function(y){return new d(0)},BigNumber:function(y){return new d(y.toString())},Fraction:function(y){return y},Object:function(y){return new d(y)},"Array | Matrix":function(y){return Jn(y,this)}})}),ed="isNumeric",td=ot(ed,["typed"],c=>{var{typed:f}=c;return f(ed,{"number | BigNumber | Fraction | boolean":function(){return!0},"Complex | Unit | string | null | undefined | Node":function(){return!1},"Array | Matrix":function(m){return Jn(m,this)}})}),Z_=ot("matrix",["typed","Matrix","DenseMatrix","SparseMatrix"],c=>{var{typed:f,DenseMatrix:m,SparseMatrix:y}=c;return f("matrix",{"":function(){return b([])},string:function(C){return b([],C)},"string, string":function(C,A){return b([],C,A)},Array:function(C){return b(C)},Matrix:function(C){return b(C,C.storage())},"Array | Matrix, string":b,"Array | Matrix, string, string":b});function b(I,C,A){if("dense"===C||"default"===C||void 0===C)return new m(I,A);if("sparse"===C)return new y(I,A);throw new TypeError("Unknown matrix type "+JSON.stringify(C)+".")}}),Gu=ot("algorithm03",["typed"],c=>{var{typed:f}=c;return function(m,y,b,I){var C=m._data,A=m._size,T=m._datatype,E=y._values,S=y._index,R=y._ptr,P=y._size,F=y._datatype;if(A.length!==P.length)throw new Hr(A.length,P.length);if(A[0]!==P[0]||A[1]!==P[1])throw new RangeError("Dimension mismatch. Matrix A ("+A+") must match Matrix B ("+P+")");if(!E)throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");var j,B=A[0],J=A[1],oe=0,G=b;"string"==typeof T&&T===F&&(oe=f.convert(0,j=T),G=f.find(b,[j,j]));for(var ee=[],ne=0;ne<B;ne++)ee[ne]=[];for(var X=[],be=[],Ie=0;Ie<J;Ie++){for(var Ce=Ie+1,Ve=R[Ie+1],qe=R[Ie];qe<Ve;qe++){var at=S[qe];X[at]=I?G(E[qe],C[at][Ie]):G(C[at][Ie],E[qe]),be[at]=Ce}for(var ht=0;ht<B;ht++)ee[ht][Ie]=be[ht]===Ce?X[ht]:I?G(oe,C[ht][Ie]):G(C[ht][Ie],oe)}return m.createDenseMatrix({data:ee,size:[B,J],datatype:j})}}),cp=ot("algorithm05",["typed","equalScalar"],c=>{var{typed:f,equalScalar:d}=c;return function(y,b,I){var C=y._values,A=y._index,T=y._ptr,E=y._size,S=y._datatype,R=b._values,P=b._index,F=b._ptr,B=b._size,J=b._datatype;if(E.length!==B.length)throw new Hr(E.length,B.length);if(E[0]!==B[0]||E[1]!==B[1])throw new RangeError("Dimension mismatch. Matrix A ("+E+") must match Matrix B ("+B+")");var G,j=E[0],oe=E[1],ee=d,ne=0,X=I;"string"==typeof S&&S===J&&(ee=f.find(d,[G=S,G]),ne=f.convert(0,G),X=f.find(I,[G,G]));var ht,bt,ct,Ge,be=C&&R?[]:void 0,Ie=[],Ce=[],fe=be?[]:void 0,Ve=be?[]:void 0,qe=[],at=[];for(bt=0;bt<oe;bt++){Ce[bt]=Ie.length;var Ft=bt+1;for(ct=T[bt],Ge=T[bt+1];ct<Ge;ct++)Ie.push(ht=A[ct]),qe[ht]=Ft,fe&&(fe[ht]=C[ct]);for(ct=F[bt],Ge=F[bt+1];ct<Ge;ct++)qe[ht=P[ct]]!==Ft&&Ie.push(ht),at[ht]=Ft,Ve&&(Ve[ht]=R[ct]);if(be)for(ct=Ce[bt];ct<Ie.length;){var Re=qe[ht=Ie[ct]],Nt=at[ht];if(Re===Ft||Nt===Ft){var At=X(Re===Ft?fe[ht]:ne,Nt===Ft?Ve[ht]:ne);ee(At,ne)?Ie.splice(ct,1):(be.push(At),ct++)}}}return Ce[oe]=Ie.length,y.createSparseMatrix({values:be,index:Ie,ptr:Ce,size:[j,oe],datatype:G})}}),nu=ot("algorithm11",["typed","equalScalar"],c=>{var{typed:f,equalScalar:d}=c;return function(y,b,I,C){var A=y._values,T=y._index,E=y._ptr,S=y._size,R=y._datatype;if(!A)throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");var B,P=S[0],F=S[1],J=d,j=0,oe=I;"string"==typeof R&&(J=f.find(d,[B=R,B]),j=f.convert(0,B),b=f.convert(b,B),oe=f.find(I,[B,B]));for(var G=[],ee=[],ne=[],X=0;X<F;X++){ne[X]=ee.length;for(var Ie=E[X+1],Ce=E[X];Ce<Ie;Ce++){var fe=T[Ce],Ve=C?oe(b,A[Ce]):oe(A[Ce],b);J(Ve,j)||(ee.push(fe),G.push(Ve))}}return ne[F]=ee.length,y.createSparseMatrix({values:G,index:ee,ptr:ne,size:[P,F],datatype:B})}}),Pa=ot("algorithm12",["typed","DenseMatrix"],c=>{var{typed:f,DenseMatrix:d}=c;return function(y,b,I,C){var A=y._values,T=y._index,E=y._ptr,S=y._size,R=y._datatype;if(!A)throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");var B,P=S[0],F=S[1],J=I;"string"==typeof R&&(b=f.convert(b,B=R),J=f.find(I,[B,B]));for(var j=[],oe=[],G=[],ee=0;ee<F;ee++){for(var ne=ee+1,be=E[ee+1],Ie=E[ee];Ie<be;Ie++){var Ce=T[Ie];oe[Ce]=A[Ie],G[Ce]=ne}for(var fe=0;fe<P;fe++)0===ee&&(j[fe]=[]),j[fe][ee]=G[fe]===ne?C?J(b,oe[fe]):J(oe[fe],b):C?J(b,0):J(0,b)}return new d({data:j,size:[P,F],datatype:B})}}),Ds=ot("algorithm13",["typed"],c=>{var{typed:f}=c;return function(y,b,I){var C=y._data,A=y._size,T=y._datatype,E=b._data,S=b._size,R=b._datatype,P=[];if(A.length!==S.length)throw new Hr(A.length,S.length);for(var F=0;F<A.length;F++){if(A[F]!==S[F])throw new RangeError("Dimension mismatch. Matrix A ("+A+") must match Matrix B ("+S+")");P[F]=A[F]}var B,J=I;"string"==typeof T&&T===R&&(J=f.find(I,[B=T,B]));var j=P.length>0?d(J,0,P,P[0],C,E):[];return y.createDenseMatrix({data:j,size:P,datatype:B})};function d(m,y,b,I,C,A){var T=[];if(y===b.length-1)for(var E=0;E<I;E++)T[E]=m(C[E],A[E]);else for(var S=0;S<I;S++)T[S]=d(m,y+1,b,b[y+1],C[S],A[S]);return T}}),Ji=ot("algorithm14",["typed"],c=>{var{typed:f}=c;return function(y,b,I,C){var S,A=y._data,T=y._size,E=y._datatype,R=I;"string"==typeof E&&(b=f.convert(b,S=E),R=f.find(I,[S,S]));var P=T.length>0?d(R,0,T,T[0],A,b,C):[];return y.createDenseMatrix({data:P,size:ir(T),datatype:S})};function d(m,y,b,I,C,A,T){var E=[];if(y===b.length-1)for(var S=0;S<I;S++)E[S]=T?m(A,C[S]):m(C[S],A);else for(var R=0;R<I;R++)E[R]=d(m,y+1,b,b[y+1],C[R],A,T);return E}}),df=ot("algorithm01",["typed"],c=>{var{typed:f}=c;return function(m,y,b,I){var C=m._data,A=m._size,T=m._datatype,E=y._values,S=y._index,R=y._ptr,P=y._size,F=y._datatype;if(A.length!==P.length)throw new Hr(A.length,P.length);if(A[0]!==P[0]||A[1]!==P[1])throw new RangeError("Dimension mismatch. Matrix A ("+A+") must match Matrix B ("+P+")");if(!E)throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");var G,ee,B=A[0],J=A[1],j="string"==typeof T&&T===F?T:void 0,oe=j?f.find(b,[j,j]):b,ne=[];for(G=0;G<B;G++)ne[G]=[];var X=[],be=[];for(ee=0;ee<J;ee++){for(var Ie=ee+1,fe=R[ee+1],Ve=R[ee];Ve<fe;Ve++)X[G=S[Ve]]=I?oe(E[Ve],C[G][ee]):oe(C[G][ee],E[Ve]),be[G]=Ie;for(G=0;G<B;G++)ne[G][ee]=be[G]===Ie?X[G]:C[G][ee]}return m.createDenseMatrix({data:ne,size:[B,J],datatype:j})}});function eN(){throw new Error('No "bignumber" implementation available')}function Th(){throw new Error('No "fraction" implementation available')}var gm=ot("numeric",["number","?bignumber","?fraction"],c=>{var{number:f,bignumber:d,fraction:m}=c,y={string:!0,number:!0,BigNumber:!0,Fraction:!0},b={number:I=>f(I),BigNumber:d?I=>d(I):eN,Fraction:m?I=>m(I):Th};return function(C,A){var T=es(C);if(!(T in y))throw new TypeError("Cannot convert "+C+' of type "'+T+'"; valid input types are '+Object.keys(y).join(", "));if(!(A in b))throw new TypeError("Cannot convert "+C+' to type "'+A+'"; valid output types are '+Object.keys(b).join(", "));return A===T?C:b[A](C)}});var sM=ot("size",["typed","config","?matrix"],c=>{var{typed:f,config:d,matrix:m}=c;return f("size",{Matrix:function(b){return b.create(b.size())},Array:ei,string:function(b){return"Array"===d.matrix?[b.length]:m([b.length])},"number | Complex | BigNumber | Unit | boolean | null":function(b){return"Array"===d.matrix?[]:m?m([]):function tN(){throw new Error('No "matrix" implementation available')}()}})}),hp=ot("algorithm10",["typed","DenseMatrix"],c=>{var{typed:f,DenseMatrix:d}=c;return function(y,b,I,C){var A=y._values,T=y._index,E=y._ptr,S=y._size,R=y._datatype;if(!A)throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");var B,P=S[0],F=S[1],J=I;"string"==typeof R&&(b=f.convert(b,B=R),J=f.find(I,[B,B]));for(var j=[],oe=[],G=[],ee=0;ee<F;ee++){for(var ne=ee+1,be=E[ee+1],Ie=E[ee];Ie<be;Ie++){var Ce=T[Ie];oe[Ce]=A[Ie],G[Ce]=ne}for(var fe=0;fe<P;fe++)0===ee&&(j[fe]=[]),j[fe][ee]=G[fe]===ne?C?J(b,oe[fe]):J(oe[fe],b):b}return new d({data:j,size:[P,F],datatype:B})}}),S1="subtract",dN=ot(S1,["typed","matrix","equalScalar","addScalar","unaryMinus","DenseMatrix"],c=>{var{typed:f,matrix:d,equalScalar:m,addScalar:y,unaryMinus:b,DenseMatrix:I}=c,C=df({typed:f}),A=Gu({typed:f}),T=cp({typed:f,equalScalar:m}),E=hp({typed:f,DenseMatrix:I}),S=Ds({typed:f}),R=Ji({typed:f});return f(S1,{"number, number":function(F,B){return F-B},"Complex, Complex":function(F,B){return F.sub(B)},"BigNumber, BigNumber":function(F,B){return F.minus(B)},"Fraction, Fraction":function(F,B){return F.sub(B)},"Unit, Unit":function(F,B){if(null===F.value)throw new Error("Parameter x contains a unit with undefined value");if(null===B.value)throw new Error("Parameter y contains a unit with undefined value");if(!F.equalBase(B))throw new Error("Units do not match");var J=F.clone();return J.value=this(J.value,B.value),J.fixPrefix=!1,J},"SparseMatrix, SparseMatrix":function(F,B){return i0(F,B),T(F,B,this)},"SparseMatrix, DenseMatrix":function(F,B){return i0(F,B),A(B,F,this,!0)},"DenseMatrix, SparseMatrix":function(F,B){return i0(F,B),C(F,B,this,!1)},"DenseMatrix, DenseMatrix":function(F,B){return i0(F,B),S(F,B,this)},"Array, Array":function(F,B){return this(d(F),d(B)).valueOf()},"Array, Matrix":function(F,B){return this(d(F),B)},"Matrix, Array":function(F,B){return this(F,d(B))},"SparseMatrix, any":function(F,B){return E(F,b(B),y)},"DenseMatrix, any":function(F,B){return R(F,B,this)},"any, SparseMatrix":function(F,B){return E(B,F,this,!0)},"any, DenseMatrix":function(F,B){return R(B,F,this,!0)},"Array, any":function(F,B){return R(d(F),B,this,!1).valueOf()},"any, Array":function(F,B){return R(d(B),F,this,!0).valueOf()}})});function i0(c,f){var d=c.size(),m=f.size();if(d.length!==m.length)throw new Hr(d.length,m.length)}var vN="compare",EM=ot(vN,["typed","config","matrix","equalScalar","BigNumber","Fraction","DenseMatrix"],c=>{var{typed:f,config:d,equalScalar:m,matrix:y,BigNumber:b,Fraction:I,DenseMatrix:C}=c,A=Gu({typed:f}),T=cp({typed:f,equalScalar:m}),E=Pa({typed:f,DenseMatrix:C}),S=Ds({typed:f}),R=Ji({typed:f});return f(vN,{"boolean, boolean":function(F,B){return F===B?0:F>B?1:-1},"number, number":function(F,B){return Bo(F,B,d.epsilon)?0:F>B?1:-1},"BigNumber, BigNumber":function(F,B){return ff(F,B,d.epsilon)?new b(0):new b(F.cmp(B))},"Fraction, Fraction":function(F,B){return new I(F.compare(B))},"Complex, Complex":function(){throw new TypeError("No ordering relation is defined for complex numbers")},"Unit, Unit":function(F,B){if(!F.equalBase(B))throw new Error("Cannot compare units with different base");return this(F.value,B.value)},"SparseMatrix, SparseMatrix":function(F,B){return T(F,B,this)},"SparseMatrix, DenseMatrix":function(F,B){return A(B,F,this,!0)},"DenseMatrix, SparseMatrix":function(F,B){return A(F,B,this,!1)},"DenseMatrix, DenseMatrix":function(F,B){return S(F,B,this)},"Array, Array":function(F,B){return this(y(F),y(B)).valueOf()},"Array, Matrix":function(F,B){return this(y(F),B)},"Matrix, Array":function(F,B){return this(F,y(B))},"SparseMatrix, any":function(F,B){return E(F,B,this,!1)},"DenseMatrix, any":function(F,B){return R(F,B,this,!1)},"any, SparseMatrix":function(F,B){return E(B,F,this,!0)},"any, DenseMatrix":function(F,B){return R(B,F,this,!0)},"Array, any":function(F,B){return R(y(F),B,this,!1).valueOf()},"any, Array":function(F,B){return R(y(B),F,this,!0).valueOf()}})}),f0="divideScalar",DM=ot(f0,["typed","numeric"],c=>{var{typed:f,numeric:d}=c;return f(f0,{"number, number":function(y,b){return y/b},"Complex, Complex":function(y,b){return y.div(b)},"BigNumber, BigNumber":function(y,b){return y.div(b)},"Fraction, Fraction":function(y,b){return y.div(b)},"Unit, number | Fraction | BigNumber":function(y,b){var I=y.clone(),C=d(1,es(b));return I.value=this(null===I.value?I._normalize(C):I.value,b),I},"number | Fraction | BigNumber, Unit":function(y,b){var I=b.clone();I=I.pow(-1);var C=d(1,es(y));return I.value=this(y,null===b.value?b._normalize(C):b.value),I},"Unit, Unit":function(y,b){return y.divide(b)}})}),M1=(ot("equal",["typed","equalScalar"],c=>{var{typed:f,equalScalar:d}=c;return f("equal",{"any, any":function(y,b){return null===y?null===b:null===b?null===y:void 0===y?void 0===b:void 0===b?void 0===y:d(y,b)}})}),ot("algorithm04",["typed","equalScalar"],c=>{var{typed:f,equalScalar:d}=c;return function(y,b,I){var C=y._values,A=y._index,T=y._ptr,E=y._size,S=y._datatype,R=b._values,P=b._index,F=b._ptr,B=b._size,J=b._datatype;if(E.length!==B.length)throw new Hr(E.length,B.length);if(E[0]!==B[0]||E[1]!==B[1])throw new RangeError("Dimension mismatch. Matrix A ("+E+") must match Matrix B ("+B+")");var G,j=E[0],oe=E[1],ee=d,ne=0,X=I;"string"==typeof S&&S===J&&(ee=f.find(d,[G=S,G]),ne=f.convert(0,G),X=f.find(I,[G,G]));var ht,bt,ct,Ft,be=C&&R?[]:void 0,Ie=[],Ce=[],fe=C&&R?[]:void 0,Ve=C&&R?[]:void 0,qe=[],at=[];for(bt=0;bt<oe;bt++){Ce[bt]=Ie.length;var Re=bt+1;for(Ft=T[bt+1],ct=T[bt];ct<Ft;ct++)Ie.push(ht=A[ct]),qe[ht]=Re,fe&&(fe[ht]=C[ct]);for(Ft=F[bt+1],ct=F[bt];ct<Ft;ct++)if(qe[ht=P[ct]]===Re){if(fe){var Nt=X(fe[ht],R[ct]);ee(Nt,ne)?qe[ht]=null:fe[ht]=Nt}}else Ie.push(ht),at[ht]=Re,Ve&&(Ve[ht]=R[ct]);if(fe&&Ve)for(ct=Ce[bt];ct<Ie.length;)qe[ht=Ie[ct]]===Re?(be[ct]=fe[ht],ct++):at[ht]===Re?(be[ct]=Ve[ht],ct++):Ie.splice(ct,1)}return Ce[oe]=Ie.length,y.createSparseMatrix({values:be,index:Ie,ptr:Ce,size:[j,oe],datatype:G})}})),FN="partitionSelect",LN=ot(FN,["typed","isNumeric","isNaN","compare"],c=>{var{typed:f,isNumeric:d,isNaN:m,compare:y}=c,b=y,I=(T,E)=>-y(T,E);return f(FN,{"Array | Matrix, number":function(E,S){return C(E,S,b)},"Array | Matrix, number, string":function(E,S,R){if("asc"===R)return C(E,S,b);if("desc"===R)return C(E,S,I);throw new Error('Compare string must be "asc" or "desc"')},"Array | Matrix, number, function":C});function C(T,E,S){if(!Qn(E)||E<0)throw new Error("k must be a non-negative integer");if(Cr(T)){if(T.size().length>1)throw new Error("Only one dimensional matrices supported");return A(T.valueOf(),E,S)}if(Array.isArray(T))return A(T,E,S)}function A(T,E,S){if(E>=T.length)throw new Error("k out of bounds");for(var R=0;R<T.length;R++)if(d(T[R])&&m(T[R]))return T[R];for(var P=0,F=T.length-1;P<F;){for(var B=P,J=F,j=T[Math.floor(Math.random()*(F-P+1))+P];B<J;)if(S(T[B],j)>=0){var oe=T[J];T[J]=T[B],T[B]=oe,--J}else++B;S(T[B],j)>0&&--B,E<=B?F=B:P=B+1}return T[E]}});function ld(c,f,d,m){if(!(this instanceof ld))throw new SyntaxError("Constructor must be called with the new operator");this.fn=c,this.count=f,this.min=d,this.max=m,this.message="Wrong number of arguments in function "+c+" ("+f+" provided, "+d+(null!=m?"-"+m:"")+" expected)",this.stack=(new Error).stack}(ld.prototype=new Error).constructor=Error,ld.prototype.name="ArgumentsError",ld.prototype.isArgumentsError=!0;var _m="unequal",nR=(ot(_m,["typed","equalScalar"],c=>{var{typed:f,equalScalar:d}=c;return f(_m,{"any, any":function(y,b){return null===y?null!==b:null===b?null!==y:void 0===y?void 0!==b:void 0===b?void 0!==y:!d(y,b)}})}),ot("add",["typed","matrix","addScalar","equalScalar","DenseMatrix","SparseMatrix"],c=>{var{typed:f,matrix:d,addScalar:m,equalScalar:y,DenseMatrix:b}=c,C=df({typed:f}),A=M1({typed:f,equalScalar:y}),T=hp({typed:f,DenseMatrix:b}),E=Ds({typed:f}),S=Ji({typed:f});return f("add",Ss({"DenseMatrix, DenseMatrix":function(P,F){return E(P,F,m)},"DenseMatrix, SparseMatrix":function(P,F){return C(P,F,m,!1)},"SparseMatrix, DenseMatrix":function(P,F){return C(F,P,m,!0)},"SparseMatrix, SparseMatrix":function(P,F){return A(P,F,m)},"Array, Array":function(P,F){return this(d(P),d(F)).valueOf()},"Array, Matrix":function(P,F){return this(d(P),F)},"Matrix, Array":function(P,F){return this(P,d(F))},"DenseMatrix, any":function(P,F){return S(P,F,m,!1)},"SparseMatrix, any":function(P,F){return T(P,F,m,!1)},"any, DenseMatrix":function(P,F){return S(F,P,m,!0)},"any, SparseMatrix":function(P,F){return T(F,P,m,!0)},"Array, any":function(P,F){return S(d(P),F,m,!1).valueOf()},"any, Array":function(P,F){return S(d(F),P,m,!0).valueOf()},"any, any":m,"any, any, ...any":function(P,F,B){for(var J=this(P,F),j=0;j<B.length;j++)J=this(J,B[j]);return J}},m.signatures))}));Y(9286);var A0=ot("dot",["typed","addScalar","multiplyScalar","conj","size"],c=>{var{typed:f,addScalar:d,multiplyScalar:m,conj:y,size:b}=c;return f("dot",{"Array | DenseMatrix, Array | DenseMatrix":function C(E,S){var R=I(E,S),P=Cr(E)?E._data:E,F=Cr(E)?E._datatype:void 0,B=Cr(S)?S._data:S,J=Cr(S)?S._datatype:void 0,j=2===T(E).length,oe=2===T(S).length,G=d,ee=m;if(F&&J&&F===J&&"string"==typeof F){var ne=F;G=f.find(d,[ne,ne]),ee=f.find(m,[ne,ne])}if(!j&&!oe){for(var X=ee(y(P[0]),B[0]),be=1;be<R;be++)X=G(X,ee(y(P[be]),B[be]));return X}if(!j&&oe){for(var Ie=ee(y(P[0]),B[0][0]),Ce=1;Ce<R;Ce++)Ie=G(Ie,ee(y(P[Ce]),B[Ce][0]));return Ie}if(j&&!oe){for(var fe=ee(y(P[0][0]),B[0]),Ve=1;Ve<R;Ve++)fe=G(fe,ee(y(P[Ve][0]),B[Ve]));return fe}if(j&&oe){for(var qe=ee(y(P[0][0]),B[0][0]),at=1;at<R;at++)qe=G(qe,ee(y(P[at][0]),B[at][0]));return qe}},"SparseMatrix, SparseMatrix":function A(E,S){I(E,S);for(var R=E._index,P=E._values,F=S._index,B=S._values,J=0,j=d,oe=m,G=0,ee=0;G<R.length&&ee<F.length;){var ne=R[G],X=F[ee];ne<X?G++:ne>X?ee++:ne===X&&(J=j(J,oe(P[G],B[ee])),G++,ee++)}return J}});function I(E,S){var F,B,R=T(E),P=T(S);if(1===R.length)F=R[0];else{if(2!==R.length||1!==R[1])throw new RangeError("Expected a column vector, instead got a matrix of size ("+R.join(", ")+")");F=R[0]}if(1===P.length)B=P[0];else{if(2!==P.length||1!==P[1])throw new RangeError("Expected a column vector, instead got a matrix of size ("+P.join(", ")+")");B=P[0]}if(F!==B)throw new RangeError("Vectors must have equal length ("+F+" != "+B+")");if(0===F)throw new RangeError("Cannot calculate the dot product of empty vectors");return F}function T(E){return Cr(E)?E.size():b(E)}}),M0="identity",xR=ot(M0,["typed","config","matrix","BigNumber","DenseMatrix","SparseMatrix"],c=>{var{typed:f,config:d,matrix:m,BigNumber:y,DenseMatrix:b,SparseMatrix:I}=c;return f(M0,{"":function(){return"Matrix"===d.matrix?m([]):[]},string:function(E){return m(E)},"number | BigNumber":function(E){return A(E,E,"Matrix"===d.matrix?"dense":void 0)},"number | BigNumber, string":function(E,S){return A(E,E,S)},"number | BigNumber, number | BigNumber":function(E,S){return A(E,S,"Matrix"===d.matrix?"dense":void 0)},"number | BigNumber, number | BigNumber, string":function(E,S,R){return A(E,S,R)},Array:function(E){return C(E)},"Array, string":function(E,S){return C(E,S)},Matrix:function(E){return C(E.valueOf(),E.storage())},"Matrix, string":function(E,S){return C(E.valueOf(),S)}});function C(T,E){switch(T.length){case 0:return E?m(E):[];case 1:return A(T[0],T[0],E);case 2:return A(T[0],T[1],E);default:throw new Error("Vector containing two values expected")}}function A(T,E,S){var R=Gn(T)||Gn(E)?y:null;if(Gn(T)&&(T=T.toNumber()),Gn(E)&&(E=E.toNumber()),!Qn(T)||T<1)throw new Error("Parameters in function identity must be positive integers");if(!Qn(E)||E<1)throw new Error("Parameters in function identity must be positive integers");var P=R?new y(1):1,F=R?new R(0):0,B=[T,E];if(S){if("sparse"===S)return I.diagonal(B,P,0,F);if("dense"===S)return b.diagonal(B,P,0,F);throw new TypeError('Unknown matrix type "'.concat(S,'"'))}for(var J=Lp([],B,F),j=T<E?T:E,oe=0;oe<j;oe++)J[oe][oe]=P;return J}}),lS="multiply",TR=ot(lS,["typed","matrix","addScalar","multiplyScalar","equalScalar","dot"],c=>{var{typed:f,matrix:d,addScalar:m,multiplyScalar:y,equalScalar:b,dot:I}=c,C=nu({typed:f,equalScalar:b}),A=Ji({typed:f});function T(ne,X){switch(ne.length){case 1:switch(X.length){case 1:if(ne[0]!==X[0])throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");break;case 2:if(ne[0]!==X[0])throw new RangeError("Dimension mismatch in multiplication. Vector length ("+ne[0]+") must match Matrix rows ("+X[0]+")");break;default:throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has "+X.length+" dimensions)")}break;case 2:switch(X.length){case 1:if(ne[1]!==X[0])throw new RangeError("Dimension mismatch in multiplication. Matrix columns ("+ne[1]+") must match Vector length ("+X[0]+")");break;case 2:if(ne[1]!==X[0])throw new RangeError("Dimension mismatch in multiplication. Matrix A columns ("+ne[1]+") must match Matrix B rows ("+X[0]+")");break;default:throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has "+X.length+" dimensions)")}break;default:throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has "+ne.length+" dimensions)")}}var P=f("_multiplyMatrixVector",{"DenseMatrix, any":function B(ne,X){var ht,be=ne._data,Ie=ne._size,Ce=ne._datatype,fe=X._data,Ve=X._datatype,qe=Ie[0],at=Ie[1],bt=m,ct=y;Ce&&Ve&&Ce===Ve&&"string"==typeof Ce&&(bt=f.find(m,[ht=Ce,ht]),ct=f.find(y,[ht,ht]));for(var Ge=[],Ft=0;Ft<qe;Ft++){for(var Re=be[Ft],Nt=ct(Re[0],fe[0]),Ut=1;Ut<at;Ut++)Nt=bt(Nt,ct(Re[Ut],fe[Ut]));Ge[Ft]=Nt}return ne.createDenseMatrix({data:Ge,size:[qe],datatype:ht})},"SparseMatrix, any":function oe(ne,X){var be=ne._values,Ie=ne._index,Ce=ne._ptr,fe=ne._datatype;if(!be)throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");var Ft,Ve=X._data,qe=X._datatype,at=ne._size[0],ht=X._size[0],bt=[],ct=[],Ge=[],Re=m,Nt=y,Ut=b,un=0;fe&&qe&&fe===qe&&"string"==typeof fe&&(Re=f.find(m,[Ft=fe,Ft]),Nt=f.find(y,[Ft,Ft]),Ut=f.find(b,[Ft,Ft]),un=f.convert(0,Ft));var At=[],qt=[];Ge[0]=0;for(var an=0;an<ht;an++){var jt=Ve[an];if(!Ut(jt,un))for(var Nn=Ce[an+1],Cn=Ce[an];Cn<Nn;Cn++){var sn=Ie[Cn];qt[sn]?At[sn]=Re(At[sn],Nt(jt,be[Cn])):(qt[sn]=!0,ct.push(sn),At[sn]=Nt(jt,be[Cn]))}}for(var Sr=ct.length,dr=0;dr<Sr;dr++)bt[dr]=At[ct[dr]];return Ge[1]=ct.length,ne.createSparseMatrix({values:bt,index:ct,ptr:Ge,size:[at,1],datatype:Ft})}}),F=f("_multiplyMatrixMatrix",{"DenseMatrix, DenseMatrix":function J(ne,X){var ct,be=ne._data,Ie=ne._size,Ce=ne._datatype,fe=X._data,qe=X._datatype,at=Ie[0],ht=Ie[1],bt=X._size[1],Ge=m,Ft=y;Ce&&qe&&Ce===qe&&"string"==typeof Ce&&(Ge=f.find(m,[ct=Ce,ct]),Ft=f.find(y,[ct,ct]));for(var Re=[],Nt=0;Nt<at;Nt++){var Ut=be[Nt];Re[Nt]=[];for(var un=0;un<bt;un++){for(var At=Ft(Ut[0],fe[0][un]),qt=1;qt<ht;qt++)At=Ge(At,Ft(Ut[qt],fe[qt][un]));Re[Nt][un]=At}}return ne.createDenseMatrix({data:Re,size:[at,bt],datatype:ct})},"DenseMatrix, SparseMatrix":function j(ne,X){var be=ne._data,Ie=ne._size,Ce=ne._datatype,fe=X._values,Ve=X._index,qe=X._ptr,at=X._size,ht=X._datatype;if(!fe)throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");var Ge,bt=Ie[0],ct=at[1],Ft=m,Re=y,Nt=b,Ut=0;Ce&&ht&&Ce===ht&&"string"==typeof Ce&&(Ft=f.find(m,[Ge=Ce,Ge]),Re=f.find(y,[Ge,Ge]),Nt=f.find(b,[Ge,Ge]),Ut=f.convert(0,Ge));for(var un=[],At=[],qt=[],an=X.createSparseMatrix({values:un,index:At,ptr:qt,size:[bt,ct],datatype:Ge}),jt=0;jt<ct;jt++){qt[jt]=At.length;var dn=qe[jt],Nn=qe[jt+1];if(Nn>dn)for(var Cn=0,sn=0;sn<bt;sn++){for(var Sr=sn+1,dr=void 0,Ln=dn;Ln<Nn;Ln++){var sr=Ve[Ln];Cn!==Sr?(dr=Re(be[sn][sr],fe[Ln]),Cn=Sr):dr=Ft(dr,Re(be[sn][sr],fe[Ln]))}Cn===Sr&&!Nt(dr,Ut)&&(At.push(sn),un.push(dr))}}return qt[ct]=At.length,an},"SparseMatrix, DenseMatrix":function G(ne,X){var be=ne._values,Ie=ne._index,Ce=ne._ptr,fe=ne._datatype;if(!be)throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");var ct,Ve=X._data,qe=X._datatype,at=ne._size[0],ht=X._size[0],bt=X._size[1],Ge=m,Ft=y,Re=b,Nt=0;fe&&qe&&fe===qe&&"string"==typeof fe&&(Ge=f.find(m,[ct=fe,ct]),Ft=f.find(y,[ct,ct]),Re=f.find(b,[ct,ct]),Nt=f.convert(0,ct));for(var Ut=[],un=[],At=[],qt=ne.createSparseMatrix({values:Ut,index:un,ptr:At,size:[at,bt],datatype:ct}),an=[],jt=[],dn=0;dn<bt;dn++){At[dn]=un.length;for(var Nn=dn+1,Cn=0;Cn<ht;Cn++){var sn=Ve[Cn][dn];if(!Re(sn,Nt))for(var dr=Ce[Cn+1],Ln=Ce[Cn];Ln<dr;Ln++){var sr=Ie[Ln];jt[sr]!==Nn?(jt[sr]=Nn,un.push(sr),an[sr]=Ft(sn,be[Ln])):an[sr]=Ge(an[sr],Ft(sn,be[Ln]))}}for(var wt=un.length,Qt=At[dn];Qt<wt;Qt++)Ut[Qt]=an[un[Qt]]}return At[bt]=un.length,qt},"SparseMatrix, SparseMatrix":function ee(ne,X){var Ft,be=ne._values,Ie=ne._index,Ce=ne._ptr,fe=ne._datatype,Ve=X._values,qe=X._index,at=X._ptr,ht=X._datatype,bt=ne._size[0],ct=X._size[1],Ge=be&&Ve,Re=m,Nt=y;fe&&ht&&fe===ht&&"string"==typeof fe&&(Re=f.find(m,[Ft=fe,Ft]),Nt=f.find(y,[Ft,Ft]));for(var dn,Cn,sn,dr,Ln,sr,Ut=Ge?[]:void 0,un=[],At=[],qt=ne.createSparseMatrix({values:Ut,index:un,ptr:At,size:[bt,ct],datatype:Ft}),an=Ge?[]:void 0,jt=[],st=0;st<ct;st++){At[st]=un.length;var wt=st+1;for(dr=at[st+1],sn=at[st];sn<dr;sn++)if(sr=qe[sn],Ge)for(Cn=Ce[sr+1],dn=Ce[sr];dn<Cn;dn++)jt[Ln=Ie[dn]]!==wt?(jt[Ln]=wt,un.push(Ln),an[Ln]=Nt(Ve[sn],be[dn])):an[Ln]=Re(an[Ln],Nt(Ve[sn],be[dn]));else for(Cn=Ce[sr+1],dn=Ce[sr];dn<Cn;dn++)jt[Ln=Ie[dn]]!==wt&&(jt[Ln]=wt,un.push(Ln));if(Ge)for(var Zt=un.length,vn=At[st];vn<Zt;vn++)Ut[vn]=an[un[vn]]}return At[ct]=un.length,qt}});return f(lS,Ss({"Array, Array":function(X,be){T(ei(X),ei(be));var Ie=this(d(X),d(be));return Cr(Ie)?Ie.valueOf():Ie},"Matrix, Matrix":function(X,be){var Ie=X.size(),Ce=be.size();return T(Ie,Ce),1===Ie.length?1===Ce.length?function E(ne,X,be){if(0===be)throw new Error("Cannot multiply two empty vectors");return I(ne,X)}(X,be,Ie[0]):function S(ne,X){if("dense"!==X.storage())throw new Error("Support for SparseMatrix not implemented");return function R(ne,X){var bt,be=ne._data,Ce=ne._datatype,fe=X._data,qe=X._datatype,at=ne._size[0],ht=X._size[1],ct=m,Ge=y;Ce&&qe&&Ce===qe&&"string"==typeof Ce&&(ct=f.find(m,[bt=Ce,bt]),Ge=f.find(y,[bt,bt]));for(var Ft=[],Re=0;Re<ht;Re++){for(var Nt=Ge(be[0],fe[0][Re]),Ut=1;Ut<at;Ut++)Nt=ct(Nt,Ge(be[Ut],fe[Ut][Re]));Ft[Re]=Nt}return ne.createDenseMatrix({data:Ft,size:[ht],datatype:bt})}(ne,X)}(X,be):1===Ce.length?P(X,be):F(X,be)},"Matrix, Array":function(X,be){return this(X,d(be))},"Array, Matrix":function(X,be){return this(d(X,be.storage()),be)},"SparseMatrix, any":function(X,be){return C(X,be,y,!1)},"DenseMatrix, any":function(X,be){return A(X,be,y,!1)},"any, SparseMatrix":function(X,be){return C(be,X,y,!0)},"any, DenseMatrix":function(X,be){return A(be,X,y,!0)},"Array, any":function(X,be){return A(d(X),be,y,!1).valueOf()},"any, Array":function(X,be){return A(d(be),X,y,!0).valueOf()},"any, any":y,"any, any, ...any":function(X,be,Ie){for(var Ce=this(X,be),fe=0;fe<Ie.length;fe++)Ce=this(Ce,Ie[fe]);return Ce}},y.signatures))}),Q1=ot("det",["typed","matrix","subtract","multiply","divideScalar","isZero","unaryMinus"],c=>{var{typed:f,matrix:d,subtract:m,multiply:y,divideScalar:b,isZero:I,unaryMinus:C}=c;return f("det",{any:function(E){return ir(E)},"Array | Matrix":function(E){var S;switch((S=Cr(E)?E.size():Array.isArray(E)?(E=d(E)).size():[]).length){case 0:return ir(E);case 1:if(1===S[0])return ir(E.valueOf()[0]);throw new RangeError("Matrix must be square (size: "+ii(S)+")");case 2:var R=S[0];if(R===S[1])return function A(T,E,S){if(1===E)return ir(T[0][0]);if(2===E)return m(y(T[0][0],T[1][1]),y(T[1][0],T[0][1]));for(var R=!1,P=new Array(E).fill(0).map((be,Ie)=>Ie),F=0;F<E;F++){var B=P[F];if(I(T[B][F])){var J=void 0;for(J=F+1;J<E;J++)if(!I(T[P[J]][F])){B=P[J],P[J]=P[F],P[F]=B,R=!R;break}if(J===E)return T[B][F]}for(var j=T[B][F],oe=0===F?1:T[P[F-1]][F-1],G=F+1;G<E;G++)for(var ee=P[G],ne=F+1;ne<E;ne++)T[ee][ne]=b(m(y(T[ee][ne],j),y(T[ee][F],T[B][ne])),oe)}var X=T[P[E-1]][E-1];return R?C(X):X}(E.clone().valueOf(),R);throw new RangeError("Matrix must be square (size: "+ii(S)+")");default:throw new RangeError("Matrix must be two dimensional (size: "+ii(S)+")")}}})}),BS=ot("quantileSeq",["typed","add","multiply","partitionSelect","compare"],c=>{var{typed:f,add:d,multiply:m,partitionSelect:y,compare:b}=c;function C(T,E,S){var R=ti(T),P=R.length;if(0===P)throw new Error("Cannot calculate quantile of an empty sequence");if(Qr(E)){var F=E*(P-1),B=F%1;if(0===B){var J=S?R[F]:y(R,F);return A(J),J}var oe,G,j=Math.floor(F);if(S)oe=R[j],G=R[j+1];else{G=y(R,j+1),oe=R[j];for(var ee=0;ee<j;++ee)b(R[ee],oe)>0&&(oe=R[ee])}return A(oe),A(G),d(m(oe,1-B),m(G,B))}var ne=E.times(P-1);if(ne.isInteger()){ne=ne.toNumber();var X=S?R[ne]:y(R,ne);return A(X),X}var fe,Ve,be=ne.floor(),Ie=ne.minus(be),Ce=be.toNumber();if(S)fe=R[Ce],Ve=R[Ce+1];else{Ve=y(R,Ce+1),fe=R[Ce];for(var qe=0;qe<Ce;++qe)b(R[qe],fe)>0&&(fe=R[qe])}A(fe),A(Ve);var at=new Ie.constructor(1);return d(m(fe,at.minus(Ie)),m(Ve,Ie))}var A=f({"number | BigNumber | Unit":function(E){return E}});return function I(T,E,S){var R,P,F;if(arguments.length<2||arguments.length>3)throw new SyntaxError("Function quantileSeq requires two or three parameters");if(Qc(T)){if("boolean"==typeof(S=S||!1)){if(P=T.valueOf(),Qr(E)){if(E<0)throw new Error("N/prob must be non-negative");if(E<=1)return C(P,E,S);if(E>1){if(!Qn(E))throw new Error("N must be a positive integer");var B=E+1;R=new Array(E);for(var J=0;J<E;)R[J]=C(P,++J/B,S);return R}}if(Gn(E)){var j=E.constructor;if(E.isNegative())throw new Error("N/prob must be non-negative");if(F=new j(1),E.lte(F))return new j(C(P,E,S));if(E.gt(F)){if(!E.isInteger())throw new Error("N must be a positive integer");var oe=E.toNumber();if(oe>4294967295)throw new Error("N must be less than or equal to 2^32-1, as that is the maximum length of an Array");var G=new j(oe+1);R=new Array(oe);for(var ee=0;ee<oe;)R[ee]=new j(C(P,new j(++ee).div(G),S));return R}}if(Array.isArray(E)){R=new Array(E.length);for(var ne=0;ne<R.length;++ne){var X=E[ne];if(Qr(X)){if(X<0||X>1)throw new Error("Probability must be between 0 and 1, inclusive")}else{if(!Gn(X))throw new TypeError("Unexpected type of argument in function quantileSeq");if(F=new X.constructor(1),X.isNegative()||X.gt(F))throw new Error("Probability must be between 0 and 1, inclusive")}R[ne]=C(P,X,S)}return R}throw new TypeError("Unexpected type of argument in function quantileSeq")}throw new TypeError("Unexpected type of argument in function quantileSeq")}throw new TypeError("Unexpected type of argument in function quantileSeq")}}),yD=ot("inv",["typed","matrix","divideScalar","addScalar","multiply","unaryMinus","det","identity","abs"],c=>{var{typed:f,matrix:d,divideScalar:m,addScalar:y,multiply:b,unaryMinus:I,det:C,identity:A,abs:T}=c;return f("inv",{"Array | Matrix":function(R){var P=Cr(R)?R.size():ei(R);switch(P.length){case 1:if(1===P[0])return Cr(R)?d([m(1,R.valueOf()[0])]):[m(1,R[0])];throw new RangeError("Matrix must be square (size: "+ii(P)+")");case 2:var F=P[0],B=P[1];if(F===B)return Cr(R)?d(E(R.valueOf(),F,B),R.storage()):E(R,F,B);throw new RangeError("Matrix must be square (size: "+ii(P)+")");default:throw new RangeError("Matrix must be two dimensional (size: "+ii(P)+")")}},any:function(R){return m(1,R)}});function E(S,R,P){var F,B,J,j,oe;if(1===R){if(0===(j=S[0][0]))throw Error("Cannot calculate inverse, determinant is zero");return[[m(1,j)]]}if(2===R){var G=C(S);if(0===G)throw Error("Cannot calculate inverse, determinant is zero");return[[m(S[1][1],G),m(I(S[0][1]),G)],[m(I(S[1][0]),G),m(S[0][0],G)]]}var ee=S.concat();for(F=0;F<R;F++)ee[F]=ee[F].concat();for(var ne=A(R).valueOf(),X=0;X<P;X++){var be=T(ee[X][X]),Ie=X;for(F=X+1;F<R;)T(ee[F][X])>be&&(be=T(ee[F][X]),Ie=F),F++;if(0===be)throw Error("Cannot calculate inverse, determinant is zero");(F=Ie)!==X&&(oe=ee[X],ee[X]=ee[F],ee[F]=oe,oe=ne[X],ne[X]=ne[F],ne[F]=oe);var Ce=ee[X],fe=ne[X];for(F=0;F<R;F++){var Ve=ee[F],qe=ne[F];if(F!==X){if(0!==Ve[X]){for(J=m(I(Ve[X]),Ce[X]),B=X;B<P;B++)Ve[B]=y(Ve[B],b(J,Ce[B]));for(B=0;B<P;B++)qe[B]=y(qe[B],b(J,fe[B]))}}else{for(J=Ce[X],B=X;B<P;B++)Ve[B]=m(Ve[B],J);for(B=0;B<P;B++)qe[B]=m(qe[B],J)}}}return ne}}),lE=ot("divide",["typed","matrix","multiply","equalScalar","divideScalar","inv"],c=>{var{typed:f,matrix:d,multiply:m,equalScalar:y,divideScalar:b,inv:I}=c,C=nu({typed:f,equalScalar:y}),A=Ji({typed:f});return f("divide",Ss({"Array | Matrix, Array | Matrix":function(E,S){return m(E,I(S))},"DenseMatrix, any":function(E,S){return A(E,S,b,!1)},"SparseMatrix, any":function(E,S){return C(E,S,b,!1)},"Array, any":function(E,S){return A(d(E),S,b,!1).valueOf()},"any, Array | Matrix":function(E,S){return m(E,I(S))}},b.signatures))}),vO=ot("median",["typed","add","divide","compare","partitionSelect"],c=>{var{typed:f,add:d,divide:m,compare:y,partitionSelect:b}=c;function I(T){try{var E=(T=ti(T.valueOf())).length;if(0===E)throw new Error("Cannot calculate median of an empty array");if(E%2==0){for(var S=E/2-1,R=b(T,S+1),P=T[S],F=0;F<S;++F)y(T[F],P)>0&&(P=T[F]);return A(P,R)}var B=b(T,(E-1)/2);return C(B)}catch(J){throw function wu(c,f,d){var m;return-1!==String(c).indexOf("Unexpected type")?(m=arguments.length>2?" (type: "+es(d)+", value: "+JSON.stringify(d)+")":" (type: "+c.data.actual+")",new TypeError("Cannot calculate "+f+", unexpected type of argument"+m)):-1!==String(c).indexOf("complex numbers")?(m=arguments.length>2?" (type: "+es(d)+", value: "+JSON.stringify(d)+")":"",new TypeError("Cannot calculate "+f+", no ordering relation is defined for complex numbers"+m)):c}(J,"median")}}var C=f({"number | BigNumber | Complex | Unit":function(E){return E}}),A=f({"number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit":function(E,S){return m(d(E,S),2)}});return f("median",{"Array | Matrix":I,"Array | Matrix, number | BigNumber":function(E,S){throw new Error("median(A, dim) is not yet supported")},"...":function(E){if(function Qd(c){for(var f=0;f<c.length;f++)if(Qc(c[f]))return!0;return!1}(E))throw new TypeError("Scalar values expected in function median");return I(E)}})}),Sn=Lo({config:fn}),ds=Kl({}),us=vw({}),Mm=Wd({}),pr=tA({Matrix:Mm}),Et=uv({BigNumber:Sn,Complex:ds,DenseMatrix:pr,Fraction:us}),sc=_t({typed:Et}),wo=wA({typed:Et}),Dm=Jw({BigNumber:Sn,typed:Et}),yd=l_({typed:Et}),si=d_({config:fn,typed:Et}),G0=_h({typed:Et}),Xa=Tc({typed:Et}),oc=cT({typed:Et}),xp=P_({Matrix:Mm,equalScalar:si,typed:Et}),Cx=MT({typed:Et}),eh=bu({typed:Et}),Hu=VT({Fraction:us,typed:Et}),kh=td({typed:Et}),Dn=Z_({DenseMatrix:pr,Matrix:Mm,SparseMatrix:xp,typed:Et}),bp=gm({bignumber:Dm,fraction:Hu,number:oc}),mi=sM({matrix:Dn,config:fn,typed:Et}),tr=dN({DenseMatrix:pr,addScalar:wo,equalScalar:si,matrix:Dn,typed:Et,unaryMinus:eh}),X0=EM({BigNumber:Sn,DenseMatrix:pr,Fraction:us,config:fn,equalScalar:si,matrix:Dn,typed:Et}),Fa=DM({numeric:bp,typed:Et}),th=LN({compare:X0,isNaN:Cx,isNumeric:kh,typed:Et}),Nu=nR({DenseMatrix:pr,SparseMatrix:xp,addScalar:wo,equalScalar:si,matrix:Dn,typed:Et}),Z0=A0({addScalar:wo,conj:yd,multiplyScalar:Xa,size:mi,typed:Et}),ha=xR({BigNumber:Sn,DenseMatrix:pr,SparseMatrix:xp,config:fn,matrix:Dn,typed:Et}),ru=TR({addScalar:wo,dot:Z0,equalScalar:si,matrix:Dn,multiplyScalar:Xa,typed:Et}),lk=Q1({divideScalar:Fa,isZero:G0,matrix:Dn,multiply:ru,subtract:tr,typed:Et,unaryMinus:eh}),j0=BS({add:Nu,compare:X0,multiply:ru,partitionSelect:th,typed:Et}),ty=vO({add:Nu,compare:X0,divide:lE({divideScalar:Fa,equalScalar:si,inv:yD({abs:sc,addScalar:wo,det:lk,divideScalar:Fa,identity:ha,matrix:Dn,multiply:ru,typed:Et,unaryMinus:eh}),matrix:Dn,multiply:ru,typed:Et}),partitionSelect:th,typed:Et});class Bm extends Wo{constructor({strategy:f="mean",constant:d,quantile:m}={}){super(),H(this,"strategy",void 0),H(this,"constant",void 0),H(this,"quantile",void 0),H(this,"name","DummyRegressor"),H(this,"tf",void 0),this.tf=Ae(),this.strategy=f,this.constant=d,this.quantile=m}fit(f,d){ie(Pe(d),"y variable can not be converted to a 1D Tensor."),ie(["mean","median","constant","quantile"].includes(this.strategy),`Strategy ${this.strategy} not supported. We support 'mean', 'median', 'constant', and 'quantile'`);const m=kt(d);return"mean"===this.strategy?(this.constant=m.mean().dataSync()[0],this):"median"===this.strategy?(this.constant=ty(m.arraySync()),this):"quantile"===this.strategy?(ie("number"==typeof this.quantile&&!isNaN(this.quantile)&&isFinite(this.quantile),"quantile is not set to a number. Please set it to a value between 0 and 1 in the constructor"),ie(this.quantile<0||this.quantile>1,"quantile must be set to a value between 0 and 1"),this.constant=j0(m.arraySync(),this.quantile),this):this}predict(f){ie(Z(f),"Data can not be converted to a 2D matrix.");let m=rt(f).shape[0];return this.tf.tensor1d(Array(m).fill(this.constant))}}function yI(c){for(var d,f=new Map,m=0,y=0;y<c.length;y++){var b=f.get(c[y]);void 0===b?b=1:b++,b>m&&(d=c[y],m=b),f.set(c[y],b)}if(0===m)throw new Error("mode requires at last one data point");return d}var iy=function(){this.totalCount=0,this.data={}};iy.prototype.train=function(f,d){for(var m in this.data[d]||(this.data[d]={}),f){var y=f[m];void 0===this.data[d][m]&&(this.data[d][m]={}),void 0===this.data[d][m][y]&&(this.data[d][m][y]=0),this.data[d][m][y]++}this.totalCount++},iy.prototype.score=function(f){var m,d={};for(var y in f){var b=f[y];for(m in this.data)d[m]={},d[m][y+"_"+b]=this.data[m][y]?(this.data[m][y][b]||0)/this.totalCount:0}var I={};for(m in d)for(var C in I[m]=0,d[m])I[m]+=d[m][C];return I};var Zx=function(){this.weights=[],this.bias=0};Zx.prototype.predict=function(f){if(f.length!==this.weights.length)return null;for(var d=0,m=0;m<this.weights.length;m++)d+=this.weights[m]*f[m];return(d+=this.bias)>0?1:0},Zx.prototype.train=function(f,d){if(0!==d&&1!==d)return null;f.length!==this.weights.length&&(this.weights=f,this.bias=1);var m=this.predict(f);if("number"==typeof m&&m!==d){for(var y=d-m,b=0;b<this.weights.length;b++)this.weights[b]+=y*f[b];this.bias+=y}return this},Math.log(Math.sqrt(2*Math.PI)),Math.sqrt(2*Math.PI);var OI=Math.sqrt(2*Math.PI);function eb(c){for(var f=c,d=c,m=1;m<15;m++)f+=d*=c*c/(2*m+1);return Math.round(1e4*(.5+f/OI*Math.exp(-c*c/2)))/1e4}for(var $c=[],tb=0;tb<=3.09;tb+=.01)$c.push(eb(tb));var w$=Y(8799),cy=Y.n(w$);class _$ extends fu{constructor({strategy:f="mostFrequent",constant:d=0}={}){super(),H(this,"constant",void 0),H(this,"strategy",void 0),H(this,"classes",void 0),H(this,"name","DummyClassifier"),H(this,"tf",void 0),this.tf=Ae(),this.constant=d,this.strategy=f,this.classes=[]}fit(f,d){ie(Pe(d),"Data can not be converted to a 1D or 2D matrix."),ie(["mostFrequent","uniform","constant"].includes(this.strategy),`Strategy ${this.strategy} not supported. We support 'mostFrequent', 'uniform', and 'constant'`);const m=kt(d);return this.classes=Gi()(m.arraySync()),"mostFrequent"===this.strategy?(this.constant=yI(m.arraySync()),this):this}predictProba(f){return ie(Z(f),"Data can not be converted to a 1D or 2D matrix."),ie(["mostFrequent","uniform","constant"].includes(this.strategy),`Strategy ${this.strategy} not supported. We support 'mostFrequent', 'uniform', and 'constant'`),this.tf.oneHot(this.predict(f).toInt(),this.classes.length)}predict(f){ie(Z(f),"Data can not be converted to a 1D or 2D matrix."),ie(["mostFrequent","uniform","constant"].includes(this.strategy),`Strategy ${this.strategy} not supported. We support 'mostFrequent', 'uniform', and 'constant'`);let m=rt(f).shape[0];if("mostFrequent"===this.strategy||"constant"===this.strategy)return this.tf.tensor1d(Array(m).fill(this.constant));let y=[];for(let b=0;b<m;b++)y.push(cy()(this.classes));return this.tf.tensor1d(y)}}function zI(c,f,d){let m=Ae();return d?m.tidy(()=>m.where(c.isNaN(),-1/0,c).max(f)):c.min(f)}function hy(c,f,d){let m=Ae();return d?m.tidy(()=>m.where(c.isNaN(),0,c).sum(f)):c.sum(f)}function py(c,f,d){let m=Ae();return d?m.tidy(()=>m.logicalNot(c.isNaN()).sum(f)):m.onesLike(c).sum(f)}function ab(c,f,d,m){let y=Ae();return d?y.tidy(m?()=>hy(c,f,d).div(Sd(py(c,f,d))):()=>hy(c,f,d).div(py(c,f,d))):c.mean(f)}function Sd(c){let f=Ae();return f.tidy(()=>{const d=f.zerosLike(c),m=c.equal(d);return c.add(m)})}class GI extends Cs{constructor({featureRange:f=[0,1]}={}){super(),H(this,"featureRange",void 0),H(this,"scale",void 0),H(this,"min",void 0),H(this,"dataMin",void 0),H(this,"dataMax",void 0),H(this,"dataRange",void 0),H(this,"nFeaturesIn",void 0),H(this,"nSamplesSeen",void 0),H(this,"featureNamesIn",void 0),H(this,"name","MinMaxScaler"),this.tf=Ae(),this.featureRange=f,this.scale=this.tf.tensor1d([]),this.min=this.tf.tensor1d([]),this.dataMin=this.tf.tensor1d([]),this.dataMax=this.tf.tensor1d([]),this.dataRange=this.tf.tensor1d([]),this.nFeaturesIn=0,this.nSamplesSeen=0,this.featureNamesIn=[]}isNumber(f){return"number"==typeof f&&isFinite(f)}fit(f){ie(Z(f),"Data can not be converted to a 2D matrix."),ie(this.isNumber(this.featureRange[0])&&this.isNumber(this.featureRange[1])&&this.featureRange[0]<this.featureRange[1],"featureRange needs to contain exactly two numbers where the first is less than the second");const d=rt(f),m=zI(d,0,!0),y=function N$(c,f,d){let m=Ae();return d?m.tidy(()=>m.where(c.isNaN(),1/0,c).min(f)):c.min(f)}(d,0,!0),b=m.sub(y);return this.scale=this.tf.div(this.featureRange[1]-this.featureRange[0],Sd(b)),this.min=this.tf.sub(this.featureRange[0],y.mul(this.scale)),this.dataMin=y,this.dataMax=m,this.dataRange=b,this.nSamplesSeen=d.shape[0],this.nFeaturesIn=d.shape[1],Se(f)&&(this.featureNamesIn=[...f.columns]),this}transform(f){return ie(Z(f),"Data can not be converted to a 2D matrix."),rt(f).mul(this.scale).add(this.min)}inverseTransform(f){return ie(Z(f),"Data can not be converted to a 2D matrix."),rt(f).sub(this.min).div(this.scale)}}class qI extends Cs{constructor({withMean:f=!0,withStd:d=!0}={}){super(),H(this,"scale",void 0),H(this,"mean",void 0),H(this,"withMean",void 0),H(this,"withStd",void 0),H(this,"nFeaturesIn",void 0),H(this,"nSamplesSeen",void 0),H(this,"featureNamesIn",void 0),H(this,"name","StandardScaler"),this.tf=Ae(),this.withMean=f,this.withStd=d,this.scale=this.tf.tensor1d([]),this.mean=this.tf.tensor1d([]),this.nFeaturesIn=0,this.nSamplesSeen=0,this.featureNamesIn=[]}fit(f){ie(Z(f),"Data can not be converted to a 2D matrix.");const d=rt(f);if(this.withMean&&(this.mean=ab(d,0,!0)),this.withStd){const m=function eP(c,f,d){return ie(Boolean(d),"We only need to call this function when ignoreNaN is true"),Ae().tidy(()=>{const y=ab(c,f,d),b=py(c,f,d),I=hy(c.sub(y).square(),f,d),C=Sd(b);return I.div(C).sqrt()})}(d,0,!0);this.scale=Sd(m)}return this.nSamplesSeen=d.shape[0],this.nFeaturesIn=d.shape[1],Se(f)&&(this.featureNamesIn=[...f.columns]),this}transform(f){ie(Z(f),"Data can not be converted to a 2D matrix.");let d=rt(f);return this.withMean&&(d=d.sub(this.mean)),this.withStd&&(d=d.div(this.scale)),d}inverseTransform(f){ie(Z(f),"Data can not be converted to a 2D matrix.");let d=rt(f);return this.withStd&&(d=d.mul(this.scale)),this.withMean&&(d=d.add(this.mean)),d}}class S$ extends Cs{constructor(){super(),H(this,"scale",void 0),H(this,"nFeaturesIn",void 0),H(this,"nSamplesSeen",void 0),H(this,"featureNamesIn",void 0),H(this,"name","MaxAbsScaler"),this.tf=Ae(),this.scale=this.tf.tensor1d([]),this.nFeaturesIn=0,this.nSamplesSeen=0,this.featureNamesIn=[]}fit(f){ie(Z(f),"Data can not be converted to a 2D matrix.");const d=rt(f),m=zI(d.abs(),0,!0);return this.scale=Sd(m),this.nSamplesSeen=d.shape[0],this.nFeaturesIn=d.shape[1],Se(f)&&(this.featureNamesIn=[...f.columns]),this}transform(f){return ie(Z(f),"Data can not be converted to a 2D matrix."),rt(f).div(this.scale)}inverseTransform(f){return ie(Z(f),"Data can not be converted to a 2D matrix."),rt(f).mul(this.scale)}}function ob(c){return c.filter(d=>!function tP(c){return null==c||isNaN(c)&&"string"!=typeof c}(d))}class my extends Cs{constructor({strategy:f="mean",fillValue:d,missingValues:m=NaN}={}){super(),H(this,"missingValues",void 0),H(this,"fillValue",void 0),H(this,"strategy",void 0),H(this,"statistics",void 0),H(this,"name","SimpleImputer"),H(this,"tf",void 0),this.tf=Ae(),this.missingValues=m,this.strategy=f,this.fillValue=d,this.statistics=this.tf.tensor1d([])}fit(f){if("constant"===this.strategy)return this;if("mean"===this.strategy){const m=ab(rt(f),0,!0);return this.statistics=m,this}if("mostFrequent"===this.strategy){const m=rt(f).transpose().arraySync().map(y=>yI(ob(y)));return this.statistics=this.tf.tensor1d(m),this}if("median"===this.strategy){const m=rt(f).transpose().arraySync().map(y=>ty(ob(y)));return this.statistics=this.tf.tensor1d(m),this}throw new Error(`Strategy ${this.strategy} is unsupported. Supported strategies are 'mean', 'median', 'mostFrequent', and 'constant'`)}transform(f){if("constant"===this.strategy){const m=Ct(f);return this.tf.where(m.isNaN(),void 0===this.fillValue?"string"!==m.dtype?0:"missing_value":this.fillValue,m)}const d=rt(f);return this.tf.where(d.isNaN(),this.statistics.reshape([1,-1]),d)}}class gy extends Zn{constructor(){super(),H(this,"classes",void 0),H(this,"name","LabelEncoder"),H(this,"tf",void 0),this.tf=Ae(),this.classes=[]}convertTo1DArray(f){return Ne(f)?f.values:$e(f)?f.arraySync():f}classesToMapping(f){const d=new Map;return f.forEach((m,y)=>{d.set(m,y)}),d}fit(f){const d=this.convertTo1DArray(f),m=Array.from(new Set(d));return this.classes=m,this}transform(f){const d=this.convertTo1DArray(f),m=this.classesToMapping(this.classes),y=d.map(b=>{let I=m.get(b);return void 0===I?-1:I});return this.tf.tensor1d(y)}fitTransform(f){return this.fit(f).transform(f)}inverseTransform(f){const d=this.convertTo1DArray(f),m=this.classesToMapping(this.classes),y=new Map(Array.from(m,I=>I.reverse()));return d.map(I=>void 0===y.get(I)?null:y.get(I))}}class WI extends Cs{constructor({categories:f="auto",handleUnknown:d="error",unknownValue:m=NaN}={}){super(),H(this,"categories",void 0),H(this,"handleUnknown",void 0),H(this,"unknownValue",void 0),H(this,"categoriesParam",void 0),H(this,"nFeaturesIn",void 0),H(this,"featureNamesIn",void 0),H(this,"name","OrdinalEncoder"),this.tf=Ae(),this.categoriesParam=f,this.categories=[],this.handleUnknown=d,this.unknownValue=m,this.nFeaturesIn=0,this.featureNamesIn=[]}classesToMapping(f){const d=new Map;return f.forEach((m,y)=>{d.set(m,y)}),d}loopOver2DArrayToSetLabels(f){for(let d=0;d<f[0].length;d++){let m=new Set;for(let b=0;b<f.length;b++)m.add(f[b][d]);let y=Array.from(m);this.categories.push(y)}}fit(f,d){const m=$t(f);return"auto"===this.categoriesParam?(this.loopOver2DArrayToSetLabels(m),this):(this.categories=this.categoriesParam,this.nFeaturesIn=0===m.length?0:m[0].length||0,Se(f)&&(this.featureNamesIn=[...f.columns]),this)}loopOver2DArrayToUseLabels(f){let d=this.categories.map(y=>this.classesToMapping(y)),m=[];for(let y=0;y<f.length;y++){let b=[];for(let I=0;I<f[0].length;I++){let C=f[y][I],A=d[I].get(C);if(void 0===A){if("error"===this.handleUnknown)throw new Error(`Unknown value ${C} encountered while transforming. Not encountered in training data`);A=this.unknownValue}b.push(A)}m.push(b)}return m}transform(f,d){const m=$t(f),y=this.loopOver2DArrayToUseLabels(m);return this.tf.tensor2d(y,void 0,"int32")}}class HI extends Cs{constructor({norm:f="l2"}={}){super(),H(this,"norm",void 0),H(this,"nFeaturesIn",void 0),H(this,"featureNamesIn",void 0),H(this,"name","Normalizer"),this.tf=Ae(),this.norm=f,this.nFeaturesIn=0,this.featureNamesIn=[]}fit(f){ie(Z(f),"Data can not be converted to a 2D matrix.");const d=rt(f);return this.nFeaturesIn=d.shape[1],Se(f)&&(this.featureNamesIn=[...f.columns]),this}transform(f){ie(Z(f),"Data can not be converted to a 2D matrix.");const d=rt(f);if("l1"===this.norm){const y=this.tf.abs(d).sum(1).reshape([-1,1]);return d.divNoNan(y)}if("l2"===this.norm){const y=d.square().sum(1).sqrt().reshape([-1,1]);return d.divNoNan(y)}const m=this.tf.abs(d).max(1).reshape([-1,1]);return d.divNoNan(m)}}class ub extends Zn{constructor({steps:f=[]}={}){super(),H(this,"steps",void 0),H(this,"name","Pipeline"),this.steps=f,this.validateSteps(this.steps)}isTransformer(f){return"passthrough"===f||"function"==typeof f.fit&&"function"==typeof f.transform&&"function"==typeof f.fitTransform}isEstimator(f){return"passthrough"===f||"function"==typeof f.fit}validateSteps(f){if(ie(Array.isArray(f),`steps is not an array. It is ${f}`),0===f.length)return;for(let m=0;m<f.length-1;m++){const y=f[m];ie(Array.isArray(y),`A single step in your pipeline must be an array containing a string as the first argument, and the transformer in the second. Something akin to ['minmaxscaler', new MinMaxScaler()]. Instead it is ${y}`),ie(this.isTransformer(y[1]),`The ${m}th step in your pipeline isn't an array containing a name and a Transformer. Instead it is ${f[m]}.`)}let d=f[f.length-1];ie(Array.isArray(d),`The last element in your pipeline must be a 2-element array that contains a string as the first argument, and an estimator as the second. Instead it is ${d}`),ie(this.isEstimator(d[1]),`The last element in your pipeline should be an Estimator. Instead it is ${d}`)}transformExceptLast(f){let d=f;for(let m=0;m<this.steps.length-1;m++){const[,y]=this.steps[m];"passthrough"!==y&&(d=y.transform(d))}return d}fitTransformExceptLast(f){let d=f;for(let m=0;m<this.steps.length-1;m++){const[,y]=this.steps[m];"passthrough"!==y&&(d=y.fitTransform(d))}return d}getLastEstimator(){return 0===this.steps.length?null:this.steps[this.steps.length-1][1]}assertEstimatorHasFunction(f,d){ie(null!==f,`Your final Estimator is null and therefore you can't call ${d}`),ie("function"==typeof f[d],`Estimator ${f} doesn't implement the function ${d}`)}fit(f,d){var m=this;return(0,he.Z)(function*(){m.validateSteps(m.steps);const y=m.getLastEstimator();m.assertEstimatorHasFunction(y,"fit");let b=m.fitTransformExceptLast(f);return yield y.fit(b,d),m})()}transform(f){this.validateSteps(this.steps);const d=this.getLastEstimator();this.assertEstimatorHasFunction(d,"transform");let m=this.transformExceptLast(f);return d.transform(m)}fitTransform(f,d){this.validateSteps(this.steps);const m=this.getLastEstimator();this.assertEstimatorHasFunction(m,"fitTransform");let y=this.fitTransformExceptLast(f);return m.fitTransform(y)}predict(f){this.validateSteps(this.steps);const d=this.getLastEstimator();this.assertEstimatorHasFunction(d,"predict");let m=this.transformExceptLast(f);return d.predict(m)}fitPredict(f,d){var m=this;return(0,he.Z)(function*(){m.validateSteps(m.steps);const y=m.getLastEstimator();m.assertEstimatorHasFunction(y,"fitPredict");let b=m.fitTransformExceptLast(f);return yield y.fitPredict(b,d)})()}}function XI(...c){let f=[];for(let d=0;d<c.length;d++){let m=c[d];f.push([m.name,m])}return new ub({steps:f})}function lb(c){return Array.isArray(c)&&"string"==typeof c[0]}class KI extends Zn{constructor({transformers:f=[],remainder:d="drop"}={}){super(),H(this,"transformers",void 0),H(this,"remainder",void 0),H(this,"name","ColumnTransformer"),H(this,"tf",void 0),this.tf=Ae(),this.transformers=f,this.remainder=d}fit(f,d){for(let m=0;m<this.transformers.length;m++){let[,y,b]=this.transformers[m],I=this.getColumns(f,b);y.fit(I,d)}return this}transform(f,d){let m=[];for(let y=0;y<this.transformers.length;y++){let[,b,I]=this.transformers[y],C=this.getColumns(f,I);m.push(b.transform(C,d))}return this.tf.concat(m,1)}fitTransform(f,d){let m=[];for(let y=0;y<this.transformers.length;y++){let[,b,I]=this.transformers[y],C=this.getColumns(f,I);m.push(b.fitTransform(C,d))}return this.tf.concat(m,1)}getColumns(f,d){if(Se(f))return lb(d)?f.loc({columns:d}).tensor:Array.isArray(d)?f.iloc({columns:d}).tensor:"string"==typeof d?f[d].tensor:f.iloc({columns:[d]}).tensor;if(lb(d)||"string"==typeof d)throw new Error("Can't pass string selected columns when not a DataFrame");if("number"==typeof d){let m=this.tf.tensor1d([d]);return f.gather(m,1)}{let m=this.tf.tensor1d(d);return f.gather(m,1)}}}function cb(c){return c.filter(d=>!function YI(c){return null==c||isNaN(c)&&"string"!=typeof c}(d))}class ZI extends Cs{constructor({quantileRange:f=[25,75],withCentering:d=!0,withScaling:m=!0}={}){super(),H(this,"scale",void 0),H(this,"center",void 0),H(this,"nFeaturesIn",void 0),H(this,"featureNamesIn",void 0),H(this,"quantileRange",void 0),H(this,"withScaling",void 0),H(this,"withCentering",void 0),H(this,"name","RobustScaler"),this.tf=Ae(),this.scale=this.tf.tensor1d([]),this.center=this.tf.tensor1d([]),this.quantileRange=f,this.withScaling=m,this.withCentering=d,this.nFeaturesIn=0,this.featureNamesIn=[]}isNumber(f){return"number"==typeof f&&isFinite(f)}fit(f){ie(Z(f),"Data can not be converted to a 2D matrix."),ie(this.isNumber(this.quantileRange[0])&&this.isNumber(this.quantileRange[1]),"quantileRange values must be numbers");let d=this.quantileRange[0],m=this.quantileRange[1];ie(d<m&&0<=d&&d<=100&&0<=m&&m<=100,"quantileRange numbers must be between 0 and 100");const y=rt(f),b=y.transpose().arraySync();if(this.withCentering){const I=b.map(C=>j0(cb(C),.5));this.center=this.tf.tensor1d(I)}if(this.withScaling){const I=b.map(A=>j0(cb(A),[d/100,m/100])),C=this.tf.tensor1d(I.map(A=>A[1]-A[0]));this.scale=Sd(C)}return this.nFeaturesIn=y.shape[1],Se(f)&&(this.featureNamesIn=[...f.columns]),this}transform(f){ie(Z(f),"Data can not be converted to a 2D matrix.");let d=rt(f);return this.withCentering&&(d=d.sub(this.center)),this.withScaling&&(d=d.div(this.scale)),d}inverseTransform(f){ie(Z(f),"Data can not be converted to a 2D matrix.");let d=rt(f);return this.withScaling&&(d=d.mul(this.scale)),this.withCentering&&(d=d.add(this.center)),d}}class jI extends Zn{constructor({nClusters:f=8,init:d="random",maxIter:m=300,tol:y=1e-4,nInit:b=10,randomState:I}={}){super(),H(this,"nClusters",void 0),H(this,"init",void 0),H(this,"nInit",void 0),H(this,"maxIter",void 0),H(this,"tol",void 0),H(this,"randomState",void 0),H(this,"clusterCenters",void 0),H(this,"name","KMeans"),H(this,"tf",void 0),this.tf=Ae(),this.nClusters=f,this.init=d,this.maxIter=m,this.tol=y,this.randomState=I,this.nInit=b,this.clusterCenters=this.tf.tensor2d([[]])}initCentroids(f){if("random"!==this.init)throw new Error(`init ${this.init} is not currently implemented`);{let d=Bn(f.shape[0],this.nClusters,this.randomState);this.clusterCenters=this.tf.gather(f,d)}}closestCentroid(f){return this.tf.tidy(()=>{const d=this.tf.expandDims(f,1),m=this.tf.expandDims(this.clusterCenters,0);return this.tf.squaredDifference(d,m).sum(2).argMin(1)})}updateCentroids(f,d){return this.tf.tidy(()=>{const m=[];for(let y=0;y<this.nClusters;y++){const b=this.tf.equal(d,this.tf.scalar(y).toInt()),I=this.tf.div(this.tf.sum(this.tf.mul(this.tf.expandDims(b.toFloat(),1),f),0),this.tf.sum(b.toFloat()));m.push(I)}return this.tf.stack(m)})}fit(f){let d=rt(f);this.initCentroids(d);for(let m=0;m<this.maxIter;m++){const y=this.closestCentroid(d);this.clusterCenters=this.updateCentroids(d,y)}return this}predict(f){let d=rt(f);return this.closestCentroid(d)}transform(f){return this.tf.tidy(()=>{const d=rt(f),m=this.tf.expandDims(d,1),y=this.tf.expandDims(this.clusterCenters,0);return this.tf.squaredDifference(m,y).sum(2).sqrt()})}fitPredict(f){return this.fit(f).predict(f)}fitTransform(f){return this.fit(f).transform(f)}score(f){return this.tf.tidy(()=>{const d=rt(f),m=this.tf.expandDims(d,1),y=this.tf.expandDims(this.clusterCenters,0);return this.tf.squaredDifference(m,y).sum(2).min(1).sqrt().sum()})}}const JI={loadBoston:"http://scikitjs.org/data/boston.csv",loadIris:"http://scikitjs.org/data/iris.csv",loadWine:"http://scikitjs.org/data/wine.csv",loadDiabetes:"http://scikitjs.org/data/diabetes.csv",loadBreastCancer:"http://scikitjs.org/data/breast_cancer.csv",loadDigits:"http://scikitjs.org/data/digits.csv",fetchCaliforniaHousing:"http://scikitjs.org/data/california_housing.csv"};class fb extends Wo{constructor({estimators:f=[],weights:d}={}){super(),H(this,"estimators",void 0),H(this,"weights",void 0),H(this,"name","VotingRegressor"),this.tf=Ae(),this.estimators=f,this.weights=d}fit(f,d){var m=this;return(0,he.Z)(function*(){for(let y=0;y<m.estimators?.length;y++){let[b,I]=m.estimators[y];yield I.fit(f,d)}return m})()}predict(f){let d=[],m=this.estimators.length;const y=this.weights||Array(m).fill(1/m);for(let b=0;b<m;b++){let[I,C]=this.estimators[b],A=y[b];d.push(C.predict(f).mul(A))}return this.tf.addN(d)}transform(f){let d=[],m=this.estimators.length;for(let y=0;y<m;y++){let[b,I]=this.estimators[y];d.push(I.predict(f))}return d}fitTransform(f,d){var m=this;return(0,he.Z)(function*(){return(yield m.fit(f,d)).transform(f)})()}}function QI(...c){let f=[];for(let d=0;d<c.length;d++){let m=c[d];f.push([m.name,m])}return new fb({estimators:f})}class hb extends fu{constructor({estimators:f=[],weights:d,voting:m="hard"}={}){super(),H(this,"estimators",void 0),H(this,"weights",void 0),H(this,"le",void 0),H(this,"name","VotingClassifier"),H(this,"tf",void 0),this.tf=Ae(),this.estimators=f,this.weights=d,this.voting=m,this.le=new gy}fit(f,d){var m=this;return(0,he.Z)(function*(){let y=m.le.fitTransform(d);for(let b=0;b<m.estimators?.length;b++){let[I,C]=m.estimators[b];yield C.fit(f,y)}return m})()}predictProba(f){let d=[],m=this.estimators.length;const y=this.weights||Array(m).fill(1/m);for(let b=0;b<m;b++){let[I,C]=this.estimators[b],A=y[b];d.push(C.predictProba(f).mul(A))}return this.tf.addN(d)}predict(f){let d=[],m=this.estimators.length;const y=this.weights||Array(m).fill(1/m);if("hard"===this.voting){for(let b=0;b<m;b++){let[I,C]=this.estimators[b],A=y[b],T=C.predict(f).toInt(),E=this.tf.oneHot(T,this.le.classes.length);d.push(E.mul(A))}return this.tf.tensor1d(this.le.inverseTransform(this.tf.addN(d).argMax(1)))}for(let b=0;b<m;b++){let[I,C]=this.estimators[b],A=y[b],T=C.predictProba(f);d.push(T.mul(A))}return this.tf.tensor1d(this.le.inverseTransform(this.tf.addN(d).argMax(1)))}transform(f){let d=[],m=this.estimators.length;if("hard"===this.voting){for(let y=0;y<m;y++){let[b,I]=this.estimators[y];d.push(I.predict(f))}return d}for(let y=0;y<m;y++){let[b,I]=this.estimators[y];d.push(I.predictProba(f))}return d}fitTransform(f,d){var m=this;return(0,he.Z)(function*(){return(yield m.fit(f,d)).transform(f)})()}}function eC(...c){let f=[];for(let d=0;d<c.length;d++){let m=c[d];f.push([m.name,m])}return new hb({estimators:f})}class tC{constructor({metric:f,entries:d}){H(this,"_metric",void 0),H(this,"_entries",void 0),H(this,"tf",void 0),this._metric=f,this._entries=d,this.tf=Ae()}kNearest(f,d){const{_metric:m,_entries:y}=this;return ie(y.shape[1]==d.shape[1],"X_train.shape[1] must equal X_predict.shape[1]"),this.tf.tidy(()=>{const b=this.tf.unstack(d).map(I=>this.tf.tidy(()=>{const C=m.tensorDistance(I,y).neg(),{values:A,indices:T}=this.tf.topk(C,f);return[A,T]}));return{distances:this.tf.stack(b.map(I=>I[0])).neg(),indices:this.tf.stack(b.map(I=>I[1]))}})}}const Hm=c=>(f,d)=>{let m=Ae();return ie((f.shape[f.rank-1]??NaN)===(d.shape[d.rank-1]??NaN),`minkowskiDistance(${c}).tensorDistance(u,v): u.shape[-1] must equal v.shape[-1].`),m.tidy(()=>m.norm(m.sub(f,d),c,-1))},yy=c=>{switch(c){case 1:return nP;case 2:return nC;case 1/0:return rC}ie(1<=c,"minkowskiMetric(p): Invalid p.");const f={tensorDistance:Hm(c),distance(d,m){const y=d.length;if(y!==m.length)throw new Error(`minkowskiMetric(${c}).treeMetric(u,v): u and v must have same length.`);let b=0;for(let I=0;I<y;I++)b+=Math.abs(d[I]-m[I])**c;return b**(1/c)},distToBBox(d,m){if(2*d.length!=m.length)throw new Error(`minkowskiMetric(${c}).treeMetric.minDistToBBox(pt,bBox): pt.length*2 must equal bBox.length.`);let y=0;for(let b=0,I=0;I<d.length;I++)y+=Math.max(0,m[b++]-d[I],d[I]-m[b++])**c;return y**(1/c)},name:`minkowskiMetric(${c})`,toString(){return this.name}};return Object.freeze(f)},nP=Object.freeze({tensorDistance:Hm(1),distance(c,f){const d=c.length;if(d!==f.length)throw new Error("minkowskiMetric(1).distance(u,v): u and v must have same length.");let m=0;for(let y=0;y<d;y++)m+=Math.abs(c[y]-f[y]);return m},minDistToBBox(c,f){const d=f.length;if(d!==c.length<<1)throw new Error("minkowskiMetric(1).minDistToBBox(pt,bBox): pt.length*2 must equal bBox.length.");let m=0;for(let y=0;y<d;){const b=c[y>>>1],I=f[y++]-b,C=b-f[y++];m+=.5*(Math.abs(I)+I+(Math.abs(C)+C))}return m},name:"manhattanMetric",toString(){return this.name}}),nC=Object.freeze({tensorDistance:Hm(2),distance(c,f){const d=c.length;if(d!==f.length)throw new Error("minkowskiMetric(2).distance(u,v): u and v must have same length.");let m=0;for(let y=0;y<d;y++){const b=c[y]-f[y];m+=b*b}return Math.sqrt(m)},minDistToBBox(c,f){const d=f.length;if(d!==2*c.length)throw new Error("minkowskiMetric(2).minDistToBBox(pt,bBox): pt.length*2 must equal bBox.length.");let m=0;for(let y=0;y<d;){const b=c[y>>>1],I=f[y++]-b,C=b-f[y++],A=.5*(Math.abs(I)+I+(Math.abs(C)+C));m+=A*A}return Math.sqrt(m)},name:"euclideanMetric",toString(){return this.name}}),rC=Object.freeze({tensorDistance:Hm(1/0),distance(c,f){const d=c.length;if(d!==f.length)throw new Error("minkowskiMetric(Infinity).distance(u,v): u and v must have same length.");let m=0;for(let y=0;y<d;y++){const b=Math.abs(c[y]-f[y]);m=Math.max(m,b)}return m},minDistToBBox(c,f){const d=f.length;if(d!==2*c.length)throw new Error("minkowskiMetric(Infinity).minDistToBBox(pt,bBox): pt.length*2 must equal bBox.length.");let m=-1/0;for(let y=0;y<d;){const b=c[y>>>1],I=f[y++]-b,C=b-f[y++],A=.5*(Math.abs(I)+I+(Math.abs(C)+C));m=Math.max(m,A)}return m},name:"chebyshevMetric",toString(){return this.name}});function iC(c,f){let d=new sC(c),m=()=>d.next();return function rP(c,f,d){let m=d&&d.state;m&&("object"==typeof m&&f.copy(m,f),c.state=()=>f.copy(f,{}))}(m,d,f),m}class sC{constructor(f){H(this,"c",void 0),H(this,"s0",void 0),H(this,"s1",void 0),H(this,"s2",void 0),null==f&&(f=+new Date);let d=4022871197;function m(y){y=String(y);for(let b=0;b<y.length;b++){d+=y.charCodeAt(b);let I=.02519603282416938*d;d=I>>>0,I-=d,I*=d,d=I>>>0,I-=d,d+=4294967296*I}return 2.3283064365386963e-10*(d>>>0)}this.c=1,this.s0=m(" "),this.s1=m(" "),this.s2=m(" "),this.s0-=m(f),this.s0<0&&(this.s0+=1),this.s1-=m(f),this.s1<0&&(this.s1+=1),this.s2-=m(f),this.s2<0&&(this.s2+=1)}next(){let{c:f,s0:d,s1:m,s2:y}=this,b=2091639*d+2.3283064365386963e-10*f;return this.s0=m,this.s1=y,this.s2=b-(this.c=0|b)}copy(f,d){return d.c=f.c,d.s0=f.s0,d.s1=f.s1,d.s2=f.s2,d}}const vy=c=>(f,d)=>{if(f>=d)throw new Error("randInt(rng)(from,until): from must be less than until.");const m=Math.floor(f+(d-f)*c());return m===d?m-1:m};class oC{constructor(f,d){H(this,"_keys",void 0),H(this,"_vals",void 0),H(this,"_pos",void 0);const m=f.length;ie(m>0,"new CappedMaxHeap(keys,vals): keys.length must be positive."),ie(m===d.length,"new CappedMaxHeap(keys,vals): keys.length must equal vals.length."),f[0]=NaN,this._keys=f,this._vals=d,this._pos=m}get maxKey(){return this._keys[0]}add(f,d){let{_keys:m,_vals:y,_pos:b}=this;if(0<b)this._pos=--b;else if(m[0]<=f)return;const I=m.length-1;for(;;){let C=1+(b<<1);if(C>I||(C+=+(C<I&&m[C]<m[C+1]),m[C]<=f))break;m[b]=m[C],y[b]=y[C],b=C}m[b]=f,y[b]=d}sort(){const{_keys:f,_vals:d,_pos:m}=this;ie(0===m,"CappedMaxHeap().sort(): Heap is not full yet.");const y=(A,T)=>{let E=f[A];f[A]=f[T],f[T]=E;let S=d[A];d[A]=d[T],d[T]=S},b=A=>{f[A]>f[A+1]&&y(A,A+1)},I=A=>{b(A),f[A+1]>f[A+2]&&(y(A+1,A+2),b(A))},C=(A,T)=>{switch(T-A){case 0:case 1:return;case 2:return b(A);case 3:return I(A)}const E=A+T>>>1;I(E-1);const S=f[E];y(A,E);let R=A,P=A+1;for(let F=P;F<T;F++){let B=f[F];B<=S&&(y(F,P),B<S&&y(R++,P),P++)}C(A,R),C(P,T)};C(0,f.length)}}const uC=c=>1+(c<<1);class xy{constructor(f,d,m,y,b,I,C){H(this,"_nSamples",void 0),H(this,"_nFeatures",void 0),H(this,"_metric",void 0),H(this,"_points",void 0),H(this,"_indices",void 0),H(this,"_bBoxes",void 0),H(this,"_offsets",void 0),H(this,"tf",void 0),this.tf=Ae(),this._nSamples=f,this._nFeatures=d,this._metric=m,this._points=y,this._bBoxes=b,this._offsets=I,this._indices=C,Object.freeze(this)}static build({metric:f,entries:d,leafSize:m=16}){return(0,he.Z)(function*(){ie(1<m,"new KdTree({leafSize=16}): leafSize must be a positive number."),ie("function"==typeof f.minDistToBBox,"new KdTree({metric}): metric must implement `minDistToBBox` function.");const[y,b]=d.shape,I=new Int32Array(y);for(let oe=0;oe<y;oe++)I[oe]=oe;const C=(yield d.data()).slice(),A=Array.from(I,(oe,G)=>C.subarray(b*G,b*++G)),T=(ie(0<=(c=y/m)&&c<=1073741824,"ceilPow2(x): x must be in range [0, 1<<30]."),c=Math.ceil(c),c=Math.max(c,1),2147483648>>>-1+Math.clz32(c-1)),E=2*T-1,S=E-T,R=new Int32Array(T+1),P=function(){const oe=2*b,G=new Float32Array(E*oe),ee=[];for(let ne=0;ne<E;)ee.push(G.subarray(oe*ne,oe*++ne));return ee}(),F=vy(iC(`KdTree[${y},${b}]`)),B=(oe,G)=>{const ee=I[oe];I[oe]=I[G],I[G]=ee},J=(oe,G,ee)=>{const ne=P[oe];for(let Ce=0;Ce<ne.length;Ce++)ne[Ce]=Ce%2?-1/0:1/0;for(let Ce=G;Ce<ee;Ce++){const fe=b*I[Ce];for(let Ve=0;Ve<ne.length;){const qe=C[fe+(Ve>>>1)];ne[Ve]=Math.min(ne[Ve++],qe),ne[Ve]=Math.max(ne[Ve++],qe)}}if(S<=oe){const Ce=oe-S;return R[Ce]=G,void(R[Ce+1]=ee)}const X=function(){let Ce=0,fe=-1/0;for(let Ve=ne.length;Ve>0;){const qe=ne[--Ve]-ne[--Ve];qe>fe&&(fe=qe,Ce=Ve>>>1)}return Ce}(),be=G+ee>>>1;for(let Ce=G,fe=ee;;){const Ve=C[b*I[F(Ce,fe)]+X];let qe=Ce,at=Ce;for(let ht=Ce;ht<fe;ht++){let bt=C[b*I[ht]+X];bt<=Ve&&(B(ht,at),bt<Ve&&B(qe++,at),at++)}if(qe>be)fe=qe;else{if(!(at<be))break;Ce=at}}const Ie=uC(oe);J(Ie,G,be),J(Ie+1,be,ee)};var c;J(0,0,y);const j=(oe,G)=>{G*=b;for(const ee=(oe*=b)+b;oe<ee;oe++,G++){const ne=C[oe];C[oe]=C[G],C[G]=ne}};for(let oe=I.slice(),G=0;G<y;G++)for(let ee=G;;){let ne=oe[ee];if(oe[ee]=ee,ne===G)break;j(ee,ee=ne)}return new xy(y,b,f,A,P,R,I)})()}kNearest(f,d){const{_nSamples:m,_nFeatures:y,_metric:b,_points:I,_bBoxes:C,_offsets:A,_indices:T}=this;f=Math.min(f,m);const[E,S]=d.shape;ie(y===S,"KNeighbors: X_train.shape[1] must equal X_predict.shape[1].");const R=new Float32Array(E*f),P=new Int32Array(E*f),F=1+(C.length-1-1>>1);if(0<f&&0<E){const B=d.dataSync();let J,j;const oe=(G,ee)=>{if(!(ee>=J.maxKey))if(G<F){const ne=uC(G),X=b.minDistToBBox(j,C[ne]),be=b.minDistToBBox(j,C[ne+1]);X<=be?(oe(ne,X),oe(ne+1,be)):(oe(ne+1,be),oe(ne,X))}else{const X=A[1+(G-=F)];for(let be=A[G];be<X;be++){const Ie=b.distance(j,I[be]);J.add(Ie,T[be])}}};for(let G=0;G<E;G++){j=B.subarray(S*G,S*(G+1));const ee=f*G,ne=f+ee;J=new oC(R.subarray(ee,ne),P.subarray(ee,ne)),oe(0,b.minDistToBBox(j,C[0]))}}return{distances:this.tf.tensor2d(R,[E,f],"float32"),indices:this.tf.tensor2d(P,[E,f],"int32")}}}const pb={uniform(c){let f=Ae();const{shape:d}=c;return f.fill(d,1/d[1])},distance(c){let f=Ae();return f.tidy(()=>{const d=c.min(1,!0),m=f.divNoNan(d.toFloat(),c),y=c.lessEqual(0).toFloat(),b=f.where(d.lessEqual(0),y,m),I=b.sum(1,!0);return b.div(I)})}},lC={minkowski:c=>yy(c),manhattan:()=>yy(1),euclidean:()=>yy(2),chebyshev:()=>yy(1/0)},Xm={kdTree:xy.build,brute:(c=(0,he.Z)(function*(f){return new tC(f)}),function(d){return c.apply(this,arguments)}),auto:c=>"function"==typeof c.metric.minDistToBBox?Xm.kdTree(c):Xm.brute(c)};var c;class db extends Zn{constructor(f={}){super(),H(this,"_neighborhood",void 0),H(this,"_y",void 0),H(this,"weights",void 0),H(this,"algorithm",void 0),H(this,"leafSize",void 0),H(this,"p",void 0),H(this,"metric",void 0),H(this,"nNeighbors",void 0),Object.assign(this,f)}_getFitParams(){const{_neighborhood:f,_y:d,nNeighbors:m=5,weights:y="uniform"}=this;return ie(0<=m&&m%1==0,"KNeighbors({nNeighbors})::predict(X): nNeighbors must be a positive int."),ie(Object.keys(pb).includes(y),"KNeighbors({weights})::predict(X): invalid weights."),ie(null!=f&&null!=d,"KNeighbors::predict(X): model not trained yet. Call `await fit(x, y)` first."),{nNeighbors:m,weightsFn:pb[y],neighborhood:f,y:d}}fit(f,d){var m=this;return(0,he.Z)(function*(){const{algorithm:y="auto",metric:b="minkowski",p:I=2,leafSize:C}=m;ie(Object.keys(lC).includes(b),"KNeighbors({metric}).fit(X,y): invalid metric."),ie(Object.keys(Xm).includes(y),"KNeighbors({algorithm}).fit(X,y): invalid algorithm.");const A=lC[b](I),T=rt(f);return m._neighborhood=yield Xm[y]({entries:T,metric:A,leafSize:C}),m._y=kt(d),m})()}}H(db,"SUPPORTED_ALGORITHMS",Object.freeze(Object.keys(Xm)));class oP extends db{constructor(...f){super(...f),H(this,"name","KNeighborsRegressor")}predict(f){let d=Ae();const{neighborhood:m,y,nNeighbors:b,weightsFn:I}=this._getFitParams();return d.tidy(()=>{const C=rt(f),{distances:A,indices:T}=m.kNearest(b,C),E=y.gather(T),S=I(A);return d.matMul(E.reshape([-1,1,b]),S.reshape([-1,b,1])).as1D()})}}function cC(c){c.engine().backendNames().includes("tensorflow")&&!c.getKernel("Unique","tensorflow")&&(console.info("[scikit.js] Installing tfjs-node polyfill for tf.unique()."),c.registerKernel({kernelName:"Unique",backendName:"tensorflow",kernelFunc:f=>{const d=f.inputs.x,m=f.backend,{axis:y}=f.attrs,b=c.tensor1d([y],"int32"),I={float32:m.binding.TF_FLOAT,float64:m.binding.TF_DOUBLE,int32:m.binding.TF_INT32,int64:m.binding.TF_INT64,complex64:m.binding.TF_COMPLEX64,bool:m.binding.TF_BOOL,string:m.binding.TF_STRING};ie(Object.keys(I).includes(d.dtype),"Unexpected dtype.");try{return m.executeMultipleOutputs("UniqueV2",[{value:I[d.dtype],name:"T",type:m.binding.TF_ATTR_TYPE},{value:I.int32,name:"Taxis",type:m.binding.TF_ATTR_TYPE},{value:I.int32,name:"out_idx",type:m.binding.TF_ATTR_TYPE}],[d,b],2)}finally{b.dispose()}}}))}function uP(c,f){let d=Ae();return d.tidy(()=>{f=_e(f);const m=this.predict(c);return d.equal(f,m).sum().div(f.shape[0])})}class lP extends db{constructor(...f){super(...f),H(this,"classes_",void 0),H(this,"score",uP),H(this,"name","KNeighborsClassifier")}predictProba(f){const{neighborhood:d,y:m,nNeighbors:y,weightsFn:b}=this._getFitParams(),[I]=this.classes_?.shape;let C=Ae();return C.tidy(()=>{const A=rt(f),T=A.shape[0],{distances:E,indices:S}=d.kNearest(y,A),R=m.gather(S),P=b(E),F=C.oneHot(R,I);return C.mul(F.reshape([T,y,I]),P.reshape([T,y,1])).sum(1)})}predict(f){const d=this.classes_;return Ae().tidy(()=>{const b=this.predictProba(f).argMax(1);return d.gather(b)})}fit(f,d){var m=()=>super.fit,y=this;return(0,he.Z)(function*(){let b=Ae();const{values:I,indices:C}=b.tidy(()=>{const A=_e(d);return cC(b),b.unique(A)});return yield m().call(y,f,C),y.classes_=I,y})()}}class cP extends Ur{constructor({penalty:f="l2",C:d=1,fitIntercept:m=!0}={}){let y=Ae();super({modelCompileArgs:{optimizer:y.train.adam(.1),loss:y.losses.hingeLoss,metrics:["accuracy"]},modelFitArgs:{batchSize:32,epochs:1e3,verbose:0,callbacks:[y.callbacks.earlyStopping({monitor:"loss",patience:50})]},denseLayerArgs:{units:1,useBias:Boolean(m),activation:"softmax",kernelInitializer:y.initializers.zeros(),biasInitializer:y.initializers.zeros(),kernelRegularizer:"l2"===f?y.regularizers.l2({l2:d}):"l1"===f?y.regularizers.l1({l1:d}):void 0},isClassification:!0,optimizerType:"adam",lossType:"hingeLoss"}),this.name="LinearSVC"}}class fP extends Ao{constructor({epsilon:f=0,C:d=1,fitIntercept:m=!0}={}){let y=Ae();super({modelCompileArgs:{optimizer:y.train.adam(.1),loss:function(b,I){return y.abs(y.sub(b,I)).sub(f).maximum(0)},metrics:["accuracy"]},modelFitArgs:{batchSize:32,epochs:1e3,verbose:0,callbacks:[y.callbacks.earlyStopping({monitor:"loss",patience:50})]},denseLayerArgs:{units:1,useBias:Boolean(m),kernelRegularizer:y.regularizers.l2({l2:d})},optimizerType:"adam",lossType:"custom"}),this.name="LinearSVR"}}class hP extends Zn{constructor(f={}){super(),H(this,"priors",void 0),H(this,"varSmoothing",void 0),H(this,"classes",void 0),H(this,"means",void 0),H(this,"variances",void 0),H(this,"tf",void 0),this.tf=Ae(),this.classes=this.tf.tensor1d([]),this.means=[],this.variances=[],f.priors&&(this.priors=_e(f.priors)),this.varSmoothing=f.varSmoothing?f.varSmoothing:1e-9}fit(f,d){var m=this;return(0,he.Z)(function*(){const y=rt(f),b=_e(d),{values:I,meansByLabel:C,variancesByLabel:A}=m.tf.tidy(()=>{cC(m.tf);const T=[],E=[],{values:S}=m.tf.unique(b),{variance:R}=m.tf.moments(y,0),P=R.max().mul(m.varSmoothing);return m.tf.unstack(S).forEach(F=>{const B=m.tf.equal(b,F).toFloat(),J=m.tf.sum(B),j=m.tf.mul(y,B.expandDims(1)).sum(0).div(J),oe=m.tf.sub(y,j).mul(B.expandDims(1)).pow(2).sum(0).div(J).add(P);T.push(j),E.push(oe)}),{values:S,meansByLabel:T,variancesByLabel:E}});return m.classes=I,m.means=C,m.variances=A,m})()}predictProba(f){const d=rt(f);return this.tf.tidy(()=>{let y=[];this.classes.unstack().forEach((I,C)=>{const E=this.kernel(d,this.means[C],this.variances[C]);y.push(E)});const b=this.tf.stack(y,1);return this.priors?b.mul(this.priors):b})}predict(f){return this.predictProba(f).argMax(1)}}class pP extends hP{constructor(...f){super(...f),H(this,"name","GaussianNB")}kernel(f,d,m){let y=Ae();return y.tidy(()=>y.sub(f,d.expandDims(0)).pow(2).div(m.expandDims(0).mul(-2)).exp().div(m.mul(2*Math.PI).expandDims(0).sqrt()).prod(1))}}function fC(c,f){let d=0;for(let m=0;m<c.length;m++)d+=c[m]*c[m];return 1-d/(f*f)}function hC(c,f){let d=0;for(let m=0;m<c.length;m++){let y=c[m];y>0&&(y/=f,d-=y*Math.log2(y))}return d}function pC(c,f,d){let m=f/d;return c/d-m*m}class by extends Zn{constructor({impurityMeasure:f,y:d}){super(),H(this,"y",void 0),H(this,"impurityMeasure",void 0),H(this,"start",0),H(this,"end",0),H(this,"pos",0),H(this,"nLabels",void 0),H(this,"labelFreqsTotal",[]),H(this,"labelFreqsLeft",[]),H(this,"labelFreqsRight",[]),H(this,"nSamples",0),H(this,"nSamplesLeft",0),H(this,"nSamplesRight",0),H(this,"name","ClassificationCriterion"),this.impurityMeasure=f,this.nLabels=function dP(c){let f=Number.NEGATIVE_INFINITY;for(let d=0;d<c.length;d++)c[d]>f&&(f=c[d]);return f}(d)+1,this.y=d,this.labelFreqsTotal=new Array(this.nLabels).fill(0),this.labelFreqsLeft=new Array(this.nLabels).fill(0),this.labelFreqsRight=new Array(this.nLabels).fill(0)}init(f,d,m){this.start=f,this.end=d,this.nSamples=d-f,this.labelFreqsTotal=this.labelFreqsTotal.fill(0),this.labelFreqsLeft=this.labelFreqsLeft.fill(0),this.labelFreqsRight=this.labelFreqsRight.fill(0);for(let y=f;y<d;y++)this.labelFreqsTotal[this.y[m[y]]]+=1}reset(){this.pos=this.start,this.labelFreqsLeft=this.labelFreqsLeft.fill(0),this.labelFreqsRight=this.labelFreqsRight.fill(0)}update(f,d){for(let m=this.pos;m<f;m++)this.labelFreqsLeft[this.y[d[m]]]+=1;for(let m=0;m<this.labelFreqsTotal.length;m++)this.labelFreqsRight[m]=this.labelFreqsTotal[m]-this.labelFreqsLeft[m];this.pos=f,this.nSamplesLeft=this.pos-this.start,this.nSamplesRight=this.end-this.pos}childrenImpurities(){let f="gini"===this.impurityMeasure?fC:hC;return{impurityLeft:f(this.labelFreqsLeft,this.nSamplesLeft),impurityRight:f(this.labelFreqsRight,this.nSamplesRight)}}impurityImprovement(){let{impurityLeft:f,impurityRight:d}=this.childrenImpurities();return-this.nSamplesLeft*f-this.nSamplesRight*d}nodeImpurity(){return("gini"===this.impurityMeasure?fC:hC)(this.labelFreqsTotal,this.nSamples)}nodeValue(){return this.labelFreqsTotal}static fromJson(f){const d=JSON.parse(f),m=new by({impurityMeasure:d.impurityMeasure,y:d.y});return Object.assign(m,d)}}class wy extends Zn{constructor({impurityMeasure:f,y:d}){super(),H(this,"y",void 0),H(this,"impurityMeasure",void 0),H(this,"start",0),H(this,"end",0),H(this,"pos",0),H(this,"squaredSum",0),H(this,"squaredSumLeft",0),H(this,"squaredSumRight",0),H(this,"sumTotal",0),H(this,"sumTotalLeft",0),H(this,"sumTotalRight",0),H(this,"nSamples",0),H(this,"nSamplesLeft",0),H(this,"nSamplesRight",0),H(this,"name","RegressionCriterion"),this.impurityMeasure=f,this.y=d}init(f,d,m){this.sumTotal=0,this.squaredSum=0,this.start=f,this.end=d,this.nSamples=d-f;for(let y=f;y<d;y++){let I=this.y[m[y]];this.sumTotal+=I,this.squaredSum+=I*I}}reset(){this.pos=this.start,this.squaredSumLeft=0,this.sumTotalLeft=0,this.squaredSumRight=0,this.sumTotalRight=0}update(f,d){for(let m=this.pos;m<f;m++){let b=this.y[d[m]];this.sumTotalLeft+=b,this.squaredSumLeft+=b*b}this.sumTotalRight=this.sumTotal-this.sumTotalLeft,this.squaredSumRight=this.squaredSum-this.squaredSumLeft,this.pos=f,this.nSamplesLeft=this.pos-this.start,this.nSamplesRight=this.end-this.pos}childrenImpurities(){let f=pC;return{impurityLeft:f(this.squaredSumLeft,this.sumTotalLeft,this.nSamplesLeft),impurityRight:f(this.squaredSumRight,this.sumTotalRight,this.nSamplesRight)}}impurityImprovement(){let{impurityLeft:f,impurityRight:d}=this.childrenImpurities();return-this.nSamplesLeft*f-this.nSamplesRight*d}nodeImpurity(){return pC(this.squaredSum,this.sumTotal,this.nSamples)}nodeValue(){return[this.sumTotal/this.nSamples]}static fromJson(f){const d=JSON.parse(f),m=new wy({impurityMeasure:d.impurityMeasure,y:d.y});return Object.assign(m,d)}}var mP=Y(9336),gP=Y.n(mP);function mb(){return{feature:0,threshold:0,pos:-1,impurityLeft:Number.POSITIVE_INFINITY,impurityRight:Number.POSITIVE_INFINITY,foundSplit:!1}}class dC extends Zn{constructor({X:f,y:d,minSamplesLeaf:m,impurityMeasure:y,maxFeatures:b,samplesSubset:I=[]}){if(super(),H(this,"kMinSplitDiff",void 0),H(this,"X",void 0),H(this,"y",void 0),H(this,"criterion",void 0),H(this,"start",void 0),H(this,"end",void 0),H(this,"minSamplesLeaf",void 0),H(this,"maxFeatures",void 0),H(this,"featureOrder",void 0),H(this,"shuffleFeatures",void 0),H(this,"sampleMap",void 0),H(this,"nSamplesTotal",void 0),H(this,"nFeatures",void 0),H(this,"name","Splitter"),this.X=f,this.y=d,this.nFeatures=f[0].length,this.minSamplesLeaf=m,this.maxFeatures=Math.min(b,this.nFeatures),this.shuffleFeatures=b<this.nFeatures,this.sampleMap=new Int32Array(f.length),this.start=0,this.end=0,this.kMinSplitDiff=1e-8,0===I.length){this.nSamplesTotal=f.length;for(let C=0;C<this.nSamplesTotal;C++)this.sampleMap[C]=C}else{this.nSamplesTotal=I.length;for(let C=0;C<this.nSamplesTotal;C++)this.sampleMap[C]=I[C]}this.criterion="squared_error"===y?new wy({impurityMeasure:y,y:d}):new by({impurityMeasure:y,y:d}),this.featureOrder=[];for(let C=0;C<this.nFeatures;C++)this.featureOrder.push(C);this.resetSampleRange(0,this.nSamplesTotal)}resetSampleRange(f,d){this.start=f,this.end=d,this.criterion.init(f,d,this.sampleMap)}splitNode(){let f=mb(),d=mb(),m=Number.NEGATIVE_INFINITY,y=Number.NEGATIVE_INFINITY,b=0,I=0;for(f.foundSplit=!1,this.shuffleFeatures&&(this.featureOrder=gP()(this.featureOrder));b<this.maxFeatures;){I=this.featureOrder[b];let C=new Float32Array(this.end-this.start);for(let T=this.start;T<this.end;T++)C[T-this.start]=this.X[this.sampleMap[T]][I];if(C.sort(),this.criterion.reset(),this.sampleMap.subarray(this.start,this.end).sort((T,E)=>this.X[T][I]-this.X[E][I]),C[0]===C[C.length-1]){b+=1;continue}let A=this.start+1;for(;A<this.end;){for(;A<this.end&&C[A-this.start]<=C[A-this.start-1]+this.kMinSplitDiff;)A++;A!==this.end?(A-this.start<this.minSamplesLeaf||this.end-A<this.minSamplesLeaf||(f.pos=A,this.criterion.update(f.pos,this.sampleMap),m=this.criterion.impurityImprovement(),m>y&&(y=m,f.foundSplit=!0,f.feature=I,f.threshold=(C[A-this.start-1]+C[A-this.start])/2,d=Object.assign({},f))),A+=1):A++}b+=1}if(f.foundSplit){if(d.pos<this.end&&I!==d.feature){let T=this.start,E=this.end,S=0;for(;T<E;)this.X[this.sampleMap[T]][d.feature]<=d.threshold?T+=1:(E-=1,S=this.sampleMap[T],this.sampleMap[T]=this.sampleMap[E],this.sampleMap[E]=S)}this.criterion.reset(),this.criterion.update(d.pos,this.sampleMap);let{impurityLeft:C,impurityRight:A}=this.criterion.childrenImpurities();return d.impurityLeft=C,d.impurityRight=A,d}return f}}function gb(c){if(0===c.length)throw new Error(`X can not be empty, but it has a length of 0. It is ${c}.`);for(let f=0;f<c.length;f++){let d=c[f];if(0===d.length)throw new Error(`Rows in X can not be empty, but row ${f} in X is ${d}.`);for(let m=0;m<d.length;m++)if("number"!=typeof d[m]||!Number.isFinite(d[m]))throw new Error(`X must contain finite non-NaN numbers, but the element at X[${f}][${m}] is ${d[m]}`)}}function vP(c){return c.map((f,d)=>[f,d]).reduce((f,d)=>d[0]>f[0]?d:f)[1]}class mC{constructor(){H(this,"nodes",[]),H(this,"isBuilt",!1),H(this,"name","DecisionTree")}getLeafNodes(f){let d=[];for(let m=0;m<f.length;m++){let y=0;for(;!this.nodes[y].isLeaf;)y=f[m][this.nodes[y].splitFeature]<=this.nodes[y].threshold?this.nodes[y].leftChildId:this.nodes[y].rightChildId;d.push(y)}return d}populateChildIds(){for(let f=1;f<this.nodes.length;f++)this.nodes[f].isLeft?this.nodes[this.nodes[f].parentId].leftChildId=f:this.nodes[this.nodes[f].parentId].rightChildId=f}predictProba(f){if(!this.isBuilt)throw new Error("Decision tree must be built with BuildTree method before predictions can be made.");let d=this.getLeafNodes(f),m=[];for(let y=0;y<d.length;y++){let b=[],I=d[y];for(let C=0;C<this.nodes[0].value.length;C++)b.push(this.nodes[I].value[C]/this.nodes[I].nSamples);m.push(b)}return m}predictClassification(f){if(!this.isBuilt)throw new Error("Decision tree must be built with BuildTree method before predictions can be made.");let d=this.getLeafNodes(f),m=[];for(let y=0;y<d.length;y++)m.push(vP(this.nodes[d[y]].value));return m}predictRegression(f){if(!this.isBuilt)throw new Error("Decision tree must be built with BuildTree method before predictions can be made.");let d=this.getLeafNodes(f),m=[];for(let y=0;y<d.length;y++)m.push(this.nodes[d[y]].value[0]);return m}}class yb extends Zn{constructor({criterion:f="gini",maxDepth:d=Number.POSITIVE_INFINITY,minSamplesSplit:m=2,minSamplesLeaf:y=1,maxFeatures:b,minImpurityDecrease:I=0}={}){super(),H(this,"splitter",void 0),H(this,"stack",[]),H(this,"minSamplesLeaf",void 0),H(this,"maxDepth",void 0),H(this,"minSamplesSplit",void 0),H(this,"minImpurityDecrease",void 0),H(this,"tree",void 0),H(this,"criterion",void 0),H(this,"maxFeatures",void 0),H(this,"maxFeaturesNumb",void 0),H(this,"X",[]),H(this,"y",[]),H(this,"labelEncoder",void 0),H(this,"name",void 0),this.criterion=f,this.maxDepth=void 0===d?Number.POSITIVE_INFINITY:Number(d),this.minSamplesSplit=m,this.minSamplesLeaf=y,this.maxFeatures=b,this.minImpurityDecrease=I,this.maxFeaturesNumb=0,this.tree=new mC,this.name="DecisionTreeBase"}calcMaxFeatures(f,d){return"log2"===d?Math.floor(Math.log2(f)):"sqrt"===d||"auto"===d?Math.floor(Math.sqrt(f)):"number"==typeof d?(ie(d>=1,"maxFeatures must be greater than 1"),Math.min(Math.floor(d),f)):f}fit(f,d,m){this.X=f,this.y=d;let y=m||[];this.maxFeaturesNumb=this.calcMaxFeatures(f[0].length,this.maxFeatures),this.splitter=new dC({X:f,y:d,minSamplesLeaf:this.minSamplesLeaf,impurityMeasure:this.criterion,maxFeatures:this.maxFeaturesNumb,samplesSubset:y}),this.stack.push({start:0,end:this.splitter.sampleMap.length,depth:0,impurity:0,nSamples:this.splitter.sampleMap.length,parentId:-1,isLeft:!1});let I=!0;for(;0!==this.stack.length;){let C=this.stack.pop();this.splitter.resetSampleRange(C.start,C.end);let A=mb(),T=!(C.depth<this.maxDepth)||C.nSamples<this.minSamplesSplit||C.nSamples<2*this.minSamplesLeaf;I&&(C.impurity=this.splitter.criterion.nodeImpurity(),I=!1),T||(A=this.splitter.splitNode(),T=T||!A.foundSplit||C.impurity<=this.minImpurityDecrease);let E={parentId:C.parentId,impurity:C.impurity,isLeaf:T,isLeft:C.isLeft,nSamples:C.nSamples,splitFeature:A.feature,threshold:A.threshold,value:this.splitter.criterion.nodeValue().slice(),leftChildId:-1,rightChildId:-1};this.tree.nodes.push(E);let S=this.tree.nodes.length-1;T||(this.stack.push({start:A.pos,end:C.end,nSamples:C.end-A.pos,depth:C.depth+1,parentId:S,isLeft:!1,impurity:A.impurityRight}),this.stack.push({start:C.start,end:A.pos,nSamples:A.pos-C.start,depth:C.depth+1,parentId:S,isLeft:!0,impurity:A.impurityLeft}))}this.tree.populateChildIds(),this.tree.isBuilt=!0}}class xP extends yb{constructor({criterion:f="gini",maxDepth:d,minSamplesSplit:m=2,minSamplesLeaf:y=1,maxFeatures:b,minImpurityDecrease:I=0}={}){ie(["gini","entropy"].includes(f),'For classification must pass either the "gini" or "entropy" criterion'),super({criterion:f,maxDepth:d,minSamplesSplit:m,minSamplesLeaf:y,maxFeatures:b,minImpurityDecrease:I}),H(this,"labelEncoder",void 0),H(this,"name",void 0),this.labelEncoder=new gy,this.name="DecisionTreeClassifier"}fit(f,d){ie(Pe(d),"y value is not a 1D container"),ie(Z(f),"X value is not a 2D container");let m=$t(f),y=tn(d);ie(m.length===y.length,"X and y must be the same size"),gb(m),function yP(c){if(0===c.length)throw new Error(`y can not be empty, but it has a length of 0. It is ${c}.`);for(let f=0;f<c.length;f++){let d=c[f];if(!Number.isSafeInteger(d))throw new Error(`Some y values are not an integer. Found ${d} but must be an integer only`)}}(y);let b=this.labelEncoder.fitTransform(y);return super.fit(m,tn(b)),this}getNLeaves(){return this.tree.nodes.filter(f=>f.isLeaf).length}predict(f){ie(Z(f),"X value is not a 2D container");let d=$t(f);gb(d);let m=this.tree.predictClassification(d);return this.labelEncoder.inverseTransform(m)}predictProba(f){return this.tree.predictProba(f)}score(f,d){return ri(d,this.predict(f))}}class bP extends yb{constructor({criterion:f="squared_error",maxDepth:d,minSamplesSplit:m=2,minSamplesLeaf:y=1,maxFeatures:b,minImpurityDecrease:I=0}={}){ie(["squared_error"].includes(f),'Must pass the regression criterion of "squared_error"'),super({criterion:f,maxDepth:d,minSamplesSplit:m,minSamplesLeaf:y,maxFeatures:b,minImpurityDecrease:I}),H(this,"name",void 0),this.name="DecisionTreeRegressor"}fit(f,d){ie(Pe(d),"y value is not a 1D container"),ie(Z(f),"X value is not a 2D container");let m=$t(f),y=tn(d);return ie(m.length===y.length,"X and y must be the same size"),gb(m),super.fit(m,y),this}getNLeaves(){return this.tree.nodes.filter(f=>f.isLeaf).length}predict(f){return this.tree.predictRegression(f)}score(f,d){return Tt(d,this.predict(f))}}const wP=({nSamples:c=100,nFeatures:f=100,nInformative:d=10,nTargets:m=1,noise:y=1,bias:b=0,effectiveRank:I=null,tailStrength:C=.5,shuffle:A=!1,coef:T=!1}={})=>{let E=Ae();return E.tidy(()=>{const S=Math.min(f,d);let R;R=null===I?E.randomNormal([c,f]):gC({nSamples:c,nFeatures:f,effectiveRank:I,tailStrength:C});const P=E.randomNormal([S,m]).mul(100),F=E.zeros([f-S,m]),B=E.concat([P,F]);let J=R.dot(B).add(b);if(y>0&&(J=J.add(E.randomNormal(J.shape,void 0,y))),A){const j=E.util.createShuffledIndices(c);R=R.gather(j)}return J=E.squeeze(J),T?[R,J,E.squeeze(B)]:[R,J]})},gC=({nSamples:c=100,nFeatures:f=100,effectiveRank:d=10,tailStrength:m=.5}={})=>{let y=Ae();return y.tidy(()=>{let b=Math.min(c,f),[I]=y.linalg.qr(y.randomNormal([c,b])),[C]=y.linalg.qr(y.randomNormal([f,b]));const T=y.range(0,b).div(d),E=y.exp(T.square().neg()).mul(1-m);let S=y.exp(T.mul(-.1)).mul(m),R=E.add(S);return I.mul(R).dot(C.transpose())})};class yC{constructor({nSplits:f=5,shuffle:d=!1,randomState:m}={}){H(this,"nSplits",void 0),H(this,"shuffle",void 0),H(this,"randomState",void 0),H(this,"name",void 0),H(this,"tf",void 0),f=Number(f),ie(Number.isInteger(f)&&f>1,"new KFold({nSplits}): nSplits must be an int greater than 1."),this.tf=Ae(),this.nSplits=f,this.shuffle=Boolean(d),this.randomState=m,this.name="KFold"}getNumSplits(){return this.nSplits}*split(f,d,m){const{nSplits:y,shuffle:b,randomState:I}=this,C=Rn(f);ie(y<=C,"KFold({nSplits})::split(X): nSplits must not be greater than X.shape[0]."),null!=d&&ie(C===Rn(d),"KFold::split(X,y): X.shape[0] must equal y.shape[0]."),null!=m&&ie(C===Rn(m),"KFold::split(X,y,groups): X.shape[0] must equal groups.shape[0].");const A=new Int32Array(C);for(let R=0;R<A.length;R++)A[R]=R;if(b){const R=(c=>iC(c?.toString()))(I);(c=>f=>{const d=vy(c);for(let m=f.length;m>1;m--){const y=d(0,m),b=f[m-1];f[m-1]=f[y],f[y]=b}})(R)(A)}const T=Math.floor(C/y);let E=C%y,S=0;for(;S<C;){const R=E-- >0?T+1:T,P=new Int32Array(C-R);P.set(A.subarray(0,S),0),P.set(A.subarray(S+R),S);const F=A.slice(S,S+R);yield{trainIndex:this.tf.tensor1d(P,"int32"),testIndex:this.tf.tensor1d(F,"int32")},S+=R}}}function _y(c,f){let d=Ae();return $e(c)?d.gather(c,f):Se(c)?c.iloc({rows:f}):Ne(c)?c.iloc(f):f.map(m=>c[m])}function vb(c,f,d=.1,m,y){const b=Rn(c);ie(b===Rn(f),"X and y don't have the same number of elements. They are of different size");let[C,A]=function _P(c,f,d,m=.1){if(ie(void 0===d||"number"==typeof d,`Invalid value for trainSize: ${d}. Must be number or undefined`),ie(void 0===f||"number"==typeof f,`Invalid value for testSize: ${f}. Must be number or undefined`),void 0===f&&void 0===d&&(f=m),"number"==typeof f&&(Number.isInteger(f)&&(f>=c||f<=0)||!Number.isInteger(f)&&(f<=0||f>=1)))throw Error(`testSize=${f} should be either positive and smaller than the number of samples ${c} or a float in the (0, 1) range`);if("number"==typeof d&&(Number.isInteger(d)&&(d>=c||d<=0)||!Number.isInteger(d)&&(d<=0||d>=1)))throw Error(`trainSize=${d} should be either positive and smaller than the number of samples ${c} or a float in the (0, 1) range`);if(!Number.isInteger(d)&&!Number.isInteger(f)&&d&&f&&d+f>1)throw Error(`The sum of testSize and trainSize = ${d+f}, should be in the (0, 1) range. Reduce testSize and/or trainSize.`);let y,b;if(Number.isInteger(f)?y=f:"number"==typeof f&&(y=Math.ceil(f*c)),Number.isInteger(d)?b=d:"number"==typeof d&&(b=Math.ceil(d*c)),void 0===d&&(b=c-y),void 0===f&&(y=c-b),"number"!=typeof b||"number"!=typeof y)throw Error("nTrain and nTest must be a number");if(b+y>c)throw Error(`The sum of trainSize and testSize = ${b+y}, should be smaller than the number of samples ${c}. Reduce testSize and/or trainSize.`);if(b=Math.floor(b),y=Math.floor(y),0===b)throw Error(`With nSamples=${c}, testSize=${f} and trainSize=${d}, the resulting train set will be empty. Adjust any of the aforementioned parameters.`);return[b,y]}(b,d,m),T=Bn(b,b,y),E=T.slice(0,C),S=T.slice(C);return[_y(c,E),_y(c,S),_y(f,E),_y(f,S)]}function NP(c,f,d,m){return xb.apply(this,arguments)}function xb(){return xb=(0,he.Z)(function*(c,f,d,m){let y=Ae(),b=null==d||null==m&&!Pe(d);b&&(m=m??d);let{cv:I=new yC,groups:C,scoring:A}=m??{};null==A&&(ie("function"==typeof c.score,"crossValScore(estimator,[X,y],params): Either params.scoring or estimator.score(X,y) must be defined."),A=c.score);const T=[];let E;A=A.bind(c),y.engine().startScope();try{f=Ct(f),b||(d=_e(d));for(const{trainIndex:S,testIndex:R}of I.split(f,d,C)){let P;const F=f.gather(S),B=f.gather(R);if(b)yield c.fit(F),P=A(B);else{const J=d.gather(S),j=d.gather(R);yield c.fit(F,J),P=A(B,j),J.dispose(),j.dispose()}T.push(P),S.dispose(),R.dispose(),F.dispose(),B.dispose()}return E=y.stack(T)}finally{y.engine().endScope(E)}}),xb.apply(this,arguments)}},340:(ze,Fe,Y)=>{var te=Y(9471),he=Y(2992),ye=Y(7657),de=Y(5583),Me=Y(1929),H=Y(8083),Ye=Y(3818);Ye.alea=te,Ye.xor128=he,Ye.xorwow=ye,Ye.xorshift7=de,Ye.xor4096=Me,Ye.tychei=H,ze.exports=Ye},9471:function(ze,Fe,Y){var te;!function(he,ye,de){function Me(Ae){var Le=this,re=function Je(){var Ae=4022871197;return function(re){re=String(re);for(var ae=0;ae<re.length;ae++){var ie=.02519603282416938*(Ae+=re.charCodeAt(ae));ie-=Ae=ie>>>0,Ae=(ie*=Ae)>>>0,Ae+=4294967296*(ie-=Ae)}return 2.3283064365386963e-10*(Ae>>>0)}}();Le.next=function(){var ae=2091639*Le.s0+2.3283064365386963e-10*Le.c;return Le.s0=Le.s1,Le.s1=Le.s2,Le.s2=ae-(Le.c=0|ae)},Le.c=1,Le.s0=re(" "),Le.s1=re(" "),Le.s2=re(" "),Le.s0-=re(Ae),Le.s0<0&&(Le.s0+=1),Le.s1-=re(Ae),Le.s1<0&&(Le.s1+=1),Le.s2-=re(Ae),Le.s2<0&&(Le.s2+=1),re=null}function H(Ae,Le){return Le.c=Ae.c,Le.s0=Ae.s0,Le.s1=Ae.s1,Le.s2=Ae.s2,Le}function Ye(Ae,Le){var re=new Me(Ae),ae=Le&&Le.state,ie=re.next;return ie.int32=function(){return 4294967296*re.next()|0},ie.double=function(){return ie()+11102230246251565e-32*(2097152*ie()|0)},ie.quick=ie,ae&&("object"==typeof ae&&H(ae,re),ie.state=function(){return H(re,{})}),ie}ye&&ye.exports?ye.exports=Ye:Y.amdD&&Y.amdO?void 0!==(te=function(){return Ye}.call(Fe,Y,Fe,ye))&&(ye.exports=te):this.alea=Ye}(0,ze=Y.nmd(ze))},8083:function(ze,Fe,Y){var te;!function(he,ye,de){function Me(Je){var Ae=this,Le="";Ae.next=function(){var ae=Ae.b,ie=Ae.c,Ue=Ae.d,Q=Ae.a;return ae=ae<<25^ae>>>7^ie,ie=ie-Ue|0,Ue=Ue<<24^Ue>>>8^Q,Q=Q-ae|0,Ae.b=ae=ae<<20^ae>>>12^ie,Ae.c=ie=ie-Ue|0,Ae.d=Ue<<16^ie>>>16^Q,Ae.a=Q-ae|0},Ae.a=0,Ae.b=0,Ae.c=-1640531527,Ae.d=1367130551,Je===Math.floor(Je)?(Ae.a=Je/4294967296|0,Ae.b=0|Je):Le+=Je;for(var re=0;re<Le.length+20;re++)Ae.b^=0|Le.charCodeAt(re),Ae.next()}function H(Je,Ae){return Ae.a=Je.a,Ae.b=Je.b,Ae.c=Je.c,Ae.d=Je.d,Ae}function Ye(Je,Ae){var Le=new Me(Je),re=Ae&&Ae.state,ae=function(){return(Le.next()>>>0)/4294967296};return ae.double=function(){do{var Q=((Le.next()>>>11)+(Le.next()>>>0)/4294967296)/(1<<21)}while(0===Q);return Q},ae.int32=Le.next,ae.quick=ae,re&&("object"==typeof re&&H(re,Le),ae.state=function(){return H(Le,{})}),ae}ye&&ye.exports?ye.exports=Ye:Y.amdD&&Y.amdO?void 0!==(te=function(){return Ye}.call(Fe,Y,Fe,ye))&&(ye.exports=te):this.tychei=Ye}(0,ze=Y.nmd(ze))},2992:function(ze,Fe,Y){var te;!function(he,ye,de){function Me(Je){var Ae=this,Le="";Ae.x=0,Ae.y=0,Ae.z=0,Ae.w=0,Ae.next=function(){var ae=Ae.x^Ae.x<<11;return Ae.x=Ae.y,Ae.y=Ae.z,Ae.z=Ae.w,Ae.w^=Ae.w>>>19^ae^ae>>>8},Je===(0|Je)?Ae.x=Je:Le+=Je;for(var re=0;re<Le.length+64;re++)Ae.x^=0|Le.charCodeAt(re),Ae.next()}function H(Je,Ae){return Ae.x=Je.x,Ae.y=Je.y,Ae.z=Je.z,Ae.w=Je.w,Ae}function Ye(Je,Ae){var Le=new Me(Je),re=Ae&&Ae.state,ae=function(){return(Le.next()>>>0)/4294967296};return ae.double=function(){do{var Q=((Le.next()>>>11)+(Le.next()>>>0)/4294967296)/(1<<21)}while(0===Q);return Q},ae.int32=Le.next,ae.quick=ae,re&&("object"==typeof re&&H(re,Le),ae.state=function(){return H(Le,{})}),ae}ye&&ye.exports?ye.exports=Ye:Y.amdD&&Y.amdO?void 0!==(te=function(){return Ye}.call(Fe,Y,Fe,ye))&&(ye.exports=te):this.xor128=Ye}(0,ze=Y.nmd(ze))},1929:function(ze,Fe,Y){var te;!function(he,ye,de){function Me(Je){var Ae=this;Ae.next=function(){var Ue,Q,re=Ae.w,ae=Ae.X,ie=Ae.i;return Ae.w=re=re+1640531527|0,Q=ae[ie+34&127],Ue=ae[ie=ie+1&127],Q^=Q<<13,Ue^=Ue<<17,Q=ae[ie]=(Q^=Q>>>15)^(Ue^=Ue>>>12),Ae.i=ie,Q+(re^re>>>16)|0},function Le(re,ae){var ie,Ue,Q,pe,le,xe=[],we=128;for(ae===(0|ae)?(Ue=ae,ae=null):(ae+="\0",Ue=0,we=Math.max(we,ae.length)),Q=0,pe=-32;pe<we;++pe)ae&&(Ue^=ae.charCodeAt((pe+32)%ae.length)),0===pe&&(le=Ue),Ue^=Ue<<10,Ue^=Ue>>>15,Ue^=Ue<<4,Ue^=Ue>>>13,pe>=0&&(Q=0==(ie=xe[127&pe]^=Ue+(le=le+1640531527|0))?Q+1:0);for(Q>=128&&(xe[127&(ae&&ae.length||0)]=-1),Q=127,pe=512;pe>0;--pe)Ue=xe[Q+34&127],ie=xe[Q=Q+1&127],Ue^=Ue<<13,ie^=ie<<17,xe[Q]=(Ue^=Ue>>>15)^(ie^=ie>>>12);re.w=le,re.X=xe,re.i=Q}(Ae,Je)}function H(Je,Ae){return Ae.i=Je.i,Ae.w=Je.w,Ae.X=Je.X.slice(),Ae}function Ye(Je,Ae){null==Je&&(Je=+new Date);var Le=new Me(Je),re=Ae&&Ae.state,ae=function(){return(Le.next()>>>0)/4294967296};return ae.double=function(){do{var Q=((Le.next()>>>11)+(Le.next()>>>0)/4294967296)/(1<<21)}while(0===Q);return Q},ae.int32=Le.next,ae.quick=ae,re&&(re.X&&H(re,Le),ae.state=function(){return H(Le,{})}),ae}ye&&ye.exports?ye.exports=Ye:Y.amdD&&Y.amdO?void 0!==(te=function(){return Ye}.call(Fe,Y,Fe,ye))&&(ye.exports=te):this.xor4096=Ye}(0,ze=Y.nmd(ze))},5583:function(ze,Fe,Y){var te;!function(he,ye,de){function Me(Je){var Ae=this;Ae.next=function(){var ie,Ue,re=Ae.x,ae=Ae.i;return ie=re[ae],Ue=(ie^=ie>>>7)^ie<<24,Ue^=(ie=re[ae+1&7])^ie>>>10,Ue^=(ie=re[ae+3&7])^ie>>>3,Ue^=(ie=re[ae+4&7])^ie<<7,ie=re[ae+7&7],re[ae]=Ue^=(ie^=ie<<13)^ie<<9,Ae.i=ae+1&7,Ue},function Le(re,ae){var ie,Q=[];if(ae===(0|ae))Q[0]=ae;else for(ae=""+ae,ie=0;ie<ae.length;++ie)Q[7&ie]=Q[7&ie]<<15^ae.charCodeAt(ie)+Q[ie+1&7]<<13;for(;Q.length<8;)Q.push(0);for(ie=0;ie<8&&0===Q[ie];++ie);for(8==ie&&(Q[7]=-1),re.x=Q,re.i=0,ie=256;ie>0;--ie)re.next()}(Ae,Je)}function H(Je,Ae){return Ae.x=Je.x.slice(),Ae.i=Je.i,Ae}function Ye(Je,Ae){null==Je&&(Je=+new Date);var Le=new Me(Je),re=Ae&&Ae.state,ae=function(){return(Le.next()>>>0)/4294967296};return ae.double=function(){do{var Q=((Le.next()>>>11)+(Le.next()>>>0)/4294967296)/(1<<21)}while(0===Q);return Q},ae.int32=Le.next,ae.quick=ae,re&&(re.x&&H(re,Le),ae.state=function(){return H(Le,{})}),ae}ye&&ye.exports?ye.exports=Ye:Y.amdD&&Y.amdO?void 0!==(te=function(){return Ye}.call(Fe,Y,Fe,ye))&&(ye.exports=te):this.xorshift7=Ye}(0,ze=Y.nmd(ze))},7657:function(ze,Fe,Y){var te;!function(he,ye,de){function Me(Je){var Ae=this,Le="";Ae.next=function(){var ae=Ae.x^Ae.x>>>2;return Ae.x=Ae.y,Ae.y=Ae.z,Ae.z=Ae.w,Ae.w=Ae.v,(Ae.d=Ae.d+362437|0)+(Ae.v=Ae.v^Ae.v<<4^ae^ae<<1)|0},Ae.x=0,Ae.y=0,Ae.z=0,Ae.w=0,Ae.v=0,Je===(0|Je)?Ae.x=Je:Le+=Je;for(var re=0;re<Le.length+64;re++)Ae.x^=0|Le.charCodeAt(re),re==Le.length&&(Ae.d=Ae.x<<10^Ae.x>>>4),Ae.next()}function H(Je,Ae){return Ae.x=Je.x,Ae.y=Je.y,Ae.z=Je.z,Ae.w=Je.w,Ae.v=Je.v,Ae.d=Je.d,Ae}function Ye(Je,Ae){var Le=new Me(Je),re=Ae&&Ae.state,ae=function(){return(Le.next()>>>0)/4294967296};return ae.double=function(){do{var Q=((Le.next()>>>11)+(Le.next()>>>0)/4294967296)/(1<<21)}while(0===Q);return Q},ae.int32=Le.next,ae.quick=ae,re&&("object"==typeof re&&H(re,Le),ae.state=function(){return H(Le,{})}),ae}ye&&ye.exports?ye.exports=Ye:Y.amdD&&Y.amdO?void 0!==(te=function(){return Ye}.call(Fe,Y,Fe,ye))&&(ye.exports=te):this.xorwow=Ye}(0,ze=Y.nmd(ze))},3818:function(ze,Fe,Y){var te;!function(he,ye,de){var ie,Me=256,H=6,Je="random",Ae=de.pow(Me,H),Le=de.pow(2,52),re=2*Le,ae=Me-1;function Ue(Ne,Se,Pe){var Z=[],Be=xe(le((Se=1==Se?{entropy:!0}:Se||{}).entropy?[Ne,$e(ye)]:Ne??function we(){try{var Ne;return ie&&(Ne=ie.randomBytes)?Ne=Ne(Me):(Ne=new Uint8Array(Me),(he.crypto||he.msCrypto).getRandomValues(Ne)),$e(Ne)}catch{var Se=he.navigator,Pe=Se&&Se.plugins;return[+new Date,he,Pe,he.screen,$e(ye)]}}(),3),Z),ue=new Q(Z),He=function(){for(var _e=ue.g(H),kt=Ae,Ct=0;_e<Le;)_e=(_e+Ct)*Me,kt*=Me,Ct=ue.g(1);for(;_e>=re;)_e/=2,kt/=2,Ct>>>=1;return(_e+Ct)/kt};return He.int32=function(){return 0|ue.g(4)},He.quick=function(){return ue.g(4)/4294967296},He.double=He,xe($e(ue.S),ye),(Se.pass||Pe||function(_e,kt,Ct,Ke){return Ke&&(Ke.S&&pe(Ke,ue),_e.state=function(){return pe(ue,{})}),Ct?(de[Je]=_e,kt):_e})(He,Be,"global"in Se?Se.global:this==de,Se.state)}function Q(Ne){var Se,Pe=Ne.length,Z=this,Be=0,ue=Z.i=Z.j=0,He=Z.S=[];for(Pe||(Ne=[Pe++]);Be<Me;)He[Be]=Be++;for(Be=0;Be<Me;Be++)He[Be]=He[ue=ae&ue+Ne[Be%Pe]+(Se=He[Be])],He[ue]=Se;(Z.g=function(_e){for(var kt,Ct=0,Ke=Z.i,rt=Z.j,et=Z.S;_e--;)kt=et[Ke=ae&Ke+1],Ct=Ct*Me+et[ae&(et[Ke]=et[rt=ae&rt+kt])+(et[rt]=kt)];return Z.i=Ke,Z.j=rt,Ct})(Me)}function pe(Ne,Se){return Se.i=Ne.i,Se.j=Ne.j,Se.S=Ne.S.slice(),Se}function le(Ne,Se){var Be,Pe=[],Z=typeof Ne;if(Se&&"object"==Z)for(Be in Ne)try{Pe.push(le(Ne[Be],Se-1))}catch{}return Pe.length?Pe:"string"==Z?Ne:Ne+"\0"}function xe(Ne,Se){for(var Z,Pe=Ne+"",Be=0;Be<Pe.length;)Se[ae&Be]=ae&(Z^=19*Se[ae&Be])+Pe.charCodeAt(Be++);return $e(Se)}function $e(Ne){return String.fromCharCode.apply(0,Ne)}if(xe(de.random(),ye),ze.exports){ze.exports=Ue;try{ie=Y(5042)}catch{}}else void 0!==(te=function(){return Ue}.call(Fe,Y,Fe,ze))&&(ze.exports=te)}(typeof self<"u"?self:this,[],Math)},7253:(ze,Fe,Y)=>{"use strict";Y.r(Fe),Y.d(Fe,{default:()=>te});class te{constructor(de=[],Me=he){if(this.data=de,this.length=this.data.length,this.compare=Me,this.length>0)for(let H=(this.length>>1)-1;H>=0;H--)this._down(H)}push(de){this.data.push(de),this.length++,this._up(this.length-1)}pop(){if(0===this.length)return;const de=this.data[0],Me=this.data.pop();return this.length--,this.length>0&&(this.data[0]=Me,this._down(0)),de}peek(){return this.data[0]}_up(de){const{data:Me,compare:H}=this,Ye=Me[de];for(;de>0;){const Je=de-1>>1,Ae=Me[Je];if(H(Ye,Ae)>=0)break;Me[de]=Ae,de=Je}Me[de]=Ye}_down(de){const{data:Me,compare:H}=this,Ye=this.length>>1,Je=Me[de];for(;de<Ye;){let Ae=1+(de<<1),Le=Me[Ae];const re=Ae+1;if(re<this.length&&H(Me[re],Le)<0&&(Ae=re,Le=Me[re]),H(Le,Je)>=0)break;Me[de]=Le,de=Ae}Me[de]=Je}}function he(ye,de){return ye<de?-1:ye>de?1:0}},770:function(ze,Fe){!function(Y){"use strict";function te(){}function he(u){this.message=u||""}function ye(u){this.message=u||""}function de(u){this.message=u||""}function Me(){}function H(u){return null===u?zn:u.color}function Ye(u){return null===u?null:u.parent}function Je(u,h){null!==u&&(u.color=h)}function Ae(u){return null===u?null:u.left}function Le(u){return null===u?null:u.right}function re(){this.root_=null,this.size_=0}function ae(){}function ie(){this.array_=[],arguments[0]instanceof Kr&&this.addAll(arguments[0])}function Ue(){}function Q(u){this.message=u||""}function pe(){this.array_=[]}"fill"in Array.prototype||Object.defineProperty(Array.prototype,"fill",{configurable:!0,value:function(u){if(null==this)throw new TypeError(this+" is not an object");var h=Object(this),x=Math.max(Math.min(h.length,9007199254740991),0)||0,_=1 in arguments&&parseInt(Number(arguments[1]),10)||0;_=_<0?Math.max(x+_,0):Math.min(_,x);var M=2 in arguments&&void 0!==arguments[2]?parseInt(Number(arguments[2]),10)||0:x;for(M=M<0?Math.max(x+arguments[2],0):Math.min(M,x);_<M;)h[_]=u,++_;return h},writable:!0}),Number.isFinite=Number.isFinite||function(u){return"number"==typeof u&&isFinite(u)},Number.isInteger=Number.isInteger||function(u){return"number"==typeof u&&isFinite(u)&&Math.floor(u)===u},Number.parseFloat=Number.parseFloat||parseFloat,Number.isNaN=Number.isNaN||function(u){return u!=u},Math.trunc=Math.trunc||function(u){return u<0?Math.ceil(u):Math.floor(u)};var le=function(){};le.prototype.interfaces_=function(){return[]},le.prototype.getClass=function(){return le},le.prototype.equalsWithTolerance=function(u,h,x){return Math.abs(u-h)<=x};var xe=function(u){function h(x){u.call(this,x),this.name="IllegalArgumentException",this.message=x,this.stack=(new u).stack}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h}(Error),we=function(){},$e={MAX_VALUE:{configurable:!0}};we.isNaN=function(u){return Number.isNaN(u)},we.doubleToLongBits=function(u){return u},we.longBitsToDouble=function(u){return u},we.isInfinite=function(u){return!Number.isFinite(u)},$e.MAX_VALUE.get=function(){return Number.MAX_VALUE},Object.defineProperties(we,$e);var Ne=function(){},Se=function(){},Pe=function(){},Z=function u(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)this.x=0,this.y=0,this.z=u.NULL_ORDINATE;else if(1===arguments.length){var h=arguments[0];this.x=h.x,this.y=h.y,this.z=h.z}else 2===arguments.length?(this.x=arguments[0],this.y=arguments[1],this.z=u.NULL_ORDINATE):3===arguments.length&&(this.x=arguments[0],this.y=arguments[1],this.z=arguments[2])},Be={DimensionalComparator:{configurable:!0},serialVersionUID:{configurable:!0},NULL_ORDINATE:{configurable:!0},X:{configurable:!0},Y:{configurable:!0},Z:{configurable:!0}};Z.prototype.setOrdinate=function(u,h){switch(u){case Z.X:this.x=h;break;case Z.Y:this.y=h;break;case Z.Z:this.z=h;break;default:throw new xe("Invalid ordinate index: "+u)}},Z.prototype.equals2D=function(){if(1===arguments.length){var u=arguments[0];return this.x===u.x&&this.y===u.y}if(2===arguments.length){var h=arguments[0],x=arguments[1];return!!le.equalsWithTolerance(this.x,h.x,x)&&!!le.equalsWithTolerance(this.y,h.y,x)}},Z.prototype.getOrdinate=function(u){switch(u){case Z.X:return this.x;case Z.Y:return this.y;case Z.Z:return this.z}throw new xe("Invalid ordinate index: "+u)},Z.prototype.equals3D=function(u){return this.x===u.x&&this.y===u.y&&(this.z===u.z||we.isNaN(this.z))&&we.isNaN(u.z)},Z.prototype.equals=function(u){return u instanceof Z&&this.equals2D(u)},Z.prototype.equalInZ=function(u,h){return le.equalsWithTolerance(this.z,u.z,h)},Z.prototype.compareTo=function(u){return this.x<u.x?-1:this.x>u.x?1:this.y<u.y?-1:this.y>u.y?1:0},Z.prototype.clone=function(){},Z.prototype.copy=function(){return new Z(this)},Z.prototype.toString=function(){return"("+this.x+", "+this.y+", "+this.z+")"},Z.prototype.distance3D=function(u){var h=this.x-u.x,x=this.y-u.y,_=this.z-u.z;return Math.sqrt(h*h+x*x+_*_)},Z.prototype.distance=function(u){var h=this.x-u.x,x=this.y-u.y;return Math.sqrt(h*h+x*x)},Z.prototype.hashCode=function(){var u=17;return 37*(u=37*u+Z.hashCode(this.x))+Z.hashCode(this.y)},Z.prototype.setCoordinate=function(u){this.x=u.x,this.y=u.y,this.z=u.z},Z.prototype.interfaces_=function(){return[Ne,Se,te]},Z.prototype.getClass=function(){return Z},Z.hashCode=function(){if(1===arguments.length){var h=we.doubleToLongBits(arguments[0]);return Math.trunc((h^h)>>>32)}},Be.DimensionalComparator.get=function(){return ue},Be.serialVersionUID.get=function(){return 0x5cbf2c235c7e5800},Be.NULL_ORDINATE.get=function(){return we.NaN},Be.X.get=function(){return 0},Be.Y.get=function(){return 1},Be.Z.get=function(){return 2},Object.defineProperties(Z,Be);var ue=function(u){if(this._dimensionsToTest=2,0!==arguments.length&&1===arguments.length){var h=arguments[0];if(2!==h&&3!==h)throw new xe("only 2 or 3 dimensions may be specified");this._dimensionsToTest=h}};ue.prototype.compare=function(u,h){var x=u,_=h,M=ue.compare(x.x,_.x);if(0!==M)return M;var z=ue.compare(x.y,_.y);return 0!==z?z:this._dimensionsToTest<=2?0:ue.compare(x.z,_.z)},ue.prototype.interfaces_=function(){return[Pe]},ue.prototype.getClass=function(){return ue},ue.compare=function(u,h){return u<h?-1:u>h?1:we.isNaN(u)?we.isNaN(h)?0:-1:we.isNaN(h)?1:0};var He=function(){};He.prototype.create=function(){},He.prototype.interfaces_=function(){return[]},He.prototype.getClass=function(){return He};var _e=function(){},kt={INTERIOR:{configurable:!0},BOUNDARY:{configurable:!0},EXTERIOR:{configurable:!0},NONE:{configurable:!0}};_e.prototype.interfaces_=function(){return[]},_e.prototype.getClass=function(){return _e},_e.toLocationSymbol=function(u){switch(u){case _e.EXTERIOR:return"e";case _e.BOUNDARY:return"b";case _e.INTERIOR:return"i";case _e.NONE:return"-"}throw new xe("Unknown location value: "+u)},kt.INTERIOR.get=function(){return 0},kt.BOUNDARY.get=function(){return 1},kt.EXTERIOR.get=function(){return 2},kt.NONE.get=function(){return-1},Object.defineProperties(_e,kt);var Ct=function(u,h){return u.interfaces_&&u.interfaces_().indexOf(h)>-1},Ke=function(){},rt={LOG_10:{configurable:!0}};Ke.prototype.interfaces_=function(){return[]},Ke.prototype.getClass=function(){return Ke},Ke.log10=function(u){var h=Math.log(u);return we.isInfinite(h)||we.isNaN(h)?h:h/Ke.LOG_10},Ke.min=function(u,h,x,_){var M=u;return h<M&&(M=h),x<M&&(M=x),_<M&&(M=_),M},Ke.clamp=function(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){var u=arguments[0],h=arguments[1],x=arguments[2];return u<h?h:u>x?x:u}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var _=arguments[0],M=arguments[1],z=arguments[2];return _<M?M:_>z?z:_}},Ke.wrap=function(u,h){return u<0?h- -u%h:u%h},Ke.max=function(){if(3===arguments.length){var h=arguments[1],x=arguments[2],_=arguments[0];return h>_&&(_=h),x>_&&(_=x),_}if(4===arguments.length){var z=arguments[1],q=arguments[2],me=arguments[3],Ze=arguments[0];return z>Ze&&(Ze=z),q>Ze&&(Ze=q),me>Ze&&(Ze=me),Ze}},Ke.average=function(u,h){return(u+h)/2},rt.LOG_10.get=function(){return Math.log(10)},Object.defineProperties(Ke,rt);var et=function(u){this.str=u};et.prototype.append=function(u){this.str+=u},et.prototype.setCharAt=function(u,h){this.str=this.str.substr(0,u)+h+this.str.substr(u+1)},et.prototype.toString=function(u){return this.str};var pt=function(u){this.value=u};pt.prototype.intValue=function(){return this.value},pt.prototype.compareTo=function(u){return this.value<u?-1:this.value>u?1:0},pt.isNaN=function(u){return Number.isNaN(u)};var dt=function(){};dt.isWhitespace=function(u){return u<=32&&u>=0||127===u},dt.toUpperCase=function(u){return u.toUpperCase()};var je=function u(){this._hi=0,this._lo=0,0===arguments.length?this.init(0):1===arguments.length?"number"==typeof arguments[0]||arguments[0]instanceof u?this.init(arguments[0]):"string"==typeof arguments[0]&&u.call(this,u.parse(arguments[0])):2===arguments.length&&this.init(arguments[0],arguments[1])},zt={PI:{configurable:!0},TWO_PI:{configurable:!0},PI_2:{configurable:!0},E:{configurable:!0},NaN:{configurable:!0},EPS:{configurable:!0},SPLIT:{configurable:!0},MAX_PRINT_DIGITS:{configurable:!0},TEN:{configurable:!0},ONE:{configurable:!0},SCI_NOT_EXPONENT_CHAR:{configurable:!0},SCI_NOT_ZERO:{configurable:!0}};je.prototype.le=function(u){return(this._hi<u._hi||this._hi===u._hi)&&this._lo<=u._lo},je.prototype.extractSignificantDigits=function(u,h){var x=this.abs(),_=je.magnitude(x._hi),M=je.TEN.pow(_);(x=x.divide(M)).gt(je.TEN)?(x=x.divide(je.TEN),_+=1):x.lt(je.ONE)&&(x=x.multiply(je.TEN),_-=1);for(var z=_+1,q=new et,me=je.MAX_PRINT_DIGITS-1,Ze=0;Ze<=me;Ze++){u&&Ze===z&&q.append(".");var lt=Math.trunc(x._hi);if(lt<0)break;var Vt=!1,Yt=0;lt>9?(Vt=!0,Yt="9"):Yt="0"+lt,q.append(Yt),x=x.subtract(je.valueOf(lt)).multiply(je.TEN),Vt&&x.selfAdd(je.TEN);var wn=!0,En=je.magnitude(x._hi);if(En<0&&Math.abs(En)>=me-Ze&&(wn=!1),!wn)break}return h[0]=_,q.toString()},je.prototype.sqr=function(){return this.multiply(this)},je.prototype.doubleValue=function(){return this._hi+this._lo},je.prototype.subtract=function(){return arguments[0]instanceof je?this.add(arguments[0].negate()):"number"==typeof arguments[0]?this.add(-arguments[0]):void 0},je.prototype.equals=function(){if(1===arguments.length){var u=arguments[0];return this._hi===u._hi&&this._lo===u._lo}},je.prototype.isZero=function(){return 0===this._hi&&0===this._lo},je.prototype.selfSubtract=function(){if(arguments[0]instanceof je){var u=arguments[0];return this.isNaN()?this:this.selfAdd(-u._hi,-u._lo)}if("number"==typeof arguments[0]){var h=arguments[0];return this.isNaN()?this:this.selfAdd(-h,0)}},je.prototype.getSpecialNumberString=function(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null},je.prototype.min=function(u){return this.le(u)?this:u},je.prototype.selfDivide=function(){if(1===arguments.length){if(arguments[0]instanceof je){var u=arguments[0];return this.selfDivide(u._hi,u._lo)}if("number"==typeof arguments[0])return this.selfDivide(arguments[0],0)}else if(2===arguments.length){var z,me,Ze,Vt,x=arguments[0],M=null,q=null,lt=null,Yt=null;return this._hi=Yt=(Ze=this._hi/x)+(lt=(this._hi-(Vt=Ze*x)-(Yt=(M=(lt=je.SPLIT*Ze)-(M=lt-Ze))*(q=(Yt=je.SPLIT*x)-(q=Yt-x))-Vt+M*(me=x-q)+(z=Ze-M)*q+z*me)+this._lo-Ze*arguments[1])/x),this._lo=Ze-Yt+lt,this}},je.prototype.dump=function(){return"DD<"+this._hi+", "+this._lo+">"},je.prototype.divide=function(){if(arguments[0]instanceof je){var x,M,z,me,u=arguments[0],h=null,_=null,q=null,Ze=null;return x=(z=this._hi/u._hi)-(h=(q=je.SPLIT*z)-(h=q-z)),Ze=h*(_=(Ze=je.SPLIT*u._hi)-(_=Ze-u._hi))-(me=z*u._hi)+h*(M=u._hi-_)+x*_+x*M,new je(Ze=z+(q=(this._hi-me-Ze+this._lo-z*u._lo)/u._hi),z-Ze+q)}if("number"==typeof arguments[0]){var lt=arguments[0];return we.isNaN(lt)?je.createNaN():je.copy(this).selfDivide(lt,0)}},je.prototype.ge=function(u){return(this._hi>u._hi||this._hi===u._hi)&&this._lo>=u._lo},je.prototype.pow=function(u){if(0===u)return je.valueOf(1);var h=new je(this),x=je.valueOf(1),_=Math.abs(u);if(_>1)for(;_>0;)_%2==1&&x.selfMultiply(h),(_/=2)>0&&(h=h.sqr());else x=h;return u<0?x.reciprocal():x},je.prototype.ceil=function(){if(this.isNaN())return je.NaN;var u=Math.ceil(this._hi),h=0;return u===this._hi&&(h=Math.ceil(this._lo)),new je(u,h)},je.prototype.compareTo=function(u){return this._hi<u._hi?-1:this._hi>u._hi?1:this._lo<u._lo?-1:this._lo>u._lo?1:0},je.prototype.rint=function(){return this.isNaN()?this:this.add(.5).floor()},je.prototype.setValue=function(){return arguments[0]instanceof je||"number"==typeof arguments[0]?(this.init(arguments[0]),this):void 0},je.prototype.max=function(u){return this.ge(u)?this:u},je.prototype.sqrt=function(){if(this.isZero())return je.valueOf(0);if(this.isNegative())return je.NaN;var u=1/Math.sqrt(this._hi),x=je.valueOf(this._hi*u),_=this.subtract(x.sqr())._hi*(.5*u);return x.add(_)},je.prototype.selfAdd=function(){if(1===arguments.length){if(arguments[0]instanceof je){var u=arguments[0];return this.selfAdd(u._hi,u._lo)}if("number"==typeof arguments[0]){var x,_,M,q,me,h=arguments[0];return this._hi=(x=(M=this._hi+h)+(me=h-(q=M-this._hi)+(this._hi-(M-q))+this._lo))+(_=me+(M-x)),this._lo=_+(x-this._hi),this}}else if(2===arguments.length){var Vt,Yt,En,fi,Ze=arguments[0],lt=arguments[1],wn=null,Fn=null,or=null;Fn=(En=this._hi+Ze)-(or=En-this._hi),wn=(Yt=this._lo+lt)-(fi=Yt-this._lo);var ji=(Vt=En+(or=(Fn=Ze-or+(this._hi-Fn))+Yt))+(or=(wn=lt-fi+(this._lo-wn))+(or+(En-Vt))),ro=or+(Vt-ji);return this._hi=ji,this._lo=ro,this}},je.prototype.selfMultiply=function(){if(1===arguments.length){if(arguments[0]instanceof je){var u=arguments[0];return this.selfMultiply(u._hi,u._lo)}if("number"==typeof arguments[0])return this.selfMultiply(arguments[0],0)}else if(2===arguments.length){var z,me,x=arguments[0],M=null,q=null,Ze=null,lt=null;M=(Ze=je.SPLIT*this._hi)-this._hi,M=Ze-M;var Vt=(Ze=this._hi*x)+(lt=M*(q=(lt=je.SPLIT*x)-(q=lt-x))-Ze+M*(me=x-q)+(z=this._hi-M)*q+z*me+(this._hi*arguments[1]+this._lo*x)),Yt=lt+(M=Ze-Vt);return this._hi=Vt,this._lo=Yt,this}},je.prototype.selfSqr=function(){return this.selfMultiply(this)},je.prototype.floor=function(){if(this.isNaN())return je.NaN;var u=Math.floor(this._hi),h=0;return u===this._hi&&(h=Math.floor(this._lo)),new je(u,h)},je.prototype.negate=function(){return this.isNaN()?this:new je(-this._hi,-this._lo)},je.prototype.clone=function(){},je.prototype.multiply=function(){if(arguments[0]instanceof je){var u=arguments[0];return u.isNaN()?je.createNaN():je.copy(this).selfMultiply(u)}if("number"==typeof arguments[0]){var h=arguments[0];return we.isNaN(h)?je.createNaN():je.copy(this).selfMultiply(h,0)}},je.prototype.isNaN=function(){return we.isNaN(this._hi)},je.prototype.intValue=function(){return Math.trunc(this._hi)},je.prototype.toString=function(){var u=je.magnitude(this._hi);return u>=-3&&u<=20?this.toStandardNotation():this.toSciNotation()},je.prototype.toStandardNotation=function(){var u=this.getSpecialNumberString();if(null!==u)return u;var h=new Array(1).fill(null),x=this.extractSignificantDigits(!0,h),_=h[0]+1,M=x;return"."===x.charAt(0)?M="0"+x:_<0?M="0."+je.stringOfChar("0",-_)+x:-1===x.indexOf(".")&&(M=x+je.stringOfChar("0",_-x.length)+".0"),this.isNegative()?"-"+M:M},je.prototype.reciprocal=function(){var h,_,M,q,u=null,x=null,z=null,me=null;h=(M=1/this._hi)-(u=(z=je.SPLIT*M)-(u=z-M)),x=(me=je.SPLIT*this._hi)-this._hi;var Ze=M+(z=(1-(q=M*this._hi)-(me=u*(x=me-x)-q+u*(_=this._hi-x)+h*x+h*_)-M*this._lo)/this._hi);return new je(Ze,M-Ze+z)},je.prototype.toSciNotation=function(){if(this.isZero())return je.SCI_NOT_ZERO;var u=this.getSpecialNumberString();if(null!==u)return u;var h=new Array(1).fill(null),x=this.extractSignificantDigits(!1,h),_=je.SCI_NOT_EXPONENT_CHAR+h[0];if("0"===x.charAt(0))throw new Error("Found leading zero: "+x);var M="";x.length>1&&(M=x.substring(1));var z=x.charAt(0)+"."+M;return this.isNegative()?"-"+z+_:z+_},je.prototype.abs=function(){return this.isNaN()?je.NaN:this.isNegative()?this.negate():new je(this)},je.prototype.isPositive=function(){return(this._hi>0||0===this._hi)&&this._lo>0},je.prototype.lt=function(u){return(this._hi<u._hi||this._hi===u._hi)&&this._lo<u._lo},je.prototype.add=function(){if(arguments[0]instanceof je){var u=arguments[0];return je.copy(this).selfAdd(u)}if("number"==typeof arguments[0]){var h=arguments[0];return je.copy(this).selfAdd(h)}},je.prototype.init=function(){if(1===arguments.length){if("number"==typeof arguments[0])this._hi=arguments[0],this._lo=0;else if(arguments[0]instanceof je){var h=arguments[0];this._hi=h._hi,this._lo=h._lo}}else if(2===arguments.length){var _=arguments[1];this._hi=arguments[0],this._lo=_}},je.prototype.gt=function(u){return(this._hi>u._hi||this._hi===u._hi)&&this._lo>u._lo},je.prototype.isNegative=function(){return(this._hi<0||0===this._hi)&&this._lo<0},je.prototype.trunc=function(){return this.isNaN()?je.NaN:this.isPositive()?this.floor():this.ceil()},je.prototype.signum=function(){return this._hi>0?1:this._hi<0?-1:this._lo>0?1:this._lo<0?-1:0},je.prototype.interfaces_=function(){return[te,Ne,Se]},je.prototype.getClass=function(){return je},je.sqr=function(u){return je.valueOf(u).selfMultiply(u)},je.valueOf=function(){return"string"==typeof arguments[0]?je.parse(arguments[0]):"number"==typeof arguments[0]?new je(arguments[0]):void 0},je.sqrt=function(u){return je.valueOf(u).sqrt()},je.parse=function(u){for(var h=0,x=u.length;dt.isWhitespace(u.charAt(h));)h++;var _=!1;if(h<x){var M=u.charAt(h);"-"!==M&&"+"!==M||(h++,"-"===M&&(_=!0))}for(var z=new je,q=0,me=0,Ze=0;!(h>=x);){var lt=u.charAt(h);if(h++,dt.isDigit(lt)){var Vt=lt-"0";z.selfMultiply(je.TEN),z.selfAdd(Vt),q++}else{if("."!==lt){if("e"===lt||"E"===lt){var Yt=u.substring(h);try{Ze=pt.parseInt(Yt)}catch(fi){throw fi instanceof Error?new Error("Invalid exponent "+Yt+" in string "+u):fi}break}throw new Error("Unexpected character '"+lt+"' at position "+h+" in string "+u)}me=q}}var wn=z,En=q-me-Ze;if(0===En)wn=z;else if(En>0){var Fn=je.TEN.pow(En);wn=z.divide(Fn)}else if(En<0){var or=je.TEN.pow(-En);wn=z.multiply(or)}return _?wn.negate():wn},je.createNaN=function(){return new je(we.NaN,we.NaN)},je.copy=function(u){return new je(u)},je.magnitude=function(u){var h=Math.abs(u),x=Math.log(h)/Math.log(10),_=Math.trunc(Math.floor(x));return 10*Math.pow(10,_)<=h&&(_+=1),_},je.stringOfChar=function(u,h){for(var x=new et,_=0;_<h;_++)x.append(u);return x.toString()},zt.PI.get=function(){return new je(3.141592653589793,12246467991473532e-32)},zt.TWO_PI.get=function(){return new je(6.283185307179586,24492935982947064e-32)},zt.PI_2.get=function(){return new je(1.5707963267948966,6123233995736766e-32)},zt.E.get=function(){return new je(2.718281828459045,14456468917292502e-32)},zt.NaN.get=function(){return new je(we.NaN,we.NaN)},zt.EPS.get=function(){return 123259516440783e-46},zt.SPLIT.get=function(){return 134217729},zt.MAX_PRINT_DIGITS.get=function(){return 32},zt.TEN.get=function(){return je.valueOf(10)},zt.ONE.get=function(){return je.valueOf(1)},zt.SCI_NOT_EXPONENT_CHAR.get=function(){return"E"},zt.SCI_NOT_ZERO.get=function(){return"0.0E0"},Object.defineProperties(je,zt);var $t=function(){},tn={DP_SAFE_EPSILON:{configurable:!0}};$t.prototype.interfaces_=function(){return[]},$t.prototype.getClass=function(){return $t},$t.orientationIndex=function(u,h,x){var _=$t.orientationIndexFilter(u,h,x);if(_<=1)return _;var M=je.valueOf(h.x).selfAdd(-u.x),z=je.valueOf(h.y).selfAdd(-u.y),q=je.valueOf(x.x).selfAdd(-h.x),me=je.valueOf(x.y).selfAdd(-h.y);return M.selfMultiply(me).selfSubtract(z.selfMultiply(q)).signum()},$t.signOfDet2x2=function(u,h,x,_){return u.multiply(_).selfSubtract(h.multiply(x)).signum()},$t.intersection=function(u,h,x,_){var M=je.valueOf(_.y).selfSubtract(x.y).selfMultiply(je.valueOf(h.x).selfSubtract(u.x)),z=je.valueOf(_.x).selfSubtract(x.x).selfMultiply(je.valueOf(h.y).selfSubtract(u.y)),q=M.subtract(z),me=je.valueOf(_.x).selfSubtract(x.x).selfMultiply(je.valueOf(u.y).selfSubtract(x.y)),Ze=je.valueOf(_.y).selfSubtract(x.y).selfMultiply(je.valueOf(u.x).selfSubtract(x.x)),lt=me.subtract(Ze).selfDivide(q).doubleValue(),Vt=je.valueOf(u.x).selfAdd(je.valueOf(h.x).selfSubtract(u.x).selfMultiply(lt)).doubleValue(),Yt=je.valueOf(h.x).selfSubtract(u.x).selfMultiply(je.valueOf(u.y).selfSubtract(x.y)),wn=je.valueOf(h.y).selfSubtract(u.y).selfMultiply(je.valueOf(u.x).selfSubtract(x.x)),En=Yt.subtract(wn).selfDivide(q).doubleValue(),Fn=je.valueOf(x.y).selfAdd(je.valueOf(_.y).selfSubtract(x.y).selfMultiply(En)).doubleValue();return new Z(Vt,Fn)},$t.orientationIndexFilter=function(u,h,x){var _=null,M=(u.x-x.x)*(h.y-x.y),z=(u.y-x.y)*(h.x-x.x),q=M-z;if(M>0){if(z<=0)return $t.signum(q);_=M+z}else{if(!(M<0)||z>=0)return $t.signum(q);_=-M-z}var me=$t.DP_SAFE_EPSILON*_;return q>=me||-q>=me?$t.signum(q):2},$t.signum=function(u){return u>0?1:u<0?-1:0},tn.DP_SAFE_EPSILON.get=function(){return 1e-15},Object.defineProperties($t,tn);var Gt=function(){},Rn={X:{configurable:!0},Y:{configurable:!0},Z:{configurable:!0},M:{configurable:!0}};Rn.X.get=function(){return 0},Rn.Y.get=function(){return 1},Rn.Z.get=function(){return 2},Rn.M.get=function(){return 3},Gt.prototype.setOrdinate=function(u,h,x){},Gt.prototype.size=function(){},Gt.prototype.getOrdinate=function(u,h){},Gt.prototype.getCoordinate=function(){},Gt.prototype.getCoordinateCopy=function(u){},Gt.prototype.getDimension=function(){},Gt.prototype.getX=function(u){},Gt.prototype.clone=function(){},Gt.prototype.expandEnvelope=function(u){},Gt.prototype.copy=function(){},Gt.prototype.getY=function(u){},Gt.prototype.toCoordinateArray=function(){},Gt.prototype.interfaces_=function(){return[Se]},Gt.prototype.getClass=function(){return Gt},Object.defineProperties(Gt,Rn);var Bn=function(){},kn=function(u){function h(){u.call(this,"Projective point not representable on the Cartesian plane.")}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(Bn),qn=function(){};qn.arraycopy=function(u,h,x,_,M){for(var z=0,q=h;q<h+M;q++)x[_+z]=u[q],z++},qn.getProperty=function(u){return{"line.separator":"\n"}[u]};var $n=function u(){if(this.x=null,this.y=null,this.w=null,0===arguments.length)this.x=0,this.y=0,this.w=1;else if(1===arguments.length){var h=arguments[0];this.x=h.x,this.y=h.y,this.w=1}else if(2===arguments.length){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var _=arguments[1];this.x=arguments[0],this.y=_,this.w=1}else if(arguments[0]instanceof u&&arguments[1]instanceof u){var M=arguments[0],z=arguments[1];this.x=M.y*z.w-z.y*M.w,this.y=z.x*M.w-M.x*z.w,this.w=M.x*z.y-z.x*M.y}else if(arguments[0]instanceof Z&&arguments[1]instanceof Z){var q=arguments[0],me=arguments[1];this.x=q.y-me.y,this.y=me.x-q.x,this.w=q.x*me.y-me.x*q.y}}else if(3===arguments.length){var lt=arguments[1],Vt=arguments[2];this.x=arguments[0],this.y=lt,this.w=Vt}else if(4===arguments.length){var Yt=arguments[0],wn=arguments[1],En=arguments[2],Fn=arguments[3],or=Yt.y-wn.y,fi=wn.x-Yt.x,ji=Yt.x*wn.y-wn.x*Yt.y,ro=En.y-Fn.y,io=Fn.x-En.x,Fs=En.x*Fn.y-Fn.x*En.y;this.x=fi*Fs-io*ji,this.y=ro*ji-or*Fs,this.w=or*io-ro*fi}};$n.prototype.getY=function(){var u=this.y/this.w;if(we.isNaN(u)||we.isInfinite(u))throw new kn;return u},$n.prototype.getX=function(){var u=this.x/this.w;if(we.isNaN(u)||we.isInfinite(u))throw new kn;return u},$n.prototype.getCoordinate=function(){var u=new Z;return u.x=this.getX(),u.y=this.getY(),u},$n.prototype.interfaces_=function(){return[]},$n.prototype.getClass=function(){return $n},$n.intersection=function(u,h,x,_){var M=u.y-h.y,z=h.x-u.x,q=u.x*h.y-h.x*u.y,me=x.y-_.y,Ze=_.x-x.x,lt=x.x*_.y-_.x*x.y,Vt=M*Ze-me*z,Yt=(z*lt-Ze*q)/Vt,wn=(me*q-M*lt)/Vt;if(we.isNaN(Yt)||we.isInfinite(Yt)||we.isNaN(wn)||we.isInfinite(wn))throw new kn;return new Z(Yt,wn)};var Qe=function u(){if(this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,0===arguments.length)this.init();else if(1===arguments.length)if(arguments[0]instanceof Z){var h=arguments[0];this.init(h.x,h.x,h.y,h.y)}else arguments[0]instanceof u&&this.init(arguments[0]);else if(2===arguments.length){var _=arguments[0],M=arguments[1];this.init(_.x,M.x,_.y,M.y)}else 4===arguments.length&&this.init(arguments[0],arguments[1],arguments[2],arguments[3])},Gi={serialVersionUID:{configurable:!0}};Qe.prototype.getArea=function(){return this.getWidth()*this.getHeight()},Qe.prototype.equals=function(u){if(!(u instanceof Qe))return!1;var h=u;return this.isNull()?h.isNull():this._maxx===h.getMaxX()&&this._maxy===h.getMaxY()&&this._minx===h.getMinX()&&this._miny===h.getMinY()},Qe.prototype.intersection=function(u){return this.isNull()||u.isNull()||!this.intersects(u)?new Qe:new Qe(this._minx>u._minx?this._minx:u._minx,this._maxx<u._maxx?this._maxx:u._maxx,this._miny>u._miny?this._miny:u._miny,this._maxy<u._maxy?this._maxy:u._maxy)},Qe.prototype.isNull=function(){return this._maxx<this._minx},Qe.prototype.getMaxX=function(){return this._maxx},Qe.prototype.covers=function(){if(1===arguments.length){if(arguments[0]instanceof Z){var u=arguments[0];return this.covers(u.x,u.y)}if(arguments[0]instanceof Qe){var h=arguments[0];return!this.isNull()&&!h.isNull()&&h.getMinX()>=this._minx&&h.getMaxX()<=this._maxx&&h.getMinY()>=this._miny&&h.getMaxY()<=this._maxy}}else if(2===arguments.length){var x=arguments[0],_=arguments[1];return!this.isNull()&&x>=this._minx&&x<=this._maxx&&_>=this._miny&&_<=this._maxy}},Qe.prototype.intersects=function(){if(1===arguments.length){if(arguments[0]instanceof Qe){var u=arguments[0];return!this.isNull()&&!u.isNull()&&!(u._minx>this._maxx||u._maxx<this._minx||u._miny>this._maxy||u._maxy<this._miny)}if(arguments[0]instanceof Z){var h=arguments[0];return this.intersects(h.x,h.y)}}else if(2===arguments.length){var x=arguments[0],_=arguments[1];return!this.isNull()&&!(x>this._maxx||x<this._minx||_>this._maxy||_<this._miny)}},Qe.prototype.getMinY=function(){return this._miny},Qe.prototype.getMinX=function(){return this._minx},Qe.prototype.expandToInclude=function(){if(1===arguments.length){if(arguments[0]instanceof Z){var u=arguments[0];this.expandToInclude(u.x,u.y)}else if(arguments[0]instanceof Qe){var h=arguments[0];if(h.isNull())return null;this.isNull()?(this._minx=h.getMinX(),this._maxx=h.getMaxX(),this._miny=h.getMinY(),this._maxy=h.getMaxY()):(h._minx<this._minx&&(this._minx=h._minx),h._maxx>this._maxx&&(this._maxx=h._maxx),h._miny<this._miny&&(this._miny=h._miny),h._maxy>this._maxy&&(this._maxy=h._maxy))}}else if(2===arguments.length){var x=arguments[0],_=arguments[1];this.isNull()?(this._minx=x,this._maxx=x,this._miny=_,this._maxy=_):(x<this._minx&&(this._minx=x),x>this._maxx&&(this._maxx=x),_<this._miny&&(this._miny=_),_>this._maxy&&(this._maxy=_))}},Qe.prototype.minExtent=function(){if(this.isNull())return 0;var u=this.getWidth(),h=this.getHeight();return u<h?u:h},Qe.prototype.getWidth=function(){return this.isNull()?0:this._maxx-this._minx},Qe.prototype.compareTo=function(u){var h=u;return this.isNull()?h.isNull()?0:-1:h.isNull()?1:this._minx<h._minx?-1:this._minx>h._minx?1:this._miny<h._miny?-1:this._miny>h._miny?1:this._maxx<h._maxx?-1:this._maxx>h._maxx?1:this._maxy<h._maxy?-1:this._maxy>h._maxy?1:0},Qe.prototype.translate=function(u,h){if(this.isNull())return null;this.init(this.getMinX()+u,this.getMaxX()+u,this.getMinY()+h,this.getMaxY()+h)},Qe.prototype.toString=function(){return"Env["+this._minx+" : "+this._maxx+", "+this._miny+" : "+this._maxy+"]"},Qe.prototype.setToNull=function(){this._minx=0,this._maxx=-1,this._miny=0,this._maxy=-1},Qe.prototype.getHeight=function(){return this.isNull()?0:this._maxy-this._miny},Qe.prototype.maxExtent=function(){if(this.isNull())return 0;var u=this.getWidth(),h=this.getHeight();return u>h?u:h},Qe.prototype.expandBy=function(){if(1===arguments.length){var u=arguments[0];this.expandBy(u,u)}else if(2===arguments.length){var h=arguments[0],x=arguments[1];if(this.isNull())return null;this._minx-=h,this._maxx+=h,this._miny-=x,this._maxy+=x,(this._minx>this._maxx||this._miny>this._maxy)&&this.setToNull()}},Qe.prototype.contains=function(){if(1===arguments.length){if(arguments[0]instanceof Qe)return this.covers(arguments[0]);if(arguments[0]instanceof Z)return this.covers(arguments[0])}else if(2===arguments.length)return this.covers(arguments[0],arguments[1])},Qe.prototype.centre=function(){return this.isNull()?null:new Z((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)},Qe.prototype.init=function(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof Z){var u=arguments[0];this.init(u.x,u.x,u.y,u.y)}else if(arguments[0]instanceof Qe){var h=arguments[0];this._minx=h._minx,this._maxx=h._maxx,this._miny=h._miny,this._maxy=h._maxy}}else if(2===arguments.length){var x=arguments[0],_=arguments[1];this.init(x.x,_.x,x.y,_.y)}else if(4===arguments.length){var M=arguments[0],z=arguments[1],q=arguments[2],me=arguments[3];M<z?(this._minx=M,this._maxx=z):(this._minx=z,this._maxx=M),q<me?(this._miny=q,this._maxy=me):(this._miny=me,this._maxy=q)}},Qe.prototype.getMaxY=function(){return this._maxy},Qe.prototype.distance=function(u){if(this.intersects(u))return 0;var h=0;this._maxx<u._minx?h=u._minx-this._maxx:this._minx>u._maxx&&(h=this._minx-u._maxx);var x=0;return this._maxy<u._miny?x=u._miny-this._maxy:this._miny>u._maxy&&(x=this._miny-u._maxy),0===h?x:0===x?h:Math.sqrt(h*h+x*x)},Qe.prototype.hashCode=function(){var u=17;return 37*(u=37*(u=37*(u=37*u+Z.hashCode(this._minx))+Z.hashCode(this._maxx))+Z.hashCode(this._miny))+Z.hashCode(this._maxy)},Qe.prototype.interfaces_=function(){return[Ne,te]},Qe.prototype.getClass=function(){return Qe},Qe.intersects=function(){if(3===arguments.length){var u=arguments[0],h=arguments[1],x=arguments[2];return x.x>=(u.x<h.x?u.x:h.x)&&x.x<=(u.x>h.x?u.x:h.x)&&x.y>=(u.y<h.y?u.y:h.y)&&x.y<=(u.y>h.y?u.y:h.y)}if(4===arguments.length){var _=arguments[0],M=arguments[1],z=arguments[2],q=arguments[3],me=Math.min(z.x,q.x),Ze=Math.max(z.x,q.x),lt=Math.min(_.x,M.x),Vt=Math.max(_.x,M.x);return!(lt>Ze||Vt<me||(me=Math.min(z.y,q.y),Ze=Math.max(z.y,q.y),lt=Math.min(_.y,M.y),Vt=Math.max(_.y,M.y),lt>Ze||Vt<me))}},Gi.serialVersionUID.get=function(){return 0x51845cd552189800},Object.defineProperties(Qe,Gi);var Ir={typeStr:/^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,emptyTypeStr:/^\s*(\w+)\s*EMPTY\s*$/,spaces:/\s+/,parenComma:/\)\s*,\s*\(/,doubleParenComma:/\)\s*\)\s*,\s*\(\s*\(/,trimParens:/^\s*\(?(.*?)\)?\s*$/},ri=function(u){this.geometryFactory=u||new Mr};ri.prototype.read=function(u){var h,x;u=u.replace(/[\n\r]/g," ");var M=Ir.typeStr.exec(u);if(-1!==u.search("EMPTY")&&((M=Ir.emptyTypeStr.exec(u))[2]=void 0),M&&(x=M[1].toLowerCase(),Vn[x]&&(h=Vn[x].apply(this,[M[2]]))),void 0===h)throw new Error("Could not parse WKT "+u);return h},ri.prototype.write=function(u){return this.extractGeometry(u)},ri.prototype.extractGeometry=function(u){var h=u.getGeometryType().toLowerCase();if(!Yn[h])return null;var x=h.toUpperCase();return u.isEmpty()?x+" EMPTY":x+"("+Yn[h].apply(this,[u])+")"};var Yn={coordinate:function(u){return u.x+" "+u.y},point:function(u){return Yn.coordinate.call(this,u._coordinates._coordinates[0])},multipoint:function(u){for(var h=[],x=0,_=u._geometries.length;x<_;++x)h.push("("+Yn.point.apply(this,[u._geometries[x]])+")");return h.join(",")},linestring:function(u){for(var h=[],x=0,_=u._points._coordinates.length;x<_;++x)h.push(Yn.coordinate.apply(this,[u._points._coordinates[x]]));return h.join(",")},linearring:function(u){for(var h=[],x=0,_=u._points._coordinates.length;x<_;++x)h.push(Yn.coordinate.apply(this,[u._points._coordinates[x]]));return h.join(",")},multilinestring:function(u){for(var h=[],x=0,_=u._geometries.length;x<_;++x)h.push("("+Yn.linestring.apply(this,[u._geometries[x]])+")");return h.join(",")},polygon:function(u){var h=[];h.push("("+Yn.linestring.apply(this,[u._shell])+")");for(var x=0,_=u._holes.length;x<_;++x)h.push("("+Yn.linestring.apply(this,[u._holes[x]])+")");return h.join(",")},multipolygon:function(u){for(var h=[],x=0,_=u._geometries.length;x<_;++x)h.push("("+Yn.polygon.apply(this,[u._geometries[x]])+")");return h.join(",")},geometrycollection:function(u){for(var h=[],x=0,_=u._geometries.length;x<_;++x)h.push(this.extractGeometry(u._geometries[x]));return h.join(",")}},Vn={point:function(u){if(void 0===u)return this.geometryFactory.createPoint();var h=u.trim().split(Ir.spaces);return this.geometryFactory.createPoint(new Z(Number.parseFloat(h[0]),Number.parseFloat(h[1])))},multipoint:function(u){if(void 0===u)return this.geometryFactory.createMultiPoint();for(var h,x=u.trim().split(","),_=[],M=0,z=x.length;M<z;++M)h=x[M].replace(Ir.trimParens,"$1"),_.push(Vn.point.apply(this,[h]));return this.geometryFactory.createMultiPoint(_)},linestring:function(u){if(void 0===u)return this.geometryFactory.createLineString();for(var h,x=u.trim().split(","),_=[],M=0,z=x.length;M<z;++M)h=x[M].trim().split(Ir.spaces),_.push(new Z(Number.parseFloat(h[0]),Number.parseFloat(h[1])));return this.geometryFactory.createLineString(_)},linearring:function(u){if(void 0===u)return this.geometryFactory.createLinearRing();for(var h,x=u.trim().split(","),_=[],M=0,z=x.length;M<z;++M)h=x[M].trim().split(Ir.spaces),_.push(new Z(Number.parseFloat(h[0]),Number.parseFloat(h[1])));return this.geometryFactory.createLinearRing(_)},multilinestring:function(u){if(void 0===u)return this.geometryFactory.createMultiLineString();for(var h,x=u.trim().split(Ir.parenComma),_=[],M=0,z=x.length;M<z;++M)h=x[M].replace(Ir.trimParens,"$1"),_.push(Vn.linestring.apply(this,[h]));return this.geometryFactory.createMultiLineString(_)},polygon:function(u){if(void 0===u)return this.geometryFactory.createPolygon();for(var h,x,_,M,z=u.trim().split(Ir.parenComma),q=[],me=0,Ze=z.length;me<Ze;++me)h=z[me].replace(Ir.trimParens,"$1"),x=Vn.linestring.apply(this,[h]),_=this.geometryFactory.createLinearRing(x._points),0===me?M=_:q.push(_);return this.geometryFactory.createPolygon(M,q)},multipolygon:function(u){if(void 0===u)return this.geometryFactory.createMultiPolygon();for(var h,x=u.trim().split(Ir.doubleParenComma),_=[],M=0,z=x.length;M<z;++M)h=x[M].replace(Ir.trimParens,"$1"),_.push(Vn.polygon.apply(this,[h]));return this.geometryFactory.createMultiPolygon(_)},geometrycollection:function(u){if(void 0===u)return this.geometryFactory.createGeometryCollection();for(var h=(u=u.replace(/,\s*([A-Za-z])/g,"|$1")).trim().split("|"),x=[],_=0,M=h.length;_<M;++_)x.push(this.read(h[_]));return this.geometryFactory.createGeometryCollection(x)}},Tt=function(u){this.parser=new ri(u)};Tt.prototype.write=function(u){return this.parser.write(u)},Tt.toLineString=function(u,h){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+u.x+" "+u.y+", "+h.x+" "+h.y+" )"};var We=function(u){function h(x){u.call(this,x),this.name="RuntimeException",this.message=x,this.stack=(new u).stack}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h}(Error),Oe=function(u){function h(){u.call(this),0===arguments.length?u.call(this):1===arguments.length&&u.call(this,arguments[0])}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(We),De=function(){};De.prototype.interfaces_=function(){return[]},De.prototype.getClass=function(){return De},De.shouldNeverReachHere=function(){if(0===arguments.length)De.shouldNeverReachHere(null);else if(1===arguments.length){var u=arguments[0];throw new Oe("Should never reach here"+(null!==u?": "+u:""))}},De.isTrue=function(){var h;if(1===arguments.length)De.isTrue(arguments[0],null);else if(2===arguments.length&&(h=arguments[1],!arguments[0]))throw null===h?new Oe:new Oe(h)},De.equals=function(){var u,h,x;if(2===arguments.length)De.equals(u=arguments[0],h=arguments[1],null);else if(3===arguments.length&&(x=arguments[2],!(h=arguments[1]).equals(u=arguments[0])))throw new Oe("Expected "+u+" but encountered "+h+(null!==x?": "+x:""))};var nt=function(){this._result=null,this._inputLines=Array(2).fill().map(function(){return Array(2)}),this._intPt=new Array(2).fill(null),this._intLineIndex=null,this._isProper=null,this._pa=null,this._pb=null,this._precisionModel=null,this._intPt[0]=new Z,this._intPt[1]=new Z,this._pa=this._intPt[0],this._pb=this._intPt[1],this._result=0},Te={DONT_INTERSECT:{configurable:!0},DO_INTERSECT:{configurable:!0},COLLINEAR:{configurable:!0},NO_INTERSECTION:{configurable:!0},POINT_INTERSECTION:{configurable:!0},COLLINEAR_INTERSECTION:{configurable:!0}};nt.prototype.getIndexAlongSegment=function(u,h){return this.computeIntLineIndex(),this._intLineIndex[u][h]},nt.prototype.getTopologySummary=function(){var u=new et;return this.isEndPoint()&&u.append(" endpoint"),this._isProper&&u.append(" proper"),this.isCollinear()&&u.append(" collinear"),u.toString()},nt.prototype.computeIntersection=function(u,h,x,_){this._inputLines[0][0]=u,this._inputLines[0][1]=h,this._inputLines[1][0]=x,this._inputLines[1][1]=_,this._result=this.computeIntersect(u,h,x,_)},nt.prototype.getIntersectionNum=function(){return this._result},nt.prototype.computeIntLineIndex=function(){if(0===arguments.length)null===this._intLineIndex&&(this._intLineIndex=Array(2).fill().map(function(){return Array(2)}),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){var u=arguments[0];this.getEdgeDistance(u,0)>this.getEdgeDistance(u,1)?(this._intLineIndex[u][0]=0,this._intLineIndex[u][1]=1):(this._intLineIndex[u][0]=1,this._intLineIndex[u][1]=0)}},nt.prototype.isProper=function(){return this.hasIntersection()&&this._isProper},nt.prototype.setPrecisionModel=function(u){this._precisionModel=u},nt.prototype.isInteriorIntersection=function(){if(0===arguments.length)return!!this.isInteriorIntersection(0)||!!this.isInteriorIntersection(1);if(1===arguments.length){for(var u=arguments[0],h=0;h<this._result;h++)if(!this._intPt[h].equals2D(this._inputLines[u][0])&&!this._intPt[h].equals2D(this._inputLines[u][1]))return!0;return!1}},nt.prototype.getIntersection=function(u){return this._intPt[u]},nt.prototype.isEndPoint=function(){return this.hasIntersection()&&!this._isProper},nt.prototype.hasIntersection=function(){return this._result!==nt.NO_INTERSECTION},nt.prototype.getEdgeDistance=function(u,h){return nt.computeEdgeDistance(this._intPt[h],this._inputLines[u][0],this._inputLines[u][1])},nt.prototype.isCollinear=function(){return this._result===nt.COLLINEAR_INTERSECTION},nt.prototype.toString=function(){return Tt.toLineString(this._inputLines[0][0],this._inputLines[0][1])+" - "+Tt.toLineString(this._inputLines[1][0],this._inputLines[1][1])+this.getTopologySummary()},nt.prototype.getEndpoint=function(u,h){return this._inputLines[u][h]},nt.prototype.isIntersection=function(u){for(var h=0;h<this._result;h++)if(this._intPt[h].equals2D(u))return!0;return!1},nt.prototype.getIntersectionAlongSegment=function(u,h){return this.computeIntLineIndex(),this._intPt[this._intLineIndex[u][h]]},nt.prototype.interfaces_=function(){return[]},nt.prototype.getClass=function(){return nt},nt.computeEdgeDistance=function(u,h,x){var _=Math.abs(x.x-h.x),M=Math.abs(x.y-h.y),z=-1;if(u.equals(h))z=0;else if(u.equals(x))z=_>M?_:M;else{var q=Math.abs(u.x-h.x),me=Math.abs(u.y-h.y);0!==(z=_>M?q:me)||u.equals(h)||(z=Math.max(q,me))}return De.isTrue(!(0===z&&!u.equals(h)),"Bad distance calculation"),z},nt.nonRobustComputeEdgeDistance=function(u,h,x){var _=u.x-h.x,M=u.y-h.y,z=Math.sqrt(_*_+M*M);return De.isTrue(!(0===z&&!u.equals(h)),"Invalid distance calculation"),z},Te.DONT_INTERSECT.get=function(){return 0},Te.DO_INTERSECT.get=function(){return 1},Te.COLLINEAR.get=function(){return 2},Te.NO_INTERSECTION.get=function(){return 0},Te.POINT_INTERSECTION.get=function(){return 1},Te.COLLINEAR_INTERSECTION.get=function(){return 2},Object.defineProperties(nt,Te);var tt=function(u){function h(){u.apply(this,arguments)}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.isInSegmentEnvelopes=function(x){var _=new Qe(this._inputLines[0][0],this._inputLines[0][1]),M=new Qe(this._inputLines[1][0],this._inputLines[1][1]);return _.contains(x)&&M.contains(x)},h.prototype.computeIntersection=function(){if(3!==arguments.length)return u.prototype.computeIntersection.apply(this,arguments);var x=arguments[0],_=arguments[1],M=arguments[2];if(this._isProper=!1,Qe.intersects(_,M,x)&&0===xt.orientationIndex(_,M,x)&&0===xt.orientationIndex(M,_,x))return this._isProper=!0,(x.equals(_)||x.equals(M))&&(this._isProper=!1),this._result=u.POINT_INTERSECTION,null;this._result=u.NO_INTERSECTION},h.prototype.normalizeToMinimum=function(x,_,M,z,q){q.x=this.smallestInAbsValue(x.x,_.x,M.x,z.x),q.y=this.smallestInAbsValue(x.y,_.y,M.y,z.y),x.x-=q.x,x.y-=q.y,_.x-=q.x,_.y-=q.y,M.x-=q.x,M.y-=q.y,z.x-=q.x,z.y-=q.y},h.prototype.safeHCoordinateIntersection=function(x,_,M,z){var q=null;try{q=$n.intersection(x,_,M,z)}catch(me){if(!(me instanceof kn))throw me;q=h.nearestEndpoint(x,_,M,z)}return q},h.prototype.intersection=function(x,_,M,z){var q=this.intersectionWithNormalization(x,_,M,z);return this.isInSegmentEnvelopes(q)||(q=new Z(h.nearestEndpoint(x,_,M,z))),null!==this._precisionModel&&this._precisionModel.makePrecise(q),q},h.prototype.smallestInAbsValue=function(x,_,M,z){var q=x,me=Math.abs(q);return Math.abs(_)<me&&(q=_,me=Math.abs(_)),Math.abs(M)<me&&(q=M,me=Math.abs(M)),Math.abs(z)<me&&(q=z),q},h.prototype.checkDD=function(x,_,M,z,q){var me=$t.intersection(x,_,M,z),Ze=this.isInSegmentEnvelopes(me);qn.out.println("DD in env = "+Ze+"  --------------------- "+me),q.distance(me)>1e-4&&qn.out.println("Distance = "+q.distance(me))},h.prototype.intersectionWithNormalization=function(x,_,M,z){var q=new Z(x),me=new Z(_),Ze=new Z(M),lt=new Z(z),Vt=new Z;this.normalizeToEnvCentre(q,me,Ze,lt,Vt);var Yt=this.safeHCoordinateIntersection(q,me,Ze,lt);return Yt.x+=Vt.x,Yt.y+=Vt.y,Yt},h.prototype.computeCollinearIntersection=function(x,_,M,z){var q=Qe.intersects(x,_,M),me=Qe.intersects(x,_,z),Ze=Qe.intersects(M,z,x),lt=Qe.intersects(M,z,_);return q&&me?(this._intPt[0]=M,this._intPt[1]=z,u.COLLINEAR_INTERSECTION):Ze&&lt?(this._intPt[0]=x,this._intPt[1]=_,u.COLLINEAR_INTERSECTION):q&&Ze?(this._intPt[0]=M,this._intPt[1]=x,!M.equals(x)||me||lt?u.COLLINEAR_INTERSECTION:u.POINT_INTERSECTION):q&&lt?(this._intPt[0]=M,this._intPt[1]=_,!M.equals(_)||me||Ze?u.COLLINEAR_INTERSECTION:u.POINT_INTERSECTION):me&&Ze?(this._intPt[0]=z,this._intPt[1]=x,!z.equals(x)||q||lt?u.COLLINEAR_INTERSECTION:u.POINT_INTERSECTION):me&&lt?(this._intPt[0]=z,this._intPt[1]=_,!z.equals(_)||q||Ze?u.COLLINEAR_INTERSECTION:u.POINT_INTERSECTION):u.NO_INTERSECTION},h.prototype.normalizeToEnvCentre=function(x,_,M,z,q){var me=x.x<_.x?x.x:_.x,Ze=x.y<_.y?x.y:_.y,lt=x.x>_.x?x.x:_.x,Vt=x.y>_.y?x.y:_.y,Yt=M.x<z.x?M.x:z.x,wn=M.y<z.y?M.y:z.y,En=M.x>z.x?M.x:z.x,Fn=M.y>z.y?M.y:z.y,fi=((Ze>wn?Ze:wn)+(Vt<Fn?Vt:Fn))/2;q.x=((me>Yt?me:Yt)+(lt<En?lt:En))/2,q.y=fi,x.x-=q.x,x.y-=q.y,_.x-=q.x,_.y-=q.y,M.x-=q.x,M.y-=q.y,z.x-=q.x,z.y-=q.y},h.prototype.computeIntersect=function(x,_,M,z){if(this._isProper=!1,!Qe.intersects(x,_,M,z))return u.NO_INTERSECTION;var q=xt.orientationIndex(x,_,M),me=xt.orientationIndex(x,_,z);if(q>0&&me>0||q<0&&me<0)return u.NO_INTERSECTION;var Ze=xt.orientationIndex(M,z,x),lt=xt.orientationIndex(M,z,_);return Ze>0&&lt>0||Ze<0&&lt<0?u.NO_INTERSECTION:0===q&&0===me&&0===Ze&&0===lt?this.computeCollinearIntersection(x,_,M,z):(0===q||0===me||0===Ze||0===lt?(this._isProper=!1,x.equals2D(M)||x.equals2D(z)?this._intPt[0]=x:_.equals2D(M)||_.equals2D(z)?this._intPt[0]=_:0===q?this._intPt[0]=new Z(M):0===me?this._intPt[0]=new Z(z):0===Ze?this._intPt[0]=new Z(x):0===lt&&(this._intPt[0]=new Z(_))):(this._isProper=!0,this._intPt[0]=this.intersection(x,_,M,z)),u.POINT_INTERSECTION)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h.nearestEndpoint=function(x,_,M,z){var q=x,me=xt.distancePointLine(x,M,z),Ze=xt.distancePointLine(_,M,z);return Ze<me&&(me=Ze,q=_),(Ze=xt.distancePointLine(M,x,_))<me&&(me=Ze,q=M),(Ze=xt.distancePointLine(z,x,_))<me&&(me=Ze,q=z),q},h}(nt),mt=function(){};mt.prototype.interfaces_=function(){return[]},mt.prototype.getClass=function(){return mt},mt.orientationIndex=function(u,h,x){return mt.signOfDet2x2(h.x-u.x,h.y-u.y,x.x-h.x,x.y-h.y)},mt.signOfDet2x2=function(u,h,x,_){var M=null,z=null,q=null;if(M=1,0===u||0===_)return 0===h||0===x?0:h>0?x>0?-M:M:x>0?M:-M;if(0===h||0===x)return _>0?u>0?M:-M:u>0?-M:M;if(h>0?_>0?h<=_||(M=-M,z=u,u=x,x=z,z=h,h=_,_=z):h<=-_?(M=-M,x=-x,_=-_):(z=u,u=-x,x=z,z=h,h=-_,_=z):_>0?-h<=_?(M=-M,u=-u,h=-h):(z=-u,u=x,x=z,z=-h,h=_,_=z):h>=_?(u=-u,h=-h,x=-x,_=-_):(M=-M,z=-u,u=-x,x=z,z=-h,h=-_,_=z),u>0){if(!(x>0&&u<=x))return M}else{if(x>0||!(u>=x))return-M;M=-M,u=-u,x=-x}for(;;){if((_-=(q=Math.floor(x/u))*h)<0)return-M;if(_>h)return M;if(u>(x-=q*u)+x){if(h<_+_)return M}else{if(h>_+_)return-M;x=u-x,_=h-_,M=-M}if(0===_)return 0===x?0:-M;if(0===x||(u-=(q=Math.floor(u/x))*x,(h-=q*_)<0))return M;if(h>_)return-M;if(x>u+u){if(_<h+h)return-M}else{if(_>h+h)return M;u=x-u,h=_-h,M=-M}if(0===h)return 0===u?0:M;if(0===u)return-M}};var K=function(){this._p=null,this._crossingCount=0,this._isPointOnSegment=!1,this._p=arguments[0]};K.prototype.countSegment=function(u,h){if(u.x<this._p.x&&h.x<this._p.x)return null;if(this._p.x===h.x&&this._p.y===h.y)return this._isPointOnSegment=!0,null;if(u.y===this._p.y&&h.y===this._p.y){var x=u.x,_=h.x;return x>_&&(x=h.x,_=u.x),this._p.x>=x&&this._p.x<=_&&(this._isPointOnSegment=!0),null}if(u.y>this._p.y&&h.y<=this._p.y||h.y>this._p.y&&u.y<=this._p.y){var z=u.y-this._p.y,me=h.y-this._p.y,Ze=mt.signOfDet2x2(u.x-this._p.x,z,h.x-this._p.x,me);if(0===Ze)return this._isPointOnSegment=!0,null;me<z&&(Ze=-Ze),Ze>0&&this._crossingCount++}},K.prototype.isPointInPolygon=function(){return this.getLocation()!==_e.EXTERIOR},K.prototype.getLocation=function(){return this._isPointOnSegment?_e.BOUNDARY:this._crossingCount%2==1?_e.INTERIOR:_e.EXTERIOR},K.prototype.isOnSegment=function(){return this._isPointOnSegment},K.prototype.interfaces_=function(){return[]},K.prototype.getClass=function(){return K},K.locatePointInRing=function(){if(arguments[0]instanceof Z&&Ct(arguments[1],Gt)){for(var h=arguments[1],x=new K(arguments[0]),_=new Z,M=new Z,z=1;z<h.size();z++)if(h.getCoordinate(z,_),h.getCoordinate(z-1,M),x.countSegment(_,M),x.isOnSegment())return x.getLocation();return x.getLocation()}if(arguments[0]instanceof Z&&arguments[1]instanceof Array){for(var me=arguments[1],Ze=new K(arguments[0]),lt=1;lt<me.length;lt++)if(Ze.countSegment(me[lt],me[lt-1]),Ze.isOnSegment())return Ze.getLocation();return Ze.getLocation()}};var xt=function(){},on={CLOCKWISE:{configurable:!0},RIGHT:{configurable:!0},COUNTERCLOCKWISE:{configurable:!0},LEFT:{configurable:!0},COLLINEAR:{configurable:!0},STRAIGHT:{configurable:!0}};xt.prototype.interfaces_=function(){return[]},xt.prototype.getClass=function(){return xt},xt.orientationIndex=function(u,h,x){return $t.orientationIndex(u,h,x)},xt.signedArea=function(){if(arguments[0]instanceof Array){var u=arguments[0];if(u.length<3)return 0;for(var h=0,x=u[0].x,_=1;_<u.length-1;_++)h+=(u[_].x-x)*(u[_-1].y-u[_+1].y);return h/2}if(Ct(arguments[0],Gt)){var q=arguments[0],me=q.size();if(me<3)return 0;var Ze=new Z,lt=new Z,Vt=new Z;q.getCoordinate(0,lt),q.getCoordinate(1,Vt);var Yt=lt.x;Vt.x-=Yt;for(var wn=0,En=1;En<me-1;En++)Ze.y=lt.y,lt.x=Vt.x,lt.y=Vt.y,q.getCoordinate(En+1,Vt),Vt.x-=Yt,wn+=lt.x*(Ze.y-Vt.y);return wn/2}},xt.distanceLineLine=function(u,h,x,_){if(u.equals(h))return xt.distancePointLine(u,x,_);if(x.equals(_))return xt.distancePointLine(_,u,h);var M=!1;if(Qe.intersects(u,h,x,_)){var z=(h.x-u.x)*(_.y-x.y)-(h.y-u.y)*(_.x-x.x);if(0===z)M=!0;else{var me=((u.y-x.y)*(h.x-u.x)-(u.x-x.x)*(h.y-u.y))/z,Ze=((u.y-x.y)*(_.x-x.x)-(u.x-x.x)*(_.y-x.y))/z;(Ze<0||Ze>1||me<0||me>1)&&(M=!0)}}else M=!0;return M?Ke.min(xt.distancePointLine(u,x,_),xt.distancePointLine(h,x,_),xt.distancePointLine(x,u,h),xt.distancePointLine(_,u,h)):0},xt.isPointInRing=function(u,h){return xt.locatePointInRing(u,h)!==_e.EXTERIOR},xt.computeLength=function(u){var h=u.size();if(h<=1)return 0;var x=0,_=new Z;u.getCoordinate(0,_);for(var M=_.x,z=_.y,q=1;q<h;q++){u.getCoordinate(q,_);var me=_.x,Ze=_.y,lt=me-M,Vt=Ze-z;x+=Math.sqrt(lt*lt+Vt*Vt),M=me,z=Ze}return x},xt.isCCW=function(u){var h=u.length-1;if(h<3)throw new xe("Ring has fewer than 4 points, so orientation cannot be determined");for(var x=u[0],_=0,M=1;M<=h;M++){var z=u[M];z.y>x.y&&(x=z,_=M)}var q=_;do{(q-=1)<0&&(q=h)}while(u[q].equals2D(x)&&q!==_);var me=_;do{me=(me+1)%h}while(u[me].equals2D(x)&&me!==_);var Ze=u[q],lt=u[me];if(Ze.equals2D(x)||lt.equals2D(x)||Ze.equals2D(lt))return!1;var Vt=xt.computeOrientation(Ze,x,lt);return 0===Vt?Ze.x>lt.x:Vt>0},xt.locatePointInRing=function(u,h){return K.locatePointInRing(u,h)},xt.distancePointLinePerpendicular=function(u,h,x){var _=(x.x-h.x)*(x.x-h.x)+(x.y-h.y)*(x.y-h.y);return Math.abs(((h.y-u.y)*(x.x-h.x)-(h.x-u.x)*(x.y-h.y))/_)*Math.sqrt(_)},xt.computeOrientation=function(u,h,x){return xt.orientationIndex(u,h,x)},xt.distancePointLine=function(){if(2===arguments.length){var u=arguments[0],h=arguments[1];if(0===h.length)throw new xe("Line array must contain at least one vertex");for(var x=u.distance(h[0]),_=0;_<h.length-1;_++){var M=xt.distancePointLine(u,h[_],h[_+1]);M<x&&(x=M)}return x}if(3===arguments.length){var z=arguments[0],q=arguments[1],me=arguments[2];if(q.x===me.x&&q.y===me.y)return z.distance(q);var Ze=(me.x-q.x)*(me.x-q.x)+(me.y-q.y)*(me.y-q.y),lt=((z.x-q.x)*(me.x-q.x)+(z.y-q.y)*(me.y-q.y))/Ze;return lt<=0?z.distance(q):lt>=1?z.distance(me):Math.abs(((q.y-z.y)*(me.x-q.x)-(q.x-z.x)*(me.y-q.y))/Ze)*Math.sqrt(Ze)}},xt.isOnLine=function(u,h){for(var x=new tt,_=1;_<h.length;_++)if(x.computeIntersection(u,h[_-1],h[_]),x.hasIntersection())return!0;return!1},on.CLOCKWISE.get=function(){return-1},on.RIGHT.get=function(){return xt.CLOCKWISE},on.COUNTERCLOCKWISE.get=function(){return 1},on.LEFT.get=function(){return xt.COUNTERCLOCKWISE},on.COLLINEAR.get=function(){return 0},on.STRAIGHT.get=function(){return xt.COLLINEAR},Object.defineProperties(xt,on);var ft=function(){};ft.prototype.filter=function(u){},ft.prototype.interfaces_=function(){return[]},ft.prototype.getClass=function(){return ft};var Xt=function(){var u=arguments[0];this._envelope=null,this._factory=null,this._SRID=null,this._userData=null,this._factory=u,this._SRID=u.getSRID()},Kt={serialVersionUID:{configurable:!0},SORTINDEX_POINT:{configurable:!0},SORTINDEX_MULTIPOINT:{configurable:!0},SORTINDEX_LINESTRING:{configurable:!0},SORTINDEX_LINEARRING:{configurable:!0},SORTINDEX_MULTILINESTRING:{configurable:!0},SORTINDEX_POLYGON:{configurable:!0},SORTINDEX_MULTIPOLYGON:{configurable:!0},SORTINDEX_GEOMETRYCOLLECTION:{configurable:!0},geometryChangedFilter:{configurable:!0}};Xt.prototype.isGeometryCollection=function(){return this.getSortIndex()===Xt.SORTINDEX_GEOMETRYCOLLECTION},Xt.prototype.getFactory=function(){return this._factory},Xt.prototype.getGeometryN=function(u){return this},Xt.prototype.getArea=function(){return 0},Xt.prototype.isRectangle=function(){return!1},Xt.prototype.equals=function(){if(arguments[0]instanceof Xt){var u=arguments[0];return null!==u&&this.equalsTopo(u)}if(arguments[0]instanceof Object){var h=arguments[0];return h instanceof Xt&&this.equalsExact(h)}},Xt.prototype.equalsExact=function(u){return this===u||this.equalsExact(u,0)},Xt.prototype.geometryChanged=function(){this.apply(Xt.geometryChangedFilter)},Xt.prototype.geometryChangedAction=function(){this._envelope=null},Xt.prototype.equalsNorm=function(u){return null!==u&&this.norm().equalsExact(u.norm())},Xt.prototype.getLength=function(){return 0},Xt.prototype.getNumGeometries=function(){return 1},Xt.prototype.compareTo=function(){if(1===arguments.length){var u=arguments[0],h=u;return this.getSortIndex()!==h.getSortIndex()?this.getSortIndex()-h.getSortIndex():this.isEmpty()&&h.isEmpty()?0:this.isEmpty()?-1:h.isEmpty()?1:this.compareToSameClass(u)}if(2===arguments.length){var x=arguments[0],_=arguments[1];return this.getSortIndex()!==x.getSortIndex()?this.getSortIndex()-x.getSortIndex():this.isEmpty()&&x.isEmpty()?0:this.isEmpty()?-1:x.isEmpty()?1:this.compareToSameClass(x,_)}},Xt.prototype.getUserData=function(){return this._userData},Xt.prototype.getSRID=function(){return this._SRID},Xt.prototype.getEnvelope=function(){return this.getFactory().toGeometry(this.getEnvelopeInternal())},Xt.prototype.checkNotGeometryCollection=function(u){if(u.getSortIndex()===Xt.SORTINDEX_GEOMETRYCOLLECTION)throw new xe("This method does not support GeometryCollection arguments")},Xt.prototype.equal=function(u,h,x){return 0===x?u.equals(h):u.distance(h)<=x},Xt.prototype.norm=function(){var u=this.copy();return u.normalize(),u},Xt.prototype.getPrecisionModel=function(){return this._factory.getPrecisionModel()},Xt.prototype.getEnvelopeInternal=function(){return null===this._envelope&&(this._envelope=this.computeEnvelopeInternal()),new Qe(this._envelope)},Xt.prototype.setSRID=function(u){this._SRID=u},Xt.prototype.setUserData=function(u){this._userData=u},Xt.prototype.compare=function(u,h){for(var x=u.iterator(),_=h.iterator();x.hasNext()&&_.hasNext();){var M=x.next(),z=_.next(),q=M.compareTo(z);if(0!==q)return q}return x.hasNext()?1:_.hasNext()?-1:0},Xt.prototype.hashCode=function(){return this.getEnvelopeInternal().hashCode()},Xt.prototype.isGeometryCollectionOrDerived=function(){return this.getSortIndex()===Xt.SORTINDEX_GEOMETRYCOLLECTION||this.getSortIndex()===Xt.SORTINDEX_MULTIPOINT||this.getSortIndex()===Xt.SORTINDEX_MULTILINESTRING||this.getSortIndex()===Xt.SORTINDEX_MULTIPOLYGON},Xt.prototype.interfaces_=function(){return[Se,Ne,te]},Xt.prototype.getClass=function(){return Xt},Xt.hasNonEmptyElements=function(u){for(var h=0;h<u.length;h++)if(!u[h].isEmpty())return!0;return!1},Xt.hasNullElements=function(u){for(var h=0;h<u.length;h++)if(null===u[h])return!0;return!1},Kt.serialVersionUID.get=function(){return 0x799ea46522854c00},Kt.SORTINDEX_POINT.get=function(){return 0},Kt.SORTINDEX_MULTIPOINT.get=function(){return 1},Kt.SORTINDEX_LINESTRING.get=function(){return 2},Kt.SORTINDEX_LINEARRING.get=function(){return 3},Kt.SORTINDEX_MULTILINESTRING.get=function(){return 4},Kt.SORTINDEX_POLYGON.get=function(){return 5},Kt.SORTINDEX_MULTIPOLYGON.get=function(){return 6},Kt.SORTINDEX_GEOMETRYCOLLECTION.get=function(){return 7},Kt.geometryChangedFilter.get=function(){return Pn},Object.defineProperties(Xt,Kt);var Pn=function(){};Pn.interfaces_=function(){return[ft]},Pn.filter=function(u){u.geometryChangedAction()};var xr=function(){};xr.prototype.filter=function(u){},xr.prototype.interfaces_=function(){return[]},xr.prototype.getClass=function(){return xr};var br=function(){},oi={Mod2BoundaryNodeRule:{configurable:!0},EndPointBoundaryNodeRule:{configurable:!0},MultiValentEndPointBoundaryNodeRule:{configurable:!0},MonoValentEndPointBoundaryNodeRule:{configurable:!0},MOD2_BOUNDARY_RULE:{configurable:!0},ENDPOINT_BOUNDARY_RULE:{configurable:!0},MULTIVALENT_ENDPOINT_BOUNDARY_RULE:{configurable:!0},MONOVALENT_ENDPOINT_BOUNDARY_RULE:{configurable:!0},OGC_SFS_BOUNDARY_RULE:{configurable:!0}};br.prototype.isInBoundary=function(u){},br.prototype.interfaces_=function(){return[]},br.prototype.getClass=function(){return br},oi.Mod2BoundaryNodeRule.get=function(){return qi},oi.EndPointBoundaryNodeRule.get=function(){return ks},oi.MultiValentEndPointBoundaryNodeRule.get=function(){return ls},oi.MonoValentEndPointBoundaryNodeRule.get=function(){return ar},oi.MOD2_BOUNDARY_RULE.get=function(){return new qi},oi.ENDPOINT_BOUNDARY_RULE.get=function(){return new ks},oi.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get=function(){return new ls},oi.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get=function(){return new ar},oi.OGC_SFS_BOUNDARY_RULE.get=function(){return br.MOD2_BOUNDARY_RULE},Object.defineProperties(br,oi);var qi=function(){};qi.prototype.isInBoundary=function(u){return u%2==1},qi.prototype.interfaces_=function(){return[br]},qi.prototype.getClass=function(){return qi};var ks=function(){};ks.prototype.isInBoundary=function(u){return u>0},ks.prototype.interfaces_=function(){return[br]},ks.prototype.getClass=function(){return ks};var ls=function(){};ls.prototype.isInBoundary=function(u){return u>1},ls.prototype.interfaces_=function(){return[br]},ls.prototype.getClass=function(){return ls};var ar=function(){};ar.prototype.isInBoundary=function(u){return 1===u},ar.prototype.interfaces_=function(){return[br]},ar.prototype.getClass=function(){return ar};var Kr=function(){};Kr.prototype.add=function(){},Kr.prototype.addAll=function(){},Kr.prototype.isEmpty=function(){},Kr.prototype.iterator=function(){},Kr.prototype.size=function(){},Kr.prototype.toArray=function(){},Kr.prototype.remove=function(){},(he.prototype=new Error).name="IndexOutOfBoundsException";var hi=function(){};hi.prototype.hasNext=function(){},hi.prototype.next=function(){},hi.prototype.remove=function(){};var Dr=function(u){function h(){u.apply(this,arguments)}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.get=function(){},h.prototype.set=function(){},h.prototype.isEmpty=function(){},h}(Kr);(ye.prototype=new Error).name="NoSuchElementException";var pn=function(u){function h(){u.call(this),this.array_=[],arguments[0]instanceof Kr&&this.addAll(arguments[0])}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.ensureCapacity=function(){},h.prototype.interfaces_=function(){return[u,Kr]},h.prototype.add=function(x){return 1===arguments.length?this.array_.push(x):this.array_.splice(arguments[0],arguments[1]),!0},h.prototype.clear=function(){this.array_=[]},h.prototype.addAll=function(x){for(var _=x.iterator();_.hasNext();)this.add(_.next());return!0},h.prototype.set=function(x,_){var M=this.array_[x];return this.array_[x]=_,M},h.prototype.iterator=function(){return new Yu(this)},h.prototype.get=function(x){if(x<0||x>=this.size())throw new he;return this.array_[x]},h.prototype.isEmpty=function(){return 0===this.array_.length},h.prototype.size=function(){return this.array_.length},h.prototype.toArray=function(){for(var x=[],_=0,M=this.array_.length;_<M;_++)x.push(this.array_[_]);return x},h.prototype.remove=function(x){for(var _=!1,M=0,z=this.array_.length;M<z;M++)if(this.array_[M]===x){this.array_.splice(M,1),_=!0;break}return _},h}(Dr),Yu=function(u){function h(x){u.call(this),this.arrayList_=x,this.position_=0}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.next=function(){if(this.position_===this.arrayList_.size())throw new ye;return this.arrayList_.get(this.position_++)},h.prototype.hasNext=function(){return this.position_<this.arrayList_.size()},h.prototype.set=function(x){return this.arrayList_.set(this.position_-1,x)},h.prototype.remove=function(){this.arrayList_.remove(this.arrayList_.get(this.position_))},h}(hi),co=function(u){function h(){if(u.call(this),0!==arguments.length)if(1===arguments.length){var _=arguments[0];this.ensureCapacity(_.length),this.add(_,!0)}else if(2===arguments.length){var M=arguments[0],z=arguments[1];this.ensureCapacity(M.length),this.add(M,z)}}u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h;var x={coordArrayType:{configurable:!0}};return x.coordArrayType.get=function(){return new Array(0).fill(null)},h.prototype.getCoordinate=function(_){return this.get(_)},h.prototype.addAll=function(){if(2===arguments.length){for(var M=arguments[1],z=!1,q=arguments[0].iterator();q.hasNext();)this.add(q.next(),M),z=!0;return z}return u.prototype.addAll.apply(this,arguments)},h.prototype.clone=function(){for(var _=u.prototype.clone.call(this),M=0;M<this.size();M++)_.add(M,this.get(M).copy());return _},h.prototype.toCoordinateArray=function(){return this.toArray(h.coordArrayType)},h.prototype.add=function(){if(1===arguments.length)u.prototype.add.call(this,arguments[0]);else if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1])return this.add(arguments[0],arguments[1],!0),!0;if(arguments[0]instanceof Z&&"boolean"==typeof arguments[1]){var q=arguments[0];if(!arguments[1]&&this.size()>=1&&this.get(this.size()-1).equals2D(q))return null;u.prototype.add.call(this,q)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1])return this.add(arguments[0],arguments[1]),!0}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){var lt=arguments[0],Vt=arguments[1];if(arguments[2])for(var Yt=0;Yt<lt.length;Yt++)this.add(lt[Yt],Vt);else for(var wn=lt.length-1;wn>=0;wn--)this.add(lt[wn],Vt);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof Z){var En=arguments[0],Fn=arguments[1];if(!arguments[2]){var or=this.size();if(or>0&&(En>0&&this.get(En-1).equals2D(Fn)||En<or&&this.get(En).equals2D(Fn)))return null}u.prototype.add.call(this,En,Fn)}}else if(4===arguments.length){var fi=arguments[0],ji=arguments[1],ro=arguments[2],io=arguments[3],Fs=1;ro>io&&(Fs=-1);for(var Ud=ro;Ud!==io;Ud+=Fs)this.add(fi[Ud],ji);return!0}},h.prototype.closeRing=function(){this.size()>0&&this.add(new Z(this.get(0)),!1)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},Object.defineProperties(h,x),h}(pn),Zn=function(){},Cs={ForwardComparator:{configurable:!0},BidirectionalComparator:{configurable:!0},coordArrayType:{configurable:!0}};Cs.ForwardComparator.get=function(){return da},Cs.BidirectionalComparator.get=function(){return Wo},Cs.coordArrayType.get=function(){return new Array(0).fill(null)},Zn.prototype.interfaces_=function(){return[]},Zn.prototype.getClass=function(){return Zn},Zn.isRing=function(u){return!(u.length<4||!u[0].equals2D(u[u.length-1]))},Zn.ptNotInList=function(u,h){for(var x=0;x<u.length;x++){var _=u[x];if(Zn.indexOf(_,h)<0)return _}return null},Zn.scroll=function(u,h){var x=Zn.indexOf(h,u);if(x<0)return null;var _=new Array(u.length).fill(null);qn.arraycopy(u,x,_,0,u.length-x),qn.arraycopy(u,0,_,u.length-x,x),qn.arraycopy(_,0,u,0,u.length)},Zn.equals=function(){if(2===arguments.length){var u=arguments[0],h=arguments[1];if(u===h)return!0;if(null===u||null===h||u.length!==h.length)return!1;for(var x=0;x<u.length;x++)if(!u[x].equals(h[x]))return!1;return!0}if(3===arguments.length){var _=arguments[0],M=arguments[1],z=arguments[2];if(_===M)return!0;if(null===_||null===M||_.length!==M.length)return!1;for(var q=0;q<_.length;q++)if(0!==z.compare(_[q],M[q]))return!1;return!0}},Zn.intersection=function(u,h){for(var x=new co,_=0;_<u.length;_++)h.intersects(u[_])&&x.add(u[_],!0);return x.toCoordinateArray()},Zn.hasRepeatedPoints=function(u){for(var h=1;h<u.length;h++)if(u[h-1].equals(u[h]))return!0;return!1},Zn.removeRepeatedPoints=function(u){return Zn.hasRepeatedPoints(u)?new co(u,!1).toCoordinateArray():u},Zn.reverse=function(u){for(var h=u.length-1,x=Math.trunc(h/2),_=0;_<=x;_++){var M=u[_];u[_]=u[h-_],u[h-_]=M}},Zn.removeNull=function(u){for(var h=0,x=0;x<u.length;x++)null!==u[x]&&h++;var _=new Array(h).fill(null);if(0===h)return _;for(var M=0,z=0;z<u.length;z++)null!==u[z]&&(_[M++]=u[z]);return _},Zn.copyDeep=function(){if(1===arguments.length){for(var u=arguments[0],h=new Array(u.length).fill(null),x=0;x<u.length;x++)h[x]=new Z(u[x]);return h}if(5===arguments.length)for(var _=arguments[0],M=arguments[1],z=arguments[2],q=arguments[3],me=arguments[4],Ze=0;Ze<me;Ze++)z[q+Ze]=new Z(_[M+Ze])},Zn.isEqualReversed=function(u,h){for(var x=0;x<u.length;x++)if(0!==u[x].compareTo(h[u.length-x-1]))return!1;return!0},Zn.envelope=function(u){for(var h=new Qe,x=0;x<u.length;x++)h.expandToInclude(u[x]);return h},Zn.toCoordinateArray=function(u){return u.toArray(Zn.coordArrayType)},Zn.atLeastNCoordinatesOrNothing=function(u,h){return h.length>=u?h:[]},Zn.indexOf=function(u,h){for(var x=0;x<h.length;x++)if(u.equals(h[x]))return x;return-1},Zn.increasingDirection=function(u){for(var h=0;h<Math.trunc(u.length/2);h++){var _=u[h].compareTo(u[u.length-1-h]);if(0!==_)return _}return 1},Zn.compare=function(u,h){for(var x=0;x<u.length&&x<h.length;){var _=u[x].compareTo(h[x]);if(0!==_)return _;x++}return x<h.length?-1:x<u.length?1:0},Zn.minCoordinate=function(u){for(var h=null,x=0;x<u.length;x++)(null===h||h.compareTo(u[x])>0)&&(h=u[x]);return h},Zn.extract=function(u,h,x){h=Ke.clamp(h,0,u.length);var _=(x=Ke.clamp(x,-1,u.length))-h+1;x<0&&(_=0),h>=u.length&&(_=0),x<h&&(_=0);var M=new Array(_).fill(null);if(0===_)return M;for(var z=0,q=h;q<=x;q++)M[z++]=u[q];return M},Object.defineProperties(Zn,Cs);var da=function(){};da.prototype.compare=function(u,h){return Zn.compare(u,h)},da.prototype.interfaces_=function(){return[Pe]},da.prototype.getClass=function(){return da};var Wo=function(){};Wo.prototype.compare=function(u,h){var x=u,_=h;if(x.length<_.length)return-1;if(x.length>_.length)return 1;if(0===x.length)return 0;var M=Zn.compare(x,_);return Zn.isEqualReversed(x,_)?0:M},Wo.prototype.OLDcompare=function(u,h){var x=u,_=h;if(x.length<_.length)return-1;if(x.length>_.length)return 1;if(0===x.length)return 0;for(var M=Zn.increasingDirection(x),z=Zn.increasingDirection(_),q=M>0?0:x.length-1,me=z>0?0:x.length-1,Ze=0;Ze<x.length;Ze++){var lt=x[q].compareTo(_[me]);if(0!==lt)return lt;q+=M,me+=z}return 0},Wo.prototype.interfaces_=function(){return[Pe]},Wo.prototype.getClass=function(){return Wo};var fu=function(){};fu.prototype.get=function(){},fu.prototype.put=function(){},fu.prototype.size=function(){},fu.prototype.values=function(){},fu.prototype.entrySet=function(){};var Hc=function(u){function h(){u.apply(this,arguments)}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h}(fu);(de.prototype=new Error).name="OperationNotSupported",(Me.prototype=new Kr).contains=function(){};var Ao=function(u){function h(){u.call(this),this.array_=[],arguments[0]instanceof Kr&&this.addAll(arguments[0])}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.contains=function(x){for(var _=0,M=this.array_.length;_<M;_++)if(this.array_[_]===x)return!0;return!1},h.prototype.add=function(x){return!this.contains(x)&&(this.array_.push(x),!0)},h.prototype.addAll=function(x){for(var _=x.iterator();_.hasNext();)this.add(_.next());return!0},h.prototype.remove=function(x){throw new Error},h.prototype.size=function(){return this.array_.length},h.prototype.isEmpty=function(){return 0===this.array_.length},h.prototype.toArray=function(){for(var x=[],_=0,M=this.array_.length;_<M;_++)x.push(this.array_[_]);return x},h.prototype.iterator=function(){return new oh(this)},h}(Me),oh=function(u){function h(x){u.call(this),this.hashSet_=x,this.position_=0}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.next=function(){if(this.position_===this.hashSet_.size())throw new ye;return this.hashSet_.array_[this.position_++]},h.prototype.hasNext=function(){return this.position_<this.hashSet_.size()},h.prototype.remove=function(){throw new de},h}(hi),zn=0;(re.prototype=new Hc).get=function(u){for(var h=this.root_;null!==h;){var x=u.compareTo(h.key);if(x<0)h=h.left;else{if(!(x>0))return h.value;h=h.right}}return null},re.prototype.put=function(u,h){if(null===this.root_)return this.root_={key:u,value:h,left:null,right:null,parent:null,color:zn,getValue:function(){return this.value},getKey:function(){return this.key}},this.size_=1,null;var x,_,M=this.root_;do{if(x=M,(_=u.compareTo(M.key))<0)M=M.left;else{if(!(_>0)){var z=M.value;return M.value=h,z}M=M.right}}while(null!==M);var q={key:u,left:null,right:null,value:h,parent:x,color:zn,getValue:function(){return this.value},getKey:function(){return this.key}};return _<0?x.left=q:x.right=q,this.fixAfterInsertion(q),this.size_++,null},re.prototype.fixAfterInsertion=function(u){for(u.color=1;null!=u&&u!==this.root_&&1===u.parent.color;)if(Ye(u)===Ae(Ye(Ye(u)))){var h=Le(Ye(Ye(u)));1===H(h)?(Je(Ye(u),zn),Je(h,zn),Je(Ye(Ye(u)),1),u=Ye(Ye(u))):(u===Le(Ye(u))&&(u=Ye(u),this.rotateLeft(u)),Je(Ye(u),zn),Je(Ye(Ye(u)),1),this.rotateRight(Ye(Ye(u))))}else{var x=Ae(Ye(Ye(u)));1===H(x)?(Je(Ye(u),zn),Je(x,zn),Je(Ye(Ye(u)),1),u=Ye(Ye(u))):(u===Ae(Ye(u))&&(u=Ye(u),this.rotateRight(u)),Je(Ye(u),zn),Je(Ye(Ye(u)),1),this.rotateLeft(Ye(Ye(u))))}this.root_.color=zn},re.prototype.values=function(){var u=new pn,h=this.getFirstEntry();if(null!==h)for(u.add(h.value);null!==(h=re.successor(h));)u.add(h.value);return u},re.prototype.entrySet=function(){var u=new Ao,h=this.getFirstEntry();if(null!==h)for(u.add(h);null!==(h=re.successor(h));)u.add(h);return u},re.prototype.rotateLeft=function(u){if(null!=u){var h=u.right;u.right=h.left,null!=h.left&&(h.left.parent=u),h.parent=u.parent,null===u.parent?this.root_=h:u.parent.left===u?u.parent.left=h:u.parent.right=h,h.left=u,u.parent=h}},re.prototype.rotateRight=function(u){if(null!=u){var h=u.left;u.left=h.right,null!=h.right&&(h.right.parent=u),h.parent=u.parent,null===u.parent?this.root_=h:u.parent.right===u?u.parent.right=h:u.parent.left=h,h.right=u,u.parent=h}},re.prototype.getFirstEntry=function(){var u=this.root_;if(null!=u)for(;null!=u.left;)u=u.left;return u},re.successor=function(u){if(null===u)return null;if(null!==u.right){for(var h=u.right;null!==h.left;)h=h.left;return h}for(var x=u.parent,_=u;null!==x&&_===x.right;)_=x,x=x.parent;return x},re.prototype.size=function(){return this.size_};var Xc=function(){};Xc.prototype.interfaces_=function(){return[]},Xc.prototype.getClass=function(){return Xc},ae.prototype=new Me,(ie.prototype=new ae).contains=function(u){for(var h=0,x=this.array_.length;h<x;h++)if(0===this.array_[h].compareTo(u))return!0;return!1},ie.prototype.add=function(u){if(this.contains(u))return!1;for(var h=0,x=this.array_.length;h<x;h++)if(1===this.array_[h].compareTo(u))return this.array_.splice(h,0,u),!0;return this.array_.push(u),!0},ie.prototype.addAll=function(u){for(var h=u.iterator();h.hasNext();)this.add(h.next());return!0},ie.prototype.remove=function(u){throw new de},ie.prototype.size=function(){return this.array_.length},ie.prototype.isEmpty=function(){return 0===this.array_.length},ie.prototype.toArray=function(){for(var u=[],h=0,x=this.array_.length;h<x;h++)u.push(this.array_[h]);return u},ie.prototype.iterator=function(){return new Za(this)};var Za=function(u){this.treeSet_=u,this.position_=0};Za.prototype.next=function(){if(this.position_===this.treeSet_.size())throw new ye;return this.treeSet_.array_[this.position_++]},Za.prototype.hasNext=function(){return this.position_<this.treeSet_.size()},Za.prototype.remove=function(){throw new de};var Zu=function(){};Zu.sort=function(){var u,h,x,M=arguments[0];if(1===arguments.length)M.sort(function(q,me){return q.compareTo(me)});else if(2===arguments.length)x=arguments[1],M.sort(function(q,me){return x.compare(q,me)});else if(3===arguments.length){(h=M.slice(arguments[1],arguments[2])).sort();var z=M.slice(0,arguments[1]).concat(h,M.slice(arguments[2],M.length));for(M.splice(0,M.length),u=0;u<z.length;u++)M.push(z[u])}else if(4===arguments.length)for(h=M.slice(arguments[1],arguments[2]),x=arguments[3],h.sort(function(q,me){return x.compare(q,me)}),z=M.slice(0,arguments[1]).concat(h,M.slice(arguments[2],M.length)),M.splice(0,M.length),u=0;u<z.length;u++)M.push(z[u])},Zu.asList=function(u){for(var h=new pn,x=0,_=u.length;x<_;x++)h.add(u[x]);return h};var Ur=function(){},Ki={P:{configurable:!0},L:{configurable:!0},A:{configurable:!0},FALSE:{configurable:!0},TRUE:{configurable:!0},DONTCARE:{configurable:!0},SYM_FALSE:{configurable:!0},SYM_TRUE:{configurable:!0},SYM_DONTCARE:{configurable:!0},SYM_P:{configurable:!0},SYM_L:{configurable:!0},SYM_A:{configurable:!0}};Ki.P.get=function(){return 0},Ki.L.get=function(){return 1},Ki.A.get=function(){return 2},Ki.FALSE.get=function(){return-1},Ki.TRUE.get=function(){return-2},Ki.DONTCARE.get=function(){return-3},Ki.SYM_FALSE.get=function(){return"F"},Ki.SYM_TRUE.get=function(){return"T"},Ki.SYM_DONTCARE.get=function(){return"*"},Ki.SYM_P.get=function(){return"0"},Ki.SYM_L.get=function(){return"1"},Ki.SYM_A.get=function(){return"2"},Ur.prototype.interfaces_=function(){return[]},Ur.prototype.getClass=function(){return Ur},Ur.toDimensionSymbol=function(u){switch(u){case Ur.FALSE:return Ur.SYM_FALSE;case Ur.TRUE:return Ur.SYM_TRUE;case Ur.DONTCARE:return Ur.SYM_DONTCARE;case Ur.P:return Ur.SYM_P;case Ur.L:return Ur.SYM_L;case Ur.A:return Ur.SYM_A}throw new xe("Unknown dimension value: "+u)},Ur.toDimensionValue=function(u){switch(dt.toUpperCase(u)){case Ur.SYM_FALSE:return Ur.FALSE;case Ur.SYM_TRUE:return Ur.TRUE;case Ur.SYM_DONTCARE:return Ur.DONTCARE;case Ur.SYM_P:return Ur.P;case Ur.SYM_L:return Ur.L;case Ur.SYM_A:return Ur.A}throw new xe("Unknown dimension symbol: "+u)},Object.defineProperties(Ur,Ki);var oa=function(){};oa.prototype.filter=function(u){},oa.prototype.interfaces_=function(){return[]},oa.prototype.getClass=function(){return oa};var cs=function(){};cs.prototype.filter=function(u,h){},cs.prototype.isDone=function(){},cs.prototype.isGeometryChanged=function(){},cs.prototype.interfaces_=function(){return[]},cs.prototype.getClass=function(){return cs};var Yi=function(u){function h(_,M){if(u.call(this,M),this._geometries=_||[],u.hasNullElements(this._geometries))throw new xe("geometries must not contain null elements")}u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h;var x={serialVersionUID:{configurable:!0}};return h.prototype.computeEnvelopeInternal=function(){for(var _=new Qe,M=0;M<this._geometries.length;M++)_.expandToInclude(this._geometries[M].getEnvelopeInternal());return _},h.prototype.getGeometryN=function(_){return this._geometries[_]},h.prototype.getSortIndex=function(){return u.SORTINDEX_GEOMETRYCOLLECTION},h.prototype.getCoordinates=function(){for(var _=new Array(this.getNumPoints()).fill(null),M=-1,z=0;z<this._geometries.length;z++)for(var q=this._geometries[z].getCoordinates(),me=0;me<q.length;me++)_[++M]=q[me];return _},h.prototype.getArea=function(){for(var _=0,M=0;M<this._geometries.length;M++)_+=this._geometries[M].getArea();return _},h.prototype.equalsExact=function(){if(2===arguments.length){var _=arguments[0],M=arguments[1];if(!this.isEquivalentClass(_))return!1;var z=_;if(this._geometries.length!==z._geometries.length)return!1;for(var q=0;q<this._geometries.length;q++)if(!this._geometries[q].equalsExact(z._geometries[q],M))return!1;return!0}return u.prototype.equalsExact.apply(this,arguments)},h.prototype.normalize=function(){for(var _=0;_<this._geometries.length;_++)this._geometries[_].normalize();Zu.sort(this._geometries)},h.prototype.getCoordinate=function(){return this.isEmpty()?null:this._geometries[0].getCoordinate()},h.prototype.getBoundaryDimension=function(){for(var _=Ur.FALSE,M=0;M<this._geometries.length;M++)_=Math.max(_,this._geometries[M].getBoundaryDimension());return _},h.prototype.getDimension=function(){for(var _=Ur.FALSE,M=0;M<this._geometries.length;M++)_=Math.max(_,this._geometries[M].getDimension());return _},h.prototype.getLength=function(){for(var _=0,M=0;M<this._geometries.length;M++)_+=this._geometries[M].getLength();return _},h.prototype.getNumPoints=function(){for(var _=0,M=0;M<this._geometries.length;M++)_+=this._geometries[M].getNumPoints();return _},h.prototype.getNumGeometries=function(){return this._geometries.length},h.prototype.reverse=function(){for(var M=new Array(this._geometries.length).fill(null),z=0;z<this._geometries.length;z++)M[z]=this._geometries[z].reverse();return this.getFactory().createGeometryCollection(M)},h.prototype.compareToSameClass=function(){if(1===arguments.length){var _=arguments[0],M=new ie(Zu.asList(this._geometries)),z=new ie(Zu.asList(_._geometries));return this.compare(M,z)}if(2===arguments.length){for(var me=arguments[1],Ze=arguments[0],lt=this.getNumGeometries(),Vt=Ze.getNumGeometries(),Yt=0;Yt<lt&&Yt<Vt;){var wn=this.getGeometryN(Yt),En=Ze.getGeometryN(Yt),Fn=wn.compareToSameClass(En,me);if(0!==Fn)return Fn;Yt++}return Yt<lt?1:Yt<Vt?-1:0}},h.prototype.apply=function(){if(Ct(arguments[0],xr))for(var _=arguments[0],M=0;M<this._geometries.length;M++)this._geometries[M].apply(_);else if(Ct(arguments[0],cs)){var z=arguments[0];if(0===this._geometries.length)return null;for(var q=0;q<this._geometries.length&&(this._geometries[q].apply(z),!z.isDone());q++);z.isGeometryChanged()&&this.geometryChanged()}else if(Ct(arguments[0],oa)){var me=arguments[0];me.filter(this);for(var Ze=0;Ze<this._geometries.length;Ze++)this._geometries[Ze].apply(me)}else if(Ct(arguments[0],ft)){var lt=arguments[0];lt.filter(this);for(var Vt=0;Vt<this._geometries.length;Vt++)this._geometries[Vt].apply(lt)}},h.prototype.getBoundary=function(){return this.checkNotGeometryCollection(this),De.shouldNeverReachHere(),null},h.prototype.clone=function(){var _=u.prototype.clone.call(this);_._geometries=new Array(this._geometries.length).fill(null);for(var M=0;M<this._geometries.length;M++)_._geometries[M]=this._geometries[M].clone();return _},h.prototype.getGeometryType=function(){return"GeometryCollection"},h.prototype.copy=function(){for(var _=new Array(this._geometries.length).fill(null),M=0;M<_.length;M++)_[M]=this._geometries[M].copy();return new h(_,this._factory)},h.prototype.isEmpty=function(){for(var _=0;_<this._geometries.length;_++)if(!this._geometries[_].isEmpty())return!1;return!0},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},x.serialVersionUID.get=function(){return-0x4f07bcb1f857d800},Object.defineProperties(h,x),h}(Xt),Ia=function(u){function h(){u.apply(this,arguments)}u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h;var x={serialVersionUID:{configurable:!0}};return h.prototype.getSortIndex=function(){return Xt.SORTINDEX_MULTILINESTRING},h.prototype.equalsExact=function(){if(2===arguments.length){var _=arguments[0],M=arguments[1];return!!this.isEquivalentClass(_)&&u.prototype.equalsExact.call(this,_,M)}return u.prototype.equalsExact.apply(this,arguments)},h.prototype.getBoundaryDimension=function(){return this.isClosed()?Ur.FALSE:0},h.prototype.isClosed=function(){if(this.isEmpty())return!1;for(var _=0;_<this._geometries.length;_++)if(!this._geometries[_].isClosed())return!1;return!0},h.prototype.getDimension=function(){return 1},h.prototype.reverse=function(){for(var _=this._geometries.length,M=new Array(_).fill(null),z=0;z<this._geometries.length;z++)M[_-1-z]=this._geometries[z].reverse();return this.getFactory().createMultiLineString(M)},h.prototype.getBoundary=function(){return new Or(this).getBoundary()},h.prototype.getGeometryType=function(){return"MultiLineString"},h.prototype.copy=function(){for(var _=new Array(this._geometries.length).fill(null),M=0;M<_.length;M++)_[M]=this._geometries[M].copy();return new h(_,this._factory)},h.prototype.interfaces_=function(){return[Xc]},h.prototype.getClass=function(){return h},x.serialVersionUID.get=function(){return 0x7155d2ab4afa8000},Object.defineProperties(h,x),h}(Yi),Or=function(){if(this._geom=null,this._geomFact=null,this._bnRule=null,this._endpointMap=null,1===arguments.length){var u=arguments[0],h=br.MOD2_BOUNDARY_RULE;this._geom=u,this._geomFact=u.getFactory(),this._bnRule=h}else if(2===arguments.length){var x=arguments[0],_=arguments[1];this._geom=x,this._geomFact=x.getFactory(),this._bnRule=_}};Or.prototype.boundaryMultiLineString=function(u){if(this._geom.isEmpty())return this.getEmptyMultiPoint();var h=this.computeBoundaryCoordinates(u);return 1===h.length?this._geomFact.createPoint(h[0]):this._geomFact.createMultiPointFromCoords(h)},Or.prototype.getBoundary=function(){return this._geom instanceof Wi?this.boundaryLineString(this._geom):this._geom instanceof Ia?this.boundaryMultiLineString(this._geom):this._geom.getBoundary()},Or.prototype.boundaryLineString=function(u){return this._geom.isEmpty()?this.getEmptyMultiPoint():u.isClosed()?this._bnRule.isInBoundary(2)?u.getStartPoint():this._geomFact.createMultiPoint():this._geomFact.createMultiPoint([u.getStartPoint(),u.getEndPoint()])},Or.prototype.getEmptyMultiPoint=function(){return this._geomFact.createMultiPoint()},Or.prototype.computeBoundaryCoordinates=function(u){var h=new pn;this._endpointMap=new re;for(var x=0;x<u.getNumGeometries();x++){var _=u.getGeometryN(x);0!==_.getNumPoints()&&(this.addEndpoint(_.getCoordinateN(0)),this.addEndpoint(_.getCoordinateN(_.getNumPoints()-1)))}for(var M=this._endpointMap.entrySet().iterator();M.hasNext();){var z=M.next(),q=z.getValue().count;this._bnRule.isInBoundary(q)&&h.add(z.getKey())}return Zn.toCoordinateArray(h)},Or.prototype.addEndpoint=function(u){var h=this._endpointMap.get(u);null===h&&(h=new ua,this._endpointMap.put(u,h)),h.count++},Or.prototype.interfaces_=function(){return[]},Or.prototype.getClass=function(){return Or},Or.getBoundary=function(){return 1===arguments.length?new Or(arguments[0]).getBoundary():2===arguments.length?new Or(arguments[0],arguments[1]).getBoundary():void 0};var ua=function(){this.count=null};ua.prototype.interfaces_=function(){return[]},ua.prototype.getClass=function(){return ua};var _s=function(){},fn={NEWLINE:{configurable:!0},SIMPLE_ORDINATE_FORMAT:{configurable:!0}};_s.prototype.interfaces_=function(){return[]},_s.prototype.getClass=function(){return _s},_s.chars=function(u,h){for(var x=new Array(h).fill(null),_=0;_<h;_++)x[_]=u;return String(x)},_s.getStackTrace=function(){if(1===arguments.length){var u=arguments[0],h=new function(){},x=new function(){}(h);return u.printStackTrace(x),h.toString()}if(2===arguments.length){for(var M=arguments[1],z="",q=new function(){}(new function(){}(_s.getStackTrace(arguments[0]))),me=0;me<M;me++)try{z+=q.readLine()+_s.NEWLINE}catch(Ze){if(!(Ze instanceof Ue))throw Ze;De.shouldNeverReachHere()}return z}},_s.split=function(u,h){for(var x=h.length,_=new pn,M=""+u,z=M.indexOf(h);z>=0;){var q=M.substring(0,z);_.add(q),z=(M=M.substring(z+x)).indexOf(h)}M.length>0&&_.add(M);for(var me=new Array(_.size()).fill(null),Ze=0;Ze<me.length;Ze++)me[Ze]=_.get(Ze);return me},_s.toString=function(){if(1===arguments.length)return _s.SIMPLE_ORDINATE_FORMAT.format(arguments[0])},_s.spaces=function(u){return _s.chars(" ",u)},fn.NEWLINE.get=function(){return qn.getProperty("line.separator")},fn.SIMPLE_ORDINATE_FORMAT.get=function(){return new function(){}("0.#")},Object.defineProperties(_s,fn);var is=function(){};is.prototype.interfaces_=function(){return[]},is.prototype.getClass=function(){return is},is.copyCoord=function(u,h,x,_){for(var M=Math.min(u.getDimension(),x.getDimension()),z=0;z<M;z++)x.setOrdinate(_,z,u.getOrdinate(h,z))},is.isRing=function(u){var h=u.size();return 0===h||!(h<=3)&&u.getOrdinate(0,Gt.X)===u.getOrdinate(h-1,Gt.X)&&u.getOrdinate(0,Gt.Y)===u.getOrdinate(h-1,Gt.Y)},is.isEqual=function(u,h){var x=u.size();if(x!==h.size())return!1;for(var _=Math.min(u.getDimension(),h.getDimension()),M=0;M<x;M++)for(var z=0;z<_;z++){var q=u.getOrdinate(M,z),me=h.getOrdinate(M,z);if(!(u.getOrdinate(M,z)===h.getOrdinate(M,z)||we.isNaN(q)&&we.isNaN(me)))return!1}return!0},is.extend=function(u,h,x){var _=u.create(x,h.getDimension()),M=h.size();if(is.copy(h,0,_,0,M),M>0)for(var z=M;z<x;z++)is.copy(h,M-1,_,z,1);return _},is.reverse=function(u){for(var h=u.size()-1,x=Math.trunc(h/2),_=0;_<=x;_++)is.swap(u,_,h-_)},is.swap=function(u,h,x){if(h===x)return null;for(var _=0;_<u.getDimension();_++){var M=u.getOrdinate(h,_);u.setOrdinate(h,_,u.getOrdinate(x,_)),u.setOrdinate(x,_,M)}},is.copy=function(u,h,x,_,M){for(var z=0;z<M;z++)is.copyCoord(u,h+z,x,_+z)},is.toString=function(){if(1===arguments.length){var u=arguments[0],h=u.size();if(0===h)return"()";var x=u.getDimension(),_=new et;_.append("(");for(var M=0;M<h;M++){M>0&&_.append(" ");for(var z=0;z<x;z++)z>0&&_.append(","),_.append(_s.toString(u.getOrdinate(M,z)))}return _.append(")"),_.toString()}},is.ensureValidRing=function(u,h){var x=h.size();return 0===x?h:x<=3?is.createClosedRing(u,h,4):h.getOrdinate(0,Gt.X)===h.getOrdinate(x-1,Gt.X)&&h.getOrdinate(0,Gt.Y)===h.getOrdinate(x-1,Gt.Y)?h:is.createClosedRing(u,h,x+1)},is.createClosedRing=function(u,h,x){var _=u.create(x,h.getDimension()),M=h.size();is.copy(h,0,_,0,M);for(var z=M;z<x;z++)is.copy(h,0,_,z,1);return _};var Wi=function(u){function h(_,M){u.call(this,M),this._points=null,this.init(_)}u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h;var x={serialVersionUID:{configurable:!0}};return h.prototype.computeEnvelopeInternal=function(){return this.isEmpty()?new Qe:this._points.expandEnvelope(new Qe)},h.prototype.isRing=function(){return this.isClosed()&&this.isSimple()},h.prototype.getSortIndex=function(){return u.SORTINDEX_LINESTRING},h.prototype.getCoordinates=function(){return this._points.toCoordinateArray()},h.prototype.equalsExact=function(){if(2===arguments.length){var _=arguments[0],M=arguments[1];if(!this.isEquivalentClass(_))return!1;var z=_;if(this._points.size()!==z._points.size())return!1;for(var q=0;q<this._points.size();q++)if(!this.equal(this._points.getCoordinate(q),z._points.getCoordinate(q),M))return!1;return!0}return u.prototype.equalsExact.apply(this,arguments)},h.prototype.normalize=function(){for(var _=0;_<Math.trunc(this._points.size()/2);_++){var M=this._points.size()-1-_;if(!this._points.getCoordinate(_).equals(this._points.getCoordinate(M)))return this._points.getCoordinate(_).compareTo(this._points.getCoordinate(M))>0&&is.reverse(this._points),null}},h.prototype.getCoordinate=function(){return this.isEmpty()?null:this._points.getCoordinate(0)},h.prototype.getBoundaryDimension=function(){return this.isClosed()?Ur.FALSE:0},h.prototype.isClosed=function(){return!this.isEmpty()&&this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))},h.prototype.getEndPoint=function(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)},h.prototype.getDimension=function(){return 1},h.prototype.getLength=function(){return xt.computeLength(this._points)},h.prototype.getNumPoints=function(){return this._points.size()},h.prototype.reverse=function(){var _=this._points.copy();return is.reverse(_),this.getFactory().createLineString(_)},h.prototype.compareToSameClass=function(){if(1===arguments.length){for(var _=arguments[0],M=0,z=0;M<this._points.size()&&z<_._points.size();){var q=this._points.getCoordinate(M).compareTo(_._points.getCoordinate(z));if(0!==q)return q;M++,z++}return M<this._points.size()?1:z<_._points.size()?-1:0}if(2===arguments.length)return arguments[1].compare(this._points,arguments[0]._points)},h.prototype.apply=function(){if(Ct(arguments[0],xr))for(var _=arguments[0],M=0;M<this._points.size();M++)_.filter(this._points.getCoordinate(M));else if(Ct(arguments[0],cs)){var z=arguments[0];if(0===this._points.size())return null;for(var q=0;q<this._points.size()&&(z.filter(this._points,q),!z.isDone());q++);z.isGeometryChanged()&&this.geometryChanged()}else(Ct(arguments[0],oa)||Ct(arguments[0],ft))&&arguments[0].filter(this)},h.prototype.getBoundary=function(){return new Or(this).getBoundary()},h.prototype.isEquivalentClass=function(_){return _ instanceof h},h.prototype.clone=function(){var _=u.prototype.clone.call(this);return _._points=this._points.clone(),_},h.prototype.getCoordinateN=function(_){return this._points.getCoordinate(_)},h.prototype.getGeometryType=function(){return"LineString"},h.prototype.copy=function(){return new h(this._points.copy(),this._factory)},h.prototype.getCoordinateSequence=function(){return this._points},h.prototype.isEmpty=function(){return 0===this._points.size()},h.prototype.init=function(_){if(null===_&&(_=this.getFactory().getCoordinateSequenceFactory().create([])),1===_.size())throw new xe("Invalid number of points in LineString (found "+_.size()+" - must be 0 or >= 2)");this._points=_},h.prototype.isCoordinate=function(_){for(var M=0;M<this._points.size();M++)if(this._points.getCoordinate(M).equals(_))return!0;return!1},h.prototype.getStartPoint=function(){return this.isEmpty()?null:this.getPointN(0)},h.prototype.getPointN=function(_){return this.getFactory().createPoint(this._points.getCoordinate(_))},h.prototype.interfaces_=function(){return[Xc]},h.prototype.getClass=function(){return h},x.serialVersionUID.get=function(){return 0x2b2b51ba435c8e00},Object.defineProperties(h,x),h}(Xt),Pt=function(){};Pt.prototype.interfaces_=function(){return[]},Pt.prototype.getClass=function(){return Pt};var ma=function(u){function h(_,M){u.call(this,M),this._coordinates=_||null,this.init(this._coordinates)}u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h;var x={serialVersionUID:{configurable:!0}};return h.prototype.computeEnvelopeInternal=function(){if(this.isEmpty())return new Qe;var _=new Qe;return _.expandToInclude(this._coordinates.getX(0),this._coordinates.getY(0)),_},h.prototype.getSortIndex=function(){return u.SORTINDEX_POINT},h.prototype.getCoordinates=function(){return this.isEmpty()?[]:[this.getCoordinate()]},h.prototype.equalsExact=function(){if(2===arguments.length){var _=arguments[0],M=arguments[1];return!!this.isEquivalentClass(_)&&(!(!this.isEmpty()||!_.isEmpty())||this.isEmpty()===_.isEmpty()&&this.equal(_.getCoordinate(),this.getCoordinate(),M))}return u.prototype.equalsExact.apply(this,arguments)},h.prototype.normalize=function(){},h.prototype.getCoordinate=function(){return 0!==this._coordinates.size()?this._coordinates.getCoordinate(0):null},h.prototype.getBoundaryDimension=function(){return Ur.FALSE},h.prototype.getDimension=function(){return 0},h.prototype.getNumPoints=function(){return this.isEmpty()?0:1},h.prototype.reverse=function(){return this.copy()},h.prototype.getX=function(){if(null===this.getCoordinate())throw new Error("getX called on empty Point");return this.getCoordinate().x},h.prototype.compareToSameClass=function(){if(1===arguments.length){var _=arguments[0];return this.getCoordinate().compareTo(_.getCoordinate())}if(2===arguments.length)return arguments[1].compare(this._coordinates,arguments[0]._coordinates)},h.prototype.apply=function(){if(Ct(arguments[0],xr)){var _=arguments[0];if(this.isEmpty())return null;_.filter(this.getCoordinate())}else if(Ct(arguments[0],cs)){var M=arguments[0];if(this.isEmpty())return null;M.filter(this._coordinates,0),M.isGeometryChanged()&&this.geometryChanged()}else(Ct(arguments[0],oa)||Ct(arguments[0],ft))&&arguments[0].filter(this)},h.prototype.getBoundary=function(){return this.getFactory().createGeometryCollection(null)},h.prototype.clone=function(){var _=u.prototype.clone.call(this);return _._coordinates=this._coordinates.clone(),_},h.prototype.getGeometryType=function(){return"Point"},h.prototype.copy=function(){return new h(this._coordinates.copy(),this._factory)},h.prototype.getCoordinateSequence=function(){return this._coordinates},h.prototype.getY=function(){if(null===this.getCoordinate())throw new Error("getY called on empty Point");return this.getCoordinate().y},h.prototype.isEmpty=function(){return 0===this._coordinates.size()},h.prototype.init=function(_){null===_&&(_=this.getFactory().getCoordinateSequenceFactory().create([])),De.isTrue(_.size()<=1),this._coordinates=_},h.prototype.isSimple=function(){return!0},h.prototype.interfaces_=function(){return[Pt]},h.prototype.getClass=function(){return h},x.serialVersionUID.get=function(){return 0x44077bad161cbc00},Object.defineProperties(h,x),h}(Xt),ju=function(){};ju.prototype.interfaces_=function(){return[]},ju.prototype.getClass=function(){return ju};var Ns=function(u){function h(_,M,z){if(u.call(this,z),this._shell=null,this._holes=null,null===_&&(_=this.getFactory().createLinearRing()),null===M&&(M=[]),u.hasNullElements(M))throw new xe("holes must not contain null elements");if(_.isEmpty()&&u.hasNonEmptyElements(M))throw new xe("shell is empty but holes are not");this._shell=_,this._holes=M}u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h;var x={serialVersionUID:{configurable:!0}};return h.prototype.computeEnvelopeInternal=function(){return this._shell.getEnvelopeInternal()},h.prototype.getSortIndex=function(){return u.SORTINDEX_POLYGON},h.prototype.getCoordinates=function(){if(this.isEmpty())return[];for(var _=new Array(this.getNumPoints()).fill(null),M=-1,z=this._shell.getCoordinates(),q=0;q<z.length;q++)_[++M]=z[q];for(var me=0;me<this._holes.length;me++)for(var Ze=this._holes[me].getCoordinates(),lt=0;lt<Ze.length;lt++)_[++M]=Ze[lt];return _},h.prototype.getArea=function(){var _=0;_+=Math.abs(xt.signedArea(this._shell.getCoordinateSequence()));for(var M=0;M<this._holes.length;M++)_-=Math.abs(xt.signedArea(this._holes[M].getCoordinateSequence()));return _},h.prototype.isRectangle=function(){if(0!==this.getNumInteriorRing()||null===this._shell||5!==this._shell.getNumPoints())return!1;for(var _=this._shell.getCoordinateSequence(),M=this.getEnvelopeInternal(),z=0;z<5;z++){var q=_.getX(z);if(q!==M.getMinX()&&q!==M.getMaxX())return!1;var me=_.getY(z);if(me!==M.getMinY()&&me!==M.getMaxY())return!1}for(var Ze=_.getX(0),lt=_.getY(0),Vt=1;Vt<=4;Vt++){var Yt=_.getX(Vt),wn=_.getY(Vt);if(Yt!==Ze==(wn!==lt))return!1;Ze=Yt,lt=wn}return!0},h.prototype.equalsExact=function(){if(2===arguments.length){var _=arguments[0],M=arguments[1];if(!this.isEquivalentClass(_))return!1;var z=_;if(!this._shell.equalsExact(z._shell,M)||this._holes.length!==z._holes.length)return!1;for(var Ze=0;Ze<this._holes.length;Ze++)if(!this._holes[Ze].equalsExact(z._holes[Ze],M))return!1;return!0}return u.prototype.equalsExact.apply(this,arguments)},h.prototype.normalize=function(){if(0===arguments.length){this.normalize(this._shell,!0);for(var _=0;_<this._holes.length;_++)this.normalize(this._holes[_],!1);Zu.sort(this._holes)}else if(2===arguments.length){var M=arguments[0],z=arguments[1];if(M.isEmpty())return null;var q=new Array(M.getCoordinates().length-1).fill(null);qn.arraycopy(M.getCoordinates(),0,q,0,q.length);var me=Zn.minCoordinate(M.getCoordinates());Zn.scroll(q,me),qn.arraycopy(q,0,M.getCoordinates(),0,q.length),M.getCoordinates()[q.length]=q[0],xt.isCCW(M.getCoordinates())===z&&Zn.reverse(M.getCoordinates())}},h.prototype.getCoordinate=function(){return this._shell.getCoordinate()},h.prototype.getNumInteriorRing=function(){return this._holes.length},h.prototype.getBoundaryDimension=function(){return 1},h.prototype.getDimension=function(){return 2},h.prototype.getLength=function(){var _=0;_+=this._shell.getLength();for(var M=0;M<this._holes.length;M++)_+=this._holes[M].getLength();return _},h.prototype.getNumPoints=function(){for(var _=this._shell.getNumPoints(),M=0;M<this._holes.length;M++)_+=this._holes[M].getNumPoints();return _},h.prototype.reverse=function(){var _=this.copy();_._shell=this._shell.copy().reverse(),_._holes=new Array(this._holes.length).fill(null);for(var M=0;M<this._holes.length;M++)_._holes[M]=this._holes[M].copy().reverse();return _},h.prototype.convexHull=function(){return this.getExteriorRing().convexHull()},h.prototype.compareToSameClass=function(){if(1===arguments.length)return this._shell.compareToSameClass(arguments[0]._shell);if(2===arguments.length){var me=arguments[1],Ze=arguments[0],Yt=this._shell.compareToSameClass(Ze._shell,me);if(0!==Yt)return Yt;for(var wn=this.getNumInteriorRing(),En=Ze.getNumInteriorRing(),Fn=0;Fn<wn&&Fn<En;){var or=this.getInteriorRingN(Fn),fi=Ze.getInteriorRingN(Fn),ji=or.compareToSameClass(fi,me);if(0!==ji)return ji;Fn++}return Fn<wn?1:Fn<En?-1:0}},h.prototype.apply=function(_){if(Ct(_,xr)){this._shell.apply(_);for(var M=0;M<this._holes.length;M++)this._holes[M].apply(_)}else if(Ct(_,cs)){if(this._shell.apply(_),!_.isDone())for(var z=0;z<this._holes.length&&(this._holes[z].apply(_),!_.isDone());z++);_.isGeometryChanged()&&this.geometryChanged()}else if(Ct(_,oa))_.filter(this);else if(Ct(_,ft)){_.filter(this),this._shell.apply(_);for(var q=0;q<this._holes.length;q++)this._holes[q].apply(_)}},h.prototype.getBoundary=function(){if(this.isEmpty())return this.getFactory().createMultiLineString();var _=new Array(this._holes.length+1).fill(null);_[0]=this._shell;for(var M=0;M<this._holes.length;M++)_[M+1]=this._holes[M];return _.length<=1?this.getFactory().createLinearRing(_[0].getCoordinateSequence()):this.getFactory().createMultiLineString(_)},h.prototype.clone=function(){var _=u.prototype.clone.call(this);_._shell=this._shell.clone(),_._holes=new Array(this._holes.length).fill(null);for(var M=0;M<this._holes.length;M++)_._holes[M]=this._holes[M].clone();return _},h.prototype.getGeometryType=function(){return"Polygon"},h.prototype.copy=function(){for(var _=this._shell.copy(),M=new Array(this._holes.length).fill(null),z=0;z<M.length;z++)M[z]=this._holes[z].copy();return new h(_,M,this._factory)},h.prototype.getExteriorRing=function(){return this._shell},h.prototype.isEmpty=function(){return this._shell.isEmpty()},h.prototype.getInteriorRingN=function(_){return this._holes[_]},h.prototype.interfaces_=function(){return[ju]},h.prototype.getClass=function(){return h},x.serialVersionUID.get=function(){return-0x307ffefd8dc97200},Object.defineProperties(h,x),h}(Xt),Kc=function(u){function h(){u.apply(this,arguments)}u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h;var x={serialVersionUID:{configurable:!0}};return h.prototype.getSortIndex=function(){return Xt.SORTINDEX_MULTIPOINT},h.prototype.isValid=function(){return!0},h.prototype.equalsExact=function(){if(2===arguments.length){var _=arguments[0],M=arguments[1];return!!this.isEquivalentClass(_)&&u.prototype.equalsExact.call(this,_,M)}return u.prototype.equalsExact.apply(this,arguments)},h.prototype.getCoordinate=function(){return 1===arguments.length?this._geometries[arguments[0]].getCoordinate():u.prototype.getCoordinate.apply(this,arguments)},h.prototype.getBoundaryDimension=function(){return Ur.FALSE},h.prototype.getDimension=function(){return 0},h.prototype.getBoundary=function(){return this.getFactory().createGeometryCollection(null)},h.prototype.getGeometryType=function(){return"MultiPoint"},h.prototype.copy=function(){for(var _=new Array(this._geometries.length).fill(null),M=0;M<_.length;M++)_[M]=this._geometries[M].copy();return new h(_,this._factory)},h.prototype.interfaces_=function(){return[Pt]},h.prototype.getClass=function(){return h},x.serialVersionUID.get=function(){return-0x6fb1ed4162e0fc00},Object.defineProperties(h,x),h}(Yi),Ba=function(u){function h(_,M){_ instanceof Z&&M instanceof Mr&&(_=M.getCoordinateSequenceFactory().create(_)),u.call(this,_,M),this.validateConstruction()}u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h;var x={MINIMUM_VALID_SIZE:{configurable:!0},serialVersionUID:{configurable:!0}};return h.prototype.getSortIndex=function(){return Xt.SORTINDEX_LINEARRING},h.prototype.getBoundaryDimension=function(){return Ur.FALSE},h.prototype.isClosed=function(){return!!this.isEmpty()||u.prototype.isClosed.call(this)},h.prototype.reverse=function(){var _=this._points.copy();return is.reverse(_),this.getFactory().createLinearRing(_)},h.prototype.validateConstruction=function(){if(!this.isEmpty()&&!u.prototype.isClosed.call(this))throw new xe("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<h.MINIMUM_VALID_SIZE)throw new xe("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")},h.prototype.getGeometryType=function(){return"LinearRing"},h.prototype.copy=function(){return new h(this._points.copy(),this._factory)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},x.MINIMUM_VALID_SIZE.get=function(){return 4},x.serialVersionUID.get=function(){return-0x3b229e262367a600},Object.defineProperties(h,x),h}(Wi),fr=function(u){function h(){u.apply(this,arguments)}u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h;var x={serialVersionUID:{configurable:!0}};return h.prototype.getSortIndex=function(){return Xt.SORTINDEX_MULTIPOLYGON},h.prototype.equalsExact=function(){if(2===arguments.length){var _=arguments[0],M=arguments[1];return!!this.isEquivalentClass(_)&&u.prototype.equalsExact.call(this,_,M)}return u.prototype.equalsExact.apply(this,arguments)},h.prototype.getBoundaryDimension=function(){return 1},h.prototype.getDimension=function(){return 2},h.prototype.reverse=function(){for(var M=new Array(this._geometries.length).fill(null),z=0;z<this._geometries.length;z++)M[z]=this._geometries[z].reverse();return this.getFactory().createMultiPolygon(M)},h.prototype.getBoundary=function(){if(this.isEmpty())return this.getFactory().createMultiLineString();for(var _=new pn,M=0;M<this._geometries.length;M++)for(var z=this._geometries[M].getBoundary(),q=0;q<z.getNumGeometries();q++)_.add(z.getGeometryN(q));var me=new Array(_.size()).fill(null);return this.getFactory().createMultiLineString(_.toArray(me))},h.prototype.getGeometryType=function(){return"MultiPolygon"},h.prototype.copy=function(){for(var _=new Array(this._geometries.length).fill(null),M=0;M<_.length;M++)_[M]=this._geometries[M].copy();return new h(_,this._factory)},h.prototype.interfaces_=function(){return[ju]},h.prototype.getClass=function(){return h},x.serialVersionUID.get=function(){return-0x7a5aa1369171980},Object.defineProperties(h,x),h}(Yi),ga=function(u){this._factory=u||null,this._isUserDataCopied=!1},To={NoOpGeometryOperation:{configurable:!0},CoordinateOperation:{configurable:!0},CoordinateSequenceOperation:{configurable:!0}};ga.prototype.setCopyUserData=function(u){this._isUserDataCopied=u},ga.prototype.edit=function(u,h){if(null===u)return null;var x=this.editInternal(u,h);return this._isUserDataCopied&&x.setUserData(u.getUserData()),x},ga.prototype.editInternal=function(u,h){return null===this._factory&&(this._factory=u.getFactory()),u instanceof Yi?this.editGeometryCollection(u,h):u instanceof Ns?this.editPolygon(u,h):u instanceof ma||u instanceof Wi?h.edit(u,this._factory):(De.shouldNeverReachHere("Unsupported Geometry class: "+u.getClass().getName()),null)},ga.prototype.editGeometryCollection=function(u,h){for(var x=h.edit(u,this._factory),_=new pn,M=0;M<x.getNumGeometries();M++){var z=this.edit(x.getGeometryN(M),h);null===z||z.isEmpty()||_.add(z)}return x.getClass()===Kc?this._factory.createMultiPoint(_.toArray([])):x.getClass()===Ia?this._factory.createMultiLineString(_.toArray([])):x.getClass()===fr?this._factory.createMultiPolygon(_.toArray([])):this._factory.createGeometryCollection(_.toArray([]))},ga.prototype.editPolygon=function(u,h){var x=h.edit(u,this._factory);if(null===x&&(x=this._factory.createPolygon(null)),x.isEmpty())return x;var _=this.edit(x.getExteriorRing(),h);if(null===_||_.isEmpty())return this._factory.createPolygon();for(var M=new pn,z=0;z<x.getNumInteriorRing();z++){var q=this.edit(x.getInteriorRingN(z),h);null===q||q.isEmpty()||M.add(q)}return this._factory.createPolygon(_,M.toArray([]))},ga.prototype.interfaces_=function(){return[]},ga.prototype.getClass=function(){return ga},ga.GeometryEditorOperation=function(){},To.NoOpGeometryOperation.get=function(){return ml},To.CoordinateOperation.get=function(){return Ju},To.CoordinateSequenceOperation.get=function(){return kl},Object.defineProperties(ga,To);var ml=function(){};ml.prototype.edit=function(u,h){return u},ml.prototype.interfaces_=function(){return[ga.GeometryEditorOperation]},ml.prototype.getClass=function(){return ml};var Ju=function(){};Ju.prototype.edit=function(u,h){var x=this.editCoordinates(u.getCoordinates(),u);return null===x?u:u instanceof Ba?h.createLinearRing(x):u instanceof Wi?h.createLineString(x):u instanceof ma?x.length>0?h.createPoint(x[0]):h.createPoint():u},Ju.prototype.interfaces_=function(){return[ga.GeometryEditorOperation]},Ju.prototype.getClass=function(){return Ju};var kl=function(){};kl.prototype.edit=function(u,h){return u instanceof Ba?h.createLinearRing(this.edit(u.getCoordinateSequence(),u)):u instanceof Wi?h.createLineString(this.edit(u.getCoordinateSequence(),u)):u instanceof ma?h.createPoint(this.edit(u.getCoordinateSequence(),u)):u},kl.prototype.interfaces_=function(){return[ga.GeometryEditorOperation]},kl.prototype.getClass=function(){return kl};var Vr=function(){if(this._dimension=3,this._coordinates=null,1===arguments.length){if(arguments[0]instanceof Array)this._coordinates=arguments[0],this._dimension=3;else if(Number.isInteger(arguments[0])){var u=arguments[0];this._coordinates=new Array(u).fill(null);for(var h=0;h<u;h++)this._coordinates[h]=new Z}else if(Ct(arguments[0],Gt)){var x=arguments[0];if(null===x)return this._coordinates=new Array(0).fill(null),null;this._dimension=x.getDimension(),this._coordinates=new Array(x.size()).fill(null);for(var _=0;_<this._coordinates.length;_++)this._coordinates[_]=x.getCoordinateCopy(_)}}else if(2===arguments.length)if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){var M=arguments[0],z=arguments[1];this._coordinates=M,this._dimension=z,null===M&&(this._coordinates=new Array(0).fill(null))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var q=arguments[0],me=arguments[1];this._coordinates=new Array(q).fill(null),this._dimension=me;for(var Ze=0;Ze<q;Ze++)this._coordinates[Ze]=new Z}},Ks={serialVersionUID:{configurable:!0}};Vr.prototype.setOrdinate=function(u,h,x){switch(h){case Gt.X:this._coordinates[u].x=x;break;case Gt.Y:this._coordinates[u].y=x;break;case Gt.Z:this._coordinates[u].z=x;break;default:throw new xe("invalid ordinateIndex")}},Vr.prototype.size=function(){return this._coordinates.length},Vr.prototype.getOrdinate=function(u,h){switch(h){case Gt.X:return this._coordinates[u].x;case Gt.Y:return this._coordinates[u].y;case Gt.Z:return this._coordinates[u].z}return we.NaN},Vr.prototype.getCoordinate=function(){if(1===arguments.length)return this._coordinates[arguments[0]];if(2===arguments.length){var h=arguments[0],x=arguments[1];x.x=this._coordinates[h].x,x.y=this._coordinates[h].y,x.z=this._coordinates[h].z}},Vr.prototype.getCoordinateCopy=function(u){return new Z(this._coordinates[u])},Vr.prototype.getDimension=function(){return this._dimension},Vr.prototype.getX=function(u){return this._coordinates[u].x},Vr.prototype.clone=function(){for(var u=new Array(this.size()).fill(null),h=0;h<this._coordinates.length;h++)u[h]=this._coordinates[h].clone();return new Vr(u,this._dimension)},Vr.prototype.expandEnvelope=function(u){for(var h=0;h<this._coordinates.length;h++)u.expandToInclude(this._coordinates[h]);return u},Vr.prototype.copy=function(){for(var u=new Array(this.size()).fill(null),h=0;h<this._coordinates.length;h++)u[h]=this._coordinates[h].copy();return new Vr(u,this._dimension)},Vr.prototype.toString=function(){if(this._coordinates.length>0){var u=new et(17*this._coordinates.length);u.append("("),u.append(this._coordinates[0]);for(var h=1;h<this._coordinates.length;h++)u.append(", "),u.append(this._coordinates[h]);return u.append(")"),u.toString()}return"()"},Vr.prototype.getY=function(u){return this._coordinates[u].y},Vr.prototype.toCoordinateArray=function(){return this._coordinates},Vr.prototype.interfaces_=function(){return[Gt,te]},Vr.prototype.getClass=function(){return Vr},Ks.serialVersionUID.get=function(){return-0xcb44a778db18e00},Object.defineProperties(Vr,Ks);var Ho=function(){},Af={serialVersionUID:{configurable:!0},instanceObject:{configurable:!0}};Ho.prototype.readResolve=function(){return Ho.instance()},Ho.prototype.create=function(){if(1===arguments.length){if(arguments[0]instanceof Array)return new Vr(arguments[0]);if(Ct(arguments[0],Gt))return new Vr(arguments[0])}else if(2===arguments.length){var x=arguments[0],_=arguments[1];return _>3&&(_=3),_<2?new Vr(x):new Vr(x,_)}},Ho.prototype.interfaces_=function(){return[He,te]},Ho.prototype.getClass=function(){return Ho},Ho.instance=function(){return Ho.instanceObject},Af.serialVersionUID.get=function(){return-0x38e49fa6cf6f2e00},Af.instanceObject.get=function(){return new Ho},Object.defineProperties(Ho,Af);var Tf=function(u){function h(){u.call(this),this.map_=new Map}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.get=function(x){return this.map_.get(x)||null},h.prototype.put=function(x,_){return this.map_.set(x,_),_},h.prototype.values=function(){for(var x=new pn,_=this.map_.values(),M=_.next();!M.done;)x.add(M.value),M=_.next();return x},h.prototype.entrySet=function(){var x=new Ao;return this.map_.entries().forEach(function(_){return x.add(_)}),x},h.prototype.size=function(){return this.map_.size()},h}(fu),Gr=function u(){if(this._modelType=null,this._scale=null,0===arguments.length)this._modelType=u.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof jn){var h=arguments[0];this._modelType=h,h===u.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){var x=arguments[0];this._modelType=u.FIXED,this.setScale(x)}else if(arguments[0]instanceof u){var _=arguments[0];this._modelType=_._modelType,this._scale=_._scale}},ja={serialVersionUID:{configurable:!0},maximumPreciseValue:{configurable:!0}};Gr.prototype.equals=function(u){return u instanceof Gr&&this._modelType===u._modelType&&this._scale===u._scale},Gr.prototype.compareTo=function(u){var h=u,x=this.getMaximumSignificantDigits(),_=h.getMaximumSignificantDigits();return new pt(x).compareTo(new pt(_))},Gr.prototype.getScale=function(){return this._scale},Gr.prototype.isFloating=function(){return this._modelType===Gr.FLOATING||this._modelType===Gr.FLOATING_SINGLE},Gr.prototype.getType=function(){return this._modelType},Gr.prototype.toString=function(){var u="UNKNOWN";return this._modelType===Gr.FLOATING?u="Floating":this._modelType===Gr.FLOATING_SINGLE?u="Floating-Single":this._modelType===Gr.FIXED&&(u="Fixed (Scale="+this.getScale()+")"),u},Gr.prototype.makePrecise=function(){if("number"==typeof arguments[0]){var u=arguments[0];return we.isNaN(u)||this._modelType===Gr.FLOATING_SINGLE?u:this._modelType===Gr.FIXED?Math.round(u*this._scale)/this._scale:u}if(arguments[0]instanceof Z){var h=arguments[0];if(this._modelType===Gr.FLOATING)return null;h.x=this.makePrecise(h.x),h.y=this.makePrecise(h.y)}},Gr.prototype.getMaximumSignificantDigits=function(){var u=16;return this._modelType===Gr.FLOATING?u=16:this._modelType===Gr.FLOATING_SINGLE?u=6:this._modelType===Gr.FIXED&&(u=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),u},Gr.prototype.setScale=function(u){this._scale=Math.abs(u)},Gr.prototype.interfaces_=function(){return[te,Ne]},Gr.prototype.getClass=function(){return Gr},Gr.mostPrecise=function(u,h){return u.compareTo(h)>=0?u:h},ja.serialVersionUID.get=function(){return 0x6bee6404e9a25c00},ja.maximumPreciseValue.get=function(){return 9007199254740992},Object.defineProperties(Gr,ja);var jn=function u(h){this._name=h||null,u.nameToTypeMap.put(h,this)},Yc={serialVersionUID:{configurable:!0},nameToTypeMap:{configurable:!0}};jn.prototype.readResolve=function(){return jn.nameToTypeMap.get(this._name)},jn.prototype.toString=function(){return this._name},jn.prototype.interfaces_=function(){return[te]},jn.prototype.getClass=function(){return jn},Yc.serialVersionUID.get=function(){return-552860263173159e4},Yc.nameToTypeMap.get=function(){return new Tf},Object.defineProperties(jn,Yc),Gr.Type=jn,Gr.FIXED=new jn("FIXED"),Gr.FLOATING=new jn("FLOATING"),Gr.FLOATING_SINGLE=new jn("FLOATING SINGLE");var Mr=function u(){this._precisionModel=new Gr,this._SRID=0,this._coordinateSequenceFactory=u.getDefaultCoordinateSequenceFactory(),0===arguments.length||(1===arguments.length?Ct(arguments[0],He)?this._coordinateSequenceFactory=arguments[0]:arguments[0]instanceof Gr&&(this._precisionModel=arguments[0]):2===arguments.length?(this._precisionModel=arguments[0],this._SRID=arguments[1]):3===arguments.length&&(this._precisionModel=arguments[0],this._SRID=arguments[1],this._coordinateSequenceFactory=arguments[2]))},Mf={serialVersionUID:{configurable:!0}};Mr.prototype.toGeometry=function(u){return u.isNull()?this.createPoint(null):u.getMinX()===u.getMaxX()&&u.getMinY()===u.getMaxY()?this.createPoint(new Z(u.getMinX(),u.getMinY())):u.getMinX()===u.getMaxX()||u.getMinY()===u.getMaxY()?this.createLineString([new Z(u.getMinX(),u.getMinY()),new Z(u.getMaxX(),u.getMaxY())]):this.createPolygon(this.createLinearRing([new Z(u.getMinX(),u.getMinY()),new Z(u.getMinX(),u.getMaxY()),new Z(u.getMaxX(),u.getMaxY()),new Z(u.getMaxX(),u.getMinY()),new Z(u.getMinX(),u.getMinY())]),null)},Mr.prototype.createLineString=function(u){return u?u instanceof Array?new Wi(this.getCoordinateSequenceFactory().create(u),this):Ct(u,Gt)?new Wi(u,this):void 0:new Wi(this.getCoordinateSequenceFactory().create([]),this)},Mr.prototype.createMultiLineString=function(){return 0===arguments.length?new Ia(null,this):1===arguments.length?new Ia(arguments[0],this):void 0},Mr.prototype.buildGeometry=function(u){for(var h=null,x=!1,_=!1,M=u.iterator();M.hasNext();){var z=M.next(),q=z.getClass();null===h&&(h=q),q!==h&&(x=!0),z.isGeometryCollectionOrDerived()&&(_=!0)}if(null===h)return this.createGeometryCollection();if(x||_)return this.createGeometryCollection(Mr.toGeometryArray(u));var me=u.iterator().next();if(u.size()>1){if(me instanceof Ns)return this.createMultiPolygon(Mr.toPolygonArray(u));if(me instanceof Wi)return this.createMultiLineString(Mr.toLineStringArray(u));if(me instanceof ma)return this.createMultiPoint(Mr.toPointArray(u));De.shouldNeverReachHere("Unhandled class: "+me.getClass().getName())}return me},Mr.prototype.createMultiPointFromCoords=function(u){return this.createMultiPoint(null!==u?this.getCoordinateSequenceFactory().create(u):null)},Mr.prototype.createPoint=function(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Z){var u=arguments[0];return this.createPoint(null!==u?this.getCoordinateSequenceFactory().create([u]):null)}if(Ct(arguments[0],Gt))return new ma(arguments[0],this)}},Mr.prototype.getCoordinateSequenceFactory=function(){return this._coordinateSequenceFactory},Mr.prototype.createPolygon=function(){if(0===arguments.length)return new Ns(null,null,this);if(1===arguments.length){if(Ct(arguments[0],Gt))return this.createPolygon(this.createLinearRing(arguments[0]));if(arguments[0]instanceof Array)return this.createPolygon(this.createLinearRing(arguments[0]));if(arguments[0]instanceof Ba)return this.createPolygon(arguments[0],null)}else if(2===arguments.length)return new Ns(arguments[0],arguments[1],this)},Mr.prototype.getSRID=function(){return this._SRID},Mr.prototype.createGeometryCollection=function(){return 0===arguments.length?new Yi(null,this):1===arguments.length?new Yi(arguments[0],this):void 0},Mr.prototype.createGeometry=function(u){return new ga(this).edit(u,{edit:function(){if(2===arguments.length)return this._coordinateSequenceFactory.create(arguments[0])}})},Mr.prototype.getPrecisionModel=function(){return this._precisionModel},Mr.prototype.createLinearRing=function(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){var u=arguments[0];return this.createLinearRing(null!==u?this.getCoordinateSequenceFactory().create(u):null)}if(Ct(arguments[0],Gt))return new Ba(arguments[0],this)}},Mr.prototype.createMultiPolygon=function(){return 0===arguments.length?new fr(null,this):1===arguments.length?new fr(arguments[0],this):void 0},Mr.prototype.createMultiPoint=function(){if(0===arguments.length)return new Kc(null,this);if(1===arguments.length){if(arguments[0]instanceof Array)return new Kc(arguments[0],this);if(arguments[0]instanceof Array){var h=arguments[0];return this.createMultiPoint(null!==h?this.getCoordinateSequenceFactory().create(h):null)}if(Ct(arguments[0],Gt)){var x=arguments[0];if(null===x)return this.createMultiPoint(new Array(0).fill(null));for(var _=new Array(x.size()).fill(null),M=0;M<x.size();M++){var z=this.getCoordinateSequenceFactory().create(1,x.getDimension());is.copy(x,M,z,0,1),_[M]=this.createPoint(z)}return this.createMultiPoint(_)}}},Mr.prototype.interfaces_=function(){return[te]},Mr.prototype.getClass=function(){return Mr},Mr.toMultiPolygonArray=function(u){var h=new Array(u.size()).fill(null);return u.toArray(h)},Mr.toGeometryArray=function(u){if(null===u)return null;var h=new Array(u.size()).fill(null);return u.toArray(h)},Mr.getDefaultCoordinateSequenceFactory=function(){return Ho.instance()},Mr.toMultiLineStringArray=function(u){var h=new Array(u.size()).fill(null);return u.toArray(h)},Mr.toLineStringArray=function(u){var h=new Array(u.size()).fill(null);return u.toArray(h)},Mr.toMultiPointArray=function(u){var h=new Array(u.size()).fill(null);return u.toArray(h)},Mr.toLinearRingArray=function(u){var h=new Array(u.size()).fill(null);return u.toArray(h)},Mr.toPointArray=function(u){var h=new Array(u.size()).fill(null);return u.toArray(h)},Mr.toPolygonArray=function(u){var h=new Array(u.size()).fill(null);return u.toArray(h)},Mr.createPointFromInternalCoord=function(u,h){return h.getPrecisionModel().makePrecise(u),h.getFactory().createPoint(u)},Mf.serialVersionUID.get=function(){return-0x5ea75f2051eeb400},Object.defineProperties(Mr,Mf);var hn=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"],Ys=function(u){this.geometryFactory=u||new Mr};Ys.prototype.read=function(u){var h,x=(h="string"==typeof u?JSON.parse(u):u).type;if(!fs[x])throw new Error("Unknown GeoJSON type: "+h.type);return-1!==hn.indexOf(x)?fs[x].apply(this,[h.coordinates]):fs[x].apply(this,"GeometryCollection"===x?[h.geometries]:[h])},Ys.prototype.write=function(u){var h=u.getGeometryType();if(!Ja[h])throw new Error("Geometry is not supported");return Ja[h].apply(this,[u])};var fs={Feature:function(u){var h={};for(var x in u)h[x]=u[x];if(u.geometry){if(!fs[u.geometry.type])throw new Error("Unknown GeoJSON type: "+u.type);h.geometry=this.read(u.geometry)}return u.bbox&&(h.bbox=fs.bbox.apply(this,[u.bbox])),h},FeatureCollection:function(u){var h={};if(u.features){h.features=[];for(var x=0;x<u.features.length;++x)h.features.push(this.read(u.features[x]))}return u.bbox&&(h.bbox=this.parse.bbox.apply(this,[u.bbox])),h},coordinates:function(u){for(var h=[],x=0;x<u.length;++x){var _=u[x];h.push(new Z(_[0],_[1]))}return h},bbox:function(u){return this.geometryFactory.createLinearRing([new Z(u[0],u[1]),new Z(u[2],u[1]),new Z(u[2],u[3]),new Z(u[0],u[3]),new Z(u[0],u[1])])},Point:function(u){var h=new Z(u[0],u[1]);return this.geometryFactory.createPoint(h)},MultiPoint:function(u){for(var h=[],x=0;x<u.length;++x)h.push(fs.Point.apply(this,[u[x]]));return this.geometryFactory.createMultiPoint(h)},LineString:function(u){var h=fs.coordinates.apply(this,[u]);return this.geometryFactory.createLineString(h)},MultiLineString:function(u){for(var h=[],x=0;x<u.length;++x)h.push(fs.LineString.apply(this,[u[x]]));return this.geometryFactory.createMultiLineString(h)},Polygon:function(u){for(var h=fs.coordinates.apply(this,[u[0]]),x=this.geometryFactory.createLinearRing(h),_=[],M=1;M<u.length;++M){var q=fs.coordinates.apply(this,[u[M]]),me=this.geometryFactory.createLinearRing(q);_.push(me)}return this.geometryFactory.createPolygon(x,_)},MultiPolygon:function(u){for(var h=[],x=0;x<u.length;++x)h.push(fs.Polygon.apply(this,[u[x]]));return this.geometryFactory.createMultiPolygon(h)},GeometryCollection:function(u){for(var h=[],x=0;x<u.length;++x)h.push(this.read(u[x]));return this.geometryFactory.createGeometryCollection(h)}},Ja={coordinate:function(u){return[u.x,u.y]},Point:function(u){return{type:"Point",coordinates:Ja.coordinate.apply(this,[u.getCoordinate()])}},MultiPoint:function(u){for(var h=[],x=0;x<u._geometries.length;++x){var M=Ja.Point.apply(this,[u._geometries[x]]);h.push(M.coordinates)}return{type:"MultiPoint",coordinates:h}},LineString:function(u){for(var h=[],x=u.getCoordinates(),_=0;_<x.length;++_)h.push(Ja.coordinate.apply(this,[x[_]]));return{type:"LineString",coordinates:h}},MultiLineString:function(u){for(var h=[],x=0;x<u._geometries.length;++x){var M=Ja.LineString.apply(this,[u._geometries[x]]);h.push(M.coordinates)}return{type:"MultiLineString",coordinates:h}},Polygon:function(u){var h=[],x=Ja.LineString.apply(this,[u._shell]);h.push(x.coordinates);for(var _=0;_<u._holes.length;++_){var z=Ja.LineString.apply(this,[u._holes[_]]);h.push(z.coordinates)}return{type:"Polygon",coordinates:h}},MultiPolygon:function(u){for(var h=[],x=0;x<u._geometries.length;++x){var M=Ja.Polygon.apply(this,[u._geometries[x]]);h.push(M.coordinates)}return{type:"MultiPolygon",coordinates:h}},GeometryCollection:function(u){for(var h=[],x=0;x<u._geometries.length;++x){var _=u._geometries[x],M=_.getGeometryType();h.push(Ja[M].apply(this,[_]))}return{type:"GeometryCollection",geometries:h}}},mc=function(u){this.geometryFactory=u||new Mr,this.precisionModel=this.geometryFactory.getPrecisionModel(),this.parser=new Ys(this.geometryFactory)};mc.prototype.read=function(u){var h=this.parser.read(u);return this.precisionModel.getType()===Gr.FIXED&&this.reducePrecision(h),h},mc.prototype.reducePrecision=function(u){var h,x;if(u.coordinate)this.precisionModel.makePrecise(u.coordinate);else if(u.points)for(h=0,x=u.points.length;h<x;h++)this.precisionModel.makePrecise(u.points[h]);else if(u.geometries)for(h=0,x=u.geometries.length;h<x;h++)this.reducePrecision(u.geometries[h])};var Bd=function(){this.parser=new Ys(this.geometryFactory)};Bd.prototype.write=function(u){return this.parser.write(u)};var en=function(){},rr={ON:{configurable:!0},LEFT:{configurable:!0},RIGHT:{configurable:!0}};en.prototype.interfaces_=function(){return[]},en.prototype.getClass=function(){return en},en.opposite=function(u){return u===en.LEFT?en.RIGHT:u===en.RIGHT?en.LEFT:u},rr.ON.get=function(){return 0},rr.LEFT.get=function(){return 1},rr.RIGHT.get=function(){return 2},Object.defineProperties(en,rr),(Q.prototype=new Error).name="EmptyStackException",(pe.prototype=new Dr).add=function(u){return this.array_.push(u),!0},pe.prototype.get=function(u){if(u<0||u>=this.size())throw new Error;return this.array_[u]},pe.prototype.push=function(u){return this.array_.push(u),u},pe.prototype.pop=function(u){if(0===this.array_.length)throw new Q;return this.array_.pop()},pe.prototype.peek=function(){if(0===this.array_.length)throw new Q;return this.array_[this.array_.length-1]},pe.prototype.empty=function(){return 0===this.array_.length},pe.prototype.isEmpty=function(){return this.empty()},pe.prototype.search=function(u){return this.array_.indexOf(u)},pe.prototype.size=function(){return this.array_.length},pe.prototype.toArray=function(){for(var u=[],h=0,x=this.array_.length;h<x;h++)u.push(this.array_[h]);return u};var As=function(){this._minIndex=-1,this._minCoord=null,this._minDe=null,this._orientedDe=null};As.prototype.getCoordinate=function(){return this._minCoord},As.prototype.getRightmostSide=function(u,h){var x=this.getRightmostSideOfSegment(u,h);return x<0&&(x=this.getRightmostSideOfSegment(u,h-1)),x<0&&(this._minCoord=null,this.checkForRightmostCoordinate(u)),x},As.prototype.findRightmostEdgeAtVertex=function(){var u=this._minDe.getEdge().getCoordinates();De.isTrue(this._minIndex>0&&this._minIndex<u.length,"rightmost point expected to be interior vertex of edge");var h=u[this._minIndex-1],x=u[this._minIndex+1],_=xt.computeOrientation(this._minCoord,x,h),M=!1;(h.y<this._minCoord.y&&x.y<this._minCoord.y&&_===xt.COUNTERCLOCKWISE||h.y>this._minCoord.y&&x.y>this._minCoord.y&&_===xt.CLOCKWISE)&&(M=!0),M&&(this._minIndex=this._minIndex-1)},As.prototype.getRightmostSideOfSegment=function(u,h){var x=u.getEdge().getCoordinates();if(h<0||h+1>=x.length||x[h].y===x[h+1].y)return-1;var _=en.LEFT;return x[h].y<x[h+1].y&&(_=en.RIGHT),_},As.prototype.getEdge=function(){return this._orientedDe},As.prototype.checkForRightmostCoordinate=function(u){for(var h=u.getEdge().getCoordinates(),x=0;x<h.length-1;x++)(null===this._minCoord||h[x].x>this._minCoord.x)&&(this._minDe=u,this._minIndex=x,this._minCoord=h[x])},As.prototype.findRightmostEdgeAtNode=function(){var u=this._minDe.getNode().getEdges();this._minDe=u.getRightmostEdge(),this._minDe.isForward()||(this._minDe=this._minDe.getSym(),this._minIndex=this._minDe.getEdge().getCoordinates().length-1)},As.prototype.findEdge=function(u){for(var h=u.iterator();h.hasNext();){var x=h.next();x.isForward()&&this.checkForRightmostCoordinate(x)}De.isTrue(0!==this._minIndex||this._minCoord.equals(this._minDe.getCoordinate()),"inconsistency in rightmost processing"),0===this._minIndex?this.findRightmostEdgeAtNode():this.findRightmostEdgeAtVertex(),this._orientedDe=this._minDe,this.getRightmostSide(this._minDe,this._minIndex)===en.LEFT&&(this._orientedDe=this._minDe.getSym())},As.prototype.interfaces_=function(){return[]},As.prototype.getClass=function(){return As};var Qa=function(u){function h(x,_){u.call(this,h.msgWithCoord(x,_)),this.pt=_?new Z(_):null,this.name="TopologyException"}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.getCoordinate=function(){return this.pt},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h.msgWithCoord=function(x,_){return _?x:x+" [ "+_+" ]"},h}(We),Pl=function(){this.array_=[]};Pl.prototype.addLast=function(u){this.array_.push(u)},Pl.prototype.removeFirst=function(){return this.array_.shift()},Pl.prototype.isEmpty=function(){return 0===this.array_.length};var Zi=function(){this._finder=null,this._dirEdgeList=new pn,this._nodes=new pn,this._rightMostCoord=null,this._env=null,this._finder=new As};Zi.prototype.clearVisitedEdges=function(){for(var u=this._dirEdgeList.iterator();u.hasNext();)u.next().setVisited(!1)},Zi.prototype.getRightmostCoordinate=function(){return this._rightMostCoord},Zi.prototype.computeNodeDepth=function(u){for(var h=null,x=u.getEdges().iterator();x.hasNext();){var _=x.next();if(_.isVisited()||_.getSym().isVisited()){h=_;break}}if(null===h)throw new Qa("unable to find edge to compute depths at "+u.getCoordinate());u.getEdges().computeDepths(h);for(var M=u.getEdges().iterator();M.hasNext();){var z=M.next();z.setVisited(!0),this.copySymDepths(z)}},Zi.prototype.computeDepth=function(u){this.clearVisitedEdges();var h=this._finder.getEdge();h.setEdgeDepths(en.RIGHT,u),this.copySymDepths(h),this.computeDepths(h)},Zi.prototype.create=function(u){this.addReachable(u),this._finder.findEdge(this._dirEdgeList),this._rightMostCoord=this._finder.getCoordinate()},Zi.prototype.findResultEdges=function(){for(var u=this._dirEdgeList.iterator();u.hasNext();){var h=u.next();h.getDepth(en.RIGHT)>=1&&h.getDepth(en.LEFT)<=0&&!h.isInteriorAreaEdge()&&h.setInResult(!0)}},Zi.prototype.computeDepths=function(u){var h=new Ao,x=new Pl,_=u.getNode();for(x.addLast(_),h.add(_),u.setVisited(!0);!x.isEmpty();){var M=x.removeFirst();h.add(M),this.computeNodeDepth(M);for(var z=M.getEdges().iterator();z.hasNext();){var q=z.next().getSym();if(!q.isVisited()){var me=q.getNode();h.contains(me)||(x.addLast(me),h.add(me))}}}},Zi.prototype.compareTo=function(u){return this._rightMostCoord.x<u._rightMostCoord.x?-1:this._rightMostCoord.x>u._rightMostCoord.x?1:0},Zi.prototype.getEnvelope=function(){if(null===this._env){for(var u=new Qe,h=this._dirEdgeList.iterator();h.hasNext();)for(var x=h.next().getEdge().getCoordinates(),_=0;_<x.length-1;_++)u.expandToInclude(x[_]);this._env=u}return this._env},Zi.prototype.addReachable=function(u){var h=new pe;for(h.add(u);!h.empty();){var x=h.pop();this.add(x,h)}},Zi.prototype.copySymDepths=function(u){var h=u.getSym();h.setDepth(en.LEFT,u.getDepth(en.RIGHT)),h.setDepth(en.RIGHT,u.getDepth(en.LEFT))},Zi.prototype.add=function(u,h){u.setVisited(!0),this._nodes.add(u);for(var x=u.getEdges().iterator();x.hasNext();){var _=x.next();this._dirEdgeList.add(_);var M=_.getSym().getNode();M.isVisited()||h.push(M)}},Zi.prototype.getNodes=function(){return this._nodes},Zi.prototype.getDirectedEdges=function(){return this._dirEdgeList},Zi.prototype.interfaces_=function(){return[Ne]},Zi.prototype.getClass=function(){return Zi};var ci=function u(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array)this.init(arguments[0].length);else if(Number.isInteger(arguments[0])){var x=arguments[0];this.init(1),this.location[en.ON]=x}else if(arguments[0]instanceof u){var _=arguments[0];if(this.init(_.location.length),null!==_)for(var M=0;M<this.location.length;M++)this.location[M]=_.location[M]}}else if(3===arguments.length){var z=arguments[0],q=arguments[1],me=arguments[2];this.init(3),this.location[en.ON]=z,this.location[en.LEFT]=q,this.location[en.RIGHT]=me}};ci.prototype.setAllLocations=function(u){for(var h=0;h<this.location.length;h++)this.location[h]=u},ci.prototype.isNull=function(){for(var u=0;u<this.location.length;u++)if(this.location[u]!==_e.NONE)return!1;return!0},ci.prototype.setAllLocationsIfNull=function(u){for(var h=0;h<this.location.length;h++)this.location[h]===_e.NONE&&(this.location[h]=u)},ci.prototype.isLine=function(){return 1===this.location.length},ci.prototype.merge=function(u){if(u.location.length>this.location.length){var h=new Array(3).fill(null);h[en.ON]=this.location[en.ON],h[en.LEFT]=_e.NONE,h[en.RIGHT]=_e.NONE,this.location=h}for(var x=0;x<this.location.length;x++)this.location[x]===_e.NONE&&x<u.location.length&&(this.location[x]=u.location[x])},ci.prototype.getLocations=function(){return this.location},ci.prototype.flip=function(){if(this.location.length<=1)return null;var u=this.location[en.LEFT];this.location[en.LEFT]=this.location[en.RIGHT],this.location[en.RIGHT]=u},ci.prototype.toString=function(){var u=new et;return this.location.length>1&&u.append(_e.toLocationSymbol(this.location[en.LEFT])),u.append(_e.toLocationSymbol(this.location[en.ON])),this.location.length>1&&u.append(_e.toLocationSymbol(this.location[en.RIGHT])),u.toString()},ci.prototype.setLocations=function(u,h,x){this.location[en.ON]=u,this.location[en.LEFT]=h,this.location[en.RIGHT]=x},ci.prototype.get=function(u){return u<this.location.length?this.location[u]:_e.NONE},ci.prototype.isArea=function(){return this.location.length>1},ci.prototype.isAnyNull=function(){for(var u=0;u<this.location.length;u++)if(this.location[u]===_e.NONE)return!0;return!1},ci.prototype.setLocation=function(){1===arguments.length?this.setLocation(en.ON,arguments[0]):2===arguments.length&&(this.location[arguments[0]]=arguments[1])},ci.prototype.init=function(u){this.location=new Array(u).fill(null),this.setAllLocations(_e.NONE)},ci.prototype.isEqualOnSide=function(u,h){return this.location[h]===u.location[h]},ci.prototype.allPositionsEqual=function(u){for(var h=0;h<this.location.length;h++)if(this.location[h]!==u)return!1;return!0},ci.prototype.interfaces_=function(){return[]},ci.prototype.getClass=function(){return ci};var kr=function u(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){var h=arguments[0];this.elt[0]=new ci(h),this.elt[1]=new ci(h)}else if(arguments[0]instanceof u){var x=arguments[0];this.elt[0]=new ci(x.elt[0]),this.elt[1]=new ci(x.elt[1])}}else if(2===arguments.length){var _=arguments[0],M=arguments[1];this.elt[0]=new ci(_e.NONE),this.elt[1]=new ci(_e.NONE),this.elt[_].setLocation(M)}else if(3===arguments.length){var z=arguments[0],q=arguments[1],me=arguments[2];this.elt[0]=new ci(z,q,me),this.elt[1]=new ci(z,q,me)}else if(4===arguments.length){var Ze=arguments[0],lt=arguments[1],Vt=arguments[2],Yt=arguments[3];this.elt[0]=new ci(_e.NONE,_e.NONE,_e.NONE),this.elt[1]=new ci(_e.NONE,_e.NONE,_e.NONE),this.elt[Ze].setLocations(lt,Vt,Yt)}};kr.prototype.getGeometryCount=function(){var u=0;return this.elt[0].isNull()||u++,this.elt[1].isNull()||u++,u},kr.prototype.setAllLocations=function(u,h){this.elt[u].setAllLocations(h)},kr.prototype.isNull=function(u){return this.elt[u].isNull()},kr.prototype.setAllLocationsIfNull=function(){if(1===arguments.length){var u=arguments[0];this.setAllLocationsIfNull(0,u),this.setAllLocationsIfNull(1,u)}else 2===arguments.length&&this.elt[arguments[0]].setAllLocationsIfNull(arguments[1])},kr.prototype.isLine=function(u){return this.elt[u].isLine()},kr.prototype.merge=function(u){for(var h=0;h<2;h++)null===this.elt[h]&&null!==u.elt[h]?this.elt[h]=new ci(u.elt[h]):this.elt[h].merge(u.elt[h])},kr.prototype.flip=function(){this.elt[0].flip(),this.elt[1].flip()},kr.prototype.getLocation=function(){return 1===arguments.length?this.elt[arguments[0]].get(en.ON):2===arguments.length?this.elt[arguments[0]].get(arguments[1]):void 0},kr.prototype.toString=function(){var u=new et;return null!==this.elt[0]&&(u.append("A:"),u.append(this.elt[0].toString())),null!==this.elt[1]&&(u.append(" B:"),u.append(this.elt[1].toString())),u.toString()},kr.prototype.isArea=function(){return 0===arguments.length?this.elt[0].isArea()||this.elt[1].isArea():1===arguments.length?this.elt[arguments[0]].isArea():void 0},kr.prototype.isAnyNull=function(u){return this.elt[u].isAnyNull()},kr.prototype.setLocation=function(){2===arguments.length?this.elt[arguments[0]].setLocation(en.ON,arguments[1]):3===arguments.length&&this.elt[arguments[0]].setLocation(arguments[1],arguments[2])},kr.prototype.isEqualOnSide=function(u,h){return this.elt[0].isEqualOnSide(u.elt[0],h)&&this.elt[1].isEqualOnSide(u.elt[1],h)},kr.prototype.allPositionsEqual=function(u,h){return this.elt[u].allPositionsEqual(h)},kr.prototype.toLine=function(u){this.elt[u].isArea()&&(this.elt[u]=new ci(this.elt[u].location[0]))},kr.prototype.interfaces_=function(){return[]},kr.prototype.getClass=function(){return kr},kr.toLineLabel=function(u){for(var h=new kr(_e.NONE),x=0;x<2;x++)h.setLocation(x,u.getLocation(x));return h};var ys=function(){this._startDe=null,this._maxNodeDegree=-1,this._edges=new pn,this._pts=new pn,this._label=new kr(_e.NONE),this._ring=null,this._isHole=null,this._shell=null,this._holes=new pn,this._geometryFactory=null;var u=arguments[0];this._geometryFactory=arguments[1],this.computePoints(u),this.computeRing()};ys.prototype.computeRing=function(){if(null!==this._ring)return null;for(var u=new Array(this._pts.size()).fill(null),h=0;h<this._pts.size();h++)u[h]=this._pts.get(h);this._ring=this._geometryFactory.createLinearRing(u),this._isHole=xt.isCCW(this._ring.getCoordinates())},ys.prototype.isIsolated=function(){return 1===this._label.getGeometryCount()},ys.prototype.computePoints=function(u){this._startDe=u;var h=u,x=!0;do{if(null===h)throw new Qa("Found null DirectedEdge");if(h.getEdgeRing()===this)throw new Qa("Directed Edge visited twice during ring-building at "+h.getCoordinate());this._edges.add(h);var _=h.getLabel();De.isTrue(_.isArea()),this.mergeLabel(_),this.addPoints(h.getEdge(),h.isForward(),x),x=!1,this.setEdgeRing(h,this),h=this.getNext(h)}while(h!==this._startDe)},ys.prototype.getLinearRing=function(){return this._ring},ys.prototype.getCoordinate=function(u){return this._pts.get(u)},ys.prototype.computeMaxNodeDegree=function(){this._maxNodeDegree=0;var u=this._startDe;do{var h=u.getNode().getEdges().getOutgoingDegree(this);h>this._maxNodeDegree&&(this._maxNodeDegree=h),u=this.getNext(u)}while(u!==this._startDe);this._maxNodeDegree*=2},ys.prototype.addPoints=function(u,h,x){var _=u.getCoordinates();if(h){var M=1;x&&(M=0);for(var z=M;z<_.length;z++)this._pts.add(_[z])}else{var q=_.length-2;x&&(q=_.length-1);for(var me=q;me>=0;me--)this._pts.add(_[me])}},ys.prototype.isHole=function(){return this._isHole},ys.prototype.setInResult=function(){var u=this._startDe;do{u.getEdge().setInResult(!0),u=u.getNext()}while(u!==this._startDe)},ys.prototype.containsPoint=function(u){var h=this.getLinearRing();if(!h.getEnvelopeInternal().contains(u)||!xt.isPointInRing(u,h.getCoordinates()))return!1;for(var x=this._holes.iterator();x.hasNext();)if(x.next().containsPoint(u))return!1;return!0},ys.prototype.addHole=function(u){this._holes.add(u)},ys.prototype.isShell=function(){return null===this._shell},ys.prototype.getLabel=function(){return this._label},ys.prototype.getEdges=function(){return this._edges},ys.prototype.getMaxNodeDegree=function(){return this._maxNodeDegree<0&&this.computeMaxNodeDegree(),this._maxNodeDegree},ys.prototype.getShell=function(){return this._shell},ys.prototype.mergeLabel=function(){if(1===arguments.length){var u=arguments[0];this.mergeLabel(u,0),this.mergeLabel(u,1)}else if(2===arguments.length){var x=arguments[1],_=arguments[0].getLocation(x,en.RIGHT);if(_===_e.NONE)return null;if(this._label.getLocation(x)===_e.NONE)return this._label.setLocation(x,_),null}},ys.prototype.setShell=function(u){this._shell=u,null!==u&&u.addHole(this)},ys.prototype.toPolygon=function(u){for(var h=new Array(this._holes.size()).fill(null),x=0;x<this._holes.size();x++)h[x]=this._holes.get(x).getLinearRing();return u.createPolygon(this.getLinearRing(),h)},ys.prototype.interfaces_=function(){return[]},ys.prototype.getClass=function(){return ys};var uh=function(u){function h(){u.call(this,arguments[0],arguments[1])}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.setEdgeRing=function(x,_){x.setMinEdgeRing(_)},h.prototype.getNext=function(x){return x.getNextMin()},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(ys),lh=function(u){function h(){u.call(this,arguments[0],arguments[1])}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.buildMinimalRings=function(){var x=new pn,_=this._startDe;do{if(null===_.getMinEdgeRing()){var M=new uh(_,this._geometryFactory);x.add(M)}_=_.getNext()}while(_!==this._startDe);return x},h.prototype.setEdgeRing=function(x,_){x.setEdgeRing(_)},h.prototype.linkDirectedEdgesForMinimalEdgeRings=function(){var x=this._startDe;do{x.getNode().getEdges().linkMinimalDirectedEdges(this),x=x.getNext()}while(x!==this._startDe)},h.prototype.getNext=function(x){return x.getNext()},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(ys),Ca=function(){this._label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0!==arguments.length&&1===arguments.length&&(this._label=arguments[0])};Ca.prototype.setVisited=function(u){this._isVisited=u},Ca.prototype.setInResult=function(u){this._isInResult=u},Ca.prototype.isCovered=function(){return this._isCovered},Ca.prototype.isCoveredSet=function(){return this._isCoveredSet},Ca.prototype.setLabel=function(u){this._label=u},Ca.prototype.getLabel=function(){return this._label},Ca.prototype.setCovered=function(u){this._isCovered=u,this._isCoveredSet=!0},Ca.prototype.updateIM=function(u){De.isTrue(this._label.getGeometryCount()>=2,"found partial label"),this.computeIM(u)},Ca.prototype.isInResult=function(){return this._isInResult},Ca.prototype.isVisited=function(){return this._isVisited},Ca.prototype.interfaces_=function(){return[]},Ca.prototype.getClass=function(){return Ca};var hu=function(u){function h(){u.call(this),this._coord=null,this._edges=null;var _=arguments[1];this._coord=arguments[0],this._edges=_,this._label=new kr(0,_e.NONE)}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.isIncidentEdgeInResult=function(){for(var x=this.getEdges().getEdges().iterator();x.hasNext();)if(x.next().getEdge().isInResult())return!0;return!1},h.prototype.isIsolated=function(){return 1===this._label.getGeometryCount()},h.prototype.getCoordinate=function(){return this._coord},h.prototype.print=function(x){x.println("node "+this._coord+" lbl: "+this._label)},h.prototype.computeIM=function(x){},h.prototype.computeMergedLocation=function(x,_){var M=_e.NONE;if(M=this._label.getLocation(_),!x.isNull(_)){var z=x.getLocation(_);M!==_e.BOUNDARY&&(M=z)}return M},h.prototype.setLabel=function(){if(2!==arguments.length)return u.prototype.setLabel.apply(this,arguments);var x=arguments[0],_=arguments[1];null===this._label?this._label=new kr(x,_):this._label.setLocation(x,_)},h.prototype.getEdges=function(){return this._edges},h.prototype.mergeLabel=function(){if(arguments[0]instanceof h)this.mergeLabel(arguments[0]._label);else if(arguments[0]instanceof kr)for(var _=arguments[0],M=0;M<2;M++){var z=this.computeMergedLocation(_,M);this._label.getLocation(M)===_e.NONE&&this._label.setLocation(M,z)}},h.prototype.add=function(x){this._edges.insert(x),x.setNode(this)},h.prototype.setLabelBoundary=function(x){if(null===this._label)return null;var _=_e.NONE;null!==this._label&&(_=this._label.getLocation(x)),this._label.setLocation(x,_===_e.BOUNDARY?_e.INTERIOR:_e.BOUNDARY)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(Ca),eo=function(){this.nodeMap=new re,this.nodeFact=null,this.nodeFact=arguments[0]};eo.prototype.find=function(u){return this.nodeMap.get(u)},eo.prototype.addNode=function(){if(arguments[0]instanceof Z){var u=arguments[0],h=this.nodeMap.get(u);return null===h&&(h=this.nodeFact.createNode(u),this.nodeMap.put(u,h)),h}if(arguments[0]instanceof hu){var x=arguments[0],_=this.nodeMap.get(x.getCoordinate());return null===_?(this.nodeMap.put(x.getCoordinate(),x),x):(_.mergeLabel(x),_)}},eo.prototype.print=function(u){for(var h=this.iterator();h.hasNext();)h.next().print(u)},eo.prototype.iterator=function(){return this.nodeMap.values().iterator()},eo.prototype.values=function(){return this.nodeMap.values()},eo.prototype.getBoundaryNodes=function(u){for(var h=new pn,x=this.iterator();x.hasNext();){var _=x.next();_.getLabel().getLocation(u)===_e.BOUNDARY&&h.add(_)}return h},eo.prototype.add=function(u){var h=u.getCoordinate();this.addNode(h).add(u)},eo.prototype.interfaces_=function(){return[]},eo.prototype.getClass=function(){return eo};var Jr=function(){},Zc={NE:{configurable:!0},NW:{configurable:!0},SW:{configurable:!0},SE:{configurable:!0}};Jr.prototype.interfaces_=function(){return[]},Jr.prototype.getClass=function(){return Jr},Jr.isNorthern=function(u){return u===Jr.NE||u===Jr.NW},Jr.isOpposite=function(u,h){return u!==h&&(u-h+4)%4==2},Jr.commonHalfPlane=function(u,h){if(u===h)return u;if((u-h+4)%4==2)return-1;var x=u<h?u:h;return 0===x&&3===(u>h?u:h)?3:x},Jr.isInHalfPlane=function(u,h){return h===Jr.SE?u===Jr.SE||u===Jr.SW:u===h||u===h+1},Jr.quadrant=function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var u=arguments[0],h=arguments[1];if(0===u&&0===h)throw new xe("Cannot compute the quadrant for point ( "+u+", "+h+" )");return u>=0?h>=0?Jr.NE:Jr.SE:h>=0?Jr.NW:Jr.SW}if(arguments[0]instanceof Z&&arguments[1]instanceof Z){var x=arguments[0],_=arguments[1];if(_.x===x.x&&_.y===x.y)throw new xe("Cannot compute the quadrant for two identical points "+x);return _.x>=x.x?_.y>=x.y?Jr.NE:Jr.SE:_.y>=x.y?Jr.NW:Jr.SW}},Zc.NE.get=function(){return 0},Zc.NW.get=function(){return 1},Zc.SW.get=function(){return 2},Zc.SE.get=function(){return 3},Object.defineProperties(Jr,Zc);var Zs=function(){if(this._edge=null,this._label=null,this._node=null,this._p0=null,this._p1=null,this._dx=null,this._dy=null,this._quadrant=null,1===arguments.length)this._edge=arguments[0];else if(3===arguments.length){var x=arguments[1],_=arguments[2];this._edge=arguments[0],this.init(x,_),this._label=null}else if(4===arguments.length){var z=arguments[1],q=arguments[2],me=arguments[3];this._edge=arguments[0],this.init(z,q),this._label=me}};Zs.prototype.compareDirection=function(u){return this._dx===u._dx&&this._dy===u._dy?0:this._quadrant>u._quadrant?1:this._quadrant<u._quadrant?-1:xt.computeOrientation(u._p0,u._p1,this._p1)},Zs.prototype.getDy=function(){return this._dy},Zs.prototype.getCoordinate=function(){return this._p0},Zs.prototype.setNode=function(u){this._node=u},Zs.prototype.print=function(u){var h=Math.atan2(this._dy,this._dx),x=this.getClass().getName(),_=x.lastIndexOf("."),M=x.substring(_+1);u.print("  "+M+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+h+"   "+this._label)},Zs.prototype.compareTo=function(u){return this.compareDirection(u)},Zs.prototype.getDirectedCoordinate=function(){return this._p1},Zs.prototype.getDx=function(){return this._dx},Zs.prototype.getLabel=function(){return this._label},Zs.prototype.getEdge=function(){return this._edge},Zs.prototype.getQuadrant=function(){return this._quadrant},Zs.prototype.getNode=function(){return this._node},Zs.prototype.toString=function(){var u=Math.atan2(this._dy,this._dx),h=this.getClass().getName(),x=h.lastIndexOf(".");return"  "+h.substring(x+1)+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+u+"   "+this._label},Zs.prototype.computeLabel=function(u){},Zs.prototype.init=function(u,h){this._p0=u,this._p1=h,this._dx=h.x-u.x,this._dy=h.y-u.y,this._quadrant=Jr.quadrant(this._dx,this._dy),De.isTrue(!(0===this._dx&&0===this._dy),"EdgeEnd with identical endpoints found")},Zs.prototype.interfaces_=function(){return[Ne]},Zs.prototype.getClass=function(){return Zs};var gl=function(u){function h(){var x=arguments[0],_=arguments[1];if(u.call(this,x),this._isForward=null,this._isInResult=!1,this._isVisited=!1,this._sym=null,this._next=null,this._nextMin=null,this._edgeRing=null,this._minEdgeRing=null,this._depth=[0,-999,-999],this._isForward=_,_)this.init(x.getCoordinate(0),x.getCoordinate(1));else{var M=x.getNumPoints()-1;this.init(x.getCoordinate(M),x.getCoordinate(M-1))}this.computeDirectedLabel()}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.getNextMin=function(){return this._nextMin},h.prototype.getDepth=function(x){return this._depth[x]},h.prototype.setVisited=function(x){this._isVisited=x},h.prototype.computeDirectedLabel=function(){this._label=new kr(this._edge.getLabel()),this._isForward||this._label.flip()},h.prototype.getNext=function(){return this._next},h.prototype.setDepth=function(x,_){if(-999!==this._depth[x]&&this._depth[x]!==_)throw new Qa("assigned depths do not match",this.getCoordinate());this._depth[x]=_},h.prototype.isInteriorAreaEdge=function(){for(var x=!0,_=0;_<2;_++)this._label.isArea(_)&&this._label.getLocation(_,en.LEFT)===_e.INTERIOR&&this._label.getLocation(_,en.RIGHT)===_e.INTERIOR||(x=!1);return x},h.prototype.setNextMin=function(x){this._nextMin=x},h.prototype.print=function(x){u.prototype.print.call(this,x),x.print(" "+this._depth[en.LEFT]+"/"+this._depth[en.RIGHT]),x.print(" ("+this.getDepthDelta()+")"),this._isInResult&&x.print(" inResult")},h.prototype.setMinEdgeRing=function(x){this._minEdgeRing=x},h.prototype.isLineEdge=function(){var x=this._label.isLine(0)||this._label.isLine(1),_=!this._label.isArea(0)||this._label.allPositionsEqual(0,_e.EXTERIOR),M=!this._label.isArea(1)||this._label.allPositionsEqual(1,_e.EXTERIOR);return x&&_&&M},h.prototype.setEdgeRing=function(x){this._edgeRing=x},h.prototype.getMinEdgeRing=function(){return this._minEdgeRing},h.prototype.getDepthDelta=function(){var x=this._edge.getDepthDelta();return this._isForward||(x=-x),x},h.prototype.setInResult=function(x){this._isInResult=x},h.prototype.getSym=function(){return this._sym},h.prototype.isForward=function(){return this._isForward},h.prototype.getEdge=function(){return this._edge},h.prototype.printEdge=function(x){this.print(x),x.print(" "),this._isForward?this._edge.print(x):this._edge.printReverse(x)},h.prototype.setSym=function(x){this._sym=x},h.prototype.setVisitedEdge=function(x){this.setVisited(x),this._sym.setVisited(x)},h.prototype.setEdgeDepths=function(x,_){var M=this.getEdge().getDepthDelta();this._isForward||(M=-M);var z=1;x===en.LEFT&&(z=-1);var q=en.opposite(x),me=_+M*z;this.setDepth(x,_),this.setDepth(q,me)},h.prototype.getEdgeRing=function(){return this._edgeRing},h.prototype.isInResult=function(){return this._isInResult},h.prototype.setNext=function(x){this._next=x},h.prototype.isVisited=function(){return this._isVisited},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h.depthFactor=function(x,_){return x===_e.EXTERIOR&&_===_e.INTERIOR?1:x===_e.INTERIOR&&_===_e.EXTERIOR?-1:0},h}(Zs),Qu=function(){};Qu.prototype.createNode=function(u){return new hu(u,null)},Qu.prototype.interfaces_=function(){return[]},Qu.prototype.getClass=function(){return Qu};var Qi=function(){this._edges=new pn,this._nodes=null,this._edgeEndList=new pn,0===arguments.length?this._nodes=new eo(new Qu):1===arguments.length&&(this._nodes=new eo(arguments[0]))};Qi.prototype.printEdges=function(u){u.println("Edges:");for(var h=0;h<this._edges.size();h++){u.println("edge "+h+":");var x=this._edges.get(h);x.print(u),x.eiList.print(u)}},Qi.prototype.find=function(u){return this._nodes.find(u)},Qi.prototype.addNode=function(){return arguments[0]instanceof hu||arguments[0]instanceof Z?this._nodes.addNode(arguments[0]):void 0},Qi.prototype.getNodeIterator=function(){return this._nodes.iterator()},Qi.prototype.linkResultDirectedEdges=function(){for(var u=this._nodes.iterator();u.hasNext();)u.next().getEdges().linkResultDirectedEdges()},Qi.prototype.debugPrintln=function(u){qn.out.println(u)},Qi.prototype.isBoundaryNode=function(u,h){var x=this._nodes.find(h);if(null===x)return!1;var _=x.getLabel();return null!==_&&_.getLocation(u)===_e.BOUNDARY},Qi.prototype.linkAllDirectedEdges=function(){for(var u=this._nodes.iterator();u.hasNext();)u.next().getEdges().linkAllDirectedEdges()},Qi.prototype.matchInSameDirection=function(u,h,x,_){return!!u.equals(x)&&xt.computeOrientation(u,h,_)===xt.COLLINEAR&&Jr.quadrant(u,h)===Jr.quadrant(x,_)},Qi.prototype.getEdgeEnds=function(){return this._edgeEndList},Qi.prototype.debugPrint=function(u){qn.out.print(u)},Qi.prototype.getEdgeIterator=function(){return this._edges.iterator()},Qi.prototype.findEdgeInSameDirection=function(u,h){for(var x=0;x<this._edges.size();x++){var _=this._edges.get(x),M=_.getCoordinates();if(this.matchInSameDirection(u,h,M[0],M[1])||this.matchInSameDirection(u,h,M[M.length-1],M[M.length-2]))return _}return null},Qi.prototype.insertEdge=function(u){this._edges.add(u)},Qi.prototype.findEdgeEnd=function(u){for(var h=this.getEdgeEnds().iterator();h.hasNext();){var x=h.next();if(x.getEdge()===u)return x}return null},Qi.prototype.addEdges=function(u){for(var h=u.iterator();h.hasNext();){var x=h.next();this._edges.add(x);var _=new gl(x,!0),M=new gl(x,!1);_.setSym(M),M.setSym(_),this.add(_),this.add(M)}},Qi.prototype.add=function(u){this._nodes.add(u),this._edgeEndList.add(u)},Qi.prototype.getNodes=function(){return this._nodes.values()},Qi.prototype.findEdge=function(u,h){for(var x=0;x<this._edges.size();x++){var _=this._edges.get(x),M=_.getCoordinates();if(u.equals(M[0])&&h.equals(M[1]))return _}return null},Qi.prototype.interfaces_=function(){return[]},Qi.prototype.getClass=function(){return Qi},Qi.linkResultDirectedEdges=function(u){for(var h=u.iterator();h.hasNext();)h.next().getEdges().linkResultDirectedEdges()};var la=function(){this._geometryFactory=null,this._shellList=new pn,this._geometryFactory=arguments[0]};la.prototype.sortShellsAndHoles=function(u,h,x){for(var _=u.iterator();_.hasNext();){var M=_.next();M.isHole()?x.add(M):h.add(M)}},la.prototype.computePolygons=function(u){for(var h=new pn,x=u.iterator();x.hasNext();){var _=x.next().toPolygon(this._geometryFactory);h.add(_)}return h},la.prototype.placeFreeHoles=function(u,h){for(var x=h.iterator();x.hasNext();){var _=x.next();if(null===_.getShell()){var M=this.findEdgeRingContaining(_,u);if(null===M)throw new Qa("unable to assign hole to a shell",_.getCoordinate(0));_.setShell(M)}}},la.prototype.buildMinimalEdgeRings=function(u,h,x){for(var _=new pn,M=u.iterator();M.hasNext();){var z=M.next();if(z.getMaxNodeDegree()>2){z.linkDirectedEdgesForMinimalEdgeRings();var q=z.buildMinimalRings(),me=this.findShell(q);null!==me?(this.placePolygonHoles(me,q),h.add(me)):x.addAll(q)}else _.add(z)}return _},la.prototype.containsPoint=function(u){for(var h=this._shellList.iterator();h.hasNext();)if(h.next().containsPoint(u))return!0;return!1},la.prototype.buildMaximalEdgeRings=function(u){for(var h=new pn,x=u.iterator();x.hasNext();){var _=x.next();if(_.isInResult()&&_.getLabel().isArea()&&null===_.getEdgeRing()){var M=new lh(_,this._geometryFactory);h.add(M),M.setInResult()}}return h},la.prototype.placePolygonHoles=function(u,h){for(var x=h.iterator();x.hasNext();){var _=x.next();_.isHole()&&_.setShell(u)}},la.prototype.getPolygons=function(){return this.computePolygons(this._shellList)},la.prototype.findEdgeRingContaining=function(u,h){for(var x=u.getLinearRing(),_=x.getEnvelopeInternal(),M=x.getCoordinateN(0),z=null,q=null,me=h.iterator();me.hasNext();){var Ze=me.next(),lt=Ze.getLinearRing(),Vt=lt.getEnvelopeInternal();null!==z&&(q=z.getLinearRing().getEnvelopeInternal());var Yt=!1;Vt.contains(_)&&xt.isPointInRing(M,lt.getCoordinates())&&(Yt=!0),Yt&&(null===z||q.contains(Vt))&&(z=Ze)}return z},la.prototype.findShell=function(u){for(var h=0,x=null,_=u.iterator();_.hasNext();){var M=_.next();M.isHole()||(x=M,h++)}return De.isTrue(h<=1,"found two shells in MinimalEdgeRing list"),x},la.prototype.add=function(){if(1===arguments.length){var u=arguments[0];this.add(u.getEdgeEnds(),u.getNodes())}else if(2===arguments.length){var h=arguments[0];Qi.linkResultDirectedEdges(arguments[1]);var _=this.buildMaximalEdgeRings(h),M=new pn,z=this.buildMinimalEdgeRings(_,this._shellList,M);this.sortShellsAndHoles(z,this._shellList,M),this.placeFreeHoles(this._shellList,M)}},la.prototype.interfaces_=function(){return[]},la.prototype.getClass=function(){return la};var Fl=function(){};Fl.prototype.getBounds=function(){},Fl.prototype.interfaces_=function(){return[]},Fl.prototype.getClass=function(){return Fl};var Mo=function(){this._bounds=null,this._item=null;var h=arguments[1];this._bounds=arguments[0],this._item=h};Mo.prototype.getItem=function(){return this._item},Mo.prototype.getBounds=function(){return this._bounds},Mo.prototype.interfaces_=function(){return[Fl,te]},Mo.prototype.getClass=function(){return Mo};var Tu=function(){this._size=null,this._items=null,this._size=0,this._items=new pn,this._items.add(null)};Tu.prototype.poll=function(){if(this.isEmpty())return null;var u=this._items.get(1);return this._items.set(1,this._items.get(this._size)),this._size-=1,this.reorder(1),u},Tu.prototype.size=function(){return this._size},Tu.prototype.reorder=function(u){for(var h=null,x=this._items.get(u);2*u<=this._size&&((h=2*u)!==this._size&&this._items.get(h+1).compareTo(this._items.get(h))<0&&h++,this._items.get(h).compareTo(x)<0);u=h)this._items.set(u,this._items.get(h));this._items.set(u,x)},Tu.prototype.clear=function(){this._size=0,this._items.clear()},Tu.prototype.isEmpty=function(){return 0===this._size},Tu.prototype.add=function(u){this._items.add(null),this._size+=1;var h=this._size;for(this._items.set(0,u);u.compareTo(this._items.get(Math.trunc(h/2)))<0;h/=2)this._items.set(h,this._items.get(Math.trunc(h/2)));this._items.set(h,u)},Tu.prototype.interfaces_=function(){return[]},Tu.prototype.getClass=function(){return Tu};var Mu=function(){};Mu.prototype.visitItem=function(u){},Mu.prototype.interfaces_=function(){return[]},Mu.prototype.getClass=function(){return Mu};var Ll=function(){};Ll.prototype.insert=function(u,h){},Ll.prototype.remove=function(u,h){},Ll.prototype.query=function(){},Ll.prototype.interfaces_=function(){return[]},Ll.prototype.getClass=function(){return Ll};var Ts=function(){this._childBoundables=new pn,this._bounds=null,this._level=null,0!==arguments.length&&1===arguments.length&&(this._level=arguments[0])},Rf={serialVersionUID:{configurable:!0}};Ts.prototype.getLevel=function(){return this._level},Ts.prototype.size=function(){return this._childBoundables.size()},Ts.prototype.getChildBoundables=function(){return this._childBoundables},Ts.prototype.addChildBoundable=function(u){De.isTrue(null===this._bounds),this._childBoundables.add(u)},Ts.prototype.isEmpty=function(){return this._childBoundables.isEmpty()},Ts.prototype.getBounds=function(){return null===this._bounds&&(this._bounds=this.computeBounds()),this._bounds},Ts.prototype.interfaces_=function(){return[Fl,te]},Ts.prototype.getClass=function(){return Ts},Rf.serialVersionUID.get=function(){return 0x5a1e55ec41369800},Object.defineProperties(Ts,Rf);var Ro=function(){};Ro.reverseOrder=function(){return{compare:function(u,h){return h.compareTo(u)}}},Ro.min=function(u){return Ro.sort(u),u.get(0)},Ro.sort=function(u,h){var x=u.toArray();h?Zu.sort(x,h):Zu.sort(x);for(var _=u.iterator(),M=0,z=x.length;M<z;M++)_.next(),_.set(x[M])},Ro.singletonList=function(u){var h=new pn;return h.add(u),h};var hs=function(){this._boundable1=null,this._boundable2=null,this._distance=null,this._itemDistance=null;var h=arguments[1],x=arguments[2];this._boundable1=arguments[0],this._boundable2=h,this._itemDistance=x,this._distance=this.distance()};hs.prototype.expandToQueue=function(u,h){var x=hs.isComposite(this._boundable1),_=hs.isComposite(this._boundable2);if(x&&_)return hs.area(this._boundable1)>hs.area(this._boundable2)?(this.expand(this._boundable1,this._boundable2,u,h),null):(this.expand(this._boundable2,this._boundable1,u,h),null);if(x)return this.expand(this._boundable1,this._boundable2,u,h),null;if(_)return this.expand(this._boundable2,this._boundable1,u,h),null;throw new xe("neither boundable is composite")},hs.prototype.isLeaves=function(){return!(hs.isComposite(this._boundable1)||hs.isComposite(this._boundable2))},hs.prototype.compareTo=function(u){return this._distance<u._distance?-1:this._distance>u._distance?1:0},hs.prototype.expand=function(u,h,x,_){for(var M=u.getChildBoundables().iterator();M.hasNext();){var z=M.next(),q=new hs(z,h,this._itemDistance);q.getDistance()<_&&x.add(q)}},hs.prototype.getBoundable=function(u){return 0===u?this._boundable1:this._boundable2},hs.prototype.getDistance=function(){return this._distance},hs.prototype.distance=function(){return this.isLeaves()?this._itemDistance.distance(this._boundable1,this._boundable2):this._boundable1.getBounds().distance(this._boundable2.getBounds())},hs.prototype.interfaces_=function(){return[Ne]},hs.prototype.getClass=function(){return hs},hs.area=function(u){return u.getBounds().getArea()},hs.isComposite=function(u){return u instanceof Ts};var Gs=function u(){if(this._root=null,this._built=!1,this._itemBoundables=new pn,this._nodeCapacity=null,0===arguments.length)this._nodeCapacity=u.DEFAULT_NODE_CAPACITY;else if(1===arguments.length){var x=arguments[0];De.isTrue(x>1,"Node capacity must be greater than 1"),this._nodeCapacity=x}},gc={IntersectsOp:{configurable:!0},serialVersionUID:{configurable:!0},DEFAULT_NODE_CAPACITY:{configurable:!0}};Gs.prototype.getNodeCapacity=function(){return this._nodeCapacity},Gs.prototype.lastNode=function(u){return u.get(u.size()-1)},Gs.prototype.size=function(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.size(this._root));if(1===arguments.length){for(var u=0,h=arguments[0].getChildBoundables().iterator();h.hasNext();){var x=h.next();x instanceof Ts?u+=this.size(x):x instanceof Mo&&(u+=1)}return u}},Gs.prototype.removeItem=function(u,h){for(var x=null,_=u.getChildBoundables().iterator();_.hasNext();){var M=_.next();M instanceof Mo&&M.getItem()===h&&(x=M)}return null!==x&&(u.getChildBoundables().remove(x),!0)},Gs.prototype.itemsTree=function(){if(0===arguments.length){this.build();var u=this.itemsTree(this._root);return null===u?new pn:u}if(1===arguments.length){for(var h=arguments[0],x=new pn,_=h.getChildBoundables().iterator();_.hasNext();){var M=_.next();if(M instanceof Ts){var z=this.itemsTree(M);null!==z&&x.add(z)}else M instanceof Mo?x.add(M.getItem()):De.shouldNeverReachHere()}return x.size()<=0?null:x}},Gs.prototype.insert=function(u,h){De.isTrue(!this._built,"Cannot insert items into an STR packed R-tree after it has been built."),this._itemBoundables.add(new Mo(u,h))},Gs.prototype.boundablesAtLevel=function(){if(1===arguments.length){var u=arguments[0],h=new pn;return this.boundablesAtLevel(u,this._root,h),h}if(3===arguments.length){var x=arguments[0],_=arguments[1],M=arguments[2];if(De.isTrue(x>-2),_.getLevel()===x)return M.add(_),null;for(var z=_.getChildBoundables().iterator();z.hasNext();){var q=z.next();q instanceof Ts?this.boundablesAtLevel(x,q,M):(De.isTrue(q instanceof Mo),-1===x&&M.add(q))}return null}},Gs.prototype.query=function(){if(1===arguments.length){var u=arguments[0];this.build();var h=new pn;return this.isEmpty()||this.getIntersectsOp().intersects(this._root.getBounds(),u)&&this.query(u,this._root,h),h}if(2===arguments.length){var x=arguments[0],_=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this._root.getBounds(),x)&&this.query(x,this._root,_)}else if(3===arguments.length)if(Ct(arguments[2],Mu)&&arguments[0]instanceof Object&&arguments[1]instanceof Ts)for(var M=arguments[0],q=arguments[2],me=arguments[1].getChildBoundables(),Ze=0;Ze<me.size();Ze++){var lt=me.get(Ze);this.getIntersectsOp().intersects(lt.getBounds(),M)&&(lt instanceof Ts?this.query(M,lt,q):lt instanceof Mo?q.visitItem(lt.getItem()):De.shouldNeverReachHere())}else if(Ct(arguments[2],Dr)&&arguments[0]instanceof Object&&arguments[1]instanceof Ts)for(var Vt=arguments[0],wn=arguments[2],En=arguments[1].getChildBoundables(),Fn=0;Fn<En.size();Fn++){var or=En.get(Fn);this.getIntersectsOp().intersects(or.getBounds(),Vt)&&(or instanceof Ts?this.query(Vt,or,wn):or instanceof Mo?wn.add(or.getItem()):De.shouldNeverReachHere())}},Gs.prototype.build=function(){if(this._built)return null;this._root=this._itemBoundables.isEmpty()?this.createNode(0):this.createHigherLevels(this._itemBoundables,-1),this._itemBoundables=null,this._built=!0},Gs.prototype.getRoot=function(){return this.build(),this._root},Gs.prototype.remove=function(){if(2===arguments.length){var u=arguments[0],h=arguments[1];return this.build(),!!this.getIntersectsOp().intersects(this._root.getBounds(),u)&&this.remove(u,this._root,h)}if(3===arguments.length){var x=arguments[0],_=arguments[1],M=arguments[2],z=this.removeItem(_,M);if(z)return!0;for(var q=null,me=_.getChildBoundables().iterator();me.hasNext();){var Ze=me.next();if(this.getIntersectsOp().intersects(Ze.getBounds(),x)&&Ze instanceof Ts&&(z=this.remove(x,Ze,M))){q=Ze;break}}return null!==q&&q.getChildBoundables().isEmpty()&&_.getChildBoundables().remove(q),z}},Gs.prototype.createHigherLevels=function(u,h){De.isTrue(!u.isEmpty());var x=this.createParentBoundables(u,h+1);return 1===x.size()?x.get(0):this.createHigherLevels(x,h+1)},Gs.prototype.depth=function(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this._root));if(1===arguments.length){for(var u=0,h=arguments[0].getChildBoundables().iterator();h.hasNext();){var x=h.next();if(x instanceof Ts){var _=this.depth(x);_>u&&(u=_)}}return u+1}},Gs.prototype.createParentBoundables=function(u,h){De.isTrue(!u.isEmpty());var x=new pn;x.add(this.createNode(h));var _=new pn(u);Ro.sort(_,this.getComparator());for(var M=_.iterator();M.hasNext();){var z=M.next();this.lastNode(x).getChildBoundables().size()===this.getNodeCapacity()&&x.add(this.createNode(h)),this.lastNode(x).addChildBoundable(z)}return x},Gs.prototype.isEmpty=function(){return this._built?this._root.isEmpty():this._itemBoundables.isEmpty()},Gs.prototype.interfaces_=function(){return[te]},Gs.prototype.getClass=function(){return Gs},Gs.compareDoubles=function(u,h){return u>h?1:u<h?-1:0},gc.IntersectsOp.get=function(){return Hh},gc.serialVersionUID.get=function(){return-0x35ef64c82d4c5400},gc.DEFAULT_NODE_CAPACITY.get=function(){return 10},Object.defineProperties(Gs,gc);var Hh=function(){},yl=function(){};yl.prototype.distance=function(u,h){},yl.prototype.interfaces_=function(){return[]},yl.prototype.getClass=function(){return yl};var ch=function(u){function h(_){u.call(this,_=_||h.DEFAULT_NODE_CAPACITY)}u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h;var x={STRtreeNode:{configurable:!0},serialVersionUID:{configurable:!0},xComparator:{configurable:!0},yComparator:{configurable:!0},intersectsOp:{configurable:!0},DEFAULT_NODE_CAPACITY:{configurable:!0}};return h.prototype.createParentBoundablesFromVerticalSlices=function(_,M){De.isTrue(_.length>0);for(var z=new pn,q=0;q<_.length;q++)z.addAll(this.createParentBoundablesFromVerticalSlice(_[q],M));return z},h.prototype.createNode=function(_){return new Df(_)},h.prototype.size=function(){return 0===arguments.length?u.prototype.size.call(this):u.prototype.size.apply(this,arguments)},h.prototype.insert=function(){if(2!==arguments.length)return u.prototype.insert.apply(this,arguments);var _=arguments[0],M=arguments[1];if(_.isNull())return null;u.prototype.insert.call(this,_,M)},h.prototype.getIntersectsOp=function(){return h.intersectsOp},h.prototype.verticalSlices=function(_,M){for(var z=Math.trunc(Math.ceil(_.size()/M)),q=new Array(M).fill(null),me=_.iterator(),Ze=0;Ze<M;Ze++){q[Ze]=new pn;for(var lt=0;me.hasNext()&&lt<z;){var Vt=me.next();q[Ze].add(Vt),lt++}}return q},h.prototype.query=function(){if(1===arguments.length)return u.prototype.query.call(this,arguments[0]);2===arguments.length?u.prototype.query.call(this,arguments[0],arguments[1]):3===arguments.length&&(Ct(arguments[2],Mu)&&arguments[0]instanceof Object&&arguments[1]instanceof Ts||Ct(arguments[2],Dr)&&arguments[0]instanceof Object&&arguments[1]instanceof Ts)&&u.prototype.query.call(this,arguments[0],arguments[1],arguments[2])},h.prototype.getComparator=function(){return h.yComparator},h.prototype.createParentBoundablesFromVerticalSlice=function(_,M){return u.prototype.createParentBoundables.call(this,_,M)},h.prototype.remove=function(){return 2===arguments.length?u.prototype.remove.call(this,arguments[0],arguments[1]):u.prototype.remove.apply(this,arguments)},h.prototype.depth=function(){return 0===arguments.length?u.prototype.depth.call(this):u.prototype.depth.apply(this,arguments)},h.prototype.createParentBoundables=function(_,M){De.isTrue(!_.isEmpty());var z=Math.trunc(Math.ceil(_.size()/this.getNodeCapacity())),q=new pn(_);Ro.sort(q,h.xComparator);var me=this.verticalSlices(q,Math.trunc(Math.ceil(Math.sqrt(z))));return this.createParentBoundablesFromVerticalSlices(me,M)},h.prototype.nearestNeighbour=function(){if(1===arguments.length){if(Ct(arguments[0],yl)){var _=arguments[0],M=new hs(this.getRoot(),this.getRoot(),_);return this.nearestNeighbour(M)}if(arguments[0]instanceof hs)return this.nearestNeighbour(arguments[0],we.POSITIVE_INFINITY)}else if(2===arguments.length){if(arguments[0]instanceof h&&Ct(arguments[1],yl)){var q=arguments[0],me=arguments[1],Ze=new hs(this.getRoot(),q.getRoot(),me);return this.nearestNeighbour(Ze)}if(arguments[0]instanceof hs&&"number"==typeof arguments[1]){var lt=arguments[0],Vt=arguments[1],Yt=null,wn=new Tu;for(wn.add(lt);!wn.isEmpty()&&Vt>0;){var En=wn.poll(),Fn=En.getDistance();if(Fn>=Vt)break;En.isLeaves()?(Vt=Fn,Yt=En):En.expandToQueue(wn,Vt)}return[Yt.getBoundable(0).getItem(),Yt.getBoundable(1).getItem()]}}else if(3===arguments.length){var ji=arguments[2],ro=new Mo(arguments[0],arguments[1]),io=new hs(this.getRoot(),ro,ji);return this.nearestNeighbour(io)[0]}},h.prototype.interfaces_=function(){return[Ll,te]},h.prototype.getClass=function(){return h},h.centreX=function(_){return h.avg(_.getMinX(),_.getMaxX())},h.avg=function(_,M){return(_+M)/2},h.centreY=function(_){return h.avg(_.getMinY(),_.getMaxY())},x.STRtreeNode.get=function(){return Df},x.serialVersionUID.get=function(){return 0x39920f7d5f261e0},x.xComparator.get=function(){return{interfaces_:function(){return[Pe]},compare:function(_,M){return u.compareDoubles(h.centreX(_.getBounds()),h.centreX(M.getBounds()))}}},x.yComparator.get=function(){return{interfaces_:function(){return[Pe]},compare:function(_,M){return u.compareDoubles(h.centreY(_.getBounds()),h.centreY(M.getBounds()))}}},x.intersectsOp.get=function(){return{interfaces_:function(){return[u.IntersectsOp]},intersects:function(_,M){return _.intersects(M)}}},x.DEFAULT_NODE_CAPACITY.get=function(){return 10},Object.defineProperties(h,x),h}(Gs),Df=function(u){function h(){u.call(this,arguments[0])}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.computeBounds=function(){for(var x=null,_=this.getChildBoundables().iterator();_.hasNext();){var M=_.next();null===x?x=new Qe(M.getBounds()):x.expandToInclude(M.getBounds())}return x},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(Ts),Aa=function(){};Aa.prototype.interfaces_=function(){return[]},Aa.prototype.getClass=function(){return Aa},Aa.relativeSign=function(u,h){return u<h?-1:u>h?1:0},Aa.compare=function(u,h,x){if(h.equals2D(x))return 0;var _=Aa.relativeSign(h.x,x.x),M=Aa.relativeSign(h.y,x.y);switch(u){case 0:return Aa.compareValue(_,M);case 1:return Aa.compareValue(M,_);case 2:return Aa.compareValue(M,-_);case 3:return Aa.compareValue(-_,M);case 4:return Aa.compareValue(-_,-M);case 5:return Aa.compareValue(-M,-_);case 6:return Aa.compareValue(-M,_);case 7:return Aa.compareValue(_,-M)}return De.shouldNeverReachHere("invalid octant value"),0},Aa.compareValue=function(u,h){return u<0?-1:u>0?1:h<0?-1:h>0?1:0};var Ru=function(){this._segString=null,this.coord=null,this.segmentIndex=null,this._segmentOctant=null,this._isInterior=null;var u=arguments[0],h=arguments[1],x=arguments[2],_=arguments[3];this._segString=u,this.coord=new Z(h),this.segmentIndex=x,this._segmentOctant=_,this._isInterior=!h.equals2D(u.getCoordinate(x))};Ru.prototype.getCoordinate=function(){return this.coord},Ru.prototype.print=function(u){u.print(this.coord),u.print(" seg # = "+this.segmentIndex)},Ru.prototype.compareTo=function(u){var h=u;return this.segmentIndex<h.segmentIndex?-1:this.segmentIndex>h.segmentIndex?1:this.coord.equals2D(h.coord)?0:Aa.compare(this._segmentOctant,this.coord,h.coord)},Ru.prototype.isEndPoint=function(u){return 0===this.segmentIndex&&!this._isInterior||this.segmentIndex===u},Ru.prototype.isInterior=function(){return this._isInterior},Ru.prototype.interfaces_=function(){return[Ne]},Ru.prototype.getClass=function(){return Ru};var ya=function(){this._nodeMap=new re,this._edge=null,this._edge=arguments[0]};ya.prototype.getSplitCoordinates=function(){var u=new co;this.addEndpoints();for(var h=this.iterator(),x=h.next();h.hasNext();){var _=h.next();this.addEdgeCoordinates(x,_,u),x=_}return u.toCoordinateArray()},ya.prototype.addCollapsedNodes=function(){var u=new pn;this.findCollapsesFromInsertedNodes(u),this.findCollapsesFromExistingVertices(u);for(var h=u.iterator();h.hasNext();){var x=h.next().intValue();this.add(this._edge.getCoordinate(x),x)}},ya.prototype.print=function(u){u.println("Intersections:");for(var h=this.iterator();h.hasNext();)h.next().print(u)},ya.prototype.findCollapsesFromExistingVertices=function(u){for(var h=0;h<this._edge.size()-2;h++){var x=this._edge.getCoordinate(h),_=this._edge.getCoordinate(h+2);x.equals2D(_)&&u.add(new pt(h+1))}},ya.prototype.addEdgeCoordinates=function(u,h,x){var _=this._edge.getCoordinate(h.segmentIndex),M=h.isInterior()||!h.coord.equals2D(_);x.add(new Z(u.coord),!1);for(var z=u.segmentIndex+1;z<=h.segmentIndex;z++)x.add(this._edge.getCoordinate(z));M&&x.add(new Z(h.coord))},ya.prototype.iterator=function(){return this._nodeMap.values().iterator()},ya.prototype.addSplitEdges=function(u){this.addEndpoints(),this.addCollapsedNodes();for(var h=this.iterator(),x=h.next();h.hasNext();){var _=h.next(),M=this.createSplitEdge(x,_);u.add(M),x=_}},ya.prototype.findCollapseIndex=function(u,h,x){if(!u.coord.equals2D(h.coord))return!1;var _=h.segmentIndex-u.segmentIndex;return h.isInterior()||_--,1===_&&(x[0]=u.segmentIndex+1,!0)},ya.prototype.findCollapsesFromInsertedNodes=function(u){for(var h=new Array(1).fill(null),x=this.iterator(),_=x.next();x.hasNext();){var M=x.next();this.findCollapseIndex(_,M,h)&&u.add(new pt(h[0])),_=M}},ya.prototype.getEdge=function(){return this._edge},ya.prototype.addEndpoints=function(){var u=this._edge.size()-1;this.add(this._edge.getCoordinate(0),0),this.add(this._edge.getCoordinate(u),u)},ya.prototype.createSplitEdge=function(u,h){var x=h.segmentIndex-u.segmentIndex+2,_=this._edge.getCoordinate(h.segmentIndex),M=h.isInterior()||!h.coord.equals2D(_);M||x--;var z=new Array(x).fill(null),q=0;z[q++]=new Z(u.coord);for(var me=u.segmentIndex+1;me<=h.segmentIndex;me++)z[q++]=this._edge.getCoordinate(me);return M&&(z[q]=new Z(h.coord)),new ss(z,this._edge.getData())},ya.prototype.add=function(u,h){var x=new Ru(this._edge,u,h,this._edge.getSegmentOctant(h)),_=this._nodeMap.get(x);return null!==_?(De.isTrue(_.coord.equals2D(u),"Found equal nodes with different coordinates"),_):(this._nodeMap.put(x,x),x)},ya.prototype.checkSplitEdgesCorrectness=function(u){var h=this._edge.getCoordinates(),x=u.get(0).getCoordinate(0);if(!x.equals2D(h[0]))throw new We("bad split edge start point at "+x);var _=u.get(u.size()-1).getCoordinates(),M=_[_.length-1];if(!M.equals2D(h[h.length-1]))throw new We("bad split edge end point at "+M)},ya.prototype.interfaces_=function(){return[]},ya.prototype.getClass=function(){return ya};var el=function(){};el.prototype.interfaces_=function(){return[]},el.prototype.getClass=function(){return el},el.octant=function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var u=arguments[0],h=arguments[1];if(0===u&&0===h)throw new xe("Cannot compute the octant for point ( "+u+", "+h+" )");var x=Math.abs(u),_=Math.abs(h);return u>=0?h>=0?x>=_?0:1:x>=_?7:6:h>=0?x>=_?3:2:x>=_?4:5}if(arguments[0]instanceof Z&&arguments[1]instanceof Z){var M=arguments[0],z=arguments[1],q=z.x-M.x,me=z.y-M.y;if(0===q&&0===me)throw new xe("Cannot compute the octant for two identical points "+M);return el.octant(q,me)}};var Do=function(){};Do.prototype.getCoordinates=function(){},Do.prototype.size=function(){},Do.prototype.getCoordinate=function(u){},Do.prototype.isClosed=function(){},Do.prototype.setData=function(u){},Do.prototype.getData=function(){},Do.prototype.interfaces_=function(){return[]},Do.prototype.getClass=function(){return Do};var yc=function(){};yc.prototype.addIntersection=function(u,h){},yc.prototype.interfaces_=function(){return[Do]},yc.prototype.getClass=function(){return yc};var ss=function(){this._nodeList=new ya(this),this._pts=null,this._data=null;var h=arguments[1];this._pts=arguments[0],this._data=h};ss.prototype.getCoordinates=function(){return this._pts},ss.prototype.size=function(){return this._pts.length},ss.prototype.getCoordinate=function(u){return this._pts[u]},ss.prototype.isClosed=function(){return this._pts[0].equals(this._pts[this._pts.length-1])},ss.prototype.getSegmentOctant=function(u){return u===this._pts.length-1?-1:this.safeOctant(this.getCoordinate(u),this.getCoordinate(u+1))},ss.prototype.setData=function(u){this._data=u},ss.prototype.safeOctant=function(u,h){return u.equals2D(h)?0:el.octant(u,h)},ss.prototype.getData=function(){return this._data},ss.prototype.addIntersection=function(){if(2===arguments.length)this.addIntersectionNode(arguments[0],arguments[1]);else if(4===arguments.length){var _=arguments[1],z=new Z(arguments[0].getIntersection(arguments[3]));this.addIntersection(z,_)}},ss.prototype.toString=function(){return Tt.toLineString(new Vr(this._pts))},ss.prototype.getNodeList=function(){return this._nodeList},ss.prototype.addIntersectionNode=function(u,h){var x=h,_=x+1;return _<this._pts.length&&u.equals2D(this._pts[_])&&(x=_),this._nodeList.add(u,x)},ss.prototype.addIntersections=function(u,h,x){for(var _=0;_<u.getIntersectionNum();_++)this.addIntersection(u,h,x,_)},ss.prototype.interfaces_=function(){return[yc]},ss.prototype.getClass=function(){return ss},ss.getNodedSubstrings=function(){if(1===arguments.length){var u=arguments[0],h=new pn;return ss.getNodedSubstrings(u,h),h}if(2===arguments.length)for(var _=arguments[1],M=arguments[0].iterator();M.hasNext();)M.next().getNodeList().addSplitEdges(_)};var Wn=function(){if(this.p0=null,this.p1=null,0===arguments.length)this.p0=new Z,this.p1=new Z;else if(1===arguments.length){var u=arguments[0];this.p0=new Z(u.p0),this.p1=new Z(u.p1)}else if(2===arguments.length)this.p0=arguments[0],this.p1=arguments[1];else if(4===arguments.length){var _=arguments[2],M=arguments[3];this.p0=new Z(arguments[0],arguments[1]),this.p1=new Z(_,M)}},fh={serialVersionUID:{configurable:!0}};Wn.prototype.minX=function(){return Math.min(this.p0.x,this.p1.x)},Wn.prototype.orientationIndex=function(){if(arguments[0]instanceof Wn){var u=arguments[0],h=xt.orientationIndex(this.p0,this.p1,u.p0),x=xt.orientationIndex(this.p0,this.p1,u.p1);return h>=0&&x>=0||h<=0&&x<=0?Math.max(h,x):0}if(arguments[0]instanceof Z)return xt.orientationIndex(this.p0,this.p1,arguments[0])},Wn.prototype.toGeometry=function(u){return u.createLineString([this.p0,this.p1])},Wn.prototype.isVertical=function(){return this.p0.x===this.p1.x},Wn.prototype.equals=function(u){if(!(u instanceof Wn))return!1;var h=u;return this.p0.equals(h.p0)&&this.p1.equals(h.p1)},Wn.prototype.intersection=function(u){var h=new tt;return h.computeIntersection(this.p0,this.p1,u.p0,u.p1),h.hasIntersection()?h.getIntersection(0):null},Wn.prototype.project=function(){if(arguments[0]instanceof Z){var u=arguments[0];if(u.equals(this.p0)||u.equals(this.p1))return new Z(u);var h=this.projectionFactor(u),x=new Z;return x.x=this.p0.x+h*(this.p1.x-this.p0.x),x.y=this.p0.y+h*(this.p1.y-this.p0.y),x}if(arguments[0]instanceof Wn){var _=arguments[0],M=this.projectionFactor(_.p0),z=this.projectionFactor(_.p1);if(M>=1&&z>=1||M<=0&&z<=0)return null;var q=this.project(_.p0);M<0&&(q=this.p0),M>1&&(q=this.p1);var me=this.project(_.p1);return z<0&&(me=this.p0),z>1&&(me=this.p1),new Wn(q,me)}},Wn.prototype.normalize=function(){this.p1.compareTo(this.p0)<0&&this.reverse()},Wn.prototype.angle=function(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)},Wn.prototype.getCoordinate=function(u){return 0===u?this.p0:this.p1},Wn.prototype.distancePerpendicular=function(u){return xt.distancePointLinePerpendicular(u,this.p0,this.p1)},Wn.prototype.minY=function(){return Math.min(this.p0.y,this.p1.y)},Wn.prototype.midPoint=function(){return Wn.midPoint(this.p0,this.p1)},Wn.prototype.projectionFactor=function(u){if(u.equals(this.p0))return 0;if(u.equals(this.p1))return 1;var h=this.p1.x-this.p0.x,x=this.p1.y-this.p0.y,_=h*h+x*x;return _<=0?we.NaN:((u.x-this.p0.x)*h+(u.y-this.p0.y)*x)/_},Wn.prototype.closestPoints=function(u){var h=this.intersection(u);if(null!==h)return[h,h];var x=new Array(2).fill(null),_=we.MAX_VALUE,M=null,z=this.closestPoint(u.p0);_=z.distance(u.p0),x[0]=z,x[1]=u.p0;var q=this.closestPoint(u.p1);(M=q.distance(u.p1))<_&&(_=M,x[0]=q,x[1]=u.p1);var me=u.closestPoint(this.p0);(M=me.distance(this.p0))<_&&(_=M,x[0]=this.p0,x[1]=me);var Ze=u.closestPoint(this.p1);return(M=Ze.distance(this.p1))<_&&(_=M,x[0]=this.p1,x[1]=Ze),x},Wn.prototype.closestPoint=function(u){var h=this.projectionFactor(u);return h>0&&h<1?this.project(u):this.p0.distance(u)<this.p1.distance(u)?this.p0:this.p1},Wn.prototype.maxX=function(){return Math.max(this.p0.x,this.p1.x)},Wn.prototype.getLength=function(){return this.p0.distance(this.p1)},Wn.prototype.compareTo=function(u){var h=u,x=this.p0.compareTo(h.p0);return 0!==x?x:this.p1.compareTo(h.p1)},Wn.prototype.reverse=function(){var u=this.p0;this.p0=this.p1,this.p1=u},Wn.prototype.equalsTopo=function(u){return this.p0.equals(u.p0)&&(this.p1.equals(u.p1)||this.p0.equals(u.p1))&&this.p1.equals(u.p0)},Wn.prototype.lineIntersection=function(u){try{return $n.intersection(this.p0,this.p1,u.p0,u.p1)}catch(h){if(!(h instanceof kn))throw h}return null},Wn.prototype.maxY=function(){return Math.max(this.p0.y,this.p1.y)},Wn.prototype.pointAlongOffset=function(u,h){var x=this.p0.x+u*(this.p1.x-this.p0.x),_=this.p0.y+u*(this.p1.y-this.p0.y),M=this.p1.x-this.p0.x,z=this.p1.y-this.p0.y,q=Math.sqrt(M*M+z*z),me=0,Ze=0;if(0!==h){if(q<=0)throw new Error("Cannot compute offset from zero-length line segment");me=h*M/q,Ze=h*z/q}return new Z(x-Ze,_+me)},Wn.prototype.setCoordinates=function(){if(1===arguments.length){var u=arguments[0];this.setCoordinates(u.p0,u.p1)}else if(2===arguments.length){var h=arguments[0],x=arguments[1];this.p0.x=h.x,this.p0.y=h.y,this.p1.x=x.x,this.p1.y=x.y}},Wn.prototype.segmentFraction=function(u){var h=this.projectionFactor(u);return h<0?h=0:(h>1||we.isNaN(h))&&(h=1),h},Wn.prototype.toString=function(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"},Wn.prototype.isHorizontal=function(){return this.p0.y===this.p1.y},Wn.prototype.distance=function(){if(arguments[0]instanceof Wn){var u=arguments[0];return xt.distanceLineLine(this.p0,this.p1,u.p0,u.p1)}if(arguments[0]instanceof Z)return xt.distancePointLine(arguments[0],this.p0,this.p1)},Wn.prototype.pointAlong=function(u){var h=new Z;return h.x=this.p0.x+u*(this.p1.x-this.p0.x),h.y=this.p0.y+u*(this.p1.y-this.p0.y),h},Wn.prototype.hashCode=function(){var u=we.doubleToLongBits(this.p0.x);u^=31*we.doubleToLongBits(this.p0.y);var h=Math.trunc(u)^Math.trunc(u>>32),x=we.doubleToLongBits(this.p1.x);return x^=31*we.doubleToLongBits(this.p1.y),h^Math.trunc(x)^Math.trunc(x>>32)},Wn.prototype.interfaces_=function(){return[Ne,te]},Wn.prototype.getClass=function(){return Wn},Wn.midPoint=function(u,h){return new Z((u.x+h.x)/2,(u.y+h.y)/2)},fh.serialVersionUID.get=function(){return 0x2d2172135f411c00},Object.defineProperties(Wn,fh);var $l=function(){this.tempEnv1=new Qe,this.tempEnv2=new Qe,this._overlapSeg1=new Wn,this._overlapSeg2=new Wn};$l.prototype.overlap=function(){if(2!==arguments.length&&4===arguments.length){var x=arguments[2],_=arguments[3];arguments[0].getLineSegment(arguments[1],this._overlapSeg1),x.getLineSegment(_,this._overlapSeg2),this.overlap(this._overlapSeg1,this._overlapSeg2)}},$l.prototype.interfaces_=function(){return[]},$l.prototype.getClass=function(){return $l};var va=function(){this._pts=null,this._start=null,this._end=null,this._env=null,this._context=null,this._id=null;var h=arguments[1],x=arguments[2],_=arguments[3];this._pts=arguments[0],this._start=h,this._end=x,this._context=_};va.prototype.getLineSegment=function(u,h){h.p0=this._pts[u],h.p1=this._pts[u+1]},va.prototype.computeSelect=function(u,h,x,_){if(_.tempEnv1.init(this._pts[h],this._pts[x]),x-h==1)return _.select(this,h),null;if(!u.intersects(_.tempEnv1))return null;var q=Math.trunc((h+x)/2);h<q&&this.computeSelect(u,h,q,_),q<x&&this.computeSelect(u,q,x,_)},va.prototype.getCoordinates=function(){for(var u=new Array(this._end-this._start+1).fill(null),h=0,x=this._start;x<=this._end;x++)u[h++]=this._pts[x];return u},va.prototype.computeOverlaps=function(u,h){this.computeOverlapsInternal(this._start,this._end,u,u._start,u._end,h)},va.prototype.setId=function(u){this._id=u},va.prototype.select=function(u,h){this.computeSelect(u,this._start,this._end,h)},va.prototype.getEnvelope=function(){return null===this._env&&(this._env=new Qe(this._pts[this._start],this._pts[this._end])),this._env},va.prototype.getEndIndex=function(){return this._end},va.prototype.getStartIndex=function(){return this._start},va.prototype.getContext=function(){return this._context},va.prototype.getId=function(){return this._id},va.prototype.computeOverlapsInternal=function(u,h,x,_,M,z){var q=this._pts[u],me=this._pts[h],Ze=x._pts[_],lt=x._pts[M];if(h-u==1&&M-_==1)return z.overlap(this,u,x,_),null;if(z.tempEnv1.init(q,me),z.tempEnv2.init(Ze,lt),!z.tempEnv1.intersects(z.tempEnv2))return null;var Vt=Math.trunc((u+h)/2),Yt=Math.trunc((_+M)/2);u<Vt&&(_<Yt&&this.computeOverlapsInternal(u,Vt,x,_,Yt,z),Yt<M&&this.computeOverlapsInternal(u,Vt,x,Yt,M,z)),Vt<h&&(_<Yt&&this.computeOverlapsInternal(Vt,h,x,_,Yt,z),Yt<M&&this.computeOverlapsInternal(Vt,h,x,Yt,M,z))},va.prototype.interfaces_=function(){return[]},va.prototype.getClass=function(){return va};var Xo=function(){};Xo.prototype.interfaces_=function(){return[]},Xo.prototype.getClass=function(){return Xo},Xo.getChainStartIndices=function(u){var h=0,x=new pn;x.add(new pt(h));do{var _=Xo.findChainEnd(u,h);x.add(new pt(_)),h=_}while(h<u.length-1);return Xo.toIntArray(x)},Xo.findChainEnd=function(u,h){for(var x=h;x<u.length-1&&u[x].equals2D(u[x+1]);)x++;if(x>=u.length-1)return u.length-1;for(var _=Jr.quadrant(u[x],u[x+1]),M=h+1;M<u.length&&(u[M-1].equals2D(u[M])||Jr.quadrant(u[M-1],u[M])===_);)M++;return M-1},Xo.getChains=function(){if(1===arguments.length)return Xo.getChains(arguments[0],null);if(2===arguments.length){for(var h=arguments[0],x=arguments[1],_=new pn,M=Xo.getChainStartIndices(h),z=0;z<M.length-1;z++){var q=new va(h,M[z],M[z+1],x);_.add(q)}return _}},Xo.toIntArray=function(u){for(var h=new Array(u.size()).fill(null),x=0;x<h.length;x++)h[x]=u.get(x).intValue();return h};var vl=function(){};vl.prototype.computeNodes=function(u){},vl.prototype.getNodedSubstrings=function(){},vl.prototype.interfaces_=function(){return[]},vl.prototype.getClass=function(){return vl};var Bl=function(){this._segInt=null,0!==arguments.length&&1===arguments.length&&this.setSegmentIntersector(arguments[0])};Bl.prototype.setSegmentIntersector=function(u){this._segInt=u},Bl.prototype.interfaces_=function(){return[vl]},Bl.prototype.getClass=function(){return Bl};var jc=function(u){function h(_){_?u.call(this,_):u.call(this),this._monoChains=new pn,this._index=new ch,this._idCounter=0,this._nodedSegStrings=null,this._nOverlaps=0}u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h;var x={SegmentOverlapAction:{configurable:!0}};return h.prototype.getMonotoneChains=function(){return this._monoChains},h.prototype.getNodedSubstrings=function(){return ss.getNodedSubstrings(this._nodedSegStrings)},h.prototype.getIndex=function(){return this._index},h.prototype.add=function(_){for(var M=Xo.getChains(_.getCoordinates(),_).iterator();M.hasNext();){var z=M.next();z.setId(this._idCounter++),this._index.insert(z.getEnvelope(),z),this._monoChains.add(z)}},h.prototype.computeNodes=function(_){this._nodedSegStrings=_;for(var M=_.iterator();M.hasNext();)this.add(M.next());this.intersectChains()},h.prototype.intersectChains=function(){for(var _=new Of(this._segInt),M=this._monoChains.iterator();M.hasNext();)for(var z=M.next(),q=this._index.query(z.getEnvelope()).iterator();q.hasNext();){var me=q.next();if(me.getId()>z.getId()&&(z.computeOverlaps(me,_),this._nOverlaps++),this._segInt.isDone())return null}},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},x.SegmentOverlapAction.get=function(){return Of},Object.defineProperties(h,x),h}(Bl),Of=function(u){function h(){u.call(this),this._si=null,this._si=arguments[0]}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.overlap=function(){if(4!==arguments.length)return u.prototype.overlap.apply(this,arguments);var _=arguments[1],M=arguments[2],z=arguments[3],q=arguments[0].getContext(),me=M.getContext();this._si.processIntersections(q,_,me,z)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}($l),Yr=function u(){if(this._quadrantSegments=u.DEFAULT_QUADRANT_SEGMENTS,this._endCapStyle=u.CAP_ROUND,this._joinStyle=u.JOIN_ROUND,this._mitreLimit=u.DEFAULT_MITRE_LIMIT,this._isSingleSided=!1,this._simplifyFactor=u.DEFAULT_SIMPLIFY_FACTOR,0!==arguments.length)if(1===arguments.length)this.setQuadrantSegments(arguments[0]);else if(2===arguments.length){var _=arguments[1];this.setQuadrantSegments(arguments[0]),this.setEndCapStyle(_)}else if(4===arguments.length){var z=arguments[1],q=arguments[2],me=arguments[3];this.setQuadrantSegments(arguments[0]),this.setEndCapStyle(z),this.setJoinStyle(q),this.setMitreLimit(me)}},pu={CAP_ROUND:{configurable:!0},CAP_FLAT:{configurable:!0},CAP_SQUARE:{configurable:!0},JOIN_ROUND:{configurable:!0},JOIN_MITRE:{configurable:!0},JOIN_BEVEL:{configurable:!0},DEFAULT_QUADRANT_SEGMENTS:{configurable:!0},DEFAULT_MITRE_LIMIT:{configurable:!0},DEFAULT_SIMPLIFY_FACTOR:{configurable:!0}};Yr.prototype.getEndCapStyle=function(){return this._endCapStyle},Yr.prototype.isSingleSided=function(){return this._isSingleSided},Yr.prototype.setQuadrantSegments=function(u){this._quadrantSegments=u,0===this._quadrantSegments&&(this._joinStyle=Yr.JOIN_BEVEL),this._quadrantSegments<0&&(this._joinStyle=Yr.JOIN_MITRE,this._mitreLimit=Math.abs(this._quadrantSegments)),u<=0&&(this._quadrantSegments=1),this._joinStyle!==Yr.JOIN_ROUND&&(this._quadrantSegments=Yr.DEFAULT_QUADRANT_SEGMENTS)},Yr.prototype.getJoinStyle=function(){return this._joinStyle},Yr.prototype.setJoinStyle=function(u){this._joinStyle=u},Yr.prototype.setSimplifyFactor=function(u){this._simplifyFactor=u<0?0:u},Yr.prototype.getSimplifyFactor=function(){return this._simplifyFactor},Yr.prototype.getQuadrantSegments=function(){return this._quadrantSegments},Yr.prototype.setEndCapStyle=function(u){this._endCapStyle=u},Yr.prototype.getMitreLimit=function(){return this._mitreLimit},Yr.prototype.setMitreLimit=function(u){this._mitreLimit=u},Yr.prototype.setSingleSided=function(u){this._isSingleSided=u},Yr.prototype.interfaces_=function(){return[]},Yr.prototype.getClass=function(){return Yr},Yr.bufferDistanceError=function(u){var h=Math.PI/2/u;return 1-Math.cos(h/2)},pu.CAP_ROUND.get=function(){return 1},pu.CAP_FLAT.get=function(){return 2},pu.CAP_SQUARE.get=function(){return 3},pu.JOIN_ROUND.get=function(){return 1},pu.JOIN_MITRE.get=function(){return 2},pu.JOIN_BEVEL.get=function(){return 3},pu.DEFAULT_QUADRANT_SEGMENTS.get=function(){return 8},pu.DEFAULT_MITRE_LIMIT.get=function(){return 5},pu.DEFAULT_SIMPLIFY_FACTOR.get=function(){return.01},Object.defineProperties(Yr,pu);var as=function(u){this._distanceTol=null,this._isDeleted=null,this._angleOrientation=xt.COUNTERCLOCKWISE,this._inputLine=u||null},Jc={INIT:{configurable:!0},DELETE:{configurable:!0},KEEP:{configurable:!0},NUM_PTS_TO_CHECK:{configurable:!0}};as.prototype.isDeletable=function(u,h,x,_){var M=this._inputLine[u],z=this._inputLine[h],q=this._inputLine[x];return!!this.isConcave(M,z,q)&&!!this.isShallow(M,z,q,_)&&this.isShallowSampled(M,z,u,x,_)},as.prototype.deleteShallowConcavities=function(){for(var u=1,h=this.findNextNonDeletedIndex(u),x=this.findNextNonDeletedIndex(h),_=!1;x<this._inputLine.length;){var M=!1;this.isDeletable(u,h,x,this._distanceTol)&&(this._isDeleted[h]=as.DELETE,M=!0,_=!0),h=this.findNextNonDeletedIndex(u=M?x:h),x=this.findNextNonDeletedIndex(h)}return _},as.prototype.isShallowConcavity=function(u,h,x,_){return xt.computeOrientation(u,h,x)===this._angleOrientation&&xt.distancePointLine(h,u,x)<_},as.prototype.isShallowSampled=function(u,h,x,_,M){var z=Math.trunc((_-x)/as.NUM_PTS_TO_CHECK);z<=0&&(z=1);for(var q=x;q<_;q+=z)if(!this.isShallow(u,h,this._inputLine[q],M))return!1;return!0},as.prototype.isConcave=function(u,h,x){return xt.computeOrientation(u,h,x)===this._angleOrientation},as.prototype.simplify=function(u){this._distanceTol=Math.abs(u),u<0&&(this._angleOrientation=xt.CLOCKWISE),this._isDeleted=new Array(this._inputLine.length).fill(null);var h=!1;do{h=this.deleteShallowConcavities()}while(h);return this.collapseLine()},as.prototype.findNextNonDeletedIndex=function(u){for(var h=u+1;h<this._inputLine.length&&this._isDeleted[h]===as.DELETE;)h++;return h},as.prototype.isShallow=function(u,h,x,_){return xt.distancePointLine(h,u,x)<_},as.prototype.collapseLine=function(){for(var u=new co,h=0;h<this._inputLine.length;h++)this._isDeleted[h]!==as.DELETE&&u.add(this._inputLine[h]);return u.toCoordinateArray()},as.prototype.interfaces_=function(){return[]},as.prototype.getClass=function(){return as},as.simplify=function(u,h){return new as(u).simplify(h)},Jc.INIT.get=function(){return 0},Jc.DELETE.get=function(){return 1},Jc.KEEP.get=function(){return 1},Jc.NUM_PTS_TO_CHECK.get=function(){return 10},Object.defineProperties(as,Jc);var Ta=function(){this._ptList=null,this._precisionModel=null,this._minimimVertexDistance=0,this._ptList=new pn},kf={COORDINATE_ARRAY_TYPE:{configurable:!0}};Ta.prototype.getCoordinates=function(){return this._ptList.toArray(Ta.COORDINATE_ARRAY_TYPE)},Ta.prototype.setPrecisionModel=function(u){this._precisionModel=u},Ta.prototype.addPt=function(u){var h=new Z(u);if(this._precisionModel.makePrecise(h),this.isRedundant(h))return null;this._ptList.add(h)},Ta.prototype.revere=function(){},Ta.prototype.addPts=function(u,h){if(h)for(var x=0;x<u.length;x++)this.addPt(u[x]);else for(var _=u.length-1;_>=0;_--)this.addPt(u[_])},Ta.prototype.isRedundant=function(u){if(this._ptList.size()<1)return!1;var h=this._ptList.get(this._ptList.size()-1);return u.distance(h)<this._minimimVertexDistance},Ta.prototype.toString=function(){return(new Mr).createLineString(this.getCoordinates()).toString()},Ta.prototype.closeRing=function(){if(this._ptList.size()<1)return null;var u=new Z(this._ptList.get(0)),h=this._ptList.get(this._ptList.size()-1);if(u.equals(h))return null;this._ptList.add(u)},Ta.prototype.setMinimumVertexDistance=function(u){this._minimimVertexDistance=u},Ta.prototype.interfaces_=function(){return[]},Ta.prototype.getClass=function(){return Ta},kf.COORDINATE_ARRAY_TYPE.get=function(){return new Array(0).fill(null)},Object.defineProperties(Ta,kf);var Fr=function(){},xl={PI_TIMES_2:{configurable:!0},PI_OVER_2:{configurable:!0},PI_OVER_4:{configurable:!0},COUNTERCLOCKWISE:{configurable:!0},CLOCKWISE:{configurable:!0},NONE:{configurable:!0}};Fr.prototype.interfaces_=function(){return[]},Fr.prototype.getClass=function(){return Fr},Fr.toDegrees=function(u){return 180*u/Math.PI},Fr.normalize=function(u){for(;u>Math.PI;)u-=Fr.PI_TIMES_2;for(;u<=-Math.PI;)u+=Fr.PI_TIMES_2;return u},Fr.angle=function(){if(1===arguments.length){var u=arguments[0];return Math.atan2(u.y,u.x)}if(2===arguments.length){var h=arguments[0],x=arguments[1];return Math.atan2(x.y-h.y,x.x-h.x)}},Fr.isAcute=function(u,h,x){return(u.x-h.x)*(x.x-h.x)+(u.y-h.y)*(x.y-h.y)>0},Fr.isObtuse=function(u,h,x){return(u.x-h.x)*(x.x-h.x)+(u.y-h.y)*(x.y-h.y)<0},Fr.interiorAngle=function(u,h,x){var _=Fr.angle(h,u),M=Fr.angle(h,x);return Math.abs(M-_)},Fr.normalizePositive=function(u){if(u<0){for(;u<0;)u+=Fr.PI_TIMES_2;u>=Fr.PI_TIMES_2&&(u=0)}else{for(;u>=Fr.PI_TIMES_2;)u-=Fr.PI_TIMES_2;u<0&&(u=0)}return u},Fr.angleBetween=function(u,h,x){var _=Fr.angle(h,u),M=Fr.angle(h,x);return Fr.diff(_,M)},Fr.diff=function(u,h){var x=null;return(x=u<h?h-u:u-h)>Math.PI&&(x=2*Math.PI-x),x},Fr.toRadians=function(u){return u*Math.PI/180},Fr.getTurn=function(u,h){var x=Math.sin(h-u);return x>0?Fr.COUNTERCLOCKWISE:x<0?Fr.CLOCKWISE:Fr.NONE},Fr.angleBetweenOriented=function(u,h,x){var _=Fr.angle(h,u),M=Fr.angle(h,x)-_;return M<=-Math.PI?M+Fr.PI_TIMES_2:M>Math.PI?M-Fr.PI_TIMES_2:M},xl.PI_TIMES_2.get=function(){return 2*Math.PI},xl.PI_OVER_2.get=function(){return Math.PI/2},xl.PI_OVER_4.get=function(){return Math.PI/4},xl.COUNTERCLOCKWISE.get=function(){return xt.COUNTERCLOCKWISE},xl.CLOCKWISE.get=function(){return xt.CLOCKWISE},xl.NONE.get=function(){return xt.COLLINEAR},Object.defineProperties(Fr,xl);var Hi=function u(){this._maxCurveSegmentError=0,this._filletAngleQuantum=null,this._closingSegLengthFactor=1,this._segList=null,this._distance=0,this._precisionModel=null,this._bufParams=null,this._li=null,this._s0=null,this._s1=null,this._s2=null,this._seg0=new Wn,this._seg1=new Wn,this._offset0=new Wn,this._offset1=new Wn,this._side=0,this._hasNarrowConcaveAngle=!1;var x=arguments[1],_=arguments[2];this._precisionModel=arguments[0],this._bufParams=x,this._li=new tt,this._filletAngleQuantum=Math.PI/2/x.getQuadrantSegments(),x.getQuadrantSegments()>=8&&x.getJoinStyle()===Yr.JOIN_ROUND&&(this._closingSegLengthFactor=u.MAX_CLOSING_SEG_LEN_FACTOR),this.init(_)},Xh={OFFSET_SEGMENT_SEPARATION_FACTOR:{configurable:!0},INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR:{configurable:!0},CURVE_VERTEX_SNAP_DISTANCE_FACTOR:{configurable:!0},MAX_CLOSING_SEG_LEN_FACTOR:{configurable:!0}};Hi.prototype.addNextSegment=function(u,h){if(this._s0=this._s1,this._s1=this._s2,this._s2=u,this._seg0.setCoordinates(this._s0,this._s1),this.computeOffsetSegment(this._seg0,this._side,this._distance,this._offset0),this._seg1.setCoordinates(this._s1,this._s2),this.computeOffsetSegment(this._seg1,this._side,this._distance,this._offset1),this._s1.equals(this._s2))return null;var x=xt.computeOrientation(this._s0,this._s1,this._s2),_=x===xt.CLOCKWISE&&this._side===en.LEFT||x===xt.COUNTERCLOCKWISE&&this._side===en.RIGHT;0===x?this.addCollinear(h):_?this.addOutsideTurn(x,h):this.addInsideTurn(x,h)},Hi.prototype.addLineEndCap=function(u,h){var x=new Wn(u,h),_=new Wn;this.computeOffsetSegment(x,en.LEFT,this._distance,_);var M=new Wn;this.computeOffsetSegment(x,en.RIGHT,this._distance,M);var me=Math.atan2(h.y-u.y,h.x-u.x);switch(this._bufParams.getEndCapStyle()){case Yr.CAP_ROUND:this._segList.addPt(_.p1),this.addFilletArc(h,me+Math.PI/2,me-Math.PI/2,xt.CLOCKWISE,this._distance),this._segList.addPt(M.p1);break;case Yr.CAP_FLAT:this._segList.addPt(_.p1),this._segList.addPt(M.p1);break;case Yr.CAP_SQUARE:var Ze=new Z;Ze.x=Math.abs(this._distance)*Math.cos(me),Ze.y=Math.abs(this._distance)*Math.sin(me);var lt=new Z(_.p1.x+Ze.x,_.p1.y+Ze.y),Vt=new Z(M.p1.x+Ze.x,M.p1.y+Ze.y);this._segList.addPt(lt),this._segList.addPt(Vt)}},Hi.prototype.getCoordinates=function(){return this._segList.getCoordinates()},Hi.prototype.addMitreJoin=function(u,h,x,_){var M=!0,z=null;try{z=$n.intersection(h.p0,h.p1,x.p0,x.p1),(_<=0?1:z.distance(u)/Math.abs(_))>this._bufParams.getMitreLimit()&&(M=!1)}catch(q){if(!(q instanceof kn))throw q;z=new Z(0,0),M=!1}M?this._segList.addPt(z):this.addLimitedMitreJoin(h,x,_,this._bufParams.getMitreLimit())},Hi.prototype.addFilletCorner=function(u,h,x,_,M){var me=Math.atan2(h.y-u.y,h.x-u.x),Vt=Math.atan2(x.y-u.y,x.x-u.x);_===xt.CLOCKWISE?me<=Vt&&(me+=2*Math.PI):me>=Vt&&(me-=2*Math.PI),this._segList.addPt(h),this.addFilletArc(u,me,Vt,_,M),this._segList.addPt(x)},Hi.prototype.addOutsideTurn=function(u,h){if(this._offset0.p1.distance(this._offset1.p0)<this._distance*Hi.OFFSET_SEGMENT_SEPARATION_FACTOR)return this._segList.addPt(this._offset0.p1),null;this._bufParams.getJoinStyle()===Yr.JOIN_MITRE?this.addMitreJoin(this._s1,this._offset0,this._offset1,this._distance):this._bufParams.getJoinStyle()===Yr.JOIN_BEVEL?this.addBevelJoin(this._offset0,this._offset1):(h&&this._segList.addPt(this._offset0.p1),this.addFilletCorner(this._s1,this._offset0.p1,this._offset1.p0,u,this._distance),this._segList.addPt(this._offset1.p0))},Hi.prototype.createSquare=function(u){this._segList.addPt(new Z(u.x+this._distance,u.y+this._distance)),this._segList.addPt(new Z(u.x+this._distance,u.y-this._distance)),this._segList.addPt(new Z(u.x-this._distance,u.y-this._distance)),this._segList.addPt(new Z(u.x-this._distance,u.y+this._distance)),this._segList.closeRing()},Hi.prototype.addSegments=function(u,h){this._segList.addPts(u,h)},Hi.prototype.addFirstSegment=function(){this._segList.addPt(this._offset1.p0)},Hi.prototype.addLastSegment=function(){this._segList.addPt(this._offset1.p1)},Hi.prototype.initSideSegments=function(u,h,x){this._s1=u,this._s2=h,this._side=x,this._seg1.setCoordinates(u,h),this.computeOffsetSegment(this._seg1,x,this._distance,this._offset1)},Hi.prototype.addLimitedMitreJoin=function(u,h,x,_){var M=this._seg0.p1,z=Fr.angle(M,this._seg0.p0),q=Fr.angleBetweenOriented(this._seg0.p0,M,this._seg1.p1)/2,me=Fr.normalize(z+q),Ze=Fr.normalize(me+Math.PI),lt=_*x,Vt=x-lt*Math.abs(Math.sin(q)),Yt=M.x+lt*Math.cos(Ze),wn=M.y+lt*Math.sin(Ze),En=new Z(Yt,wn),Fn=new Wn(M,En),or=Fn.pointAlongOffset(1,Vt),fi=Fn.pointAlongOffset(1,-Vt);this._side===en.LEFT?(this._segList.addPt(or),this._segList.addPt(fi)):(this._segList.addPt(fi),this._segList.addPt(or))},Hi.prototype.computeOffsetSegment=function(u,h,x,_){var M=h===en.LEFT?1:-1,z=u.p1.x-u.p0.x,q=u.p1.y-u.p0.y,me=Math.sqrt(z*z+q*q),Ze=M*x*z/me,lt=M*x*q/me;_.p0.x=u.p0.x-lt,_.p0.y=u.p0.y+Ze,_.p1.x=u.p1.x-lt,_.p1.y=u.p1.y+Ze},Hi.prototype.addFilletArc=function(u,h,x,_,M){var z=_===xt.CLOCKWISE?-1:1,q=Math.abs(h-x),me=Math.trunc(q/this._filletAngleQuantum+.5);if(me<1)return null;for(var Ze=q/me,lt=0,Vt=new Z;lt<q;){var Yt=h+z*lt;Vt.x=u.x+M*Math.cos(Yt),Vt.y=u.y+M*Math.sin(Yt),this._segList.addPt(Vt),lt+=Ze}},Hi.prototype.addInsideTurn=function(u,h){if(this._li.computeIntersection(this._offset0.p0,this._offset0.p1,this._offset1.p0,this._offset1.p1),this._li.hasIntersection())this._segList.addPt(this._li.getIntersection(0));else if(this._hasNarrowConcaveAngle=!0,this._offset0.p1.distance(this._offset1.p0)<this._distance*Hi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)this._segList.addPt(this._offset0.p1);else{if(this._segList.addPt(this._offset0.p1),this._closingSegLengthFactor>0){var x=new Z((this._closingSegLengthFactor*this._offset0.p1.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset0.p1.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(x);var _=new Z((this._closingSegLengthFactor*this._offset1.p0.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset1.p0.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(_)}else this._segList.addPt(this._s1);this._segList.addPt(this._offset1.p0)}},Hi.prototype.createCircle=function(u){var h=new Z(u.x+this._distance,u.y);this._segList.addPt(h),this.addFilletArc(u,0,2*Math.PI,-1,this._distance),this._segList.closeRing()},Hi.prototype.addBevelJoin=function(u,h){this._segList.addPt(u.p1),this._segList.addPt(h.p0)},Hi.prototype.init=function(u){this._distance=u,this._maxCurveSegmentError=u*(1-Math.cos(this._filletAngleQuantum/2)),this._segList=new Ta,this._segList.setPrecisionModel(this._precisionModel),this._segList.setMinimumVertexDistance(u*Hi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)},Hi.prototype.addCollinear=function(u){this._li.computeIntersection(this._s0,this._s1,this._s1,this._s2),this._li.getIntersectionNum()>=2&&(this._bufParams.getJoinStyle()===Yr.JOIN_BEVEL||this._bufParams.getJoinStyle()===Yr.JOIN_MITRE?(u&&this._segList.addPt(this._offset0.p1),this._segList.addPt(this._offset1.p0)):this.addFilletCorner(this._s1,this._offset0.p1,this._offset1.p0,xt.CLOCKWISE,this._distance))},Hi.prototype.closeRing=function(){this._segList.closeRing()},Hi.prototype.hasNarrowConcaveAngle=function(){return this._hasNarrowConcaveAngle},Hi.prototype.interfaces_=function(){return[]},Hi.prototype.getClass=function(){return Hi},Xh.OFFSET_SEGMENT_SEPARATION_FACTOR.get=function(){return.001},Xh.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get=function(){return.001},Xh.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get=function(){return 1e-6},Xh.MAX_CLOSING_SEG_LEN_FACTOR.get=function(){return 80},Object.defineProperties(Hi,Xh);var to=function(){this._distance=0,this._precisionModel=null,this._bufParams=null;var h=arguments[1];this._precisionModel=arguments[0],this._bufParams=h};to.prototype.getOffsetCurve=function(u,h){if(this._distance=h,0===h)return null;var x=h<0,_=Math.abs(h),M=this.getSegGen(_);u.length<=1?this.computePointCurve(u[0],M):this.computeOffsetCurve(u,x,M);var z=M.getCoordinates();return x&&Zn.reverse(z),z},to.prototype.computeSingleSidedBufferCurve=function(u,h,x){var _=this.simplifyTolerance(this._distance);if(h){x.addSegments(u,!0);var M=as.simplify(u,-_),z=M.length-1;x.initSideSegments(M[z],M[z-1],en.LEFT),x.addFirstSegment();for(var q=z-2;q>=0;q--)x.addNextSegment(M[q],!0)}else{x.addSegments(u,!1);var me=as.simplify(u,_),Ze=me.length-1;x.initSideSegments(me[0],me[1],en.LEFT),x.addFirstSegment();for(var lt=2;lt<=Ze;lt++)x.addNextSegment(me[lt],!0)}x.addLastSegment(),x.closeRing()},to.prototype.computeRingBufferCurve=function(u,h,x){var _=this.simplifyTolerance(this._distance);h===en.RIGHT&&(_=-_);var M=as.simplify(u,_),z=M.length-1;x.initSideSegments(M[z-1],M[0],h);for(var q=1;q<=z;q++)x.addNextSegment(M[q],1!==q);x.closeRing()},to.prototype.computeLineBufferCurve=function(u,h){var x=this.simplifyTolerance(this._distance),_=as.simplify(u,x),M=_.length-1;h.initSideSegments(_[0],_[1],en.LEFT);for(var z=2;z<=M;z++)h.addNextSegment(_[z],!0);h.addLastSegment(),h.addLineEndCap(_[M-1],_[M]);var q=as.simplify(u,-x),me=q.length-1;h.initSideSegments(q[me],q[me-1],en.LEFT);for(var Ze=me-2;Ze>=0;Ze--)h.addNextSegment(q[Ze],!0);h.addLastSegment(),h.addLineEndCap(q[1],q[0]),h.closeRing()},to.prototype.computePointCurve=function(u,h){switch(this._bufParams.getEndCapStyle()){case Yr.CAP_ROUND:h.createCircle(u);break;case Yr.CAP_SQUARE:h.createSquare(u)}},to.prototype.getLineCurve=function(u,h){if(this._distance=h,h<0&&!this._bufParams.isSingleSided()||0===h)return null;var x=Math.abs(h),_=this.getSegGen(x);return u.length<=1?this.computePointCurve(u[0],_):this._bufParams.isSingleSided()?this.computeSingleSidedBufferCurve(u,h<0,_):this.computeLineBufferCurve(u,_),_.getCoordinates()},to.prototype.getBufferParameters=function(){return this._bufParams},to.prototype.simplifyTolerance=function(u){return u*this._bufParams.getSimplifyFactor()},to.prototype.getRingCurve=function(u,h,x){if(this._distance=x,u.length<=2)return this.getLineCurve(u,x);if(0===x)return to.copyCoordinates(u);var _=this.getSegGen(x);return this.computeRingBufferCurve(u,h,_),_.getCoordinates()},to.prototype.computeOffsetCurve=function(u,h,x){var _=this.simplifyTolerance(this._distance);if(h){var M=as.simplify(u,-_),z=M.length-1;x.initSideSegments(M[z],M[z-1],en.LEFT),x.addFirstSegment();for(var q=z-2;q>=0;q--)x.addNextSegment(M[q],!0)}else{var me=as.simplify(u,_),Ze=me.length-1;x.initSideSegments(me[0],me[1],en.LEFT),x.addFirstSegment();for(var lt=2;lt<=Ze;lt++)x.addNextSegment(me[lt],!0)}x.addLastSegment()},to.prototype.getSegGen=function(u){return new Hi(this._precisionModel,this._bufParams,u)},to.prototype.interfaces_=function(){return[]},to.prototype.getClass=function(){return to},to.copyCoordinates=function(u){for(var h=new Array(u.length).fill(null),x=0;x<h.length;x++)h[x]=new Z(u[x]);return h};var bl=function(){this._subgraphs=null,this._seg=new Wn,this._cga=new xt,this._subgraphs=arguments[0]},vc={DepthSegment:{configurable:!0}};bl.prototype.findStabbedSegments=function(){if(1===arguments.length){for(var u=arguments[0],h=new pn,x=this._subgraphs.iterator();x.hasNext();){var _=x.next(),M=_.getEnvelope();u.y<M.getMinY()||u.y>M.getMaxY()||this.findStabbedSegments(u,_.getDirectedEdges(),h)}return h}if(3===arguments.length)if(Ct(arguments[2],Dr)&&arguments[0]instanceof Z&&arguments[1]instanceof gl){for(var z=arguments[0],q=arguments[1],me=arguments[2],Ze=q.getEdge().getCoordinates(),lt=0;lt<Ze.length-1;lt++)if(this._seg.p0=Ze[lt],this._seg.p1=Ze[lt+1],this._seg.p0.y>this._seg.p1.y&&this._seg.reverse(),!(Math.max(this._seg.p0.x,this._seg.p1.x)<z.x||this._seg.isHorizontal()||z.y<this._seg.p0.y||z.y>this._seg.p1.y||xt.computeOrientation(this._seg.p0,this._seg.p1,z)===xt.RIGHT)){var Vt=q.getDepth(en.LEFT);this._seg.p0.equals(Ze[lt])||(Vt=q.getDepth(en.RIGHT));var Yt=new Qr(this._seg,Vt);me.add(Yt)}}else if(Ct(arguments[2],Dr)&&arguments[0]instanceof Z&&Ct(arguments[1],Dr))for(var wn=arguments[0],Fn=arguments[2],or=arguments[1].iterator();or.hasNext();){var fi=or.next();fi.isForward()&&this.findStabbedSegments(wn,fi,Fn)}},bl.prototype.getDepth=function(u){var h=this.findStabbedSegments(u);return 0===h.size()?0:Ro.min(h)._leftDepth},bl.prototype.interfaces_=function(){return[]},bl.prototype.getClass=function(){return bl},vc.DepthSegment.get=function(){return Qr},Object.defineProperties(bl,vc);var Qr=function(){this._upwardSeg=null,this._leftDepth=null;var h=arguments[1];this._upwardSeg=new Wn(arguments[0]),this._leftDepth=h};Qr.prototype.compareTo=function(u){var h=u;if(this._upwardSeg.minX()>=h._upwardSeg.maxX())return 1;if(this._upwardSeg.maxX()<=h._upwardSeg.minX())return-1;var x=this._upwardSeg.orientationIndex(h._upwardSeg);return 0!==x||0!=(x=-1*h._upwardSeg.orientationIndex(this._upwardSeg))?x:this._upwardSeg.compareTo(h._upwardSeg)},Qr.prototype.compareX=function(u,h){var x=u.p0.compareTo(h.p0);return 0!==x?x:u.p1.compareTo(h.p1)},Qr.prototype.toString=function(){return this._upwardSeg.toString()},Qr.prototype.interfaces_=function(){return[Ne]},Qr.prototype.getClass=function(){return Qr};var Gn=function(u,h,x){this.p0=u||null,this.p1=h||null,this.p2=x||null};Gn.prototype.area=function(){return Gn.area(this.p0,this.p1,this.p2)},Gn.prototype.signedArea=function(){return Gn.signedArea(this.p0,this.p1,this.p2)},Gn.prototype.interpolateZ=function(u){if(null===u)throw new xe("Supplied point is null.");return Gn.interpolateZ(u,this.p0,this.p1,this.p2)},Gn.prototype.longestSideLength=function(){return Gn.longestSideLength(this.p0,this.p1,this.p2)},Gn.prototype.isAcute=function(){return Gn.isAcute(this.p0,this.p1,this.p2)},Gn.prototype.circumcentre=function(){return Gn.circumcentre(this.p0,this.p1,this.p2)},Gn.prototype.area3D=function(){return Gn.area3D(this.p0,this.p1,this.p2)},Gn.prototype.centroid=function(){return Gn.centroid(this.p0,this.p1,this.p2)},Gn.prototype.inCentre=function(){return Gn.inCentre(this.p0,this.p1,this.p2)},Gn.prototype.interfaces_=function(){return[]},Gn.prototype.getClass=function(){return Gn},Gn.area=function(u,h,x){return Math.abs(((x.x-u.x)*(h.y-u.y)-(h.x-u.x)*(x.y-u.y))/2)},Gn.signedArea=function(u,h,x){return((x.x-u.x)*(h.y-u.y)-(h.x-u.x)*(x.y-u.y))/2},Gn.det=function(u,h,x,_){return u*_-h*x},Gn.interpolateZ=function(u,h,x,_){var M=h.x,z=h.y,q=x.x-M,me=_.x-M,Ze=x.y-z,lt=_.y-z,Vt=q*lt-me*Ze,Yt=u.x-M,wn=u.y-z;return h.z+(lt*Yt-me*wn)/Vt*(x.z-h.z)+(-Ze*Yt+q*wn)/Vt*(_.z-h.z)},Gn.longestSideLength=function(u,h,x){var _=u.distance(h),M=h.distance(x),z=x.distance(u),q=_;return M>q&&(q=M),z>q&&(q=z),q},Gn.isAcute=function(u,h,x){return!!Fr.isAcute(u,h,x)&&!!Fr.isAcute(h,x,u)&&!!Fr.isAcute(x,u,h)},Gn.circumcentre=function(u,h,x){var _=x.x,M=x.y,z=u.x-_,q=u.y-M,me=h.x-_,Ze=h.y-M,lt=2*Gn.det(z,q,me,Ze),Vt=Gn.det(q,z*z+q*q,Ze,me*me+Ze*Ze),Yt=Gn.det(z,z*z+q*q,me,me*me+Ze*Ze);return new Z(_-Vt/lt,M+Yt/lt)},Gn.perpendicularBisector=function(u,h){var x=h.x-u.x,_=h.y-u.y,M=new $n(u.x+x/2,u.y+_/2,1),z=new $n(u.x-_+x/2,u.y+x+_/2,1);return new $n(M,z)},Gn.angleBisector=function(u,h,x){var _=h.distance(u),M=_/(_+h.distance(x));return new Z(u.x+M*(x.x-u.x),u.y+M*(x.y-u.y))},Gn.area3D=function(u,h,x){var _=h.x-u.x,M=h.y-u.y,z=h.z-u.z,q=x.x-u.x,me=x.y-u.y,Ze=x.z-u.z,lt=M*Ze-z*me,Vt=z*q-_*Ze,Yt=_*me-M*q;return Math.sqrt(lt*lt+Vt*Vt+Yt*Yt)/2},Gn.centroid=function(u,h,x){return new Z((u.x+h.x+x.x)/3,(u.y+h.y+x.y)/3)},Gn.inCentre=function(u,h,x){var _=h.distance(x),M=u.distance(x),z=u.distance(h),q=_+M+z;return new Z((_*u.x+M*h.x+z*x.x)/q,(_*u.y+M*h.y+z*x.y)/q)};var Ps=function(){this._inputGeom=null,this._distance=null,this._curveBuilder=null,this._curveList=new pn;var h=arguments[1],x=arguments[2];this._inputGeom=arguments[0],this._distance=h,this._curveBuilder=x};Ps.prototype.addPoint=function(u){if(this._distance<=0)return null;var h=u.getCoordinates(),x=this._curveBuilder.getLineCurve(h,this._distance);this.addCurve(x,_e.EXTERIOR,_e.INTERIOR)},Ps.prototype.addPolygon=function(u){var h=this._distance,x=en.LEFT;this._distance<0&&(h=-this._distance,x=en.RIGHT);var _=u.getExteriorRing(),M=Zn.removeRepeatedPoints(_.getCoordinates());if(this._distance<0&&this.isErodedCompletely(_,this._distance)||this._distance<=0&&M.length<3)return null;this.addPolygonRing(M,h,x,_e.EXTERIOR,_e.INTERIOR);for(var z=0;z<u.getNumInteriorRing();z++){var q=u.getInteriorRingN(z),me=Zn.removeRepeatedPoints(q.getCoordinates());this._distance>0&&this.isErodedCompletely(q,-this._distance)||this.addPolygonRing(me,h,en.opposite(x),_e.INTERIOR,_e.EXTERIOR)}},Ps.prototype.isTriangleErodedCompletely=function(u,h){var x=new Gn(u[0],u[1],u[2]),_=x.inCentre();return xt.distancePointLine(_,x.p0,x.p1)<Math.abs(h)},Ps.prototype.addLineString=function(u){if(this._distance<=0&&!this._curveBuilder.getBufferParameters().isSingleSided())return null;var h=Zn.removeRepeatedPoints(u.getCoordinates()),x=this._curveBuilder.getLineCurve(h,this._distance);this.addCurve(x,_e.EXTERIOR,_e.INTERIOR)},Ps.prototype.addCurve=function(u,h,x){if(null===u||u.length<2)return null;var _=new ss(u,new kr(0,_e.BOUNDARY,h,x));this._curveList.add(_)},Ps.prototype.getCurves=function(){return this.add(this._inputGeom),this._curveList},Ps.prototype.addPolygonRing=function(u,h,x,_,M){if(0===h&&u.length<Ba.MINIMUM_VALID_SIZE)return null;var z=_,q=M;u.length>=Ba.MINIMUM_VALID_SIZE&&xt.isCCW(u)&&(z=M,q=_,x=en.opposite(x));var me=this._curveBuilder.getRingCurve(u,x,h);this.addCurve(me,z,q)},Ps.prototype.add=function(u){if(u.isEmpty())return null;u instanceof Ns?this.addPolygon(u):u instanceof Wi?this.addLineString(u):u instanceof ma?this.addPoint(u):(u instanceof Kc||u instanceof Ia||u instanceof fr||u instanceof Yi)&&this.addCollection(u)},Ps.prototype.isErodedCompletely=function(u,h){var x=u.getCoordinates();if(x.length<4)return h<0;if(4===x.length)return this.isTriangleErodedCompletely(x,h);var _=u.getEnvelopeInternal(),M=Math.min(_.getHeight(),_.getWidth());return h<0&&2*Math.abs(h)>M},Ps.prototype.addCollection=function(u){for(var h=0;h<u.getNumGeometries();h++){var x=u.getGeometryN(h);this.add(x)}},Ps.prototype.interfaces_=function(){return[]},Ps.prototype.getClass=function(){return Ps};var Ko=function(){};Ko.prototype.locate=function(u){},Ko.prototype.interfaces_=function(){return[]},Ko.prototype.getClass=function(){return Ko};var no=function(){this._parent=null,this._atStart=null,this._max=null,this._index=null,this._subcollectionIterator=null;var u=arguments[0];this._parent=u,this._atStart=!0,this._index=0,this._max=u.getNumGeometries()};no.prototype.next=function(){if(this._atStart)return this._atStart=!1,no.isAtomic(this._parent)&&this._index++,this._parent;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return this._subcollectionIterator.next();this._subcollectionIterator=null}if(this._index>=this._max)throw new ye;var u=this._parent.getGeometryN(this._index++);return u instanceof Yi?(this._subcollectionIterator=new no(u),this._subcollectionIterator.next()):u},no.prototype.remove=function(){throw new Error(this.getClass().getName())},no.prototype.hasNext=function(){if(this._atStart)return!0;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return!0;this._subcollectionIterator=null}return!(this._index>=this._max)},no.prototype.interfaces_=function(){return[hi]},no.prototype.getClass=function(){return no},no.isAtomic=function(u){return!(u instanceof Yi)};var os=function(){this._geom=null,this._geom=arguments[0]};os.prototype.locate=function(u){return os.locate(u,this._geom)},os.prototype.interfaces_=function(){return[Ko]},os.prototype.getClass=function(){return os},os.isPointInRing=function(u,h){return!!h.getEnvelopeInternal().intersects(u)&&xt.isPointInRing(u,h.getCoordinates())},os.containsPointInPolygon=function(u,h){if(h.isEmpty())return!1;var x=h.getExteriorRing();if(!os.isPointInRing(u,x))return!1;for(var _=0;_<h.getNumInteriorRing();_++){var M=h.getInteriorRingN(_);if(os.isPointInRing(u,M))return!1}return!0},os.containsPoint=function(u,h){if(h instanceof Ns)return os.containsPointInPolygon(u,h);if(h instanceof Yi)for(var x=new no(h);x.hasNext();){var _=x.next();if(_!==h&&os.containsPoint(u,_))return!0}return!1},os.locate=function(u,h){return h.isEmpty()?_e.EXTERIOR:os.containsPoint(u,h)?_e.INTERIOR:_e.EXTERIOR};var _r=function(){this._edgeMap=new re,this._edgeList=null,this._ptInAreaLocation=[_e.NONE,_e.NONE]};_r.prototype.getNextCW=function(u){this.getEdges();var h=this._edgeList.indexOf(u),x=h-1;return 0===h&&(x=this._edgeList.size()-1),this._edgeList.get(x)},_r.prototype.propagateSideLabels=function(u){for(var h=_e.NONE,x=this.iterator();x.hasNext();){var _=x.next().getLabel();_.isArea(u)&&_.getLocation(u,en.LEFT)!==_e.NONE&&(h=_.getLocation(u,en.LEFT))}if(h===_e.NONE)return null;for(var M=h,z=this.iterator();z.hasNext();){var q=z.next(),me=q.getLabel();if(me.getLocation(u,en.ON)===_e.NONE&&me.setLocation(u,en.ON,M),me.isArea(u)){var Ze=me.getLocation(u,en.LEFT),lt=me.getLocation(u,en.RIGHT);if(lt!==_e.NONE){if(lt!==M)throw new Qa("side location conflict",q.getCoordinate());Ze===_e.NONE&&De.shouldNeverReachHere("found single null side (at "+q.getCoordinate()+")"),M=Ze}else De.isTrue(me.getLocation(u,en.LEFT)===_e.NONE,"found single null side"),me.setLocation(u,en.RIGHT,M),me.setLocation(u,en.LEFT,M)}}},_r.prototype.getCoordinate=function(){var u=this.iterator();return u.hasNext()?u.next().getCoordinate():null},_r.prototype.print=function(u){qn.out.println("EdgeEndStar:   "+this.getCoordinate());for(var h=this.iterator();h.hasNext();)h.next().print(u)},_r.prototype.isAreaLabelsConsistent=function(u){return this.computeEdgeEndLabels(u.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)},_r.prototype.checkAreaLabelsConsistent=function(u){var h=this.getEdges();if(h.size()<=0)return!0;var x=h.size()-1,_=h.get(x).getLabel().getLocation(u,en.LEFT);De.isTrue(_!==_e.NONE,"Found unlabelled area edge");for(var M=_,z=this.iterator();z.hasNext();){var q=z.next().getLabel();De.isTrue(q.isArea(u),"Found non-area edge");var me=q.getLocation(u,en.LEFT),Ze=q.getLocation(u,en.RIGHT);if(me===Ze||Ze!==M)return!1;M=me}return!0},_r.prototype.findIndex=function(u){this.iterator();for(var h=0;h<this._edgeList.size();h++)if(this._edgeList.get(h)===u)return h;return-1},_r.prototype.iterator=function(){return this.getEdges().iterator()},_r.prototype.getEdges=function(){return null===this._edgeList&&(this._edgeList=new pn(this._edgeMap.values())),this._edgeList},_r.prototype.getLocation=function(u,h,x){return this._ptInAreaLocation[u]===_e.NONE&&(this._ptInAreaLocation[u]=os.locate(h,x[u].getGeometry())),this._ptInAreaLocation[u]},_r.prototype.toString=function(){var u=new et;u.append("EdgeEndStar:   "+this.getCoordinate()),u.append("\n");for(var h=this.iterator();h.hasNext();){var x=h.next();u.append(x),u.append("\n")}return u.toString()},_r.prototype.computeEdgeEndLabels=function(u){for(var h=this.iterator();h.hasNext();)h.next().computeLabel(u)},_r.prototype.computeLabelling=function(u){this.computeEdgeEndLabels(u[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);for(var h=[!1,!1],x=this.iterator();x.hasNext();)for(var _=x.next().getLabel(),M=0;M<2;M++)_.isLine(M)&&_.getLocation(M)===_e.BOUNDARY&&(h[M]=!0);for(var z=this.iterator();z.hasNext();)for(var q=z.next(),me=q.getLabel(),Ze=0;Ze<2;Ze++)if(me.isAnyNull(Ze)){var lt=_e.NONE;if(h[Ze])lt=_e.EXTERIOR;else{var Vt=q.getCoordinate();lt=this.getLocation(Ze,Vt,u)}me.setAllLocationsIfNull(Ze,lt)}},_r.prototype.getDegree=function(){return this._edgeMap.size()},_r.prototype.insertEdgeEnd=function(u,h){this._edgeMap.put(u,h),this._edgeList=null},_r.prototype.interfaces_=function(){return[]},_r.prototype.getClass=function(){return _r};var Cr=function(u){function h(){u.call(this),this._resultAreaEdgeList=null,this._label=null,this._SCANNING_FOR_INCOMING=1,this._LINKING_TO_OUTGOING=2}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.linkResultDirectedEdges=function(){this.getResultAreaEdges();for(var x=null,_=null,M=this._SCANNING_FOR_INCOMING,z=0;z<this._resultAreaEdgeList.size();z++){var q=this._resultAreaEdgeList.get(z),me=q.getSym();if(q.getLabel().isArea())switch(null===x&&q.isInResult()&&(x=q),M){case this._SCANNING_FOR_INCOMING:if(!me.isInResult())continue;_=me,M=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(!q.isInResult())continue;_.setNext(q),M=this._SCANNING_FOR_INCOMING}}if(M===this._LINKING_TO_OUTGOING){if(null===x)throw new Qa("no outgoing dirEdge found",this.getCoordinate());De.isTrue(x.isInResult(),"unable to link last incoming dirEdge"),_.setNext(x)}},h.prototype.insert=function(x){this.insertEdgeEnd(x,x)},h.prototype.getRightmostEdge=function(){var x=this.getEdges(),_=x.size();if(_<1)return null;var M=x.get(0);if(1===_)return M;var z=x.get(_-1),q=M.getQuadrant(),me=z.getQuadrant();return Jr.isNorthern(q)&&Jr.isNorthern(me)?M:Jr.isNorthern(q)||Jr.isNorthern(me)?0!==M.getDy()?M:0!==z.getDy()?z:(De.shouldNeverReachHere("found two horizontal edges incident on node"),null):z},h.prototype.print=function(x){qn.out.println("DirectedEdgeStar: "+this.getCoordinate());for(var _=this.iterator();_.hasNext();){var M=_.next();x.print("out "),M.print(x),x.println(),x.print("in "),M.getSym().print(x),x.println()}},h.prototype.getResultAreaEdges=function(){if(null!==this._resultAreaEdgeList)return this._resultAreaEdgeList;this._resultAreaEdgeList=new pn;for(var x=this.iterator();x.hasNext();){var _=x.next();(_.isInResult()||_.getSym().isInResult())&&this._resultAreaEdgeList.add(_)}return this._resultAreaEdgeList},h.prototype.updateLabelling=function(x){for(var _=this.iterator();_.hasNext();){var M=_.next().getLabel();M.setAllLocationsIfNull(0,x.getLocation(0)),M.setAllLocationsIfNull(1,x.getLocation(1))}},h.prototype.linkAllDirectedEdges=function(){this.getEdges();for(var x=null,_=null,M=this._edgeList.size()-1;M>=0;M--){var z=this._edgeList.get(M),q=z.getSym();null===_&&(_=q),null!==x&&q.setNext(x),x=z}_.setNext(x)},h.prototype.computeDepths=function(){if(1===arguments.length){var x=arguments[0],_=this.findIndex(x),M=x.getDepth(en.LEFT),z=x.getDepth(en.RIGHT),q=this.computeDepths(_+1,this._edgeList.size(),M);if(this.computeDepths(0,_,q)!==z)throw new Qa("depth mismatch at "+x.getCoordinate())}else if(3===arguments.length){for(var Ze=arguments[1],lt=arguments[2],Vt=arguments[0];Vt<Ze;Vt++){var Yt=this._edgeList.get(Vt);Yt.setEdgeDepths(en.RIGHT,lt),lt=Yt.getDepth(en.LEFT)}return lt}},h.prototype.mergeSymLabels=function(){for(var x=this.iterator();x.hasNext();){var _=x.next();_.getLabel().merge(_.getSym().getLabel())}},h.prototype.linkMinimalDirectedEdges=function(x){for(var _=null,M=null,z=this._SCANNING_FOR_INCOMING,q=this._resultAreaEdgeList.size()-1;q>=0;q--){var me=this._resultAreaEdgeList.get(q),Ze=me.getSym();switch(null===_&&me.getEdgeRing()===x&&(_=me),z){case this._SCANNING_FOR_INCOMING:if(Ze.getEdgeRing()!==x)continue;M=Ze,z=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(me.getEdgeRing()!==x)continue;M.setNextMin(me),z=this._SCANNING_FOR_INCOMING}}z===this._LINKING_TO_OUTGOING&&(De.isTrue(null!==_,"found null for first outgoing dirEdge"),De.isTrue(_.getEdgeRing()===x,"unable to link last incoming dirEdge"),M.setNextMin(_))},h.prototype.getOutgoingDegree=function(){if(0===arguments.length){for(var x=0,_=this.iterator();_.hasNext();)_.next().isInResult()&&x++;return x}if(1===arguments.length){for(var M=arguments[0],z=0,q=this.iterator();q.hasNext();)q.next().getEdgeRing()===M&&z++;return z}},h.prototype.getLabel=function(){return this._label},h.prototype.findCoveredLineEdges=function(){for(var x=_e.NONE,_=this.iterator();_.hasNext();){var M=_.next(),z=M.getSym();if(!M.isLineEdge()){if(M.isInResult()){x=_e.INTERIOR;break}if(z.isInResult()){x=_e.EXTERIOR;break}}}if(x===_e.NONE)return null;for(var q=x,me=this.iterator();me.hasNext();){var Ze=me.next(),lt=Ze.getSym();Ze.isLineEdge()?Ze.getEdge().setCovered(q===_e.INTERIOR):(Ze.isInResult()&&(q=_e.EXTERIOR),lt.isInResult()&&(q=_e.INTERIOR))}},h.prototype.computeLabelling=function(x){u.prototype.computeLabelling.call(this,x),this._label=new kr(_e.NONE);for(var _=this.iterator();_.hasNext();)for(var M=_.next().getEdge().getLabel(),z=0;z<2;z++){var q=M.getLocation(z);q!==_e.INTERIOR&&q!==_e.BOUNDARY||this._label.setLocation(z,_e.INTERIOR)}},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(_r),Qc=function(u){function h(){u.apply(this,arguments)}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.createNode=function(x){return new hu(x,new Cr)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(Qu),Oo=function u(){this._pts=null,this._orientation=null;var h=arguments[0];this._pts=h,this._orientation=u.orientation(h)};Oo.prototype.compareTo=function(u){return Oo.compareOriented(this._pts,this._orientation,u._pts,u._orientation)},Oo.prototype.interfaces_=function(){return[Ne]},Oo.prototype.getClass=function(){return Oo},Oo.orientation=function(u){return 1===Zn.increasingDirection(u)},Oo.compareOriented=function(u,h,x,_){for(var M=h?1:-1,z=_?1:-1,q=h?u.length:-1,me=_?x.length:-1,Ze=h?0:u.length-1,lt=_?0:x.length-1;;){var Vt=u[Ze].compareTo(x[lt]);if(0!==Vt)return Vt;var Yt=(Ze+=M)===q,wn=(lt+=z)===me;if(Yt&&!wn)return-1;if(!Yt&&wn)return 1;if(Yt&&wn)return 0}};var js=function(){this._edges=new pn,this._ocaMap=new re};js.prototype.print=function(u){u.print("MULTILINESTRING ( ");for(var h=0;h<this._edges.size();h++){var x=this._edges.get(h);h>0&&u.print(","),u.print("(");for(var _=x.getCoordinates(),M=0;M<_.length;M++)M>0&&u.print(","),u.print(_[M].x+" "+_[M].y);u.println(")")}u.print(")  ")},js.prototype.addAll=function(u){for(var h=u.iterator();h.hasNext();)this.add(h.next())},js.prototype.findEdgeIndex=function(u){for(var h=0;h<this._edges.size();h++)if(this._edges.get(h).equals(u))return h;return-1},js.prototype.iterator=function(){return this._edges.iterator()},js.prototype.getEdges=function(){return this._edges},js.prototype.get=function(u){return this._edges.get(u)},js.prototype.findEqualEdge=function(u){var h=new Oo(u.getCoordinates());return this._ocaMap.get(h)},js.prototype.add=function(u){this._edges.add(u);var h=new Oo(u.getCoordinates());this._ocaMap.put(h,u)},js.prototype.interfaces_=function(){return[]},js.prototype.getClass=function(){return js};var Yo=function(){};Yo.prototype.processIntersections=function(u,h,x,_){},Yo.prototype.isDone=function(){},Yo.prototype.interfaces_=function(){return[]},Yo.prototype.getClass=function(){return Yo};var Js=function(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._hasInterior=!1,this._properIntersectionPoint=null,this._li=null,this._isSelfIntersection=null,this.numIntersections=0,this.numInteriorIntersections=0,this.numProperIntersections=0,this.numTests=0,this._li=arguments[0]};Js.prototype.isTrivialIntersection=function(u,h,x,_){if(u===x&&1===this._li.getIntersectionNum()){if(Js.isAdjacentSegments(h,_))return!0;if(u.isClosed()){var M=u.size()-1;if(0===h&&_===M||0===_&&h===M)return!0}}return!1},Js.prototype.getProperIntersectionPoint=function(){return this._properIntersectionPoint},Js.prototype.hasProperInteriorIntersection=function(){return this._hasProperInterior},Js.prototype.getLineIntersector=function(){return this._li},Js.prototype.hasProperIntersection=function(){return this._hasProper},Js.prototype.processIntersections=function(u,h,x,_){if(u===x&&h===_)return null;this.numTests++;var M=u.getCoordinates()[h],z=u.getCoordinates()[h+1],q=x.getCoordinates()[_],me=x.getCoordinates()[_+1];this._li.computeIntersection(M,z,q,me),this._li.hasIntersection()&&(this.numIntersections++,this._li.isInteriorIntersection()&&(this.numInteriorIntersections++,this._hasInterior=!0),this.isTrivialIntersection(u,h,x,_)||(this._hasIntersection=!0,u.addIntersections(this._li,h,0),x.addIntersections(this._li,_,1),this._li.isProper()&&(this.numProperIntersections++,this._hasProper=!0,this._hasProperInterior=!0)))},Js.prototype.hasIntersection=function(){return this._hasIntersection},Js.prototype.isDone=function(){return!1},Js.prototype.hasInteriorIntersection=function(){return this._hasInterior},Js.prototype.interfaces_=function(){return[Yo]},Js.prototype.getClass=function(){return Js},Js.isAdjacentSegments=function(u,h){return 1===Math.abs(u-h)};var fo=function(){this.coord=null,this.segmentIndex=null,this.dist=null;var h=arguments[1],x=arguments[2];this.coord=new Z(arguments[0]),this.segmentIndex=h,this.dist=x};fo.prototype.getSegmentIndex=function(){return this.segmentIndex},fo.prototype.getCoordinate=function(){return this.coord},fo.prototype.print=function(u){u.print(this.coord),u.print(" seg # = "+this.segmentIndex),u.println(" dist = "+this.dist)},fo.prototype.compareTo=function(u){return this.compare(u.segmentIndex,u.dist)},fo.prototype.isEndPoint=function(u){return 0===this.segmentIndex&&0===this.dist||this.segmentIndex===u},fo.prototype.toString=function(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist},fo.prototype.getDistance=function(){return this.dist},fo.prototype.compare=function(u,h){return this.segmentIndex<u?-1:this.segmentIndex>u?1:this.dist<h?-1:this.dist>h?1:0},fo.prototype.interfaces_=function(){return[Ne]},fo.prototype.getClass=function(){return fo};var Zo=function(){this._nodeMap=new re,this.edge=null,this.edge=arguments[0]};Zo.prototype.print=function(u){u.println("Intersections:");for(var h=this.iterator();h.hasNext();)h.next().print(u)},Zo.prototype.iterator=function(){return this._nodeMap.values().iterator()},Zo.prototype.addSplitEdges=function(u){this.addEndpoints();for(var h=this.iterator(),x=h.next();h.hasNext();){var _=h.next(),M=this.createSplitEdge(x,_);u.add(M),x=_}},Zo.prototype.addEndpoints=function(){var u=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[u],u,0)},Zo.prototype.createSplitEdge=function(u,h){var x=h.segmentIndex-u.segmentIndex+2,M=h.dist>0||!h.coord.equals2D(this.edge.pts[h.segmentIndex]);M||x--;var z=new Array(x).fill(null),q=0;z[q++]=new Z(u.coord);for(var me=u.segmentIndex+1;me<=h.segmentIndex;me++)z[q++]=this.edge.pts[me];return M&&(z[q]=h.coord),new Pf(z,new kr(this.edge._label))},Zo.prototype.add=function(u,h,x){var _=new fo(u,h,x),M=this._nodeMap.get(_);return null!==M?M:(this._nodeMap.put(_,_),_)},Zo.prototype.isIntersection=function(u){for(var h=this.iterator();h.hasNext();)if(h.next().coord.equals(u))return!0;return!1},Zo.prototype.interfaces_=function(){return[]},Zo.prototype.getClass=function(){return Zo};var du=function(){};du.prototype.getChainStartIndices=function(u){var h=0,x=new pn;x.add(new pt(h));do{var _=this.findChainEnd(u,h);x.add(new pt(_)),h=_}while(h<u.length-1);return du.toIntArray(x)},du.prototype.findChainEnd=function(u,h){for(var x=Jr.quadrant(u[h],u[h+1]),_=h+1;_<u.length&&Jr.quadrant(u[_-1],u[_])===x;)_++;return _-1},du.prototype.interfaces_=function(){return[]},du.prototype.getClass=function(){return du},du.toIntArray=function(u){for(var h=new Array(u.size()).fill(null),x=0;x<h.length;x++)h[x]=u.get(x).intValue();return h};var mu=function(){this.e=null,this.pts=null,this.startIndex=null,this.env1=new Qe,this.env2=new Qe;var u=arguments[0];this.e=u,this.pts=u.getCoordinates();var h=new du;this.startIndex=h.getChainStartIndices(this.pts)};mu.prototype.getCoordinates=function(){return this.pts},mu.prototype.getMaxX=function(u){var h=this.pts[this.startIndex[u]].x,x=this.pts[this.startIndex[u+1]].x;return h>x?h:x},mu.prototype.getMinX=function(u){var h=this.pts[this.startIndex[u]].x,x=this.pts[this.startIndex[u+1]].x;return h<x?h:x},mu.prototype.computeIntersectsForChain=function(){if(4===arguments.length){var u=arguments[0],h=arguments[1],x=arguments[2];this.computeIntersectsForChain(this.startIndex[u],this.startIndex[u+1],h,h.startIndex[x],h.startIndex[x+1],arguments[3])}else if(6===arguments.length){var M=arguments[0],z=arguments[1],q=arguments[2],me=arguments[3],Ze=arguments[4],lt=arguments[5],Vt=this.pts[M],Yt=this.pts[z],wn=q.pts[me],En=q.pts[Ze];if(z-M==1&&Ze-me==1)return lt.addIntersections(this.e,M,q.e,me),null;if(this.env1.init(Vt,Yt),this.env2.init(wn,En),!this.env1.intersects(this.env2))return null;var Fn=Math.trunc((M+z)/2),or=Math.trunc((me+Ze)/2);M<Fn&&(me<or&&this.computeIntersectsForChain(M,Fn,q,me,or,lt),or<Ze&&this.computeIntersectsForChain(M,Fn,q,or,Ze,lt)),Fn<z&&(me<or&&this.computeIntersectsForChain(Fn,z,q,me,or,lt),or<Ze&&this.computeIntersectsForChain(Fn,z,q,or,Ze,lt))}},mu.prototype.getStartIndexes=function(){return this.startIndex},mu.prototype.computeIntersects=function(u,h){for(var x=0;x<this.startIndex.length-1;x++)for(var _=0;_<u.startIndex.length-1;_++)this.computeIntersectsForChain(x,u,_,h)},mu.prototype.interfaces_=function(){return[]},mu.prototype.getClass=function(){return mu};var qs=function u(){this._depth=Array(2).fill().map(function(){return Array(3)});for(var h=0;h<2;h++)for(var x=0;x<3;x++)this._depth[h][x]=u.NULL_VALUE},Kh={NULL_VALUE:{configurable:!0}};qs.prototype.getDepth=function(u,h){return this._depth[u][h]},qs.prototype.setDepth=function(u,h,x){this._depth[u][h]=x},qs.prototype.isNull=function(){if(0===arguments.length){for(var u=0;u<2;u++)for(var h=0;h<3;h++)if(this._depth[u][h]!==qs.NULL_VALUE)return!1;return!0}return 1===arguments.length?this._depth[arguments[0]][1]===qs.NULL_VALUE:2===arguments.length?this._depth[arguments[0]][arguments[1]]===qs.NULL_VALUE:void 0},qs.prototype.normalize=function(){for(var u=0;u<2;u++)if(!this.isNull(u)){var h=this._depth[u][1];this._depth[u][2]<h&&(h=this._depth[u][2]),h<0&&(h=0);for(var x=1;x<3;x++){var _=0;this._depth[u][x]>h&&(_=1),this._depth[u][x]=_}}},qs.prototype.getDelta=function(u){return this._depth[u][en.RIGHT]-this._depth[u][en.LEFT]},qs.prototype.getLocation=function(u,h){return this._depth[u][h]<=0?_e.EXTERIOR:_e.INTERIOR},qs.prototype.toString=function(){return"A: "+this._depth[0][1]+","+this._depth[0][2]+" B: "+this._depth[1][1]+","+this._depth[1][2]},qs.prototype.add=function(){if(1===arguments.length)for(var u=arguments[0],h=0;h<2;h++)for(var x=1;x<3;x++){var _=u.getLocation(h,x);_!==_e.EXTERIOR&&_!==_e.INTERIOR||(this.isNull(h,x)?this._depth[h][x]=qs.depthAtLocation(_):this._depth[h][x]+=qs.depthAtLocation(_))}else 3===arguments.length&&arguments[2]===_e.INTERIOR&&this._depth[arguments[0]][arguments[1]]++},qs.prototype.interfaces_=function(){return[]},qs.prototype.getClass=function(){return qs},qs.depthAtLocation=function(u){return u===_e.EXTERIOR?0:u===_e.INTERIOR?1:qs.NULL_VALUE},Kh.NULL_VALUE.get=function(){return-1},Object.defineProperties(qs,Kh);var Pf=function(u){function h(){if(u.call(this),this.pts=null,this._env=null,this.eiList=new Zo(this),this._name=null,this._mce=null,this._isIsolated=!0,this._depth=new qs,this._depthDelta=0,1===arguments.length)h.call(this,arguments[0],null);else if(2===arguments.length){var M=arguments[1];this.pts=arguments[0],this._label=M}}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.getDepth=function(){return this._depth},h.prototype.getCollapsedEdge=function(){var x=new Array(2).fill(null);return x[0]=this.pts[0],x[1]=this.pts[1],new h(x,kr.toLineLabel(this._label))},h.prototype.isIsolated=function(){return this._isIsolated},h.prototype.getCoordinates=function(){return this.pts},h.prototype.setIsolated=function(x){this._isIsolated=x},h.prototype.setName=function(x){this._name=x},h.prototype.equals=function(x){if(!(x instanceof h))return!1;var _=x;if(this.pts.length!==_.pts.length)return!1;for(var M=!0,z=!0,q=this.pts.length,me=0;me<this.pts.length;me++)if(this.pts[me].equals2D(_.pts[me])||(M=!1),this.pts[me].equals2D(_.pts[--q])||(z=!1),!M&&!z)return!1;return!0},h.prototype.getCoordinate=function(){return 0===arguments.length?this.pts.length>0?this.pts[0]:null:1===arguments.length?this.pts[arguments[0]]:void 0},h.prototype.print=function(x){x.print("edge "+this._name+": "),x.print("LINESTRING (");for(var _=0;_<this.pts.length;_++)_>0&&x.print(","),x.print(this.pts[_].x+" "+this.pts[_].y);x.print(")  "+this._label+" "+this._depthDelta)},h.prototype.computeIM=function(x){h.updateIM(this._label,x)},h.prototype.isCollapsed=function(){return!!this._label.isArea()&&3===this.pts.length&&!!this.pts[0].equals(this.pts[2])},h.prototype.isClosed=function(){return this.pts[0].equals(this.pts[this.pts.length-1])},h.prototype.getMaximumSegmentIndex=function(){return this.pts.length-1},h.prototype.getDepthDelta=function(){return this._depthDelta},h.prototype.getNumPoints=function(){return this.pts.length},h.prototype.printReverse=function(x){x.print("edge "+this._name+": ");for(var _=this.pts.length-1;_>=0;_--)x.print(this.pts[_]+" ");x.println("")},h.prototype.getMonotoneChainEdge=function(){return null===this._mce&&(this._mce=new mu(this)),this._mce},h.prototype.getEnvelope=function(){if(null===this._env){this._env=new Qe;for(var x=0;x<this.pts.length;x++)this._env.expandToInclude(this.pts[x])}return this._env},h.prototype.addIntersection=function(x,_,M,z){var q=new Z(x.getIntersection(z)),me=_,Ze=x.getEdgeDistance(M,z),lt=me+1;lt<this.pts.length&&q.equals2D(this.pts[lt])&&(me=lt,Ze=0),this.eiList.add(q,me,Ze)},h.prototype.toString=function(){var x=new et;x.append("edge "+this._name+": "),x.append("LINESTRING (");for(var _=0;_<this.pts.length;_++)_>0&&x.append(","),x.append(this.pts[_].x+" "+this.pts[_].y);return x.append(")  "+this._label+" "+this._depthDelta),x.toString()},h.prototype.isPointwiseEqual=function(x){if(this.pts.length!==x.pts.length)return!1;for(var _=0;_<this.pts.length;_++)if(!this.pts[_].equals2D(x.pts[_]))return!1;return!0},h.prototype.setDepthDelta=function(x){this._depthDelta=x},h.prototype.getEdgeIntersectionList=function(){return this.eiList},h.prototype.addIntersections=function(x,_,M){for(var z=0;z<x.getIntersectionNum();z++)this.addIntersection(x,_,M,z)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h.updateIM=function(){if(2!==arguments.length)return u.prototype.updateIM.apply(this,arguments);var x=arguments[0],_=arguments[1];_.setAtLeastIfValid(x.getLocation(0,en.ON),x.getLocation(1,en.ON),1),x.isArea()&&(_.setAtLeastIfValid(x.getLocation(0,en.LEFT),x.getLocation(1,en.LEFT),2),_.setAtLeastIfValid(x.getLocation(0,en.RIGHT),x.getLocation(1,en.RIGHT),2))},h}(Ca),xa=function(u){this._workingPrecisionModel=null,this._workingNoder=null,this._geomFact=null,this._graph=null,this._edgeList=new js,this._bufParams=u||null};xa.prototype.setWorkingPrecisionModel=function(u){this._workingPrecisionModel=u},xa.prototype.insertUniqueEdge=function(u){var h=this._edgeList.findEqualEdge(u);if(null!==h){var x=h.getLabel(),_=u.getLabel();h.isPointwiseEqual(u)||(_=new kr(u.getLabel())).flip(),x.merge(_);var M=xa.depthDelta(_),z=h.getDepthDelta()+M;h.setDepthDelta(z)}else this._edgeList.add(u),u.setDepthDelta(xa.depthDelta(u.getLabel()))},xa.prototype.buildSubgraphs=function(u,h){for(var x=new pn,_=u.iterator();_.hasNext();){var M=_.next(),z=M.getRightmostCoordinate(),q=new bl(x).getDepth(z);M.computeDepth(q),M.findResultEdges(),x.add(M),h.add(M.getDirectedEdges(),M.getNodes())}},xa.prototype.createSubgraphs=function(u){for(var h=new pn,x=u.getNodes().iterator();x.hasNext();){var _=x.next();if(!_.isVisited()){var M=new Zi;M.create(_),h.add(M)}}return Ro.sort(h,Ro.reverseOrder()),h},xa.prototype.createEmptyResultGeometry=function(){return this._geomFact.createPolygon()},xa.prototype.getNoder=function(u){if(null!==this._workingNoder)return this._workingNoder;var h=new jc,x=new tt;return x.setPrecisionModel(u),h.setSegmentIntersector(new Js(x)),h},xa.prototype.buffer=function(u,h){var x=this._workingPrecisionModel;null===x&&(x=u.getPrecisionModel()),this._geomFact=u.getFactory();var _=new to(x,this._bufParams),M=new Ps(u,h,_).getCurves();if(M.size()<=0)return this.createEmptyResultGeometry();this.computeNodedEdges(M,x),this._graph=new Qi(new Qc),this._graph.addEdges(this._edgeList.getEdges());var z=this.createSubgraphs(this._graph),q=new la(this._geomFact);this.buildSubgraphs(z,q);var me=q.getPolygons();return me.size()<=0?this.createEmptyResultGeometry():this._geomFact.buildGeometry(me)},xa.prototype.computeNodedEdges=function(u,h){var x=this.getNoder(h);x.computeNodes(u);for(var _=x.getNodedSubstrings().iterator();_.hasNext();){var M=_.next(),z=M.getCoordinates();if(2!==z.length||!z[0].equals2D(z[1])){var q=M.getData(),me=new Pf(M.getCoordinates(),new kr(q));this.insertUniqueEdge(me)}}},xa.prototype.setNoder=function(u){this._workingNoder=u},xa.prototype.interfaces_=function(){return[]},xa.prototype.getClass=function(){return xa},xa.depthDelta=function(u){var h=u.getLocation(0,en.LEFT),x=u.getLocation(0,en.RIGHT);return h===_e.INTERIOR&&x===_e.EXTERIOR?1:h===_e.EXTERIOR&&x===_e.INTERIOR?-1:0},xa.convertSegStrings=function(u){for(var h=new Mr,x=new pn;u.hasNext();){var _=u.next(),M=h.createLineString(_.getCoordinates());x.add(M)}return h.buildGeometry(x)};var Du=function(){if(this._noder=null,this._scaleFactor=null,this._offsetX=null,this._offsetY=null,this._isScaled=!1,2===arguments.length){var h=arguments[1];this._noder=arguments[0],this._scaleFactor=h,this._offsetX=0,this._offsetY=0,this._isScaled=!this.isIntegerPrecision()}else if(4===arguments.length){var _=arguments[1],M=arguments[2],z=arguments[3];this._noder=arguments[0],this._scaleFactor=_,this._offsetX=M,this._offsetY=z,this._isScaled=!this.isIntegerPrecision()}};Du.prototype.rescale=function(){if(Ct(arguments[0],Kr))for(var u=arguments[0].iterator();u.hasNext();){var h=u.next();this.rescale(h.getCoordinates())}else if(arguments[0]instanceof Array){for(var x=arguments[0],_=0;_<x.length;_++)x[_].x=x[_].x/this._scaleFactor+this._offsetX,x[_].y=x[_].y/this._scaleFactor+this._offsetY;2===x.length&&x[0].equals2D(x[1])&&qn.out.println(x)}},Du.prototype.scale=function(){if(Ct(arguments[0],Kr)){for(var u=arguments[0],h=new pn,x=u.iterator();x.hasNext();){var _=x.next();h.add(new ss(this.scale(_.getCoordinates()),_.getData()))}return h}if(arguments[0]instanceof Array){for(var M=arguments[0],z=new Array(M.length).fill(null),q=0;q<M.length;q++)z[q]=new Z(Math.round((M[q].x-this._offsetX)*this._scaleFactor),Math.round((M[q].y-this._offsetY)*this._scaleFactor),M[q].z);return Zn.removeRepeatedPoints(z)}},Du.prototype.isIntegerPrecision=function(){return 1===this._scaleFactor},Du.prototype.getNodedSubstrings=function(){var u=this._noder.getNodedSubstrings();return this._isScaled&&this.rescale(u),u},Du.prototype.computeNodes=function(u){var h=u;this._isScaled&&(h=this.scale(u)),this._noder.computeNodes(h)},Du.prototype.interfaces_=function(){return[vl]},Du.prototype.getClass=function(){return Du};var ko=function(){this._li=new tt,this._segStrings=null,this._segStrings=arguments[0]},hh={fact:{configurable:!0}};ko.prototype.checkEndPtVertexIntersections=function(){if(0===arguments.length)for(var u=this._segStrings.iterator();u.hasNext();){var h=u.next().getCoordinates();this.checkEndPtVertexIntersections(h[0],this._segStrings),this.checkEndPtVertexIntersections(h[h.length-1],this._segStrings)}else if(2===arguments.length)for(var x=arguments[0],_=arguments[1].iterator();_.hasNext();)for(var M=_.next().getCoordinates(),z=1;z<M.length-1;z++)if(M[z].equals(x))throw new We("found endpt/interior pt intersection at index "+z+" :pt "+x)},ko.prototype.checkInteriorIntersections=function(){if(0===arguments.length)for(var u=this._segStrings.iterator();u.hasNext();)for(var h=u.next(),x=this._segStrings.iterator();x.hasNext();){var _=x.next();this.checkInteriorIntersections(h,_)}else if(2===arguments.length)for(var M=arguments[0],z=arguments[1],q=M.getCoordinates(),me=z.getCoordinates(),Ze=0;Ze<q.length-1;Ze++)for(var lt=0;lt<me.length-1;lt++)this.checkInteriorIntersections(M,Ze,z,lt);else if(4===arguments.length){var Vt=arguments[0],Yt=arguments[1],wn=arguments[2],En=arguments[3];if(Vt===wn&&Yt===En)return null;var Fn=Vt.getCoordinates()[Yt],or=Vt.getCoordinates()[Yt+1],fi=wn.getCoordinates()[En],ji=wn.getCoordinates()[En+1];if(this._li.computeIntersection(Fn,or,fi,ji),this._li.hasIntersection()&&(this._li.isProper()||this.hasInteriorIntersection(this._li,Fn,or)||this.hasInteriorIntersection(this._li,fi,ji)))throw new We("found non-noded intersection at "+Fn+"-"+or+" and "+fi+"-"+ji)}},ko.prototype.checkValid=function(){this.checkEndPtVertexIntersections(),this.checkInteriorIntersections(),this.checkCollapses()},ko.prototype.checkCollapses=function(){if(0===arguments.length)for(var u=this._segStrings.iterator();u.hasNext();){var h=u.next();this.checkCollapses(h)}else if(1===arguments.length)for(var x=arguments[0].getCoordinates(),_=0;_<x.length-2;_++)this.checkCollapse(x[_],x[_+1],x[_+2])},ko.prototype.hasInteriorIntersection=function(u,h,x){for(var _=0;_<u.getIntersectionNum();_++){var M=u.getIntersection(_);if(!M.equals(h)&&!M.equals(x))return!0}return!1},ko.prototype.checkCollapse=function(u,h,x){if(u.equals(x))throw new We("found non-noded collapse at "+ko.fact.createLineString([u,h,x]))},ko.prototype.interfaces_=function(){return[]},ko.prototype.getClass=function(){return ko},hh.fact.get=function(){return new Mr},Object.defineProperties(ko,hh);var ba=function(){this._li=null,this._pt=null,this._originalPt=null,this._ptScaled=null,this._p0Scaled=null,this._p1Scaled=null,this._scaleFactor=null,this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,this._corner=new Array(4).fill(null),this._safeEnv=null;var u=arguments[0],h=arguments[1],x=arguments[2];if(this._originalPt=u,this._pt=u,this._scaleFactor=h,this._li=x,h<=0)throw new xe("Scale factor must be non-zero");1!==h&&(this._pt=new Z(this.scale(u.x),this.scale(u.y)),this._p0Scaled=new Z,this._p1Scaled=new Z),this.initCorners(this._pt)},fg={SAFE_ENV_EXPANSION_FACTOR:{configurable:!0}};ba.prototype.intersectsScaled=function(u,h){var x=Math.min(u.x,h.x),_=Math.max(u.x,h.x),M=Math.min(u.y,h.y),z=Math.max(u.y,h.y),q=this._maxx<x||this._minx>_||this._maxy<M||this._miny>z;if(q)return!1;var me=this.intersectsToleranceSquare(u,h);return De.isTrue(!(q&&me),"Found bad envelope test"),me},ba.prototype.initCorners=function(u){this._minx=u.x-.5,this._maxx=u.x+.5,this._miny=u.y-.5,this._maxy=u.y+.5,this._corner[0]=new Z(this._maxx,this._maxy),this._corner[1]=new Z(this._minx,this._maxy),this._corner[2]=new Z(this._minx,this._miny),this._corner[3]=new Z(this._maxx,this._miny)},ba.prototype.intersects=function(u,h){return 1===this._scaleFactor?this.intersectsScaled(u,h):(this.copyScaled(u,this._p0Scaled),this.copyScaled(h,this._p1Scaled),this.intersectsScaled(this._p0Scaled,this._p1Scaled))},ba.prototype.scale=function(u){return Math.round(u*this._scaleFactor)},ba.prototype.getCoordinate=function(){return this._originalPt},ba.prototype.copyScaled=function(u,h){h.x=this.scale(u.x),h.y=this.scale(u.y)},ba.prototype.getSafeEnvelope=function(){if(null===this._safeEnv){var u=ba.SAFE_ENV_EXPANSION_FACTOR/this._scaleFactor;this._safeEnv=new Qe(this._originalPt.x-u,this._originalPt.x+u,this._originalPt.y-u,this._originalPt.y+u)}return this._safeEnv},ba.prototype.intersectsPixelClosure=function(u,h){return this._li.computeIntersection(u,h,this._corner[0],this._corner[1]),!!(this._li.hasIntersection()||(this._li.computeIntersection(u,h,this._corner[1],this._corner[2]),this._li.hasIntersection()||(this._li.computeIntersection(u,h,this._corner[2],this._corner[3]),this._li.hasIntersection()||(this._li.computeIntersection(u,h,this._corner[3],this._corner[0]),this._li.hasIntersection()))))},ba.prototype.intersectsToleranceSquare=function(u,h){var x=!1,_=!1;return this._li.computeIntersection(u,h,this._corner[0],this._corner[1]),!!(this._li.isProper()||(this._li.computeIntersection(u,h,this._corner[1],this._corner[2]),this._li.isProper()||(this._li.hasIntersection()&&(x=!0),this._li.computeIntersection(u,h,this._corner[2],this._corner[3]),this._li.isProper()||(this._li.hasIntersection()&&(_=!0),this._li.computeIntersection(u,h,this._corner[3],this._corner[0]),this._li.isProper()||x&&_||u.equals(this._pt)||h.equals(this._pt)))))},ba.prototype.addSnappedNode=function(u,h){var x=u.getCoordinate(h),_=u.getCoordinate(h+1);return!!this.intersects(x,_)&&(u.addIntersection(this.getCoordinate(),h),!0)},ba.prototype.interfaces_=function(){return[]},ba.prototype.getClass=function(){return ba},fg.SAFE_ENV_EXPANSION_FACTOR.get=function(){return.75},Object.defineProperties(ba,fg);var zl=function(){this.tempEnv1=new Qe,this.selectedSegment=new Wn};zl.prototype.select=function(){1!==arguments.length&&2===arguments.length&&(arguments[0].getLineSegment(arguments[1],this.selectedSegment),this.select(this.selectedSegment))},zl.prototype.interfaces_=function(){return[]},zl.prototype.getClass=function(){return zl};var Ul=function(){this._index=null,this._index=arguments[0]},ph={HotPixelSnapAction:{configurable:!0}};Ul.prototype.snap=function(){if(1===arguments.length)return this.snap(arguments[0],null,-1);if(3===arguments.length){var h=arguments[0],x=arguments[1],_=arguments[2],M=h.getSafeEnvelope(),z=new Yh(h,x,_);return this._index.query(M,{interfaces_:function(){return[Mu]},visitItem:function(q){q.select(M,z)}}),z.isNodeAdded()}},Ul.prototype.interfaces_=function(){return[]},Ul.prototype.getClass=function(){return Ul},ph.HotPixelSnapAction.get=function(){return Yh},Object.defineProperties(Ul,ph);var Yh=function(u){function h(){u.call(this),this._hotPixel=null,this._parentEdge=null,this._hotPixelVertexIndex=null,this._isNodeAdded=!1;var _=arguments[1],M=arguments[2];this._hotPixel=arguments[0],this._parentEdge=_,this._hotPixelVertexIndex=M}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.isNodeAdded=function(){return this._isNodeAdded},h.prototype.select=function(){if(2!==arguments.length)return u.prototype.select.apply(this,arguments);var _=arguments[1],M=arguments[0].getContext();if(null!==this._parentEdge&&M===this._parentEdge&&_===this._hotPixelVertexIndex)return null;this._isNodeAdded=this._hotPixel.addSnappedNode(M,_)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(zl),Vl=function(){this._li=null,this._interiorIntersections=null,this._li=arguments[0],this._interiorIntersections=new pn};Vl.prototype.processIntersections=function(u,h,x,_){if(u===x&&h===_)return null;var M=u.getCoordinates()[h],z=u.getCoordinates()[h+1],q=x.getCoordinates()[_],me=x.getCoordinates()[_+1];if(this._li.computeIntersection(M,z,q,me),this._li.hasIntersection()&&this._li.isInteriorIntersection()){for(var Ze=0;Ze<this._li.getIntersectionNum();Ze++)this._interiorIntersections.add(this._li.getIntersection(Ze));u.addIntersections(this._li,h,0),x.addIntersections(this._li,_,1)}},Vl.prototype.isDone=function(){return!1},Vl.prototype.getInteriorIntersections=function(){return this._interiorIntersections},Vl.prototype.interfaces_=function(){return[Yo]},Vl.prototype.getClass=function(){return Vl};var jo=function(){this._pm=null,this._li=null,this._scaleFactor=null,this._noder=null,this._pointSnapper=null,this._nodedSegStrings=null;var u=arguments[0];this._pm=u,this._li=new tt,this._li.setPrecisionModel(u),this._scaleFactor=u.getScale()};jo.prototype.checkCorrectness=function(u){var h=ss.getNodedSubstrings(u),x=new ko(h);try{x.checkValid()}catch(_){if(!(_ instanceof Bn))throw _;_.printStackTrace()}},jo.prototype.getNodedSubstrings=function(){return ss.getNodedSubstrings(this._nodedSegStrings)},jo.prototype.snapRound=function(u,h){var x=this.findInteriorIntersections(u,h);this.computeIntersectionSnaps(x),this.computeVertexSnaps(u)},jo.prototype.findInteriorIntersections=function(u,h){var x=new Vl(h);return this._noder.setSegmentIntersector(x),this._noder.computeNodes(u),x.getInteriorIntersections()},jo.prototype.computeVertexSnaps=function(){if(Ct(arguments[0],Kr))for(var u=arguments[0].iterator();u.hasNext();){var h=u.next();this.computeVertexSnaps(h)}else if(arguments[0]instanceof ss)for(var x=arguments[0],_=x.getCoordinates(),M=0;M<_.length;M++){var z=new ba(_[M],this._scaleFactor,this._li);this._pointSnapper.snap(z,x,M)&&x.addIntersection(_[M],M)}},jo.prototype.computeNodes=function(u){this._nodedSegStrings=u,this._noder=new jc,this._pointSnapper=new Ul(this._noder.getIndex()),this.snapRound(u,this._li)},jo.prototype.computeIntersectionSnaps=function(u){for(var h=u.iterator();h.hasNext();){var x=h.next(),_=new ba(x,this._scaleFactor,this._li);this._pointSnapper.snap(_)}},jo.prototype.interfaces_=function(){return[vl]},jo.prototype.getClass=function(){return jo};var Qs=function(){if(this._argGeom=null,this._distance=null,this._bufParams=new Yr,this._resultGeometry=null,this._saveException=null,1===arguments.length)this._argGeom=arguments[0];else if(2===arguments.length){var x=arguments[1];this._argGeom=arguments[0],this._bufParams=x}},xc={CAP_ROUND:{configurable:!0},CAP_BUTT:{configurable:!0},CAP_FLAT:{configurable:!0},CAP_SQUARE:{configurable:!0},MAX_PRECISION_DIGITS:{configurable:!0}};Qs.prototype.bufferFixedPrecision=function(u){var h=new Du(new jo(new Gr(1)),u.getScale()),x=new xa(this._bufParams);x.setWorkingPrecisionModel(u),x.setNoder(h),this._resultGeometry=x.buffer(this._argGeom,this._distance)},Qs.prototype.bufferReducedPrecision=function(){var u=this;if(0===arguments.length){for(var h=Qs.MAX_PRECISION_DIGITS;h>=0;h--){try{u.bufferReducedPrecision(h)}catch(z){if(!(z instanceof Qa))throw z;u._saveException=z}if(null!==u._resultGeometry)return null}throw this._saveException}if(1===arguments.length){var _=Qs.precisionScaleFactor(this._argGeom,this._distance,arguments[0]),M=new Gr(_);this.bufferFixedPrecision(M)}},Qs.prototype.computeGeometry=function(){if(this.bufferOriginalPrecision(),null!==this._resultGeometry)return null;var u=this._argGeom.getFactory().getPrecisionModel();u.getType()===Gr.FIXED?this.bufferFixedPrecision(u):this.bufferReducedPrecision()},Qs.prototype.setQuadrantSegments=function(u){this._bufParams.setQuadrantSegments(u)},Qs.prototype.bufferOriginalPrecision=function(){try{var u=new xa(this._bufParams);this._resultGeometry=u.buffer(this._argGeom,this._distance)}catch(h){if(!(h instanceof We))throw h;this._saveException=h}},Qs.prototype.getResultGeometry=function(u){return this._distance=u,this.computeGeometry(),this._resultGeometry},Qs.prototype.setEndCapStyle=function(u){this._bufParams.setEndCapStyle(u)},Qs.prototype.interfaces_=function(){return[]},Qs.prototype.getClass=function(){return Qs},Qs.bufferOp=function(){if(2===arguments.length){var h=arguments[1];return new Qs(arguments[0]).getResultGeometry(h)}if(3===arguments.length){if(Number.isInteger(arguments[2])&&arguments[0]instanceof Xt&&"number"==typeof arguments[1]){var _=arguments[1],M=arguments[2],z=new Qs(arguments[0]);return z.setQuadrantSegments(M),z.getResultGeometry(_)}if(arguments[2]instanceof Yr&&arguments[0]instanceof Xt&&"number"==typeof arguments[1]){var me=arguments[1];return new Qs(arguments[0],arguments[2]).getResultGeometry(me)}}else if(4===arguments.length){var Vt=arguments[1],Yt=arguments[2],wn=arguments[3],En=new Qs(arguments[0]);return En.setQuadrantSegments(Yt),En.setEndCapStyle(wn),En.getResultGeometry(Vt)}},Qs.precisionScaleFactor=function(u,h,x){var _=u.getEnvelopeInternal(),M=Ke.max(Math.abs(_.getMaxX()),Math.abs(_.getMaxY()),Math.abs(_.getMinX()),Math.abs(_.getMinY()))+2*(h>0?h:0),z=x-Math.trunc(Math.log(M)/Math.log(10)+1);return Math.pow(10,z)},xc.CAP_ROUND.get=function(){return Yr.CAP_ROUND},xc.CAP_BUTT.get=function(){return Yr.CAP_FLAT},xc.CAP_FLAT.get=function(){return Yr.CAP_FLAT},xc.CAP_SQUARE.get=function(){return Yr.CAP_SQUARE},xc.MAX_PRECISION_DIGITS.get=function(){return 12},Object.defineProperties(Qs,xc);var ea=function(){this._pt=[new Z,new Z],this._distance=we.NaN,this._isNull=!0};ea.prototype.getCoordinates=function(){return this._pt},ea.prototype.getCoordinate=function(u){return this._pt[u]},ea.prototype.setMinimum=function(){if(1===arguments.length){var u=arguments[0];this.setMinimum(u._pt[0],u._pt[1])}else if(2===arguments.length){var h=arguments[0],x=arguments[1];if(this._isNull)return this.initialize(h,x),null;var _=h.distance(x);_<this._distance&&this.initialize(h,x,_)}},ea.prototype.initialize=function(){if(0===arguments.length)this._isNull=!0;else if(2===arguments.length){var u=arguments[0],h=arguments[1];this._pt[0].setCoordinate(u),this._pt[1].setCoordinate(h),this._distance=u.distance(h),this._isNull=!1}else if(3===arguments.length){var _=arguments[1],M=arguments[2];this._pt[0].setCoordinate(arguments[0]),this._pt[1].setCoordinate(_),this._distance=M,this._isNull=!1}},ea.prototype.getDistance=function(){return this._distance},ea.prototype.setMaximum=function(){if(1===arguments.length){var u=arguments[0];this.setMaximum(u._pt[0],u._pt[1])}else if(2===arguments.length){var h=arguments[0],x=arguments[1];if(this._isNull)return this.initialize(h,x),null;var _=h.distance(x);_>this._distance&&this.initialize(h,x,_)}},ea.prototype.interfaces_=function(){return[]},ea.prototype.getClass=function(){return ea};var Po=function(){};Po.prototype.interfaces_=function(){return[]},Po.prototype.getClass=function(){return Po},Po.computeDistance=function(){if(arguments[2]instanceof ea&&arguments[0]instanceof Wi&&arguments[1]instanceof Z)for(var h=arguments[1],x=arguments[2],_=arguments[0].getCoordinates(),M=new Wn,z=0;z<_.length-1;z++){M.setCoordinates(_[z],_[z+1]);var q=M.closestPoint(h);x.setMinimum(q,h)}else if(arguments[2]instanceof ea&&arguments[0]instanceof Ns&&arguments[1]instanceof Z){var me=arguments[0],Ze=arguments[1],lt=arguments[2];Po.computeDistance(me.getExteriorRing(),Ze,lt);for(var Vt=0;Vt<me.getNumInteriorRing();Vt++)Po.computeDistance(me.getInteriorRingN(Vt),Ze,lt)}else if(arguments[2]instanceof ea&&arguments[0]instanceof Xt&&arguments[1]instanceof Z){var Yt=arguments[0],wn=arguments[1],En=arguments[2];if(Yt instanceof Wi)Po.computeDistance(Yt,wn,En);else if(Yt instanceof Ns)Po.computeDistance(Yt,wn,En);else if(Yt instanceof Yi)for(var Fn=Yt,or=0;or<Fn.getNumGeometries();or++){var fi=Fn.getGeometryN(or);Po.computeDistance(fi,wn,En)}else En.setMinimum(Yt.getCoordinate(),wn)}else if(arguments[2]instanceof ea&&arguments[0]instanceof Wn&&arguments[1]instanceof Z){var ro=arguments[1],io=arguments[2],Fs=arguments[0].closestPoint(ro);io.setMinimum(Fs,ro)}};var tl=function(u){this._maxPtDist=new ea,this._inputGeom=u||null},ef={MaxPointDistanceFilter:{configurable:!0},MaxMidpointDistanceFilter:{configurable:!0}};tl.prototype.computeMaxMidpointDistance=function(u){var h=new ir(this._inputGeom);u.apply(h),this._maxPtDist.setMaximum(h.getMaxPointDistance())},tl.prototype.computeMaxVertexDistance=function(u){var h=new es(this._inputGeom);u.apply(h),this._maxPtDist.setMaximum(h.getMaxPointDistance())},tl.prototype.findDistance=function(u){return this.computeMaxVertexDistance(u),this.computeMaxMidpointDistance(u),this._maxPtDist.getDistance()},tl.prototype.getDistancePoints=function(){return this._maxPtDist},tl.prototype.interfaces_=function(){return[]},tl.prototype.getClass=function(){return tl},ef.MaxPointDistanceFilter.get=function(){return es},ef.MaxMidpointDistanceFilter.get=function(){return ir},Object.defineProperties(tl,ef);var es=function(u){this._maxPtDist=new ea,this._minPtDist=new ea,this._geom=u||null};es.prototype.filter=function(u){this._minPtDist.initialize(),Po.computeDistance(this._geom,u,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)},es.prototype.getMaxPointDistance=function(){return this._maxPtDist},es.prototype.interfaces_=function(){return[xr]},es.prototype.getClass=function(){return es};var ir=function(u){this._maxPtDist=new ea,this._minPtDist=new ea,this._geom=u||null};ir.prototype.filter=function(u,h){if(0===h)return null;var x=u.getCoordinate(h-1),_=u.getCoordinate(h),M=new Z((x.x+_.x)/2,(x.y+_.y)/2);this._minPtDist.initialize(),Po.computeDistance(this._geom,M,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)},ir.prototype.isDone=function(){return!1},ir.prototype.isGeometryChanged=function(){return!1},ir.prototype.getMaxPointDistance=function(){return this._maxPtDist},ir.prototype.interfaces_=function(){return[cs]},ir.prototype.getClass=function(){return ir};var Ou=function(u){this._comps=u||null};Ou.prototype.filter=function(u){u instanceof Ns&&this._comps.add(u)},Ou.prototype.interfaces_=function(){return[oa]},Ou.prototype.getClass=function(){return Ou},Ou.getPolygons=function(){if(1===arguments.length)return Ou.getPolygons(arguments[0],new pn);if(2===arguments.length){var h=arguments[0],x=arguments[1];return h instanceof Ns?x.add(h):h instanceof Yi&&h.apply(new Ou(x)),x}};var Ss=function(){if(this._lines=null,this._isForcedToLineString=!1,1===arguments.length)this._lines=arguments[0];else if(2===arguments.length){var x=arguments[1];this._lines=arguments[0],this._isForcedToLineString=x}};Ss.prototype.filter=function(u){if(this._isForcedToLineString&&u instanceof Ba){var h=u.getFactory().createLineString(u.getCoordinateSequence());return this._lines.add(h),null}u instanceof Wi&&this._lines.add(u)},Ss.prototype.setForceToLineString=function(u){this._isForcedToLineString=u},Ss.prototype.interfaces_=function(){return[ft]},Ss.prototype.getClass=function(){return Ss},Ss.getGeometry=function(){if(1===arguments.length){var u=arguments[0];return u.getFactory().buildGeometry(Ss.getLines(u))}if(2===arguments.length){var h=arguments[0],x=arguments[1];return h.getFactory().buildGeometry(Ss.getLines(h,x))}},Ss.getLines=function(){if(1===arguments.length)return Ss.getLines(arguments[0],!1);if(2===arguments.length){if(Ct(arguments[0],Kr)&&Ct(arguments[1],Kr)){for(var x=arguments[1],_=arguments[0].iterator();_.hasNext();){var M=_.next();Ss.getLines(M,x)}return x}if(arguments[0]instanceof Xt&&"boolean"==typeof arguments[1]){var z=arguments[0],q=arguments[1],me=new pn;return z.apply(new Ss(me,q)),me}if(arguments[0]instanceof Xt&&Ct(arguments[1],Kr)){var Ze=arguments[0],lt=arguments[1];return Ze instanceof Wi?lt.add(Ze):Ze.apply(new Ss(lt)),lt}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&Ct(arguments[0],Kr)&&Ct(arguments[1],Kr)){for(var Yt=arguments[1],wn=arguments[2],En=arguments[0].iterator();En.hasNext();){var Fn=En.next();Ss.getLines(Fn,Yt,wn)}return Yt}if("boolean"==typeof arguments[2]&&arguments[0]instanceof Xt&&Ct(arguments[1],Kr)){var fi=arguments[1];return arguments[0].apply(new Ss(fi,arguments[2])),fi}}};var ho=function(){if(this._boundaryRule=br.OGC_SFS_BOUNDARY_RULE,this._isIn=null,this._numBoundaries=null,0!==arguments.length&&1===arguments.length){var u=arguments[0];if(null===u)throw new xe("Rule must be non-null");this._boundaryRule=u}};ho.prototype.locateInternal=function(){if(arguments[0]instanceof Z&&arguments[1]instanceof Ns){var u=arguments[0],h=arguments[1];if(h.isEmpty())return _e.EXTERIOR;var x=h.getExteriorRing(),_=this.locateInPolygonRing(u,x);if(_===_e.EXTERIOR)return _e.EXTERIOR;if(_===_e.BOUNDARY)return _e.BOUNDARY;for(var M=0;M<h.getNumInteriorRing();M++){var z=h.getInteriorRingN(M),q=this.locateInPolygonRing(u,z);if(q===_e.INTERIOR)return _e.EXTERIOR;if(q===_e.BOUNDARY)return _e.BOUNDARY}return _e.INTERIOR}if(arguments[0]instanceof Z&&arguments[1]instanceof Wi){var me=arguments[0],Ze=arguments[1];if(!Ze.getEnvelopeInternal().intersects(me))return _e.EXTERIOR;var lt=Ze.getCoordinates();return Ze.isClosed()||!me.equals(lt[0])&&!me.equals(lt[lt.length-1])?xt.isOnLine(me,lt)?_e.INTERIOR:_e.EXTERIOR:_e.BOUNDARY}if(arguments[0]instanceof Z&&arguments[1]instanceof ma){var Vt=arguments[0];return arguments[1].getCoordinate().equals2D(Vt)?_e.INTERIOR:_e.EXTERIOR}},ho.prototype.locateInPolygonRing=function(u,h){return h.getEnvelopeInternal().intersects(u)?xt.locatePointInRing(u,h.getCoordinates()):_e.EXTERIOR},ho.prototype.intersects=function(u,h){return this.locate(u,h)!==_e.EXTERIOR},ho.prototype.updateLocationInfo=function(u){u===_e.INTERIOR&&(this._isIn=!0),u===_e.BOUNDARY&&this._numBoundaries++},ho.prototype.computeLocation=function(u,h){if(h instanceof ma&&this.updateLocationInfo(this.locateInternal(u,h)),h instanceof Wi)this.updateLocationInfo(this.locateInternal(u,h));else if(h instanceof Ns)this.updateLocationInfo(this.locateInternal(u,h));else if(h instanceof Ia)for(var x=h,_=0;_<x.getNumGeometries();_++){var M=x.getGeometryN(_);this.updateLocationInfo(this.locateInternal(u,M))}else if(h instanceof fr)for(var z=h,q=0;q<z.getNumGeometries();q++){var me=z.getGeometryN(q);this.updateLocationInfo(this.locateInternal(u,me))}else if(h instanceof Yi)for(var Ze=new no(h);Ze.hasNext();){var lt=Ze.next();lt!==h&&this.computeLocation(u,lt)}},ho.prototype.locate=function(u,h){return h.isEmpty()?_e.EXTERIOR:h instanceof Wi||h instanceof Ns?this.locateInternal(u,h):(this._isIn=!1,this._numBoundaries=0,this.computeLocation(u,h),this._boundaryRule.isInBoundary(this._numBoundaries)?_e.BOUNDARY:this._numBoundaries>0||this._isIn?_e.INTERIOR:_e.EXTERIOR)},ho.prototype.interfaces_=function(){return[]},ho.prototype.getClass=function(){return ho};var Ms=function u(){if(this._component=null,this._segIndex=null,this._pt=null,2===arguments.length)u.call(this,arguments[0],u.INSIDE_AREA,arguments[1]);else if(3===arguments.length){var M=arguments[1],z=arguments[2];this._component=arguments[0],this._segIndex=M,this._pt=z}},dh={INSIDE_AREA:{configurable:!0}};Ms.prototype.isInsideArea=function(){return this._segIndex===Ms.INSIDE_AREA},Ms.prototype.getCoordinate=function(){return this._pt},Ms.prototype.getGeometryComponent=function(){return this._component},Ms.prototype.getSegmentIndex=function(){return this._segIndex},Ms.prototype.interfaces_=function(){return[]},Ms.prototype.getClass=function(){return Ms},dh.INSIDE_AREA.get=function(){return-1},Object.defineProperties(Ms,dh);var ku=function(u){this._pts=u||null};ku.prototype.filter=function(u){u instanceof ma&&this._pts.add(u)},ku.prototype.interfaces_=function(){return[oa]},ku.prototype.getClass=function(){return ku},ku.getPoints=function(){if(1===arguments.length){var u=arguments[0];return u instanceof ma?Ro.singletonList(u):ku.getPoints(u,new pn)}if(2===arguments.length){var h=arguments[0],x=arguments[1];return h instanceof ma?x.add(h):h instanceof Yi&&h.apply(new ku(x)),x}};var bc=function(){this._locations=null,this._locations=arguments[0]};bc.prototype.filter=function(u){(u instanceof ma||u instanceof Wi||u instanceof Ns)&&this._locations.add(new Ms(u,0,u.getCoordinate()))},bc.prototype.interfaces_=function(){return[oa]},bc.prototype.getClass=function(){return bc},bc.getLocations=function(u){var h=new pn;return u.apply(new bc(h)),h};var ca=function(){if(this._geom=null,this._terminateDistance=0,this._ptLocator=new ho,this._minDistanceLocation=null,this._minDistance=we.MAX_VALUE,2===arguments.length)this._geom=[arguments[0],arguments[1]],this._terminateDistance=0;else if(3===arguments.length){var x=arguments[0],_=arguments[1],M=arguments[2];this._geom=new Array(2).fill(null),this._geom[0]=x,this._geom[1]=_,this._terminateDistance=M}};ca.prototype.computeContainmentDistance=function(){if(0===arguments.length){var u=new Array(2).fill(null);if(this.computeContainmentDistance(0,u),this._minDistance<=this._terminateDistance)return null;this.computeContainmentDistance(1,u)}else if(2===arguments.length){var h=arguments[0],x=arguments[1],_=1-h,M=Ou.getPolygons(this._geom[h]);if(M.size()>0){var z=bc.getLocations(this._geom[_]);if(this.computeContainmentDistance(z,M,x),this._minDistance<=this._terminateDistance)return this._minDistanceLocation[_]=x[0],this._minDistanceLocation[h]=x[1],null}}else if(3===arguments.length)if(arguments[2]instanceof Array&&Ct(arguments[0],Dr)&&Ct(arguments[1],Dr)){for(var q=arguments[0],me=arguments[1],Ze=arguments[2],lt=0;lt<q.size();lt++)for(var Vt=q.get(lt),Yt=0;Yt<me.size();Yt++)if(this.computeContainmentDistance(Vt,me.get(Yt),Ze),this._minDistance<=this._terminateDistance)return null}else if(arguments[2]instanceof Array&&arguments[0]instanceof Ms&&arguments[1]instanceof Ns){var wn=arguments[0],En=arguments[1],Fn=arguments[2],or=wn.getCoordinate();if(_e.EXTERIOR!==this._ptLocator.locate(or,En))return this._minDistance=0,Fn[0]=wn,Fn[1]=new Ms(En,or),null}},ca.prototype.computeMinDistanceLinesPoints=function(u,h,x){for(var _=0;_<u.size();_++)for(var M=u.get(_),z=0;z<h.size();z++){var q=h.get(z);if(this.computeMinDistance(M,q,x),this._minDistance<=this._terminateDistance)return null}},ca.prototype.computeFacetDistance=function(){var u=new Array(2).fill(null),h=Ss.getLines(this._geom[0]),x=Ss.getLines(this._geom[1]),_=ku.getPoints(this._geom[0]),M=ku.getPoints(this._geom[1]);return this.computeMinDistanceLines(h,x,u),this.updateMinDistance(u,!1),this._minDistance<=this._terminateDistance?null:(u[0]=null,u[1]=null,this.computeMinDistanceLinesPoints(h,M,u),this.updateMinDistance(u,!1),this._minDistance<=this._terminateDistance?null:(u[0]=null,u[1]=null,this.computeMinDistanceLinesPoints(x,_,u),this.updateMinDistance(u,!0),this._minDistance<=this._terminateDistance?null:(u[0]=null,u[1]=null,this.computeMinDistancePoints(_,M,u),void this.updateMinDistance(u,!1))))},ca.prototype.nearestLocations=function(){return this.computeMinDistance(),this._minDistanceLocation},ca.prototype.updateMinDistance=function(u,h){if(null===u[0])return null;h?(this._minDistanceLocation[0]=u[1],this._minDistanceLocation[1]=u[0]):(this._minDistanceLocation[0]=u[0],this._minDistanceLocation[1]=u[1])},ca.prototype.nearestPoints=function(){return this.computeMinDistance(),[this._minDistanceLocation[0].getCoordinate(),this._minDistanceLocation[1].getCoordinate()]},ca.prototype.computeMinDistance=function(){if(0===arguments.length){if(null!==this._minDistanceLocation||(this._minDistanceLocation=new Array(2).fill(null),this.computeContainmentDistance(),this._minDistance<=this._terminateDistance))return null;this.computeFacetDistance()}else if(3===arguments.length)if(arguments[2]instanceof Array&&arguments[0]instanceof Wi&&arguments[1]instanceof ma){var u=arguments[0],h=arguments[1],x=arguments[2];if(u.getEnvelopeInternal().distance(h.getEnvelopeInternal())>this._minDistance)return null;for(var _=u.getCoordinates(),M=h.getCoordinate(),z=0;z<_.length-1;z++){var q=xt.distancePointLine(M,_[z],_[z+1]);if(q<this._minDistance){this._minDistance=q;var me=new Wn(_[z],_[z+1]).closestPoint(M);x[0]=new Ms(u,z,me),x[1]=new Ms(h,0,M)}if(this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof Wi&&arguments[1]instanceof Wi){var Ze=arguments[0],lt=arguments[1],Vt=arguments[2];if(Ze.getEnvelopeInternal().distance(lt.getEnvelopeInternal())>this._minDistance)return null;for(var Yt=Ze.getCoordinates(),wn=lt.getCoordinates(),En=0;En<Yt.length-1;En++)for(var Fn=0;Fn<wn.length-1;Fn++){var or=xt.distanceLineLine(Yt[En],Yt[En+1],wn[Fn],wn[Fn+1]);if(or<this._minDistance){this._minDistance=or;var fi=new Wn(Yt[En],Yt[En+1]),ji=new Wn(wn[Fn],wn[Fn+1]),ro=fi.closestPoints(ji);Vt[0]=new Ms(Ze,En,ro[0]),Vt[1]=new Ms(lt,Fn,ro[1])}if(this._minDistance<=this._terminateDistance)return null}}},ca.prototype.computeMinDistancePoints=function(u,h,x){for(var _=0;_<u.size();_++)for(var M=u.get(_),z=0;z<h.size();z++){var q=h.get(z),me=M.getCoordinate().distance(q.getCoordinate());if(me<this._minDistance&&(this._minDistance=me,x[0]=new Ms(M,0,M.getCoordinate()),x[1]=new Ms(q,0,q.getCoordinate())),this._minDistance<=this._terminateDistance)return null}},ca.prototype.distance=function(){if(null===this._geom[0]||null===this._geom[1])throw new xe("null geometries are not supported");return this._geom[0].isEmpty()||this._geom[1].isEmpty()?0:(this.computeMinDistance(),this._minDistance)},ca.prototype.computeMinDistanceLines=function(u,h,x){for(var _=0;_<u.size();_++)for(var M=u.get(_),z=0;z<h.size();z++){var q=h.get(z);if(this.computeMinDistance(M,q,x),this._minDistance<=this._terminateDistance)return null}},ca.prototype.interfaces_=function(){return[]},ca.prototype.getClass=function(){return ca},ca.distance=function(u,h){return new ca(u,h).distance()},ca.isWithinDistance=function(u,h,x){return new ca(u,h,x).distance()<=x},ca.nearestPoints=function(u,h){return new ca(u,h).nearestPoints()};var ta=function(){this._pt=[new Z,new Z],this._distance=we.NaN,this._isNull=!0};ta.prototype.getCoordinates=function(){return this._pt},ta.prototype.getCoordinate=function(u){return this._pt[u]},ta.prototype.setMinimum=function(){if(1===arguments.length){var u=arguments[0];this.setMinimum(u._pt[0],u._pt[1])}else if(2===arguments.length){var h=arguments[0],x=arguments[1];if(this._isNull)return this.initialize(h,x),null;var _=h.distance(x);_<this._distance&&this.initialize(h,x,_)}},ta.prototype.initialize=function(){if(0===arguments.length)this._isNull=!0;else if(2===arguments.length){var u=arguments[0],h=arguments[1];this._pt[0].setCoordinate(u),this._pt[1].setCoordinate(h),this._distance=u.distance(h),this._isNull=!1}else if(3===arguments.length){var _=arguments[1],M=arguments[2];this._pt[0].setCoordinate(arguments[0]),this._pt[1].setCoordinate(_),this._distance=M,this._isNull=!1}},ta.prototype.toString=function(){return Tt.toLineString(this._pt[0],this._pt[1])},ta.prototype.getDistance=function(){return this._distance},ta.prototype.setMaximum=function(){if(1===arguments.length){var u=arguments[0];this.setMaximum(u._pt[0],u._pt[1])}else if(2===arguments.length){var h=arguments[0],x=arguments[1];if(this._isNull)return this.initialize(h,x),null;var _=h.distance(x);_>this._distance&&this.initialize(h,x,_)}},ta.prototype.interfaces_=function(){return[]},ta.prototype.getClass=function(){return ta};var Pr=function(){};Pr.prototype.interfaces_=function(){return[]},Pr.prototype.getClass=function(){return Pr},Pr.computeDistance=function(){if(arguments[2]instanceof ta&&arguments[0]instanceof Wi&&arguments[1]instanceof Z)for(var u=arguments[0],h=arguments[1],x=arguments[2],_=new Wn,M=u.getCoordinates(),z=0;z<M.length-1;z++){_.setCoordinates(M[z],M[z+1]);var q=_.closestPoint(h);x.setMinimum(q,h)}else if(arguments[2]instanceof ta&&arguments[0]instanceof Ns&&arguments[1]instanceof Z){var me=arguments[0],Ze=arguments[1],lt=arguments[2];Pr.computeDistance(me.getExteriorRing(),Ze,lt);for(var Vt=0;Vt<me.getNumInteriorRing();Vt++)Pr.computeDistance(me.getInteriorRingN(Vt),Ze,lt)}else if(arguments[2]instanceof ta&&arguments[0]instanceof Xt&&arguments[1]instanceof Z){var Yt=arguments[0],wn=arguments[1],En=arguments[2];if(Yt instanceof Wi)Pr.computeDistance(Yt,wn,En);else if(Yt instanceof Ns)Pr.computeDistance(Yt,wn,En);else if(Yt instanceof Yi)for(var Fn=Yt,or=0;or<Fn.getNumGeometries();or++){var fi=Fn.getGeometryN(or);Pr.computeDistance(fi,wn,En)}else En.setMinimum(Yt.getCoordinate(),wn)}else if(arguments[2]instanceof ta&&arguments[0]instanceof Wn&&arguments[1]instanceof Z){var ro=arguments[1],io=arguments[2],Fs=arguments[0].closestPoint(ro);io.setMinimum(Fs,ro)}};var po=function(){this._g0=null,this._g1=null,this._ptDist=new ta,this._densifyFrac=0;var h=arguments[1];this._g0=arguments[0],this._g1=h},wc={MaxPointDistanceFilter:{configurable:!0},MaxDensifiedByFractionDistanceFilter:{configurable:!0}};po.prototype.getCoordinates=function(){return this._ptDist.getCoordinates()},po.prototype.setDensifyFraction=function(u){if(u>1||u<=0)throw new xe("Fraction is not in range (0.0 - 1.0]");this._densifyFrac=u},po.prototype.compute=function(u,h){this.computeOrientedDistance(u,h,this._ptDist),this.computeOrientedDistance(h,u,this._ptDist)},po.prototype.distance=function(){return this.compute(this._g0,this._g1),this._ptDist.getDistance()},po.prototype.computeOrientedDistance=function(u,h,x){var _=new Pu(h);if(u.apply(_),x.setMaximum(_.getMaxPointDistance()),this._densifyFrac>0){var M=new Fu(h,this._densifyFrac);u.apply(M),x.setMaximum(M.getMaxPointDistance())}},po.prototype.orientedDistance=function(){return this.computeOrientedDistance(this._g0,this._g1,this._ptDist),this._ptDist.getDistance()},po.prototype.interfaces_=function(){return[]},po.prototype.getClass=function(){return po},po.distance=function(){if(2===arguments.length)return new po(arguments[0],arguments[1]).distance();if(3===arguments.length){var M=arguments[2],z=new po(arguments[0],arguments[1]);return z.setDensifyFraction(M),z.distance()}},wc.MaxPointDistanceFilter.get=function(){return Pu},wc.MaxDensifiedByFractionDistanceFilter.get=function(){return Fu},Object.defineProperties(po,wc);var Pu=function(){this._maxPtDist=new ta,this._minPtDist=new ta,this._euclideanDist=new Pr,this._geom=null,this._geom=arguments[0]};Pu.prototype.filter=function(u){this._minPtDist.initialize(),Pr.computeDistance(this._geom,u,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)},Pu.prototype.getMaxPointDistance=function(){return this._maxPtDist},Pu.prototype.interfaces_=function(){return[xr]},Pu.prototype.getClass=function(){return Pu};var Fu=function(){this._maxPtDist=new ta,this._minPtDist=new ta,this._geom=null,this._numSubSegs=0;var h=arguments[1];this._geom=arguments[0],this._numSubSegs=Math.trunc(Math.round(1/h))};Fu.prototype.filter=function(u,h){if(0===h)return null;for(var x=u.getCoordinate(h-1),_=u.getCoordinate(h),M=(_.x-x.x)/this._numSubSegs,z=(_.y-x.y)/this._numSubSegs,q=0;q<this._numSubSegs;q++){var lt=new Z(x.x+q*M,x.y+q*z);this._minPtDist.initialize(),Pr.computeDistance(this._geom,lt,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}},Fu.prototype.isDone=function(){return!1},Fu.prototype.isGeometryChanged=function(){return!1},Fu.prototype.getMaxPointDistance=function(){return this._maxPtDist},Fu.prototype.interfaces_=function(){return[cs]},Fu.prototype.getClass=function(){return Fu};var wa=function(u,h,x){this._minValidDistance=null,this._maxValidDistance=null,this._minDistanceFound=null,this._maxDistanceFound=null,this._isValid=!0,this._errMsg=null,this._errorLocation=null,this._errorIndicator=null,this._input=u||null,this._bufDistance=h||null,this._result=x||null},Ff={VERBOSE:{configurable:!0},MAX_DISTANCE_DIFF_FRAC:{configurable:!0}};wa.prototype.checkMaximumDistance=function(u,h,x){var _=new po(h,u);if(_.setDensifyFraction(.25),this._maxDistanceFound=_.orientedDistance(),this._maxDistanceFound>x){this._isValid=!1;var M=_.getCoordinates();this._errorLocation=M[1],this._errorIndicator=u.getFactory().createLineString(M),this._errMsg="Distance between buffer curve and input is too large ("+this._maxDistanceFound+" at "+Tt.toLineString(M[0],M[1])+")"}},wa.prototype.isValid=function(){var u=Math.abs(this._bufDistance),h=wa.MAX_DISTANCE_DIFF_FRAC*u;return this._minValidDistance=u-h,this._maxValidDistance=u+h,!(!this._input.isEmpty()&&!this._result.isEmpty())||(this._bufDistance>0?this.checkPositiveValid():this.checkNegativeValid(),wa.VERBOSE&&qn.out.println("Min Dist= "+this._minDistanceFound+"  err= "+(1-this._minDistanceFound/this._bufDistance)+"  Max Dist= "+this._maxDistanceFound+"  err= "+(this._maxDistanceFound/this._bufDistance-1)),this._isValid)},wa.prototype.checkNegativeValid=function(){if(!(this._input instanceof Ns||this._input instanceof fr||this._input instanceof Yi))return null;var u=this.getPolygonLines(this._input);if(this.checkMinimumDistance(u,this._result,this._minValidDistance),!this._isValid)return null;this.checkMaximumDistance(u,this._result,this._maxValidDistance)},wa.prototype.getErrorIndicator=function(){return this._errorIndicator},wa.prototype.checkMinimumDistance=function(u,h,x){var _=new ca(u,h,x);if(this._minDistanceFound=_.distance(),this._minDistanceFound<x){this._isValid=!1;var M=_.nearestPoints();this._errorLocation=_.nearestPoints()[1],this._errorIndicator=u.getFactory().createLineString(M),this._errMsg="Distance between buffer curve and input is too small ("+this._minDistanceFound+" at "+Tt.toLineString(M[0],M[1])+" )"}},wa.prototype.checkPositiveValid=function(){var u=this._result.getBoundary();if(this.checkMinimumDistance(this._input,u,this._minValidDistance),!this._isValid)return null;this.checkMaximumDistance(this._input,u,this._maxValidDistance)},wa.prototype.getErrorLocation=function(){return this._errorLocation},wa.prototype.getPolygonLines=function(u){for(var h=new pn,x=new Ss(h),_=Ou.getPolygons(u).iterator();_.hasNext();)_.next().apply(x);return u.getFactory().buildGeometry(h)},wa.prototype.getErrorMessage=function(){return this._errMsg},wa.prototype.interfaces_=function(){return[]},wa.prototype.getClass=function(){return wa},Ff.VERBOSE.get=function(){return!1},Ff.MAX_DISTANCE_DIFF_FRAC.get=function(){return.012},Object.defineProperties(wa,Ff);var Rs=function(u,h,x){this._isValid=!0,this._errorMsg=null,this._errorLocation=null,this._errorIndicator=null,this._input=u||null,this._distance=h||null,this._result=x||null},ot={VERBOSE:{configurable:!0},MAX_ENV_DIFF_FRAC:{configurable:!0}};Rs.prototype.isValid=function(){return this.checkPolygonal(),this._isValid?(this.checkExpectedEmpty(),this._isValid?(this.checkEnvelope(),this._isValid?(this.checkArea(),this._isValid?(this.checkDistance(),this._isValid):this._isValid):this._isValid):this._isValid):this._isValid},Rs.prototype.checkEnvelope=function(){if(this._distance<0)return null;var u=this._distance*Rs.MAX_ENV_DIFF_FRAC;0===u&&(u=.001);var h=new Qe(this._input.getEnvelopeInternal());h.expandBy(this._distance);var x=new Qe(this._result.getEnvelopeInternal());x.expandBy(u),x.contains(h)||(this._isValid=!1,this._errorMsg="Buffer envelope is incorrect",this._errorIndicator=this._input.getFactory().toGeometry(x)),this.report("Envelope")},Rs.prototype.checkDistance=function(){var u=new wa(this._input,this._distance,this._result);u.isValid()||(this._isValid=!1,this._errorMsg=u.getErrorMessage(),this._errorLocation=u.getErrorLocation(),this._errorIndicator=u.getErrorIndicator()),this.report("Distance")},Rs.prototype.checkArea=function(){var u=this._input.getArea(),h=this._result.getArea();this._distance>0&&u>h&&(this._isValid=!1,this._errorMsg="Area of positive buffer is smaller than input",this._errorIndicator=this._result),this._distance<0&&u<h&&(this._isValid=!1,this._errorMsg="Area of negative buffer is larger than input",this._errorIndicator=this._result),this.report("Area")},Rs.prototype.checkPolygonal=function(){this._result instanceof Ns||this._result instanceof fr||(this._isValid=!1),this._errorMsg="Result is not polygonal",this._errorIndicator=this._result,this.report("Polygonal")},Rs.prototype.getErrorIndicator=function(){return this._errorIndicator},Rs.prototype.getErrorLocation=function(){return this._errorLocation},Rs.prototype.checkExpectedEmpty=function(){return this._input.getDimension()>=2||this._distance>0?null:(this._result.isEmpty()||(this._isValid=!1,this._errorMsg="Result is non-empty",this._errorIndicator=this._result),void this.report("ExpectedEmpty"))},Rs.prototype.report=function(u){if(!Rs.VERBOSE)return null;qn.out.println("Check "+u+": "+(this._isValid?"passed":"FAILED"))},Rs.prototype.getErrorMessage=function(){return this._errorMsg},Rs.prototype.interfaces_=function(){return[]},Rs.prototype.getClass=function(){return Rs},Rs.isValidMsg=function(u,h,x){var _=new Rs(u,h,x);return _.isValid()?null:_.getErrorMessage()},Rs.isValid=function(u,h,x){return!!new Rs(u,h,x).isValid()},ot.VERBOSE.get=function(){return!1},ot.MAX_ENV_DIFF_FRAC.get=function(){return.012},Object.defineProperties(Rs,ot);var Fo=function(){this._pts=null,this._data=null;var h=arguments[1];this._pts=arguments[0],this._data=h};Fo.prototype.getCoordinates=function(){return this._pts},Fo.prototype.size=function(){return this._pts.length},Fo.prototype.getCoordinate=function(u){return this._pts[u]},Fo.prototype.isClosed=function(){return this._pts[0].equals(this._pts[this._pts.length-1])},Fo.prototype.getSegmentOctant=function(u){return u===this._pts.length-1?-1:el.octant(this.getCoordinate(u),this.getCoordinate(u+1))},Fo.prototype.setData=function(u){this._data=u},Fo.prototype.getData=function(){return this._data},Fo.prototype.toString=function(){return Tt.toLineString(new Vr(this._pts))},Fo.prototype.interfaces_=function(){return[Do]},Fo.prototype.getClass=function(){return Fo};var Ws=function(){this._findAllIntersections=!1,this._isCheckEndSegmentsOnly=!1,this._li=null,this._interiorIntersection=null,this._intSegments=null,this._intersections=new pn,this._intersectionCount=0,this._keepIntersections=!0,this._li=arguments[0],this._interiorIntersection=null};Ws.prototype.getInteriorIntersection=function(){return this._interiorIntersection},Ws.prototype.setCheckEndSegmentsOnly=function(u){this._isCheckEndSegmentsOnly=u},Ws.prototype.getIntersectionSegments=function(){return this._intSegments},Ws.prototype.count=function(){return this._intersectionCount},Ws.prototype.getIntersections=function(){return this._intersections},Ws.prototype.setFindAllIntersections=function(u){this._findAllIntersections=u},Ws.prototype.setKeepIntersections=function(u){this._keepIntersections=u},Ws.prototype.processIntersections=function(u,h,x,_){if(!this._findAllIntersections&&this.hasIntersection()||u===x&&h===_||this._isCheckEndSegmentsOnly&&!this.isEndSegment(u,h)&&!this.isEndSegment(x,_))return null;var M=u.getCoordinates()[h],z=u.getCoordinates()[h+1],q=x.getCoordinates()[_],me=x.getCoordinates()[_+1];this._li.computeIntersection(M,z,q,me),this._li.hasIntersection()&&this._li.isInteriorIntersection()&&(this._intSegments=new Array(4).fill(null),this._intSegments[0]=M,this._intSegments[1]=z,this._intSegments[2]=q,this._intSegments[3]=me,this._interiorIntersection=this._li.getIntersection(0),this._keepIntersections&&this._intersections.add(this._interiorIntersection),this._intersectionCount++)},Ws.prototype.isEndSegment=function(u,h){return 0===h||h>=u.size()-2},Ws.prototype.hasIntersection=function(){return null!==this._interiorIntersection},Ws.prototype.isDone=function(){return!this._findAllIntersections&&null!==this._interiorIntersection},Ws.prototype.interfaces_=function(){return[Yo]},Ws.prototype.getClass=function(){return Ws},Ws.createAllIntersectionsFinder=function(u){var h=new Ws(u);return h.setFindAllIntersections(!0),h},Ws.createAnyIntersectionFinder=function(u){return new Ws(u)},Ws.createIntersectionCounter=function(u){var h=new Ws(u);return h.setFindAllIntersections(!0),h.setKeepIntersections(!1),h};var za=function(){this._li=new tt,this._segStrings=null,this._findAllIntersections=!1,this._segInt=null,this._isValid=!0,this._segStrings=arguments[0]};za.prototype.execute=function(){if(null!==this._segInt)return null;this.checkInteriorIntersections()},za.prototype.getIntersections=function(){return this._segInt.getIntersections()},za.prototype.isValid=function(){return this.execute(),this._isValid},za.prototype.setFindAllIntersections=function(u){this._findAllIntersections=u},za.prototype.checkInteriorIntersections=function(){this._isValid=!0,this._segInt=new Ws(this._li),this._segInt.setFindAllIntersections(this._findAllIntersections);var u=new jc;if(u.setSegmentIntersector(this._segInt),u.computeNodes(this._segStrings),this._segInt.hasIntersection())return this._isValid=!1,null},za.prototype.checkValid=function(){if(this.execute(),!this._isValid)throw new Qa(this.getErrorMessage(),this._segInt.getInteriorIntersection())},za.prototype.getErrorMessage=function(){if(this._isValid)return"no intersections found";var u=this._segInt.getIntersectionSegments();return"found non-noded intersection between "+Tt.toLineString(u[0],u[1])+" and "+Tt.toLineString(u[2],u[3])},za.prototype.interfaces_=function(){return[]},za.prototype.getClass=function(){return za},za.computeIntersections=function(u){var h=new za(u);return h.setFindAllIntersections(!0),h.isValid(),h.getIntersections()};var wl=function u(){this._nv=null,this._nv=new za(u.toSegmentStrings(arguments[0]))};wl.prototype.checkValid=function(){this._nv.checkValid()},wl.prototype.interfaces_=function(){return[]},wl.prototype.getClass=function(){return wl},wl.toSegmentStrings=function(u){for(var h=new pn,x=u.iterator();x.hasNext();){var _=x.next();h.add(new Fo(_.getCoordinates(),_))}return h},wl.checkValid=function(u){new wl(u).checkValid()};var Gl=function(u){this._mapOp=u};Gl.prototype.map=function(u){for(var h=new pn,x=0;x<u.getNumGeometries();x++){var _=this._mapOp.map(u.getGeometryN(x));_.isEmpty()||h.add(_)}return u.getFactory().createGeometryCollection(Mr.toGeometryArray(h))},Gl.prototype.interfaces_=function(){return[]},Gl.prototype.getClass=function(){return Gl},Gl.map=function(u,h){return new Gl(h).map(u)};var Jo=function(){this._op=null,this._geometryFactory=null,this._ptLocator=null,this._lineEdgesList=new pn,this._resultLineList=new pn;var h=arguments[1],x=arguments[2];this._op=arguments[0],this._geometryFactory=h,this._ptLocator=x};Jo.prototype.collectLines=function(u){for(var h=this._op.getGraph().getEdgeEnds().iterator();h.hasNext();){var x=h.next();this.collectLineEdge(x,u,this._lineEdgesList),this.collectBoundaryTouchEdge(x,u,this._lineEdgesList)}},Jo.prototype.labelIsolatedLine=function(u,h){var x=this._ptLocator.locate(u.getCoordinate(),this._op.getArgGeometry(h));u.getLabel().setLocation(h,x)},Jo.prototype.build=function(u){return this.findCoveredLineEdges(),this.collectLines(u),this.buildLines(u),this._resultLineList},Jo.prototype.collectLineEdge=function(u,h,x){var _=u.getLabel(),M=u.getEdge();u.isLineEdge()&&(u.isVisited()||!vr.isResultOfOp(_,h)||M.isCovered()||(x.add(M),u.setVisitedEdge(!0)))},Jo.prototype.findCoveredLineEdges=function(){for(var u=this._op.getGraph().getNodes().iterator();u.hasNext();)u.next().getEdges().findCoveredLineEdges();for(var h=this._op.getGraph().getEdgeEnds().iterator();h.hasNext();){var x=h.next(),_=x.getEdge();if(x.isLineEdge()&&!_.isCoveredSet()){var M=this._op.isCoveredByA(x.getCoordinate());_.setCovered(M)}}},Jo.prototype.labelIsolatedLines=function(u){for(var h=u.iterator();h.hasNext();){var x=h.next(),_=x.getLabel();x.isIsolated()&&(_.isNull(0)?this.labelIsolatedLine(x,0):this.labelIsolatedLine(x,1))}},Jo.prototype.buildLines=function(u){for(var h=this._lineEdgesList.iterator();h.hasNext();){var x=h.next(),_=this._geometryFactory.createLineString(x.getCoordinates());this._resultLineList.add(_),x.setInResult(!0)}},Jo.prototype.collectBoundaryTouchEdge=function(u,h,x){var _=u.getLabel();return u.isLineEdge()||u.isVisited()||u.isInteriorAreaEdge()||u.getEdge().isInResult()?null:(De.isTrue(!(u.isInResult()||u.getSym().isInResult())||!u.getEdge().isInResult()),void(vr.isResultOfOp(_,h)&&h===vr.INTERSECTION&&(x.add(u.getEdge()),u.setVisitedEdge(!0))))},Jo.prototype.interfaces_=function(){return[]},Jo.prototype.getClass=function(){return Jo};var ql=function(){this._op=null,this._geometryFactory=null,this._resultPointList=new pn;var h=arguments[1];this._op=arguments[0],this._geometryFactory=h};ql.prototype.filterCoveredNodeToPoint=function(u){var h=u.getCoordinate();if(!this._op.isCoveredByLA(h)){var x=this._geometryFactory.createPoint(h);this._resultPointList.add(x)}},ql.prototype.extractNonCoveredResultNodes=function(u){for(var h=this._op.getGraph().getNodes().iterator();h.hasNext();){var x=h.next();if(!(x.isInResult()||x.isIncidentEdgeInResult()||0!==x.getEdges().getDegree()&&u!==vr.INTERSECTION)){var _=x.getLabel();vr.isResultOfOp(_,u)&&this.filterCoveredNodeToPoint(x)}}},ql.prototype.build=function(u){return this.extractNonCoveredResultNodes(u),this._resultPointList},ql.prototype.interfaces_=function(){return[]},ql.prototype.getClass=function(){return ql};var Ma=function(){this._inputGeom=null,this._factory=null,this._pruneEmptyGeometry=!0,this._preserveGeometryCollectionType=!0,this._preserveCollections=!1,this._preserveType=!1};Ma.prototype.transformPoint=function(u,h){return this._factory.createPoint(this.transformCoordinates(u.getCoordinateSequence(),u))},Ma.prototype.transformPolygon=function(u,h){var x=!0,_=this.transformLinearRing(u.getExteriorRing(),u);null!==_&&_ instanceof Ba&&!_.isEmpty()||(x=!1);for(var M=new pn,z=0;z<u.getNumInteriorRing();z++){var q=this.transformLinearRing(u.getInteriorRingN(z),u);null===q||q.isEmpty()||(q instanceof Ba||(x=!1),M.add(q))}if(x)return this._factory.createPolygon(_,M.toArray([]));var me=new pn;return null!==_&&me.add(_),me.addAll(M),this._factory.buildGeometry(me)},Ma.prototype.createCoordinateSequence=function(u){return this._factory.getCoordinateSequenceFactory().create(u)},Ma.prototype.getInputGeometry=function(){return this._inputGeom},Ma.prototype.transformMultiLineString=function(u,h){for(var x=new pn,_=0;_<u.getNumGeometries();_++){var M=this.transformLineString(u.getGeometryN(_),u);null!==M&&(M.isEmpty()||x.add(M))}return this._factory.buildGeometry(x)},Ma.prototype.transformCoordinates=function(u,h){return this.copy(u)},Ma.prototype.transformLineString=function(u,h){return this._factory.createLineString(this.transformCoordinates(u.getCoordinateSequence(),u))},Ma.prototype.transformMultiPoint=function(u,h){for(var x=new pn,_=0;_<u.getNumGeometries();_++){var M=this.transformPoint(u.getGeometryN(_),u);null!==M&&(M.isEmpty()||x.add(M))}return this._factory.buildGeometry(x)},Ma.prototype.transformMultiPolygon=function(u,h){for(var x=new pn,_=0;_<u.getNumGeometries();_++){var M=this.transformPolygon(u.getGeometryN(_),u);null!==M&&(M.isEmpty()||x.add(M))}return this._factory.buildGeometry(x)},Ma.prototype.copy=function(u){return u.copy()},Ma.prototype.transformGeometryCollection=function(u,h){for(var x=new pn,_=0;_<u.getNumGeometries();_++){var M=this.transform(u.getGeometryN(_));null!==M&&(this._pruneEmptyGeometry&&M.isEmpty()||x.add(M))}return this._preserveGeometryCollectionType?this._factory.createGeometryCollection(Mr.toGeometryArray(x)):this._factory.buildGeometry(x)},Ma.prototype.transform=function(u){if(this._inputGeom=u,this._factory=u.getFactory(),u instanceof ma)return this.transformPoint(u,null);if(u instanceof Kc)return this.transformMultiPoint(u,null);if(u instanceof Ba)return this.transformLinearRing(u,null);if(u instanceof Wi)return this.transformLineString(u,null);if(u instanceof Ia)return this.transformMultiLineString(u,null);if(u instanceof Ns)return this.transformPolygon(u,null);if(u instanceof fr)return this.transformMultiPolygon(u,null);if(u instanceof Yi)return this.transformGeometryCollection(u,null);throw new xe("Unknown Geometry subtype: "+u.getClass().getName())},Ma.prototype.transformLinearRing=function(u,h){var x=this.transformCoordinates(u.getCoordinateSequence(),u);if(null===x)return this._factory.createLinearRing(null);var _=x.size();return _>0&&_<4&&!this._preserveType?this._factory.createLineString(x):this._factory.createLinearRing(x)},Ma.prototype.interfaces_=function(){return[]},Ma.prototype.getClass=function(){return Ma};var Lo=function u(){if(this._snapTolerance=0,this._srcPts=null,this._seg=new Wn,this._allowSnappingToSourceVertices=!1,this._isClosed=!1,arguments[0]instanceof Wi&&"number"==typeof arguments[1]){var x=arguments[1];u.call(this,arguments[0].getCoordinates(),x)}else if(arguments[0]instanceof Array&&"number"==typeof arguments[1]){var _=arguments[0],M=arguments[1];this._srcPts=_,this._isClosed=u.isClosed(_),this._snapTolerance=M}};Lo.prototype.snapVertices=function(u,h){for(var x=this._isClosed?u.size()-1:u.size(),_=0;_<x;_++){var M=u.get(_),z=this.findSnapForVertex(M,h);null!==z&&(u.set(_,new Z(z)),0===_&&this._isClosed&&u.set(u.size()-1,new Z(z)))}},Lo.prototype.findSnapForVertex=function(u,h){for(var x=0;x<h.length;x++){if(u.equals2D(h[x]))return null;if(u.distance(h[x])<this._snapTolerance)return h[x]}return null},Lo.prototype.snapTo=function(u){var h=new co(this._srcPts);return this.snapVertices(h,u),this.snapSegments(h,u),h.toCoordinateArray()},Lo.prototype.snapSegments=function(u,h){if(0===h.length)return null;var x=h.length;h[0].equals2D(h[h.length-1])&&(x=h.length-1);for(var _=0;_<x;_++){var M=h[_],z=this.findSegmentIndexToSnap(M,u);z>=0&&u.add(z+1,new Z(M),!1)}},Lo.prototype.findSegmentIndexToSnap=function(u,h){for(var x=we.MAX_VALUE,_=-1,M=0;M<h.size()-1;M++){if(this._seg.p0=h.get(M),this._seg.p1=h.get(M+1),this._seg.p0.equals2D(u)||this._seg.p1.equals2D(u)){if(this._allowSnappingToSourceVertices)continue;return-1}var z=this._seg.distance(u);z<this._snapTolerance&&z<x&&(x=z,_=M)}return _},Lo.prototype.setAllowSnappingToSourceVertices=function(u){this._allowSnappingToSourceVertices=u},Lo.prototype.interfaces_=function(){return[]},Lo.prototype.getClass=function(){return Lo},Lo.isClosed=function(u){return!(u.length<=1)&&u[0].equals2D(u[u.length-1])};var Zr=function(u){this._srcGeom=u||null},Qn={SNAP_PRECISION_FACTOR:{configurable:!0}};Zr.prototype.snapTo=function(u,h){var x=this.extractTargetCoordinates(u);return new nl(h,x).transform(this._srcGeom)},Zr.prototype.snapToSelf=function(u,h){var x=this.extractTargetCoordinates(this._srcGeom),_=new nl(u,x,!0).transform(this._srcGeom),M=_;return h&&Ct(M,ju)&&(M=_.buffer(0)),M},Zr.prototype.computeSnapTolerance=function(u){return this.computeMinimumSegmentLength(u)/10},Zr.prototype.extractTargetCoordinates=function(u){for(var h=new ie,x=u.getCoordinates(),_=0;_<x.length;_++)h.add(x[_]);return h.toArray(new Array(0).fill(null))},Zr.prototype.computeMinimumSegmentLength=function(u){for(var h=we.MAX_VALUE,x=0;x<u.length-1;x++){var _=u[x].distance(u[x+1]);_<h&&(h=_)}return h},Zr.prototype.interfaces_=function(){return[]},Zr.prototype.getClass=function(){return Zr},Zr.snap=function(u,h,x){var _=new Array(2).fill(null),M=new Zr(u);_[0]=M.snapTo(h,x);var z=new Zr(h);return _[1]=z.snapTo(_[0],x),_},Zr.computeOverlaySnapTolerance=function(){if(1===arguments.length){var u=arguments[0],h=Zr.computeSizeBasedSnapTolerance(u),x=u.getPrecisionModel();if(x.getType()===Gr.FIXED){var _=1/x.getScale()*2/1.415;_>h&&(h=_)}return h}if(2===arguments.length){var z=arguments[1];return Math.min(Zr.computeOverlaySnapTolerance(arguments[0]),Zr.computeOverlaySnapTolerance(z))}},Zr.computeSizeBasedSnapTolerance=function(u){var h=u.getEnvelopeInternal();return Math.min(h.getHeight(),h.getWidth())*Zr.SNAP_PRECISION_FACTOR},Zr.snapToSelf=function(u,h,x){return new Zr(u).snapToSelf(h,x)},Qn.SNAP_PRECISION_FACTOR.get=function(){return 1e-9},Object.defineProperties(Zr,Qn);var nl=function(u){function h(x,_,M){u.call(this),this._snapTolerance=x||null,this._snapPts=_||null,this._isSelfSnap=void 0!==M&&M}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.snapLine=function(x,_){var M=new Lo(x,this._snapTolerance);return M.setAllowSnappingToSourceVertices(this._isSelfSnap),M.snapTo(_)},h.prototype.transformCoordinates=function(x,_){var M=x.toCoordinateArray(),z=this.snapLine(M,this._snapPts);return this._factory.getCoordinateSequenceFactory().create(z)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(Ma),_a=function(){this._isFirst=!0,this._commonMantissaBitsCount=53,this._commonBits=0,this._commonSignExp=null};_a.prototype.getCommon=function(){return we.longBitsToDouble(this._commonBits)},_a.prototype.add=function(u){var h=we.doubleToLongBits(u);return this._isFirst?(this._commonBits=h,this._commonSignExp=_a.signExpBits(this._commonBits),this._isFirst=!1,null):_a.signExpBits(h)!==this._commonSignExp?(this._commonBits=0,null):(this._commonMantissaBitsCount=_a.numCommonMostSigMantissaBits(this._commonBits,h),void(this._commonBits=_a.zeroLowerBits(this._commonBits,64-(12+this._commonMantissaBitsCount))))},_a.prototype.toString=function(){if(1===arguments.length){var u=arguments[0],h=we.longBitsToDouble(u),x="0000000000000000000000000000000000000000000000000000000000000000"+we.toBinaryString(u),_=x.substring(x.length-64);return _.substring(0,1)+"  "+_.substring(1,12)+"(exp) "+_.substring(12)+" [ "+h+" ]"}},_a.prototype.interfaces_=function(){return[]},_a.prototype.getClass=function(){return _a},_a.getBit=function(u,h){return u&1<<h?1:0},_a.signExpBits=function(u){return u>>52},_a.zeroLowerBits=function(u,h){return u&~((1<<h)-1)},_a.numCommonMostSigMantissaBits=function(u,h){for(var x=0,_=52;_>=0;_--){if(_a.getBit(u,_)!==_a.getBit(h,_))return x;x++}return 52};var rl=function(){this._commonCoord=null,this._ccFilter=new il},Lf={CommonCoordinateFilter:{configurable:!0},Translater:{configurable:!0}};rl.prototype.addCommonBits=function(u){var h=new gu(this._commonCoord);u.apply(h),u.geometryChanged()},rl.prototype.removeCommonBits=function(u){if(0===this._commonCoord.x&&0===this._commonCoord.y)return u;var h=new Z(this._commonCoord);h.x=-h.x,h.y=-h.y;var x=new gu(h);return u.apply(x),u.geometryChanged(),u},rl.prototype.getCommonCoordinate=function(){return this._commonCoord},rl.prototype.add=function(u){u.apply(this._ccFilter),this._commonCoord=this._ccFilter.getCommonCoordinate()},rl.prototype.interfaces_=function(){return[]},rl.prototype.getClass=function(){return rl},Lf.CommonCoordinateFilter.get=function(){return il},Lf.Translater.get=function(){return gu},Object.defineProperties(rl,Lf);var il=function(){this._commonBitsX=new _a,this._commonBitsY=new _a};il.prototype.filter=function(u){this._commonBitsX.add(u.x),this._commonBitsY.add(u.y)},il.prototype.getCommonCoordinate=function(){return new Z(this._commonBitsX.getCommon(),this._commonBitsY.getCommon())},il.prototype.interfaces_=function(){return[xr]},il.prototype.getClass=function(){return il};var gu=function(){this.trans=null,this.trans=arguments[0]};gu.prototype.filter=function(u,h){var x=u.getOrdinate(h,0)+this.trans.x,_=u.getOrdinate(h,1)+this.trans.y;u.setOrdinate(h,0,x),u.setOrdinate(h,1,_)},gu.prototype.isDone=function(){return!1},gu.prototype.isGeometryChanged=function(){return!0},gu.prototype.interfaces_=function(){return[cs]},gu.prototype.getClass=function(){return gu};var vs=function(u,h){this._geom=new Array(2).fill(null),this._snapTolerance=null,this._cbr=null,this._geom[0]=u,this._geom[1]=h,this.computeSnapTolerance()};vs.prototype.selfSnap=function(u){return new Zr(u).snapTo(u,this._snapTolerance)},vs.prototype.removeCommonBits=function(u){this._cbr=new rl,this._cbr.add(u[0]),this._cbr.add(u[1]);var h=new Array(2).fill(null);return h[0]=this._cbr.removeCommonBits(u[0].copy()),h[1]=this._cbr.removeCommonBits(u[1].copy()),h},vs.prototype.prepareResult=function(u){return this._cbr.addCommonBits(u),u},vs.prototype.getResultGeometry=function(u){var h=this.snap(this._geom),x=vr.overlayOp(h[0],h[1],u);return this.prepareResult(x)},vs.prototype.checkValid=function(u){u.isValid()||qn.out.println("Snapped geometry is invalid")},vs.prototype.computeSnapTolerance=function(){this._snapTolerance=Zr.computeOverlaySnapTolerance(this._geom[0],this._geom[1])},vs.prototype.snap=function(u){var h=this.removeCommonBits(u);return Zr.snap(h[0],h[1],this._snapTolerance)},vs.prototype.interfaces_=function(){return[]},vs.prototype.getClass=function(){return vs},vs.overlayOp=function(u,h,x){return new vs(u,h).getResultGeometry(x)},vs.union=function(u,h){return vs.overlayOp(u,h,vr.UNION)},vs.intersection=function(u,h){return vs.overlayOp(u,h,vr.INTERSECTION)},vs.symDifference=function(u,h){return vs.overlayOp(u,h,vr.SYMDIFFERENCE)},vs.difference=function(u,h){return vs.overlayOp(u,h,vr.DIFFERENCE)};var ps=function(u,h){this._geom=new Array(2).fill(null),this._geom[0]=u,this._geom[1]=h};ps.prototype.getResultGeometry=function(u){var h=null,x=!1,_=null;try{h=vr.overlayOp(this._geom[0],this._geom[1],u),x=!0}catch(M){if(!(M instanceof We))throw M;_=M}if(!x)try{h=vs.overlayOp(this._geom[0],this._geom[1],u)}catch(M){throw M instanceof We?_:M}return h},ps.prototype.interfaces_=function(){return[]},ps.prototype.getClass=function(){return ps},ps.overlayOp=function(u,h,x){return new ps(u,h).getResultGeometry(x)},ps.union=function(u,h){return ps.overlayOp(u,h,vr.UNION)},ps.intersection=function(u,h){return ps.overlayOp(u,h,vr.INTERSECTION)},ps.symDifference=function(u,h){return ps.overlayOp(u,h,vr.SYMDIFFERENCE)},ps.difference=function(u,h){return ps.overlayOp(u,h,vr.DIFFERENCE)};var _l=function(){this.mce=null,this.chainIndex=null;var h=arguments[1];this.mce=arguments[0],this.chainIndex=h};_l.prototype.computeIntersections=function(u,h){this.mce.computeIntersectsForChain(this.chainIndex,u.mce,u.chainIndex,h)},_l.prototype.interfaces_=function(){return[]},_l.prototype.getClass=function(){return _l};var Ua=function u(){if(this._label=null,this._xValue=null,this._eventType=null,this._insertEvent=null,this._deleteEventIndex=null,this._obj=null,2===arguments.length){var h=arguments[0],x=arguments[1];this._eventType=u.DELETE,this._xValue=h,this._insertEvent=x}else if(3===arguments.length){var _=arguments[0],M=arguments[1],z=arguments[2];this._eventType=u.INSERT,this._label=_,this._xValue=M,this._obj=z}},Wl={INSERT:{configurable:!0},DELETE:{configurable:!0}};Ua.prototype.isDelete=function(){return this._eventType===Ua.DELETE},Ua.prototype.setDeleteEventIndex=function(u){this._deleteEventIndex=u},Ua.prototype.getObject=function(){return this._obj},Ua.prototype.compareTo=function(u){return this._xValue<u._xValue?-1:this._xValue>u._xValue?1:this._eventType<u._eventType?-1:this._eventType>u._eventType?1:0},Ua.prototype.getInsertEvent=function(){return this._insertEvent},Ua.prototype.isInsert=function(){return this._eventType===Ua.INSERT},Ua.prototype.isSameLabel=function(u){return null!==this._label&&this._label===u._label},Ua.prototype.getDeleteEventIndex=function(){return this._deleteEventIndex},Ua.prototype.interfaces_=function(){return[Ne]},Ua.prototype.getClass=function(){return Ua},Wl.INSERT.get=function(){return 1},Wl.DELETE.get=function(){return 2},Object.defineProperties(Ua,Wl);var tf=function(){};tf.prototype.interfaces_=function(){return[]},tf.prototype.getClass=function(){return tf};var Hs=function(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._properIntersectionPoint=null,this._li=null,this._includeProper=null,this._recordIsolated=null,this._isSelfIntersection=null,this._numIntersections=0,this.numTests=0,this._bdyNodes=null,this._isDone=!1,this._isDoneWhenProperInt=!1;var h=arguments[1],x=arguments[2];this._li=arguments[0],this._includeProper=h,this._recordIsolated=x};Hs.prototype.isTrivialIntersection=function(u,h,x,_){if(u===x&&1===this._li.getIntersectionNum()){if(Hs.isAdjacentSegments(h,_))return!0;if(u.isClosed()){var M=u.getNumPoints()-1;if(0===h&&_===M||0===_&&h===M)return!0}}return!1},Hs.prototype.getProperIntersectionPoint=function(){return this._properIntersectionPoint},Hs.prototype.setIsDoneIfProperInt=function(u){this._isDoneWhenProperInt=u},Hs.prototype.hasProperInteriorIntersection=function(){return this._hasProperInterior},Hs.prototype.isBoundaryPointInternal=function(u,h){for(var x=h.iterator();x.hasNext();){var _=x.next().getCoordinate();if(u.isIntersection(_))return!0}return!1},Hs.prototype.hasProperIntersection=function(){return this._hasProper},Hs.prototype.hasIntersection=function(){return this._hasIntersection},Hs.prototype.isDone=function(){return this._isDone},Hs.prototype.isBoundaryPoint=function(u,h){return!(null===h||!this.isBoundaryPointInternal(u,h[0])&&!this.isBoundaryPointInternal(u,h[1]))},Hs.prototype.setBoundaryNodes=function(u,h){this._bdyNodes=new Array(2).fill(null),this._bdyNodes[0]=u,this._bdyNodes[1]=h},Hs.prototype.addIntersections=function(u,h,x,_){if(u===x&&h===_)return null;this.numTests++;var M=u.getCoordinates()[h],z=u.getCoordinates()[h+1],q=x.getCoordinates()[_],me=x.getCoordinates()[_+1];this._li.computeIntersection(M,z,q,me),this._li.hasIntersection()&&(this._recordIsolated&&(u.setIsolated(!1),x.setIsolated(!1)),this._numIntersections++,this.isTrivialIntersection(u,h,x,_)||(this._hasIntersection=!0,!this._includeProper&&this._li.isProper()||(u.addIntersections(this._li,h,0),x.addIntersections(this._li,_,1)),this._li.isProper()&&(this._properIntersectionPoint=this._li.getIntersection(0).copy(),this._hasProper=!0,this._isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this._li,this._bdyNodes)||(this._hasProperInterior=!0))))},Hs.prototype.interfaces_=function(){return[]},Hs.prototype.getClass=function(){return Hs},Hs.isAdjacentSegments=function(u,h){return 1===Math.abs(u-h)};var nf=function(u){function h(){u.call(this),this.events=new pn,this.nOverlaps=null}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.prepareEvents=function(){Ro.sort(this.events);for(var x=0;x<this.events.size();x++){var _=this.events.get(x);_.isDelete()&&_.getInsertEvent().setDeleteEventIndex(x)}},h.prototype.computeIntersections=function(){if(1===arguments.length){var x=arguments[0];this.nOverlaps=0,this.prepareEvents();for(var _=0;_<this.events.size();_++){var M=this.events.get(_);if(M.isInsert()&&this.processOverlaps(_,M.getDeleteEventIndex(),M,x),x.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof Hs&&Ct(arguments[0],Dr)&&Ct(arguments[1],Dr)){var z=arguments[0],q=arguments[1],me=arguments[2];this.addEdges(z,z),this.addEdges(q,q),this.computeIntersections(me)}else if("boolean"==typeof arguments[2]&&Ct(arguments[0],Dr)&&arguments[1]instanceof Hs){var Ze=arguments[0],lt=arguments[1];arguments[2]?this.addEdges(Ze,null):this.addEdges(Ze),this.computeIntersections(lt)}},h.prototype.addEdge=function(x,_){for(var M=x.getMonotoneChainEdge(),z=M.getStartIndexes(),q=0;q<z.length-1;q++){var me=new _l(M,q),Ze=new Ua(_,M.getMinX(q),me);this.events.add(Ze),this.events.add(new Ua(M.getMaxX(q),Ze))}},h.prototype.processOverlaps=function(x,_,M,z){for(var q=M.getObject(),me=x;me<_;me++){var Ze=this.events.get(me);if(Ze.isInsert()){var lt=Ze.getObject();M.isSameLabel(Ze)||(q.computeIntersections(lt,z),this.nOverlaps++)}}},h.prototype.addEdges=function(){if(1===arguments.length)for(var x=arguments[0].iterator();x.hasNext();){var _=x.next();this.addEdge(_,_)}else if(2===arguments.length)for(var z=arguments[1],q=arguments[0].iterator();q.hasNext();){var me=q.next();this.addEdge(me,z)}},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(tf),$o=function(){this._min=we.POSITIVE_INFINITY,this._max=we.NEGATIVE_INFINITY},mh={NodeComparator:{configurable:!0}};$o.prototype.getMin=function(){return this._min},$o.prototype.intersects=function(u,h){return!(this._min>h||this._max<u)},$o.prototype.getMax=function(){return this._max},$o.prototype.toString=function(){return Tt.toLineString(new Z(this._min,0),new Z(this._max,0))},$o.prototype.interfaces_=function(){return[]},$o.prototype.getClass=function(){return $o},mh.NodeComparator.get=function(){return Hl},Object.defineProperties($o,mh);var Hl=function(){};Hl.prototype.compare=function(u,h){var M=(u._min+u._max)/2,z=(h._min+h._max)/2;return M<z?-1:M>z?1:0},Hl.prototype.interfaces_=function(){return[Pe]},Hl.prototype.getClass=function(){return Hl};var Bo=function(u){function h(){u.call(this),this._item=null;var _=arguments[1],M=arguments[2];this._min=arguments[0],this._max=_,this._item=M}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.query=function(x,_,M){if(!this.intersects(x,_))return null;M.visitItem(this._item)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}($o),Op=function(u){function h(){u.call(this),this._node1=null,this._node2=null;var _=arguments[1];this._node1=arguments[0],this._node2=_,this.buildExtent(this._node1,this._node2)}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.buildExtent=function(x,_){this._min=Math.min(x._min,_._min),this._max=Math.max(x._max,_._max)},h.prototype.query=function(x,_,M){if(!this.intersects(x,_))return null;null!==this._node1&&this._node1.query(x,_,M),null!==this._node2&&this._node2.query(x,_,M)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}($o),Qo=function(){this._leaves=new pn,this._root=null,this._level=0};Qo.prototype.buildTree=function(){Ro.sort(this._leaves,new $o.NodeComparator);for(var u=this._leaves,h=null,x=new pn;;){if(this.buildLevel(u,x),1===x.size())return x.get(0);h=u,u=x,x=h}},Qo.prototype.insert=function(u,h,x){if(null!==this._root)throw new Error("Index cannot be added to once it has been queried");this._leaves.add(new Bo(u,h,x))},Qo.prototype.query=function(u,h,x){this.init(),this._root.query(u,h,x)},Qo.prototype.buildRoot=function(){if(null!==this._root)return null;this._root=this.buildTree()},Qo.prototype.printNode=function(u){qn.out.println(Tt.toLineString(new Z(u._min,this._level),new Z(u._max,this._level)))},Qo.prototype.init=function(){if(null!==this._root)return null;this.buildRoot()},Qo.prototype.buildLevel=function(u,h){this._level++,h.clear();for(var x=0;x<u.size();x+=2){var _=u.get(x);if(null===(x+1<u.size()?u.get(x):null))h.add(_);else{var M=new Op(u.get(x),u.get(x+1));h.add(M)}}},Qo.prototype.interfaces_=function(){return[]},Qo.prototype.getClass=function(){return Qo};var Xl=function(){this._items=new pn};Xl.prototype.visitItem=function(u){this._items.add(u)},Xl.prototype.getItems=function(){return this._items},Xl.prototype.interfaces_=function(){return[Mu]},Xl.prototype.getClass=function(){return Xl};var Nl=function(){this._index=null;var u=arguments[0];if(!Ct(u,ju))throw new xe("Argument must be Polygonal");this._index=new Lu(u)},eu={SegmentVisitor:{configurable:!0},IntervalIndexedGeometry:{configurable:!0}};Nl.prototype.locate=function(u){var h=new K(u),x=new $f(h);return this._index.query(u.y,u.y,x),h.getLocation()},Nl.prototype.interfaces_=function(){return[Ko]},Nl.prototype.getClass=function(){return Nl},eu.SegmentVisitor.get=function(){return $f},eu.IntervalIndexedGeometry.get=function(){return Lu},Object.defineProperties(Nl,eu);var $f=function(){this._counter=null,this._counter=arguments[0]};$f.prototype.visitItem=function(u){var h=u;this._counter.countSegment(h.getCoordinate(0),h.getCoordinate(1))},$f.prototype.interfaces_=function(){return[Mu]},$f.prototype.getClass=function(){return $f};var Lu=function(){this._index=new Qo,this.init(arguments[0])};Lu.prototype.init=function(u){for(var h=Ss.getLines(u).iterator();h.hasNext();){var x=h.next().getCoordinates();this.addLine(x)}},Lu.prototype.addLine=function(u){for(var h=1;h<u.length;h++){var x=new Wn(u[h-1],u[h]),_=Math.min(x.p0.y,x.p1.y),M=Math.max(x.p0.y,x.p1.y);this._index.insert(_,M,x)}},Lu.prototype.query=function(){if(2===arguments.length){var u=arguments[0],h=arguments[1],x=new Xl;return this._index.query(u,h,x),x.getItems()}3===arguments.length&&this._index.query(arguments[0],arguments[1],arguments[2])},Lu.prototype.interfaces_=function(){return[]},Lu.prototype.getClass=function(){return Lu};var _c=function(u){function h(){if(u.call(this),this._parentGeom=null,this._lineEdgeMap=new Tf,this._boundaryNodeRule=null,this._useBoundaryDeterminationRule=!0,this._argIndex=null,this._boundaryNodes=null,this._hasTooFewPoints=!1,this._invalidPoint=null,this._areaPtLocator=null,this._ptLocator=new ho,2===arguments.length){var _=arguments[1],M=br.OGC_SFS_BOUNDARY_RULE;this._argIndex=arguments[0],this._parentGeom=_,this._boundaryNodeRule=M,null!==_&&this.add(_)}else if(3===arguments.length){var q=arguments[1],me=arguments[2];this._argIndex=arguments[0],this._parentGeom=q,this._boundaryNodeRule=me,null!==q&&this.add(q)}}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.insertBoundaryPoint=function(x,_){var M=this._nodes.addNode(_).getLabel(),z=1;M.getLocation(x,en.ON)===_e.BOUNDARY&&z++;var q=h.determineBoundary(this._boundaryNodeRule,z);M.setLocation(x,q)},h.prototype.computeSelfNodes=function(){if(2===arguments.length)return this.computeSelfNodes(arguments[0],arguments[1],!1);if(3===arguments.length){var z=arguments[1],q=arguments[2],me=new Hs(arguments[0],!0,!1);return me.setIsDoneIfProperInt(q),this.createEdgeSetIntersector().computeIntersections(this._edges,me,z||!(this._parentGeom instanceof Ba||this._parentGeom instanceof Ns||this._parentGeom instanceof fr)),this.addSelfIntersectionNodes(this._argIndex),me}},h.prototype.computeSplitEdges=function(x){for(var _=this._edges.iterator();_.hasNext();)_.next().eiList.addSplitEdges(x)},h.prototype.computeEdgeIntersections=function(x,_,M){var z=new Hs(_,M,!0);return z.setBoundaryNodes(this.getBoundaryNodes(),x.getBoundaryNodes()),this.createEdgeSetIntersector().computeIntersections(this._edges,x._edges,z),z},h.prototype.getGeometry=function(){return this._parentGeom},h.prototype.getBoundaryNodeRule=function(){return this._boundaryNodeRule},h.prototype.hasTooFewPoints=function(){return this._hasTooFewPoints},h.prototype.addPoint=function(){if(arguments[0]instanceof ma){var x=arguments[0].getCoordinate();this.insertPoint(this._argIndex,x,_e.INTERIOR)}else arguments[0]instanceof Z&&this.insertPoint(this._argIndex,arguments[0],_e.INTERIOR)},h.prototype.addPolygon=function(x){this.addPolygonRing(x.getExteriorRing(),_e.EXTERIOR,_e.INTERIOR);for(var _=0;_<x.getNumInteriorRing();_++){var M=x.getInteriorRingN(_);this.addPolygonRing(M,_e.INTERIOR,_e.EXTERIOR)}},h.prototype.addEdge=function(x){this.insertEdge(x);var _=x.getCoordinates();this.insertPoint(this._argIndex,_[0],_e.BOUNDARY),this.insertPoint(this._argIndex,_[_.length-1],_e.BOUNDARY)},h.prototype.addLineString=function(x){var _=Zn.removeRepeatedPoints(x.getCoordinates());if(_.length<2)return this._hasTooFewPoints=!0,this._invalidPoint=_[0],null;var M=new Pf(_,new kr(this._argIndex,_e.INTERIOR));this._lineEdgeMap.put(x,M),this.insertEdge(M),De.isTrue(_.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this._argIndex,_[0]),this.insertBoundaryPoint(this._argIndex,_[_.length-1])},h.prototype.getInvalidPoint=function(){return this._invalidPoint},h.prototype.getBoundaryPoints=function(){for(var x=this.getBoundaryNodes(),_=new Array(x.size()).fill(null),M=0,z=x.iterator();z.hasNext();){var q=z.next();_[M++]=q.getCoordinate().copy()}return _},h.prototype.getBoundaryNodes=function(){return null===this._boundaryNodes&&(this._boundaryNodes=this._nodes.getBoundaryNodes(this._argIndex)),this._boundaryNodes},h.prototype.addSelfIntersectionNode=function(x,_,M){if(this.isBoundaryNode(x,_))return null;M===_e.BOUNDARY&&this._useBoundaryDeterminationRule?this.insertBoundaryPoint(x,_):this.insertPoint(x,_,M)},h.prototype.addPolygonRing=function(x,_,M){if(x.isEmpty())return null;var z=Zn.removeRepeatedPoints(x.getCoordinates());if(z.length<4)return this._hasTooFewPoints=!0,this._invalidPoint=z[0],null;var q=_,me=M;xt.isCCW(z)&&(q=M,me=_);var Ze=new Pf(z,new kr(this._argIndex,_e.BOUNDARY,q,me));this._lineEdgeMap.put(x,Ze),this.insertEdge(Ze),this.insertPoint(this._argIndex,z[0],_e.BOUNDARY)},h.prototype.insertPoint=function(x,_,M){var z=this._nodes.addNode(_),q=z.getLabel();null===q?z._label=new kr(x,M):q.setLocation(x,M)},h.prototype.createEdgeSetIntersector=function(){return new nf},h.prototype.addSelfIntersectionNodes=function(x){for(var _=this._edges.iterator();_.hasNext();)for(var M=_.next(),z=M.getLabel().getLocation(x),q=M.eiList.iterator();q.hasNext();){var me=q.next();this.addSelfIntersectionNode(x,me.coord,z)}},h.prototype.add=function(){if(1!==arguments.length)return u.prototype.add.apply(this,arguments);var x=arguments[0];if(x.isEmpty())return null;if(x instanceof fr&&(this._useBoundaryDeterminationRule=!1),x instanceof Ns)this.addPolygon(x);else if(x instanceof Wi)this.addLineString(x);else if(x instanceof ma)this.addPoint(x);else if(x instanceof Kc)this.addCollection(x);else if(x instanceof Ia)this.addCollection(x);else if(x instanceof fr)this.addCollection(x);else{if(!(x instanceof Yi))throw new Error(x.getClass().getName());this.addCollection(x)}},h.prototype.addCollection=function(x){for(var _=0;_<x.getNumGeometries();_++){var M=x.getGeometryN(_);this.add(M)}},h.prototype.locate=function(x){return Ct(this._parentGeom,ju)&&this._parentGeom.getNumGeometries()>50?(null===this._areaPtLocator&&(this._areaPtLocator=new Nl(this._parentGeom)),this._areaPtLocator.locate(x)):this._ptLocator.locate(x,this._parentGeom)},h.prototype.findEdge=function(){return 1===arguments.length?this._lineEdgeMap.get(arguments[0]):u.prototype.findEdge.apply(this,arguments)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h.determineBoundary=function(x,_){return x.isInBoundary(_)?_e.BOUNDARY:_e.INTERIOR},h}(Qi),Nc=function(){if(this._li=new tt,this._resultPrecisionModel=null,this._arg=null,1===arguments.length){var u=arguments[0];this.setComputationPrecision(u.getPrecisionModel()),this._arg=new Array(1).fill(null),this._arg[0]=new _c(0,u)}else if(2===arguments.length){var h=arguments[0],x=arguments[1],_=br.OGC_SFS_BOUNDARY_RULE;h.getPrecisionModel().compareTo(x.getPrecisionModel())>=0?this.setComputationPrecision(h.getPrecisionModel()):this.setComputationPrecision(x.getPrecisionModel()),this._arg=new Array(2).fill(null),this._arg[0]=new _c(0,h,_),this._arg[1]=new _c(1,x,_)}else if(3===arguments.length){var M=arguments[0],z=arguments[1],q=arguments[2];M.getPrecisionModel().compareTo(z.getPrecisionModel())>=0?this.setComputationPrecision(M.getPrecisionModel()):this.setComputationPrecision(z.getPrecisionModel()),this._arg=new Array(2).fill(null),this._arg[0]=new _c(0,M,q),this._arg[1]=new _c(1,z,q)}};Nc.prototype.getArgGeometry=function(u){return this._arg[u].getGeometry()},Nc.prototype.setComputationPrecision=function(u){this._resultPrecisionModel=u,this._li.setPrecisionModel(this._resultPrecisionModel)},Nc.prototype.interfaces_=function(){return[]},Nc.prototype.getClass=function(){return Nc};var Kl=function(){};Kl.prototype.interfaces_=function(){return[]},Kl.prototype.getClass=function(){return Kl},Kl.map=function(){if(arguments[0]instanceof Xt&&Ct(arguments[1],Kl.MapOp)){for(var u=arguments[0],h=arguments[1],x=new pn,_=0;_<u.getNumGeometries();_++){var M=h.map(u.getGeometryN(_));null!==M&&x.add(M)}return u.getFactory().buildGeometry(x)}if(Ct(arguments[0],Kr)&&Ct(arguments[1],Kl.MapOp)){for(var z=arguments[0],q=arguments[1],me=new pn,Ze=z.iterator();Ze.hasNext();){var lt=Ze.next(),Vt=q.map(lt);null!==Vt&&me.add(Vt)}return me}},Kl.MapOp=function(){};var vr=function(u){function h(){var x=arguments[0];u.call(this,x,arguments[1]),this._ptLocator=new ho,this._geomFact=null,this._resultGeom=null,this._graph=null,this._edgeList=new js,this._resultPolyList=new pn,this._resultLineList=new pn,this._resultPointList=new pn,this._graph=new Qi(new Qc),this._geomFact=x.getFactory()}return u&&(h.__proto__=u),(h.prototype=Object.create(u&&u.prototype)).constructor=h,h.prototype.insertUniqueEdge=function(x){var _=this._edgeList.findEqualEdge(x);if(null!==_){var M=_.getLabel(),z=x.getLabel();_.isPointwiseEqual(x)||(z=new kr(x.getLabel())).flip();var q=_.getDepth();q.isNull()&&q.add(M),q.add(z),M.merge(z)}else this._edgeList.add(x)},h.prototype.getGraph=function(){return this._graph},h.prototype.cancelDuplicateResultEdges=function(){for(var x=this._graph.getEdgeEnds().iterator();x.hasNext();){var _=x.next(),M=_.getSym();_.isInResult()&&M.isInResult()&&(_.setInResult(!1),M.setInResult(!1))}},h.prototype.isCoveredByLA=function(x){return!!this.isCovered(x,this._resultLineList)||!!this.isCovered(x,this._resultPolyList)},h.prototype.computeGeometry=function(x,_,M,z){var q=new pn;return q.addAll(x),q.addAll(_),q.addAll(M),q.isEmpty()?h.createEmptyResult(z,this._arg[0].getGeometry(),this._arg[1].getGeometry(),this._geomFact):this._geomFact.buildGeometry(q)},h.prototype.mergeSymLabels=function(){for(var x=this._graph.getNodes().iterator();x.hasNext();)x.next().getEdges().mergeSymLabels()},h.prototype.isCovered=function(x,_){for(var M=_.iterator();M.hasNext();){var z=M.next();if(this._ptLocator.locate(x,z)!==_e.EXTERIOR)return!0}return!1},h.prototype.replaceCollapsedEdges=function(){for(var x=new pn,_=this._edgeList.iterator();_.hasNext();){var M=_.next();M.isCollapsed()&&(_.remove(),x.add(M.getCollapsedEdge()))}this._edgeList.addAll(x)},h.prototype.updateNodeLabelling=function(){for(var x=this._graph.getNodes().iterator();x.hasNext();){var _=x.next(),M=_.getEdges().getLabel();_.getLabel().merge(M)}},h.prototype.getResultGeometry=function(x){return this.computeOverlay(x),this._resultGeom},h.prototype.insertUniqueEdges=function(x){for(var _=x.iterator();_.hasNext();){var M=_.next();this.insertUniqueEdge(M)}},h.prototype.computeOverlay=function(x){this.copyPoints(0),this.copyPoints(1),this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1),this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!0);var _=new pn;this._arg[0].computeSplitEdges(_),this._arg[1].computeSplitEdges(_),this.insertUniqueEdges(_),this.computeLabelsFromDepths(),this.replaceCollapsedEdges(),wl.checkValid(this._edgeList.getEdges()),this._graph.addEdges(this._edgeList.getEdges()),this.computeLabelling(),this.labelIncompleteNodes(),this.findResultAreaEdges(x),this.cancelDuplicateResultEdges();var M=new la(this._geomFact);M.add(this._graph),this._resultPolyList=M.getPolygons();var z=new Jo(this,this._geomFact,this._ptLocator);this._resultLineList=z.build(x);var q=new ql(this,this._geomFact,this._ptLocator);this._resultPointList=q.build(x),this._resultGeom=this.computeGeometry(this._resultPointList,this._resultLineList,this._resultPolyList,x)},h.prototype.labelIncompleteNode=function(x,_){var M=this._ptLocator.locate(x.getCoordinate(),this._arg[_].getGeometry());x.getLabel().setLocation(_,M)},h.prototype.copyPoints=function(x){for(var _=this._arg[x].getNodeIterator();_.hasNext();){var M=_.next();this._graph.addNode(M.getCoordinate()).setLabel(x,M.getLabel().getLocation(x))}},h.prototype.findResultAreaEdges=function(x){for(var _=this._graph.getEdgeEnds().iterator();_.hasNext();){var M=_.next(),z=M.getLabel();z.isArea()&&!M.isInteriorAreaEdge()&&h.isResultOfOp(z.getLocation(0,en.RIGHT),z.getLocation(1,en.RIGHT),x)&&M.setInResult(!0)}},h.prototype.computeLabelsFromDepths=function(){for(var x=this._edgeList.iterator();x.hasNext();){var _=x.next(),M=_.getLabel(),z=_.getDepth();if(!z.isNull()){z.normalize();for(var q=0;q<2;q++)M.isNull(q)||!M.isArea()||z.isNull(q)||(0===z.getDelta(q)?M.toLine(q):(De.isTrue(!z.isNull(q,en.LEFT),"depth of LEFT side has not been initialized"),M.setLocation(q,en.LEFT,z.getLocation(q,en.LEFT)),De.isTrue(!z.isNull(q,en.RIGHT),"depth of RIGHT side has not been initialized"),M.setLocation(q,en.RIGHT,z.getLocation(q,en.RIGHT))))}}},h.prototype.computeLabelling=function(){for(var x=this._graph.getNodes().iterator();x.hasNext();)x.next().getEdges().computeLabelling(this._arg);this.mergeSymLabels(),this.updateNodeLabelling()},h.prototype.labelIncompleteNodes=function(){for(var x=this._graph.getNodes().iterator();x.hasNext();){var _=x.next(),M=_.getLabel();_.isIsolated()&&(M.isNull(0)?this.labelIncompleteNode(_,0):this.labelIncompleteNode(_,1)),_.getEdges().updateLabelling(M)}},h.prototype.isCoveredByA=function(x){return!!this.isCovered(x,this._resultPolyList)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(Nc);vr.overlayOp=function(u,h,x){return new vr(u,h).getResultGeometry(x)},vr.intersection=function(u,h){if(u.isEmpty()||h.isEmpty())return vr.createEmptyResult(vr.INTERSECTION,u,h,u.getFactory());if(u.isGeometryCollection()){var x=h;return Gl.map(u,{interfaces_:function(){return[Kl.MapOp]},map:function(_){return _.intersection(x)}})}return u.checkNotGeometryCollection(u),u.checkNotGeometryCollection(h),ps.overlayOp(u,h,vr.INTERSECTION)},vr.symDifference=function(u,h){if(u.isEmpty()||h.isEmpty()){if(u.isEmpty()&&h.isEmpty())return vr.createEmptyResult(vr.SYMDIFFERENCE,u,h,u.getFactory());if(u.isEmpty())return h.copy();if(h.isEmpty())return u.copy()}return u.checkNotGeometryCollection(u),u.checkNotGeometryCollection(h),ps.overlayOp(u,h,vr.SYMDIFFERENCE)},vr.resultDimension=function(u,h,x){var _=h.getDimension(),M=x.getDimension(),z=-1;switch(u){case vr.INTERSECTION:z=Math.min(_,M);break;case vr.UNION:z=Math.max(_,M);break;case vr.DIFFERENCE:z=_;break;case vr.SYMDIFFERENCE:z=Math.max(_,M)}return z},vr.createEmptyResult=function(u,h,x,_){var M=null;switch(vr.resultDimension(u,h,x)){case-1:M=_.createGeometryCollection(new Array(0).fill(null));break;case 0:M=_.createPoint();break;case 1:M=_.createLineString();break;case 2:M=_.createPolygon()}return M},vr.difference=function(u,h){return u.isEmpty()?vr.createEmptyResult(vr.DIFFERENCE,u,h,u.getFactory()):h.isEmpty()?u.copy():(u.checkNotGeometryCollection(u),u.checkNotGeometryCollection(h),ps.overlayOp(u,h,vr.DIFFERENCE))},vr.isResultOfOp=function(){if(2===arguments.length){var u=arguments[0],h=arguments[1],x=u.getLocation(0),_=u.getLocation(1);return vr.isResultOfOp(x,_,h)}if(3===arguments.length){var M=arguments[0],z=arguments[1];switch(M===_e.BOUNDARY&&(M=_e.INTERIOR),z===_e.BOUNDARY&&(z=_e.INTERIOR),arguments[2]){case vr.INTERSECTION:return M===_e.INTERIOR&&z===_e.INTERIOR;case vr.UNION:return M===_e.INTERIOR||z===_e.INTERIOR;case vr.DIFFERENCE:return M===_e.INTERIOR&&z!==_e.INTERIOR;case vr.SYMDIFFERENCE:return M===_e.INTERIOR&&z!==_e.INTERIOR||M!==_e.INTERIOR&&z===_e.INTERIOR}return!1}},vr.INTERSECTION=1,vr.UNION=2,vr.DIFFERENCE=3,vr.SYMDIFFERENCE=4;var sl=function(){this._g=null,this._boundaryDistanceTolerance=null,this._linework=null,this._ptLocator=new ho,this._seg=new Wn;var u=arguments[0],h=arguments[1];this._g=u,this._boundaryDistanceTolerance=h,this._linework=this.extractLinework(u)};sl.prototype.isWithinToleranceOfBoundary=function(u){for(var h=0;h<this._linework.getNumGeometries();h++)for(var x=this._linework.getGeometryN(h).getCoordinateSequence(),_=0;_<x.size()-1;_++)if(x.getCoordinate(_,this._seg.p0),x.getCoordinate(_+1,this._seg.p1),this._seg.distance(u)<=this._boundaryDistanceTolerance)return!0;return!1},sl.prototype.getLocation=function(u){return this.isWithinToleranceOfBoundary(u)?_e.BOUNDARY:this._ptLocator.locate(u,this._g)},sl.prototype.extractLinework=function(u){var h=new Sl;u.apply(h);var x=h.getLinework(),_=Mr.toLineStringArray(x);return u.getFactory().createMultiLineString(_)},sl.prototype.interfaces_=function(){return[]},sl.prototype.getClass=function(){return sl};var Sl=function(){this._linework=null,this._linework=new pn};Sl.prototype.getLinework=function(){return this._linework},Sl.prototype.filter=function(u){if(u instanceof Ns){var h=u;this._linework.add(h.getExteriorRing());for(var x=0;x<h.getNumInteriorRing();x++)this._linework.add(h.getInteriorRingN(x))}},Sl.prototype.interfaces_=function(){return[oa]},Sl.prototype.getClass=function(){return Sl};var Bf=function(){this._g=null,this._doLeft=!0,this._doRight=!0,this._g=arguments[0]};Bf.prototype.extractPoints=function(u,h,x){for(var _=u.getCoordinates(),M=0;M<_.length-1;M++)this.computeOffsetPoints(_[M],_[M+1],h,x)},Bf.prototype.setSidesToGenerate=function(u,h){this._doLeft=u,this._doRight=h},Bf.prototype.getPoints=function(u){for(var h=new pn,x=Ss.getLines(this._g).iterator();x.hasNext();){var _=x.next();this.extractPoints(_,u,h)}return h},Bf.prototype.computeOffsetPoints=function(u,h,x,_){var M=h.x-u.x,z=h.y-u.y,q=Math.sqrt(M*M+z*z),me=x*M/q,Ze=x*z/q,lt=(h.x+u.x)/2,Vt=(h.y+u.y)/2;if(this._doLeft){var Yt=new Z(lt-Ze,Vt+me);_.add(Yt)}if(this._doRight){var wn=new Z(lt+Ze,Vt-me);_.add(wn)}},Bf.prototype.interfaces_=function(){return[]},Bf.prototype.getClass=function(){return Bf};var mo=function u(){this._geom=null,this._locFinder=null,this._location=new Array(3).fill(null),this._invalidLocation=null,this._boundaryDistanceTolerance=u.TOLERANCE,this._testCoords=new pn;var h=arguments[0],x=arguments[1],_=arguments[2];this._boundaryDistanceTolerance=u.computeBoundaryDistanceTolerance(h,x),this._geom=[h,x,_],this._locFinder=[new sl(this._geom[0],this._boundaryDistanceTolerance),new sl(this._geom[1],this._boundaryDistanceTolerance),new sl(this._geom[2],this._boundaryDistanceTolerance)]},hg={TOLERANCE:{configurable:!0}};mo.prototype.reportResult=function(u,h,x){qn.out.println("Overlay result invalid - A:"+_e.toLocationSymbol(h[0])+" B:"+_e.toLocationSymbol(h[1])+" expected:"+(x?"i":"e")+" actual:"+_e.toLocationSymbol(h[2]))},mo.prototype.isValid=function(u){return this.addTestPts(this._geom[0]),this.addTestPts(this._geom[1]),this.checkValid(u)},mo.prototype.checkValid=function(){if(1===arguments.length){for(var u=arguments[0],h=0;h<this._testCoords.size();h++){var x=this._testCoords.get(h);if(!this.checkValid(u,x))return this._invalidLocation=x,!1}return!0}if(2===arguments.length){var _=arguments[0],M=arguments[1];return this._location[0]=this._locFinder[0].getLocation(M),this._location[1]=this._locFinder[1].getLocation(M),this._location[2]=this._locFinder[2].getLocation(M),!!mo.hasLocation(this._location,_e.BOUNDARY)||this.isValidResult(_,this._location)}},mo.prototype.addTestPts=function(u){var h=new Bf(u);this._testCoords.addAll(h.getPoints(5*this._boundaryDistanceTolerance))},mo.prototype.isValidResult=function(u,h){var x=vr.isResultOfOp(h[0],h[1],u),_=!(x^h[2]===_e.INTERIOR);return _||this.reportResult(u,h,x),_},mo.prototype.getInvalidLocation=function(){return this._invalidLocation},mo.prototype.interfaces_=function(){return[]},mo.prototype.getClass=function(){return mo},mo.hasLocation=function(u,h){for(var x=0;x<3;x++)if(u[x]===h)return!0;return!1},mo.computeBoundaryDistanceTolerance=function(u,h){return Math.min(Zr.computeSizeBasedSnapTolerance(u),Zr.computeSizeBasedSnapTolerance(h))},mo.isValid=function(u,h,x,_){return new mo(u,h,_).isValid(x)},hg.TOLERANCE.get=function(){return 1e-6},Object.defineProperties(mo,hg);var go=function u(h){this._geomFactory=null,this._skipEmpty=!1,this._inputGeoms=null,this._geomFactory=u.extractFactory(h),this._inputGeoms=h};go.prototype.extractElements=function(u,h){if(null===u)return null;for(var x=0;x<u.getNumGeometries();x++){var _=u.getGeometryN(x);this._skipEmpty&&_.isEmpty()||h.add(_)}},go.prototype.combine=function(){for(var u=new pn,h=this._inputGeoms.iterator();h.hasNext();){var x=h.next();this.extractElements(x,u)}return 0===u.size()?null!==this._geomFactory?this._geomFactory.createGeometryCollection(null):null:this._geomFactory.buildGeometry(u)},go.prototype.interfaces_=function(){return[]},go.prototype.getClass=function(){return go},go.combine=function(){return 1===arguments.length?new go(arguments[0]).combine():2===arguments.length?new go(go.createList(arguments[0],arguments[1])).combine():3===arguments.length?new go(go.createList(arguments[0],arguments[1],arguments[2])).combine():void 0},go.extractFactory=function(u){return u.isEmpty()?null:u.iterator().next().getFactory()},go.createList=function(){if(2===arguments.length){var u=arguments[0],h=arguments[1],x=new pn;return x.add(u),x.add(h),x}if(3===arguments.length){var _=arguments[0],M=arguments[1],z=arguments[2],q=new pn;return q.add(_),q.add(M),q.add(z),q}};var Es=function(){this._inputPolys=null,this._geomFactory=null,this._inputPolys=arguments[0],null===this._inputPolys&&(this._inputPolys=new pn)},zd={STRTREE_NODE_CAPACITY:{configurable:!0}};Es.prototype.reduceToGeometries=function(u){for(var h=new pn,x=u.iterator();x.hasNext();){var _=x.next(),M=null;Ct(_,Dr)?M=this.unionTree(_):_ instanceof Xt&&(M=_),h.add(M)}return h},Es.prototype.extractByEnvelope=function(u,h,x){for(var _=new pn,M=0;M<h.getNumGeometries();M++){var z=h.getGeometryN(M);z.getEnvelopeInternal().intersects(u)?_.add(z):x.add(z)}return this._geomFactory.buildGeometry(_)},Es.prototype.unionOptimized=function(u,h){var x=u.getEnvelopeInternal(),_=h.getEnvelopeInternal();if(!x.intersects(_))return go.combine(u,h);if(u.getNumGeometries()<=1&&h.getNumGeometries()<=1)return this.unionActual(u,h);var M=x.intersection(_);return this.unionUsingEnvelopeIntersection(u,h,M)},Es.prototype.union=function(){if(null===this._inputPolys)throw new Error("union() method cannot be called twice");if(this._inputPolys.isEmpty())return null;this._geomFactory=this._inputPolys.iterator().next().getFactory();for(var u=new ch(Es.STRTREE_NODE_CAPACITY),h=this._inputPolys.iterator();h.hasNext();){var x=h.next();u.insert(x.getEnvelopeInternal(),x)}this._inputPolys=null;var _=u.itemsTree();return this.unionTree(_)},Es.prototype.binaryUnion=function(){if(1===arguments.length){var u=arguments[0];return this.binaryUnion(u,0,u.size())}if(3===arguments.length){var h=arguments[0],x=arguments[1],_=arguments[2];if(_-x<=1){var M=Es.getGeometry(h,x);return this.unionSafe(M,null)}if(_-x==2)return this.unionSafe(Es.getGeometry(h,x),Es.getGeometry(h,x+1));var z=Math.trunc((_+x)/2),q=this.binaryUnion(h,x,z),me=this.binaryUnion(h,z,_);return this.unionSafe(q,me)}},Es.prototype.repeatedUnion=function(u){for(var h=null,x=u.iterator();x.hasNext();){var _=x.next();h=null===h?_.copy():h.union(_)}return h},Es.prototype.unionSafe=function(u,h){return null===u&&null===h?null:null===u?h.copy():null===h?u.copy():this.unionOptimized(u,h)},Es.prototype.unionActual=function(u,h){return Es.restrictToPolygons(u.union(h))},Es.prototype.unionTree=function(u){var h=this.reduceToGeometries(u);return this.binaryUnion(h)},Es.prototype.unionUsingEnvelopeIntersection=function(u,h,x){var _=new pn,M=this.extractByEnvelope(x,u,_),z=this.extractByEnvelope(x,h,_),q=this.unionActual(M,z);return _.add(q),go.combine(_)},Es.prototype.bufferUnion=function(){if(1===arguments.length){var u=arguments[0];return u.get(0).getFactory().buildGeometry(u).buffer(0)}if(2===arguments.length){var h=arguments[0],x=arguments[1];return h.getFactory().createGeometryCollection([h,x]).buffer(0)}},Es.prototype.interfaces_=function(){return[]},Es.prototype.getClass=function(){return Es},Es.restrictToPolygons=function(u){if(Ct(u,ju))return u;var h=Ou.getPolygons(u);return 1===h.size()?h.get(0):u.getFactory().createMultiPolygon(Mr.toPolygonArray(h))},Es.getGeometry=function(u,h){return h>=u.size()?null:u.get(h)},Es.union=function(u){return new Es(u).union()},zd.STRTREE_NODE_CAPACITY.get=function(){return 4},Object.defineProperties(Es,zd);var rf=function(){};rf.prototype.interfaces_=function(){return[]},rf.prototype.getClass=function(){return rf},rf.union=function(u,h){if(u.isEmpty()||h.isEmpty()){if(u.isEmpty()&&h.isEmpty())return vr.createEmptyResult(vr.UNION,u,h,u.getFactory());if(u.isEmpty())return h.copy();if(h.isEmpty())return u.copy()}return u.checkNotGeometryCollection(u),u.checkNotGeometryCollection(h),ps.overlayOp(u,h,vr.UNION)},Y.GeoJSONReader=mc,Y.GeoJSONWriter=Bd,Y.OverlayOp=vr,Y.UnionOp=rf,Y.BufferOp=Qs,Object.defineProperty(Y,"__esModule",{value:!0})}(Fe)},1977:function(ze,Fe){"use strict";var Y,he;Y=function(){function ye(){return!0}function de(){return!1}function Me(){}return function H(){var Ye=[{name:"number",test:function(Te){return"number"==typeof Te}},{name:"string",test:function(Te){return"string"==typeof Te}},{name:"boolean",test:function(Te){return"boolean"==typeof Te}},{name:"Function",test:function(Te){return"function"==typeof Te}},{name:"Array",test:Array.isArray},{name:"Date",test:function(Te){return Te instanceof Date}},{name:"RegExp",test:function(Te){return Te instanceof RegExp}},{name:"Object",test:function(Te){return"object"==typeof Te&&null!==Te&&Te.constructor===Object}},{name:"null",test:function(Te){return null===Te}},{name:"undefined",test:function(Te){return void 0===Te}}],Je={name:"any",test:ye},Ae=[],Le=[],re={types:Ye,conversions:Le,ignore:Ae};function ae(Te){var tt=Tt(re.types,function(K){return K.name===Te});if(tt)return tt;if("any"===Te)return Je;var mt=Tt(re.types,function(K){return K.name.toLowerCase()===Te.toLowerCase()});throw new TypeError('Unknown type "'+Te+'"'+(mt?'. Did you mean "'+mt.name+'"?':""))}function ie(Te){return Te===Je?999:re.types.indexOf(Te)}function Ue(Te){var tt=Tt(re.types,function(mt){return mt.test(Te)});if(tt)return tt.name;throw new TypeError("Value has unknown type. Value: "+Te)}function le(Te){return Te.map(function(tt){var mt=tt.types.map(ue);return(tt.restParam?"...":"")+mt.join("|")}).join(",")}function xe(Te,tt){var mt=0===Te.indexOf("..."),xt=(mt?Te.length>3?Te.slice(3):"any":Te).split("|").map(kn).filter(qn).filter(Bn),on=function pt(Te,tt){var mt={};return Te.forEach(function(K){-1===tt.indexOf(K.from)&&-1!==tt.indexOf(K.to)&&!mt[K.from]&&(mt[K.from]=K)}),Object.keys(mt).map(function(K){return mt[K]})}(tt,xt),ft=xt.map(function(Kt){var Pn=ae(Kt);return{name:Kt,typeIndex:ie(Pn),test:Pn.test,conversion:null,conversionIndex:-1}}),Xt=on.map(function(Kt){var Pn=ae(Kt.from);return{name:Kt.from,typeIndex:ie(Pn),test:Pn.test,conversion:Kt,conversionIndex:tt.indexOf(Kt)}});return{types:ft.concat(Xt),restParam:mt}}function $e(Te){var tt=Ir(Te);return!!tt&&tt.restParam}function Ne(Te){return Te.types.some(function(tt){return null!=tt.conversion})}function Se(Te){if(!Te||0===Te.types.length)return ye;if(1===Te.types.length)return ae(Te.types[0].name).test;if(2===Te.types.length){var tt=ae(Te.types[0].name).test,mt=ae(Te.types[1].name).test;return function(on){return tt(on)||mt(on)}}var K=Te.types.map(function(xt){return ae(xt.name).test});return function(on){for(var ft=0;ft<K.length;ft++)if(K[ft](on))return!0;return!1}}function Pe(Te){var tt,mt,K;if($e(Te)){var xt=(tt=function Gi(Te){return Te.slice(0,Te.length-1)}(Te).map(Se)).length,on=Se(Ir(Te));return function(Kt){for(var Pn=0;Pn<tt.length;Pn++)if(!tt[Pn](Kt[Pn]))return!1;return function(Xt){for(var Kt=xt;Kt<Xt.length;Kt++)if(!on(Xt[Kt]))return!1;return!0}(Kt)&&Kt.length>=xt+1}}return 0===Te.length?function(Kt){return 0===Kt.length}:1===Te.length?(mt=Se(Te[0]),function(Kt){return mt(Kt[0])&&1===Kt.length}):2===Te.length?(mt=Se(Te[0]),K=Se(Te[1]),function(Kt){return mt(Kt[0])&&K(Kt[1])&&2===Kt.length}):(tt=Te.map(Se),function(Kt){for(var Pn=0;Pn<tt.length;Pn++)if(!tt[Pn](Kt[Pn]))return!1;return Kt.length===tt.length})}function Z(Te,tt){return tt<Te.params.length?Te.params[tt]:$e(Te.params)?Ir(Te.params):null}function Be(Te,tt,mt){var K=Z(Te,tt);return(K?mt?K.types.filter(He):K.types:[]).map(ue)}function ue(Te){return Te.name}function He(Te){return null==Te.conversion}function _e(Te,tt){var mt=function We(Te){for(var tt={},mt=0;mt<Te.length;mt++)tt[Te[mt]]=!0;return Object.keys(tt)}(Oe(Te,function(K){return Be(K,tt,!1)}));return-1!==mt.indexOf("any")?["any"]:mt}function kt(Te,tt,mt){var K,xt,Xt,on=Te||"unnamed",ft=mt;for(Xt=0;Xt<tt.length;Xt++){var Kt=ft.filter(function(oi){var qi=Se(Z(oi,Xt));return(Xt<oi.params.length||$e(oi.params))&&qi(tt[Xt])});if(0===Kt.length){if((xt=_e(ft,Xt)).length>0){var Pn=Ue(tt[Xt]);return(K=new TypeError("Unexpected type of argument in function "+on+" (expected: "+xt.join(" or ")+", actual: "+Pn+", index: "+Xt+")")).data={category:"wrongType",fn:on,index:Xt,actual:Pn,expected:xt},K}}else ft=Kt}var xr=ft.map(function(oi){return $e(oi.params)?1/0:oi.params.length});if(tt.length<Math.min.apply(null,xr))return xt=_e(ft,Xt),(K=new TypeError("Too few arguments in function "+on+" (expected: "+xt.join(" or ")+", index: "+tt.length+")")).data={category:"tooFewArgs",fn:on,index:tt.length,expected:xt},K;var br=Math.max.apply(null,xr);return tt.length>br?((K=new TypeError("Too many arguments in function "+on+" (expected: "+br+", actual: "+tt.length+")")).data={category:"tooManyArgs",fn:on,index:tt.length,expectedLength:br},K):((K=new TypeError('Arguments of type "'+tt.join(", ")+'" do not match any of the defined signatures of function '+on+".")).data={category:"mismatch",actual:tt.map(Ue)},K)}function Ct(Te){for(var tt=999,mt=0;mt<Te.types.length;mt++)He(Te.types[mt])&&(tt=Math.min(tt,Te.types[mt].typeIndex));return tt}function Ke(Te){for(var tt=999,mt=0;mt<Te.types.length;mt++)He(Te.types[mt])||(tt=Math.min(tt,Te.types[mt].conversionIndex));return tt}function rt(Te,tt){var mt;return 0!=(mt=Te.restParam-tt.restParam)||0!=(mt=Ne(Te)-Ne(tt))||0!=(mt=Ct(Te)-Ct(tt))?mt:Ke(Te)-Ke(tt)}function et(Te,tt){var K,xt,mt=Math.min(Te.params.length,tt.params.length);if(0!=(xt=Te.params.some(Ne)-tt.params.some(Ne)))return xt;for(K=0;K<mt;K++)if(0!=(xt=Ne(Te.params[K])-Ne(tt.params[K])))return xt;for(K=0;K<mt;K++)if(0!==(xt=rt(Te.params[K],tt.params[K])))return xt;return Te.params.length-tt.params.length}function je(Te){var tt,mt,K,xt,on=[],ft=[];switch(Te.types.forEach(function(Xt){Xt.conversion&&(on.push(ae(Xt.conversion.from).test),ft.push(Xt.conversion.convert))}),ft.length){case 0:return function(Kt){return Kt};case 1:return tt=on[0],K=ft[0],function(Kt){return tt(Kt)?K(Kt):Kt};case 2:return tt=on[0],mt=on[1],K=ft[0],xt=ft[1],function(Kt){return tt(Kt)?K(Kt):mt(Kt)?xt(Kt):Kt};default:return function(Kt){for(var Pn=0;Pn<ft.length;Pn++)if(on[Pn](Kt))return ft[Pn](Kt);return Kt}}}function $t(Te,tt){return function mt(K,xt,on){if(xt<K.length){var Kt,ft=K[xt],Xt=tt?ft.types.filter(He):ft.types;if(ft.restParam){var Pn=Xt.filter(He);Kt=Pn.length<Xt.length?[Pn,Xt]:[Xt]}else Kt=Xt.map(function(br){return[br]});return Oe(Kt,function(br){return mt(K,xt+1,on.concat([br]))})}return[on.map(function(br,oi){return{types:br,restParam:oi===K.length-1&&$e(K)}})]}(Te,0,[])}function Gt(Te,tt){if(0===Object.keys(tt).length)throw new SyntaxError("No signatures provided");var mt=[];Object.keys(tt).map(function(Or){return function we(Te,tt,mt){var K=[];return""!==Te.trim()&&(K=Te.split(",").map(kn).map(function(xt,on,ft){var Xt=xe(xt,mt);if(Xt.restParam&&on!==ft.length-1)throw new SyntaxError('Unexpected rest parameter "'+xt+'": only allowed for the last parameter');return Xt})),K.some(Qe)?null:{params:K,fn:tt}}(Or,tt[Or],re.conversions)}).filter($n).forEach(function(Or){var ua=Tt(mt,function(_s){return function tn(Te,tt){for(var mt=Math.max(Te.params.length,tt.params.length),K=0;K<mt;K++)if(!Vn(Be(Te,K,!0),Be(tt,K,!0)))return!1;var ft=Te.params.length,Xt=tt.params.length,Kt=$e(Te.params),Pn=$e(tt.params);return Kt?Pn?ft===Xt:Xt>=ft:Pn?ft>=Xt:ft===Xt}(_s,Or)});if(ua)throw new TypeError('Conflicting signatures "'+le(ua.params)+'" and "'+le(Or.params)+'".');mt.push(Or)});var K=Oe(mt,function(Or){return(Or?$t(Or.params,!1):[]).map(function(_s){return{params:_s,fn:Or.fn}})}).filter($n);K.sort(et);var xt=K[0]&&K[0].params.length<=2&&!$e(K[0].params),on=K[1]&&K[1].params.length<=2&&!$e(K[1].params),ft=K[2]&&K[2].params.length<=2&&!$e(K[2].params),Xt=K[3]&&K[3].params.length<=2&&!$e(K[3].params),Kt=K[4]&&K[4].params.length<=2&&!$e(K[4].params),Pn=K[5]&&K[5].params.length<=2&&!$e(K[5].params),xr=xt&&on&&ft&&Xt&&Kt&&Pn,br=K.map(function(Or){return Pe(Or.params)}),oi=xt?Se(K[0].params[0]):de,qi=on?Se(K[1].params[0]):de,ks=ft?Se(K[2].params[0]):de,ls=Xt?Se(K[3].params[0]):de,ar=Kt?Se(K[4].params[0]):de,Kr=Pn?Se(K[5].params[0]):de,hi=xt?Se(K[0].params[1]):de,Dr=on?Se(K[1].params[1]):de,pn=ft?Se(K[2].params[1]):de,Yu=Xt?Se(K[3].params[1]):de,co=Kt?Se(K[4].params[1]):de,Zn=Pn?Se(K[5].params[1]):de,Cs=K.map(function(Or){return function dt(Te,tt){var mt=tt;if(Te.some(Ne)){var K=$e(Te),xt=Te.map(je);mt=function(){for(var Kt=[],Pn=K?arguments.length-1:arguments.length,xr=0;xr<Pn;xr++)Kt[xr]=xt[xr](arguments[xr]);return K&&(Kt[Pn]=arguments[Pn].map(xt[Pn])),tt.apply(this,Kt)}}var on=mt;if($e(Te)){var ft=Te.length-1;on=function(){return mt.apply(this,ri(arguments,0,ft).concat([ri(arguments,ft)]))}}return on}(Or.params,Or.fn)}),da=xt?Cs[0]:Me,Wo=on?Cs[1]:Me,fu=ft?Cs[2]:Me,Hc=Xt?Cs[3]:Me,Ao=Kt?Cs[4]:Me,oh=Pn?Cs[5]:Me,zn=xt?K[0].params.length:-1,Xc=on?K[1].params.length:-1,Za=ft?K[2].params.length:-1,Zu=Xt?K[3].params.length:-1,Ur=Kt?K[4].params.length:-1,Ki=Pn?K[5].params.length:-1,oa=xr?6:0,cs=K.length,Yi=function(){for(var ua=oa;ua<cs;ua++)if(br[ua](arguments))return Cs[ua].apply(this,arguments);return re.onMismatch(Te,arguments,K)},Ia=function Or(ua,_s){return arguments.length===zn&&oi(ua)&&hi(_s)?da.apply(Or,arguments):arguments.length===Xc&&qi(ua)&&Dr(_s)?Wo.apply(Or,arguments):arguments.length===Za&&ks(ua)&&pn(_s)?fu.apply(Or,arguments):arguments.length===Zu&&ls(ua)&&Yu(_s)?Hc.apply(Or,arguments):arguments.length===Ur&&ar(ua)&&co(_s)?Ao.apply(Or,arguments):arguments.length===Ki&&Kr(ua)&&Zn(_s)?oh.apply(Or,arguments):Yi.apply(Or,arguments)};try{Object.defineProperty(Ia,"name",{value:Te})}catch{}return Ia.signatures=function zt(Te){var tt={};return Te.forEach(function(mt){mt.params.some(Ne)||$t(mt.params,!0).forEach(function(K){tt[le(K)]=mt.fn})}),tt}(K),Ia}function Rn(Te,tt,mt){throw kt(Te,tt,mt)}function Bn(Te){return-1===re.ignore.indexOf(Te)}function kn(Te){return Te.trim()}function qn(Te){return!!Te}function $n(Te){return null!==Te}function Qe(Te){return 0===Te.types.length}function Ir(Te){return Te[Te.length-1]}function ri(Te,tt,mt){return Array.prototype.slice.call(Te,tt,mt)}function Yn(Te,tt){return-1!==Te.indexOf(tt)}function Vn(Te,tt){for(var mt=0;mt<Te.length;mt++)if(Yn(tt,Te[mt]))return!0;return!1}function Tt(Te,tt){for(var mt=0;mt<Te.length;mt++)if(tt(Te[mt]))return Te[mt]}function Oe(Te,tt){return Array.prototype.concat.apply([],Te.map(tt))}function De(Te){for(var tt="",mt=0;mt<Te.length;mt++){var K=Te[mt];if(("object"==typeof K.signatures||"string"==typeof K.signature)&&""!==K.name)if(""===tt)tt=K.name;else if(tt!==K.name){var xt=new Error("Function names do not match (expected: "+tt+", actual: "+K.name+")");throw xt.data={actual:K.name,expected:tt},xt}}return tt}function nt(Te){var tt,mt={};function K(Xt,Kt){if(mt.hasOwnProperty(Xt)&&Kt!==mt[Xt])throw(tt=new Error('Signature "'+Xt+'" is defined twice')).data={signature:Xt},tt}for(var xt=0;xt<Te.length;xt++){var on=Te[xt];if("object"==typeof on.signatures)for(var ft in on.signatures)on.signatures.hasOwnProperty(ft)&&(K(ft,on.signatures[ft]),mt[ft]=on.signatures[ft]);else{if("string"!=typeof on.signature)throw(tt=new TypeError("Function is no typed-function (index: "+xt+")")).data={index:xt},tt;K(on.signature,on),mt[on.signature]=on}}return mt}return(re=Gt("typed",{"string, Object":Gt,Object:function(Te){var tt=[];for(var mt in Te)Te.hasOwnProperty(mt)&&tt.push(Te[mt]);return Gt(De(tt),Te)},"...Function":function(Te){return Gt(De(Te),nt(Te))},"string, ...Function":function(Te,tt){return Gt(Te,nt(tt))}})).create=H,re.types=Ye,re.conversions=Le,re.ignore=Ae,re.onMismatch=Rn,re.throwMismatchError=Rn,re.createError=kt,re.convert=function pe(Te,tt){var mt=Ue(Te);if(tt===mt)return Te;for(var K=0;K<re.conversions.length;K++){var xt=re.conversions[K];if(xt.from===mt&&xt.to===tt)return xt.convert(Te)}throw new Error("Cannot convert from "+mt+" to "+tt)},re.find=function Q(Te,tt){if(!Te.signatures)throw new TypeError("Function is no typed-function");var mt;if("string"==typeof tt){mt=tt.split(",");for(var K=0;K<mt.length;K++)mt[K]=mt[K].trim()}else{if(!Array.isArray(tt))throw new TypeError("String array or a comma separated string expected");mt=tt}var xt=mt.join(","),on=Te.signatures[xt];if(on)return on;throw new TypeError("Signature not found (signature: "+(Te.name||"unnamed")+"("+mt.join(", ")+"))")},re.addType=function(Te,tt){if(!Te||"string"!=typeof Te.name||"function"!=typeof Te.test)throw new TypeError("Object with properties {name: string, test: function} expected");if(!1!==tt)for(var mt=0;mt<re.types.length;mt++)if("Object"===re.types[mt].name)return void re.types.splice(mt,0,Te);re.types.push(Te)},re.addConversion=function(Te){if(!Te||"string"!=typeof Te.from||"string"!=typeof Te.to||"function"!=typeof Te.convert)throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");re.conversions.push(Te)},re}()},void 0!==(he=Y.apply(Fe,[]))&&(ze.exports=he)},5410:()=>{},8628:()=>{},1601:()=>{},7792:()=>{},8963:()=>{},5042:()=>{},5861:(ze,Fe,Y)=>{"use strict";function te(ye,de,Me,H,Ye,Je,Ae){try{var Le=ye[Je](Ae),re=Le.value}catch(ae){return void Me(ae)}Le.done?de(re):Promise.resolve(re).then(H,Ye)}function he(ye){return function(){var de=this,Me=arguments;return new Promise(function(H,Ye){var Je=ye.apply(de,Me);function Ae(re){te(Je,H,Ye,Ae,Le,"next",re)}function Le(re){te(Je,H,Ye,Ae,Le,"throw",re)}Ae(void 0)})}}Y.d(Fe,{Z:()=>he})}},UL={};function nn(ze){var Fe=UL[ze];if(void 0!==Fe)return Fe.exports;var Y=UL[ze]={id:ze,loaded:!1,exports:{}};return eV[ze].call(Y.exports,Y,Y.exports,nn),Y.loaded=!0,Y.exports}nn.amdD=function(){throw new Error("define cannot be used indirect")},nn.amdO={},nn.n=ze=>{var Fe=ze&&ze.__esModule?()=>ze.default:()=>ze;return nn.d(Fe,{a:Fe}),Fe},nn.d=(ze,Fe)=>{for(var Y in Fe)nn.o(Fe,Y)&&!nn.o(ze,Y)&&Object.defineProperty(ze,Y,{enumerable:!0,get:Fe[Y]})},nn.o=(ze,Fe)=>Object.prototype.hasOwnProperty.call(ze,Fe),nn.r=ze=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(ze,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(ze,"__esModule",{value:!0})},nn.nmd=ze=>(ze.paths=[],ze.children||(ze.children=[]),ze),(()=>{"use strict";var ze={};nn.r(ze),nn.d(ze,{arraysEqual:()=>Kt,assert:()=>K,assertNonNegativeIntegerDimensions:()=>cs,assertNonNull:()=>on,assertShapesMatch:()=>xt,bytesFromStringArray:()=>Cs,bytesPerElement:()=>Zn,checkConversionForErrors:()=>pn,clamp:()=>Oe,computeStrides:()=>zn,convertBackendValuesAndArrayBuffer:()=>Zu,createScalarValue:()=>ji,createShuffledIndices:()=>oi,decodeString:()=>Va,distSquared:()=>mt,encodeString:()=>sf,fetch:()=>Ud,fingerPrint64:()=>fi,flatten:()=>af,getArrayFromDType:()=>Dr,getTypedArrayFromDType:()=>hi,hasEncodingLoss:()=>co,hexToLong:()=>h,indexToLoc:()=>Ia,inferDtype:()=>Hc,inferFromImplicitShape:()=>ls,isBoolean:()=>Wo,isFunction:()=>Ao,isInt:()=>Pn,isNumber:()=>fu,isPromise:()=>Or,isScalarShape:()=>Xt,isString:()=>da,isTypedArray:()=>yo,isValidDtype:()=>Yu,locToIndex:()=>Yi,makeOnesTypedArray:()=>Ur,makeZerosNestedTypedArray:()=>oa,makeZerosTypedArray:()=>Ki,nearestDivisor:()=>oh,nearestLargerEven:()=>De,now:()=>Fs,parseAxisParam:()=>ar,randUniform:()=>tt,repeatedTry:()=>ks,rightPad:()=>qi,shuffle:()=>Tt,shuffleCombo:()=>We,sizeFromShape:()=>ft,sizeToSquarishShape:()=>br,squeezeShape:()=>Kr,sum:()=>Te,swap:()=>nt,tanh:()=>xr,toNestedArray:()=>Za,toTypedArray:()=>io});var Fe={};nn.r(Fe),nn.d(Fe,{assertTypesMatch:()=>dw,getTensorsInContainer:()=>zf,isTensorInList:()=>wg,makeTypesMatch:()=>fa});var Y={};nn.r(Y),nn.d(Y,{isBrowser:()=>gh,isMobile:()=>Pp,mockIsMobile:()=>Br});var te={};nn.r(te),nn.d(te,{Serializable:()=>xh,SerializationMap:()=>El,registerClass:()=>yn});var he={};nn.r(he),nn.d(he,{assertAndGetBroadcastShape:()=>$r,getBroadcastDims:()=>np,getReductionAxes:()=>qa});var ye={};nn.r(ye),nn.d(ye,{browserFiles:()=>CA,browserHTTPRequest:()=>im,concatenateArrayBuffers:()=>Xd,copyModel:()=>lA,decodeWeights:()=>nv,encodeWeights:()=>tv,fromMemory:()=>DA,fromMemorySync:()=>qf,getLoadHandlers:()=>iv,getModelArtifactsForJSON:()=>Yl,getModelArtifactsForJSONSync:()=>Hr,getModelArtifactsInfoForJSON:()=>Fp,getSaveHandlers:()=>Kd,getWeightSpecs:()=>Sg,http:()=>rm,isHTTPScheme:()=>rp,listModels:()=>XL,loadWeights:()=>bv,moveModel:()=>lv,registerLoadRouter:()=>eA,registerSaveRouter:()=>Nw,removeModel:()=>KL,weightsLoaderFactory:()=>jw,withSaveHandler:()=>t_,withSaveHandlerSync:()=>n_});var de={};nn.r(de),nn.d(de,{confusionMatrix:()=>FA});var Me={};nn.r(Me),nn.d(Me,{fromPixels:()=>l_,fromPixelsAsync:()=>zA,toPixels:()=>u_});var H={};nn.r(H),nn.d(H,{prepareAndValidate:()=>sm});var Ye={};nn.r(Ye),nn.d(Ye,{calculateShapes:()=>Wf,validateInput:()=>Lg,validateUpdateShape:()=>Iv});var Je={};nn.r(Je),nn.d(Je,{assertParamsValid:()=>$g,computeFlatOffset:()=>Rv,computeOutShape:()=>Av,getNormalizedAxes:()=>ff,isSliceContinous:()=>Mv,maskToAxes:()=>VA,parseSliceParams:()=>Bg,sliceInfo:()=>Dv,startForAxis:()=>d_,startIndicesWithElidedDims:()=>h_,stopForAxis:()=>GA,stopIndicesWithElidedDims:()=>am,stridesForAxis:()=>p_,stridesWithElidedDims:()=>Tv});var Ae={};nn.r(Ae),nn.d(Ae,{TEST_EPSILON_FLOAT16:()=>m_,createVideoElement:()=>v_,encodeStrings:()=>Fv,expectArrayBuffersEqual:()=>KA,expectArraysClose:()=>g_,expectArraysEqual:()=>WA,expectNumbersClose:()=>HA,expectPromiseToFail:()=>y_,expectValuesInRange:()=>XA,play:()=>YA,testEpsilon:()=>Ov});var Le={};nn.r(Le),nn.d(Le,{conv2d:()=>qN,depthwiseConv2d:()=>KN,matMul:()=>z1});var re={};nn.r(re),nn.d(re,{collectGatherOpShapeInfo:()=>gx,computeOutShape:()=>GS,segOpComputeOptimalWindowSize:()=>mx});var ae={};nn.r(ae),nn.d(ae,{ERF_A1:()=>ex,ERF_A2:()=>tx,ERF_A3:()=>nx,ERF_A4:()=>rx,ERF_A5:()=>ix,ERF_P:()=>P0,PARALLELIZE_THRESHOLD:()=>j1,RowPartitionType:()=>nc,SELU_SCALE:()=>k0,SELU_SCALEALPHA:()=>O0,applyActivation:()=>I0,assertAndGetBroadcastShape:()=>$r,assertAxesAreInnerMostDims:()=>Vo,assertParamsConsistent:()=>Y1,assignToTypedArray:()=>MS,axesAreInnerMostDims:()=>h1,calculateShapes:()=>Wf,checkEinsumDimSizes:()=>ux,checkPadOnDimRoundingMode:()=>vu,combineLocations:()=>p1,combineRaggedTensorToTensorShapes:()=>SS,complexWithEvenIndex:()=>AS,complexWithOddIndex:()=>TS,computeConv2DInfo:()=>vo,computeConv3DInfo:()=>_h,computeDefaultPad:()=>Nh,computeDilation2DInfo:()=>lm,computeOptimalWindowSize:()=>Im,computeOutAndReduceShapes:()=>ao,computeOutShape:()=>tc,computePool2DInfo:()=>jl,computePool3DInfo:()=>pf,convertConv2DDataFormat:()=>Hf,decodeEinsumEquation:()=>ox,eitherStridesOrDilationsAreOne:()=>Uo,expandShapeToKeepDim:()=>Oa,exponent:()=>DS,exponents:()=>RS,fromStringArrayToUint8:()=>qS,fromUint8ToStringArray:()=>mf,getAxesPermutation:()=>na,getBroadcastDims:()=>np,getComplexWithIndex:()=>sx,getEinsumComputePath:()=>lx,getEinsumPermutation:()=>F0,getFusedBiasGradient:()=>E0,getFusedDyActivation:()=>Nm,getImageCenter:()=>J1,getInnerMostAxes:()=>ka,getPermuted:()=>pd,getRaggedRank:()=>Z1,getReductionAxes:()=>qa,getReshaped:()=>Cm,getReshapedPermuted:()=>Am,getRowPartitionTypesHelper:()=>ES,getSliceBeginCoords:()=>Q1,getSliceSize:()=>D0,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>fx,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>PS,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>FS,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>BS,getSparseReshapeInputOutputMismatchErrorMessage:()=>zS,getSparseReshapeInputOutputMultipleErrorMessage:()=>hx,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>LS,getSparseReshapeNegativeOutputDimErrorMessage:()=>$S,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>VS,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>px,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>dx,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>US,getUndoAxesPermutation:()=>Ch,isIdentityPermutation:()=>L0,log:()=>$f,mergeRealAndImagArrays:()=>Dc,prepareAndValidate:()=>sm,prepareSplitSize:()=>cx,segment_util:()=>re,shouldFuse:()=>Sm,slice_util:()=>Je,splitRealAndImagArrays:()=>CS,stridesOrDilationsArePositive:()=>Eh,tupleValuesAreOne:()=>Sh,upcastType:()=>$u,validateDefaultValueShape:()=>IS,validateInput:()=>Lg,validateUpdateShape:()=>Iv,warn:()=>eu});var ie={};nn.r(ie),nn.d(ie,{nonMaxSuppressionV3Impl:()=>A0,nonMaxSuppressionV4Impl:()=>Em,nonMaxSuppressionV5Impl:()=>T0,whereImpl:()=>_0});var Ue={};nn.r(Ue),nn.d(Ue,{maxNorm:()=>S3,minMaxNorm:()=>E3,nonNeg:()=>JE,unitNorm:()=>nh});var Q={};nn.r(Q),nn.d(Q,{constant:()=>ik,glorotNormal:()=>ok,glorotUniform:()=>T3,heNormal:()=>M3,heUniform:()=>uk,identity:()=>sk,leCunNormal:()=>R3,leCunUniform:()=>D3,ones:()=>ru,orthogonal:()=>lk,randomNormal:()=>C3,randomUniform:()=>QE,truncatedNormal:()=>A3,varianceScaling:()=>ak,zeros:()=>I3});var pe={};nn.r(pe),nn.d(pe,{Layer:()=>ai,RNN:()=>Fh,RNNCell:()=>sy,activation:()=>dP,add:()=>vP,alphaDropout:()=>bt,average:()=>mC,averagePooling1d:()=>vb,averagePooling2d:()=>c,averagePooling3d:()=>m,avgPool1d:()=>NP,avgPool2d:()=>f,avgPool3d:()=>y,avgPooling1d:()=>xb,avgPooling2d:()=>d,avgPooling3d:()=>b,batchNormalization:()=>yC,bidirectional:()=>be,categoryEncoding:()=>Nt,centerCrop:()=>Ft,concatenate:()=>yb,conv1d:()=>uP,conv2d:()=>lP,conv2dTranspose:()=>cP,conv3d:()=>fP,conv3dTranspose:()=>hP,convLstm2d:()=>G,convLstm2dCell:()=>ee,cropping2D:()=>fC,dense:()=>by,depthwiseConv2d:()=>pC,dot:()=>gC,dropout:()=>wy,elu:()=>Xm,embedding:()=>yP,flatten:()=>gP,gaussianDropout:()=>ht,gaussianNoise:()=>at,globalAveragePooling1d:()=>I,globalAveragePooling2d:()=>C,globalMaxPool1d:()=>Ce,globalMaxPool2d:()=>fe,globalMaxPooling1d:()=>A,globalMaxPooling2d:()=>T,gru:()=>P,gruCell:()=>F,input:()=>bI,inputLayer:()=>lC,layerNormalization:()=>_P,leakyReLU:()=>oP,lstm:()=>B,lstmCell:()=>J,masking:()=>ct,maxPool1d:()=>Ve,maxPool2d:()=>qe,maxPooling1d:()=>E,maxPooling2d:()=>S,maxPooling3d:()=>R,maximum:()=>xP,minimum:()=>bP,multiply:()=>wP,permute:()=>gb,prelu:()=>cC,randomWidth:()=>Ut,reLU:()=>db,repeatVector:()=>mb,rescaling:()=>Ge,reshape:()=>dC,resizing:()=>Re,rnn:()=>ne,separableConv2d:()=>pP,simpleRNN:()=>j,simpleRNNCell:()=>oe,softmax:()=>I$,spatialDropout1d:()=>mP,stackedRNNCells:()=>X,thresholdedReLU:()=>C$,timeDistributed:()=>Ie,upSampling2d:()=>hC,zeroPadding2d:()=>_y});var le={};nn.r(le),nn.d(le,{MAPE:()=>dr,MSE:()=>st,binaryAccuracy:()=>un,binaryCrossentropy:()=>At,categoricalAccuracy:()=>an,categoricalCrossentropy:()=>jt,cosineProximity:()=>Cn,mape:()=>Ln,meanAbsoluteError:()=>sn,meanAbsolutePercentageError:()=>Sr,meanSquaredError:()=>sr,mse:()=>wt,precision:()=>dn,recall:()=>Nn,sparseCategoricalAccuracy:()=>qt});var xe={};nn.r(xe),nn.d(xe,{modelFromJSON:()=>a$});var we={};nn.r(we),nn.d(we,{l1:()=>Zt,l1l2:()=>Qt,l2:()=>vn});var $e={};nn.r($e),nn.d($e,{json:()=>zV});var Ne={};nn.r(Ne),nn.d(Ne,{json:()=>UV});var Se={};nn.r(Se),nn.d(Se,{json:()=>VV});var Pe={};nn.r(Pe),nn.d(Pe,{json:()=>GV});var Z={};nn.r(Z),nn.d(Z,{json:()=>qV});var Be={};nn.r(Be),nn.d(Be,{json:()=>WV});var ue={};nn.r(ue),nn.d(ue,{json:()=>HV});var He={};nn.r(He),nn.d(He,{json:()=>XV});var _e={};nn.r(_e),nn.d(_e,{json:()=>KV});var kt={};nn.r(kt),nn.d(kt,{json:()=>YV});var Ct={};nn.r(Ct),nn.d(Ct,{json:()=>ZV});var Ke={};nn.r(Ke),nn.d(Ke,{json:()=>jV});var rt={};nn.r(rt),nn.d(rt,{json:()=>JV});var et={};nn.r(et),nn.d(et,{json:()=>QV});var pt={};nn.r(pt),nn.d(pt,{json:()=>eG});var dt={};nn.r(dt),nn.d(dt,{json:()=>tG});var je={};nn.r(je),nn.d(je,{json:()=>nG});var zt={};nn.r(zt),nn.d(zt,{json:()=>rG});var $t={};nn.r($t),nn.d($t,{json:()=>iG});var tn={};nn.r(tn),nn.d(tn,{OP_SCOPE_SUFFIX:()=>ev,abs:()=>Ra,acos:()=>Bv,acosh:()=>zv,add:()=>gn,addN:()=>Uv,all:()=>zg,any:()=>om,argMax:()=>wh,argMin:()=>Vv,asin:()=>Gv,asinh:()=>Ug,atan:()=>Vg,atan2:()=>qv,atanh:()=>Gg,avgPool:()=>Xp,avgPool3d:()=>Xv,basicLSTMCell:()=>Kv,batchNorm:()=>Kp,batchNorm2d:()=>Yv,batchNorm3d:()=>Wg,batchNorm4d:()=>Zv,batchToSpaceND:()=>cm,bincount:()=>jv,booleanMaskAsync:()=>LN,broadcastArgs:()=>Jv,broadcastTo:()=>sp,buffer:()=>zr,cast:()=>_n,ceil:()=>Qv,clipByValue:()=>xu,clone:()=>Ic,complex:()=>Uf,concat:()=>Da,concat1d:()=>Hg,concat2d:()=>t1,concat3d:()=>Xg,concat4d:()=>n1,conv1d:()=>fm,conv2d:()=>Xf,conv2dTranspose:()=>Kg,conv3d:()=>i1,conv3dTranspose:()=>s1,cos:()=>Zp,cosh:()=>Yg,cosineWindow:()=>S0,cumprod:()=>hm,cumsum:()=>pm,denseBincount:()=>Zg,depthToSpace:()=>a1,depthwiseConv2d:()=>ap,diag:()=>B_,dilation2d:()=>o1,div:()=>ur,divNoNan:()=>u1,dot:()=>l1,dropout:()=>N0,einsum:()=>c1,elu:()=>jp,enclosingPowerOfTwo:()=>B1,equal:()=>zu,erf:()=>f1,euclideanNorm:()=>d1,exp:()=>Uu,expandDims:()=>tu,expm1:()=>m1,eye:()=>Jg,fft:()=>ad,fill:()=>tp,floor:()=>Qp,floorDiv:()=>Rg,fused:()=>Le,gather:()=>up,gatherND:()=>$1,greater:()=>bu,greaterEqual:()=>Kf,ifft:()=>od,imag:()=>Up,image:()=>ec,inTopKAsync:()=>VN,irfft:()=>v0,isFinite:()=>Qg,isInf:()=>g1,isNaN:()=>y1,leakyRelu:()=>ed,less:()=>td,lessEqual:()=>Ah,linalg:()=>H1,linspace:()=>Z_,localResponseNormalization:()=>v1,log:()=>ol,log1p:()=>Vu,logSigmoid:()=>x1,logSoftmax:()=>cp,logSumExp:()=>e0,logicalAnd:()=>Jl,logicalNot:()=>Pa,logicalOr:()=>t0,logicalXor:()=>b1,losses:()=>wS,lowerBound:()=>J_,matMul:()=>ni,max:()=>Il,maxPool:()=>mm,maxPool3d:()=>df,maxPoolWithArgmax:()=>Q_,maximum:()=>cf,mean:()=>ra,meshgrid:()=>eM,min:()=>op,minimum:()=>Th,mirrorPad:()=>nN,mod:()=>w1,moments:()=>gm,movingAverage:()=>$N,mul:()=>_t,multiRNNCell:()=>iN,multinomial:()=>wu,neg:()=>Ls,norm:()=>Jp,notEqual:()=>fp,oneHot:()=>ip,ones:()=>ul,onesLike:()=>qu,op:()=>yt,outerProduct:()=>aN,pad:()=>Yf,pad1d:()=>uN,pad2d:()=>Mc,pad3d:()=>cN,pad4d:()=>uM,pool:()=>_1,pow:()=>lf,prelu:()=>nd,print:()=>Tg,prod:()=>N1,raggedGather:()=>pN,raggedRange:()=>S1,raggedTensorToTensor:()=>dN,rand:()=>E1,randomGamma:()=>A1,randomNormal:()=>s0,randomStandardNormal:()=>yN,randomUniform:()=>Mh,range:()=>pp,real:()=>Vp,reciprocal:()=>a0,relu:()=>Rc,relu6:()=>o0,reshape:()=>St,reverse:()=>Ql,reverse1d:()=>bN,reverse2d:()=>CM,reverse3d:()=>_N,reverse4d:()=>T1,rfft:()=>bm,round:()=>u0,rsqrt:()=>vm,scalar:()=>mr,scatterND:()=>BN,searchSorted:()=>dm,selu:()=>l0,separableConv2d:()=>c0,setdiff1dAsync:()=>EN,sigmoid:()=>Tc,sign:()=>h0,signal:()=>bS,sin:()=>p0,sinh:()=>m0,slice:()=>li,slice1d:()=>g0,slice2d:()=>y0,slice3d:()=>id,slice4d:()=>sd,softmax:()=>xm,softplus:()=>lp,spaceToBatchND:()=>ym,sparse:()=>X1,sparseToDense:()=>UN,spectral:()=>xS,split:()=>_u,sqrt:()=>zo,square:()=>Nr,squaredDifference:()=>x0,squeeze:()=>Zf,stack:()=>Wu,step:()=>dp,stridedSlice:()=>MN,string:()=>_S,sub:()=>Hn,sum:()=>er,tan:()=>R1,tanh:()=>Ih,tensor:()=>al,tensor1d:()=>bo,tensor2d:()=>jf,tensor3d:()=>Ac,tensor4d:()=>RN,tensor5d:()=>DN,tensor6d:()=>ud,tensorScatterUpdate:()=>kN,tile:()=>Cl,topk:()=>b0,transpose:()=>ui,truncatedNormal:()=>w0,unique:()=>D1,unsortedSegmentSum:()=>wm,unstack:()=>Al,upperBound:()=>O1,variable:()=>k1,where:()=>xo,whereAsync:()=>F1,zeros:()=>Wa,zerosLike:()=>di});var Gt={};nn.r(Gt),nn.d(Gt,{CSVDataset:()=>Z$,Dataset:()=>Nb,FileDataSource:()=>tB,TextLineDataset:()=>X$,URLDataSource:()=>nB,array:()=>dq,csv:()=>Eq,func:()=>Iq,generator:()=>Cq,microphone:()=>Tq,version_data:()=>rB,webcam:()=>Aq,zip:()=>mq});var Rn={};nn.r(Rn),nn.d(Rn,{addImpl:()=>oB,bincountImpl:()=>KP,bincountReduceImpl:()=>uB,castImpl:()=>aB,ceilImpl:()=>lB,concatImpl:()=>cB,equalImpl:()=>fB,expImpl:()=>pB,expm1Impl:()=>mB,floorDivImpl:()=>yB,floorImpl:()=>gB,gatherNdImpl:()=>vB,gatherV2Impl:()=>xB,greaterEqualImpl:()=>wB,greaterImpl:()=>bB,lessEqualImpl:()=>NB,lessImpl:()=>_B,linSpaceImpl:()=>SB,logImpl:()=>EB,maxImpl:()=>IB,maximumImpl:()=>CB,minimumImpl:()=>AB,multiplyImpl:()=>YP,negImpl:()=>TB,notEqualImpl:()=>MB,prodImpl:()=>RB,raggedGatherImpl:()=>OB,raggedRangeImpl:()=>PB,raggedTensorToTensorImpl:()=>$B,rangeImpl:()=>BB,rsqrtImpl:()=>zB,scatterImpl:()=>jm,sigmoidImpl:()=>E9,simpleAbsImpl:()=>sB,sliceImpl:()=>VB,sparseFillEmptyRowsImpl:()=>GB,sparseReshapeImpl:()=>qB,sparseSegmentReductionImpl:()=>jP,sqrtImpl:()=>A9,squaredDifferenceImpl:()=>WB,staticRegexReplaceImpl:()=>HB,stridedSliceImpl:()=>XB,stringNGramsImpl:()=>KB,stringSplitImpl:()=>YB,stringToHashBucketFastImpl:()=>ZB,subImpl:()=>jB,tileImpl:()=>JB,topKImpl:()=>e4,transposeImpl:()=>ZP,uniqueImpl:()=>t4});var Bn={};nn.r(Bn),nn.d(Bn,{assertNotComplex:()=>Ty,bindCanvasToFramebuffer:()=>oK,bindColorTextureToFramebuffer:()=>OC,bindTextureToProgramUniformSampler:()=>F4,bindTextureUnit:()=>O4,bindVertexBufferToProgramAttribute:()=>aF,callAndCheck:()=>On,canBeRepresented:()=>_4,createFragmentShader:()=>E4,createFramebuffer:()=>D4,createProgram:()=>I4,createStaticIndexBuffer:()=>T4,createStaticVertexBuffer:()=>A4,createTexture:()=>M4,createVertexShader:()=>S4,getBatchDim:()=>Qm,getExtensionOrThrow:()=>Tb,getFramebufferErrorMessage:()=>L4,getMaxTexturesInShader:()=>U4,getNumChannels:()=>sK,getProgramUniformLocation:()=>P4,getProgramUniformLocationOrThrow:()=>k4,getRowsCols:()=>eg,getShapeAs3D:()=>Rb,getTextureShapeFromLogicalShape:()=>B4,getWebGLDisjointQueryTimerVersion:()=>V4,getWebGLErrorMessage:()=>N4,getWebGLMaxTextureSize:()=>z4,hasExtension:()=>zc,isCapableOfRenderingToFloatTexture:()=>G4,isDownloadFloatTextureEnabled:()=>q4,isReshapeFree:()=>Db,isWebGLFenceEnabled:()=>W4,isWebGLVersionEnabled:()=>uF,linkProgram:()=>C4,logShaderSourceAndInfoLog:()=>sF,resetMaxTextureSize:()=>uK,resetMaxTexturesInShader:()=>lK,unbindColorTextureFromFramebuffer:()=>oF,unbindTextureUnit:()=>aK,validateFramebuffer:()=>Mb,validateProgram:()=>DC,validateTextureSize:()=>R4});var kn={};nn.r(kn),nn.d(kn,{bindVertexProgramAttributeStreams:()=>oz,createBufferFromOutputTexture:()=>cz,createFloat16MatrixTexture:()=>rz,createFloat16PackedMatrixTexture:()=>az,createFloat32MatrixTexture:()=>nz,createIndexBuffer:()=>tz,createPackedMatrixTexture:()=>sz,createUnsignedBytesMatrixTexture:()=>iz,createVertexBuffer:()=>ez,createVertexShader:()=>Q4,downloadByteEncodedFloatMatrixFromOutputTexture:()=>hz,downloadFloat32MatrixFromBuffer:()=>fz,downloadMatrixFromPackedOutputTexture:()=>dz,downloadPackedMatrixFromBuffer:()=>pz,getInternalFormatForFloat16MatrixTexture:()=>dF,getInternalFormatForFloat16PackedMatrixTexture:()=>yF,getInternalFormatForFloat32MatrixTexture:()=>pF,getInternalFormatForPackedMatrixTexture:()=>gF,getInternalFormatForUnsignedBytesMatrixTexture:()=>mF,uploadDenseMatrixToTexture:()=>uz,uploadPixelDataToTexture:()=>lz});var qn={};nn.r(qn),nn.d(qn,{Abs:()=>ga,Acos:()=>To,Acosh:()=>ml,AdadeltaOptimizer:()=>mv,AdagradOptimizer:()=>Dg,AdamOptimizer:()=>Og,AdamaxOptimizer:()=>kg,Add:()=>Ju,AddN:()=>kl,All:()=>Vr,Any:()=>Ks,ArgMax:()=>Ho,ArgMin:()=>Af,Asin:()=>Tf,Asinh:()=>Gr,Atan:()=>ja,Atan2:()=>Yc,Atanh:()=>jn,AvgPool:()=>Mr,AvgPool3D:()=>hn,AvgPool3DGrad:()=>Ys,AvgPoolGrad:()=>Mf,BatchMatMul:()=>fs,BatchToSpaceND:()=>Ja,Bincount:()=>mc,BroadcastArgs:()=>en,BroadcastTo:()=>Bd,Callback:()=>In,CallbackList:()=>fk,Cast:()=>rr,Ceil:()=>As,ClipByValue:()=>Qa,Complex:()=>Pl,ComplexAbs:()=>Zi,Concat:()=>ci,Conv2D:()=>kr,Conv2DBackpropFilter:()=>ys,Conv2DBackpropInput:()=>uh,Conv3D:()=>lh,Conv3DBackpropFilterV2:()=>Ca,Conv3DBackpropInputV2:()=>hu,Cos:()=>eo,Cosh:()=>Jr,CropAndResize:()=>gl,Cumprod:()=>Zc,Cumsum:()=>Zs,CustomCallback:()=>nI,DataStorage:()=>ri,DenseBincount:()=>Qu,DepthToSpace:()=>Qi,DepthwiseConv2dNative:()=>la,DepthwiseConv2dNativeBackpropFilter:()=>Fl,DepthwiseConv2dNativeBackpropInput:()=>Mo,Diag:()=>Tu,Dilation2D:()=>Mu,Dilation2DBackpropFilter:()=>Ts,Dilation2DBackpropInput:()=>Ll,ENV:()=>ma,EarlyStopping:()=>jr,Einsum:()=>Ro,Elu:()=>hs,EluGrad:()=>Gs,Environment:()=>_s,Equal:()=>Hh,Erf:()=>gc,Exp:()=>yl,ExpandDims:()=>ch,Expm1:()=>Df,FFT:()=>Aa,Fill:()=>Ru,FlipLeftRight:()=>ya,Floor:()=>el,FloorDiv:()=>Do,FromPixels:()=>Bo,FusedBatchNorm:()=>yc,FusedConv2D:()=>Xl,FusedDepthwiseConv2D:()=>Nl,GPGPUContext:()=>BC,GatherNd:()=>Wn,GatherV2:()=>ss,GraphModel:()=>LP,Greater:()=>fh,GreaterEqual:()=>$l,History:()=>hk,IFFT:()=>Xo,Identity:()=>va,Imag:()=>vl,InputSpec:()=>oo,IsFinite:()=>Bl,IsInf:()=>jc,IsNan:()=>Of,KernelBackend:()=>Yn,LRN:()=>vc,LRNGrad:()=>Qr,LayerVariable:()=>So,LayersModel:()=>wf,LeakyRelu:()=>Yr,Less:()=>pu,LessEqual:()=>as,LinSpace:()=>Jc,Log:()=>Ta,Log1p:()=>kf,LogSoftmax:()=>to,LogicalAnd:()=>Fr,LogicalNot:()=>xl,LogicalOr:()=>Hi,LogicalXor:()=>Xh,LowerBound:()=>bl,MathBackendCPU:()=>iB,MathBackendWebGL:()=>Sz,MatrixBandPart:()=>Gn,Max:()=>Ps,MaxPool:()=>no,MaxPool3D:()=>_r,MaxPool3DGrad:()=>Cr,MaxPoolGrad:()=>os,MaxPoolWithArgmax:()=>Qc,Maximum:()=>Ko,Mean:()=>Oo,Min:()=>js,Minimum:()=>Yo,MirrorPad:()=>Js,Mod:()=>fo,MomentumOptimizer:()=>gv,Multinomial:()=>Zo,Multiply:()=>du,Neg:()=>mu,NonMaxSuppressionV3:()=>Kh,NonMaxSuppressionV4:()=>Pf,NonMaxSuppressionV5:()=>xa,NotEqual:()=>qs,OP_SCOPE_SUFFIX:()=>ev,OneHot:()=>ko,OnesLike:()=>Du,Optimizer:()=>uf,OptimizerConstructors:()=>$v,Pack:()=>hh,PadV2:()=>ba,Pool:()=>fg,Pow:()=>zl,Prelu:()=>Ul,Prod:()=>ph,RMSPropOptimizer:()=>Fg,RNN:()=>Fh,RaggedGather:()=>Yh,RaggedRange:()=>Vl,RaggedTensorToTensor:()=>jo,Range:()=>Qs,Rank:()=>mg,Real:()=>xc,RealDiv:()=>Rf,Reciprocal:()=>ea,Reduction:()=>Go,Relu:()=>Po,Relu6:()=>Ss,Reshape:()=>tl,ResizeBilinear:()=>ir,ResizeBilinearGrad:()=>Ou,ResizeNearestNeighbor:()=>ef,ResizeNearestNeighborGrad:()=>es,Reverse:()=>ho,RotateWithOffset:()=>Op,Round:()=>Ms,Rsqrt:()=>dh,SGDOptimizer:()=>Pg,ScatterNd:()=>ku,SearchSorted:()=>ca,Select:()=>ta,Selu:()=>Pr,Sequential:()=>_p,Sigmoid:()=>wa,Sign:()=>Fu,Sin:()=>wc,Sinh:()=>Pu,Slice:()=>po,Softmax:()=>za,Softplus:()=>Ff,SpaceToBatchND:()=>Fo,SparseFillEmptyRows:()=>wl,SparseReshape:()=>Gl,SparseSegmentMean:()=>Jo,SparseSegmentSum:()=>ql,SparseToDense:()=>Ma,SplitV:()=>Ws,Sqrt:()=>Rs,Square:()=>Zr,SquaredDifference:()=>Lo,StaticRegexReplace:()=>Qn,Step:()=>Hl,StridedSlice:()=>nl,StringNGrams:()=>_a,StringSplit:()=>rl,StringToHashBucketFast:()=>Lf,Sub:()=>il,Sum:()=>ot,SymbolicTensor:()=>vf,Tan:()=>gu,Tanh:()=>vs,Tensor:()=>Xi,TensorBuffer:()=>Ga,TensorScatterUpdate:()=>bc,Tile:()=>ps,TopK:()=>_l,Transform:()=>Ua,Transpose:()=>Wl,Unique:()=>tf,Unpack:()=>Hs,UnsortedSegmentSum:()=>nf,UpperBound:()=>$o,Variable:()=>qd,ZerosLike:()=>mh,_FusedMatMul:()=>Qo,abs:()=>Ra,acos:()=>Bv,acosh:()=>zv,add:()=>gn,addN:()=>Uv,all:()=>zg,any:()=>om,argMax:()=>wh,argMin:()=>Vv,asin:()=>Gv,asinh:()=>Ug,atan:()=>Vg,atan2:()=>qv,atanh:()=>Gg,avgPool:()=>Xp,avgPool3d:()=>Xv,backend:()=>pv,backend_util:()=>ae,basicLSTMCell:()=>Kv,batchNorm:()=>Kp,batchNorm2d:()=>Yv,batchNorm3d:()=>Wg,batchNorm4d:()=>Zv,batchToSpaceND:()=>cm,bincount:()=>jv,booleanMaskAsync:()=>LN,broadcastArgs:()=>Jv,broadcastTo:()=>sp,broadcast_util:()=>he,browser:()=>Me,buffer:()=>zr,callbacks:()=>ms,cast:()=>_n,ceil:()=>Qv,clipByValue:()=>xu,clone:()=>Ic,complex:()=>Uf,concat:()=>Da,concat1d:()=>Hg,concat2d:()=>t1,concat3d:()=>Xg,concat4d:()=>n1,constraints:()=>Ue,conv1d:()=>fm,conv2d:()=>Xf,conv2dTranspose:()=>Kg,conv3d:()=>i1,conv3dTranspose:()=>s1,copyRegisteredKernels:()=>hg,cos:()=>Zp,cosh:()=>Yg,cosineWindow:()=>S0,cumprod:()=>hm,cumsum:()=>pm,customGrad:()=>Cc,data:()=>Gt,denseBincount:()=>Zg,deprecationWarn:()=>fv,depthToSpace:()=>a1,depthwiseConv2d:()=>ap,deregisterOp:()=>$h,device_util:()=>Y,diag:()=>B_,dilation2d:()=>o1,disableDeprecationWarnings:()=>Dw,dispose:()=>Lr,disposeVariables:()=>em,div:()=>ur,divNoNan:()=>u1,dot:()=>l1,dropout:()=>N0,einsum:()=>c1,elu:()=>jp,enableDebugMode:()=>fA,enableProdMode:()=>Rw,enclosingPowerOfTwo:()=>B1,engine:()=>Zl,env:()=>Pt,equal:()=>zu,erf:()=>f1,euclideanNorm:()=>d1,exp:()=>Uu,expandDims:()=>tu,expm1:()=>m1,eye:()=>Jg,fft:()=>ad,fill:()=>tp,findBackend:()=>hv,findBackendFactory:()=>pA,floor:()=>Qp,floorDiv:()=>Rg,forceHalfFloat:()=>Iz,fused:()=>Le,gather:()=>up,gatherND:()=>$1,gather_util:()=>H,getBackend:()=>Fw,getGradient:()=>Kl,getKernel:()=>Nc,getKernelsForBackend:()=>vr,gpgpu_util:()=>kn,grad:()=>Vw,grads:()=>Gw,greater:()=>bu,greaterEqual:()=>Kf,ifft:()=>od,imag:()=>Up,image:()=>ec,inTopKAsync:()=>VN,initializers:()=>Q,input:()=>bI,io:()=>ye,irfft:()=>v0,isFinite:()=>Qg,isInf:()=>g1,isNaN:()=>y1,keep:()=>so,kernel_impls:()=>ie,layers:()=>pe,leakyRelu:()=>ed,less:()=>td,lessEqual:()=>Ah,linalg:()=>H1,linspace:()=>Z_,loadGraphModel:()=>WG,loadGraphModelSync:()=>HG,loadLayersModel:()=>o$,localResponseNormalization:()=>v1,log:()=>ol,log1p:()=>Vu,logSigmoid:()=>x1,logSoftmax:()=>cp,logSumExp:()=>e0,logicalAnd:()=>Jl,logicalNot:()=>Pa,logicalOr:()=>t0,logicalXor:()=>b1,losses:()=>wS,lowerBound:()=>J_,matMul:()=>ni,math:()=>de,max:()=>Il,maxPool:()=>mm,maxPool3d:()=>df,maxPoolWithArgmax:()=>Q_,maximum:()=>cf,mean:()=>ra,memory:()=>tm,meshgrid:()=>eM,metrics:()=>le,min:()=>op,minimum:()=>Th,mirrorPad:()=>nN,mod:()=>w1,model:()=>Xx,models:()=>xe,moments:()=>gm,movingAverage:()=>$N,mul:()=>_t,multiRNNCell:()=>iN,multinomial:()=>wu,neg:()=>Ls,nextFrame:()=>K1,norm:()=>Jp,notEqual:()=>fp,oneHot:()=>ip,ones:()=>ul,onesLike:()=>qu,op:()=>yt,outerProduct:()=>aN,pad:()=>Yf,pad1d:()=>uN,pad2d:()=>Mc,pad3d:()=>cN,pad4d:()=>uM,pool:()=>_1,pow:()=>lf,prelu:()=>nd,print:()=>Tg,prod:()=>N1,profile:()=>Ow,raggedGather:()=>pN,raggedRange:()=>S1,raggedTensorToTensor:()=>dN,rand:()=>E1,randomGamma:()=>A1,randomNormal:()=>s0,randomStandardNormal:()=>yN,randomUniform:()=>Mh,range:()=>pp,ready:()=>hA,real:()=>Vp,reciprocal:()=>a0,registerBackend:()=>Mg,registerCallbackConstructor:()=>kk,registerGradient:()=>Sl,registerKernel:()=>sl,registerOp:()=>Lh,regularizers:()=>we,relu:()=>Rc,relu6:()=>o0,removeBackend:()=>Lw,reshape:()=>St,reverse:()=>Ql,reverse1d:()=>bN,reverse2d:()=>CM,reverse3d:()=>_N,reverse4d:()=>T1,rfft:()=>bm,round:()=>u0,rsqrt:()=>vm,scalar:()=>mr,scatterND:()=>BN,scatter_util:()=>Ye,searchSorted:()=>dm,selu:()=>l0,separableConv2d:()=>c0,sequential:()=>xI,serialization:()=>te,setBackend:()=>Pw,setPlatform:()=>$w,setWebGLContext:()=>w4,setdiff1dAsync:()=>EN,shared:()=>Rn,sigmoid:()=>Tc,sign:()=>h0,signal:()=>bS,sin:()=>p0,sinh:()=>m0,slice:()=>li,slice1d:()=>g0,slice2d:()=>y0,slice3d:()=>id,slice4d:()=>sd,slice_util:()=>Je,softmax:()=>xm,softplus:()=>lp,spaceToBatchND:()=>ym,sparse:()=>X1,sparseToDense:()=>UN,spectral:()=>xS,split:()=>_u,sqrt:()=>zo,square:()=>Nr,squaredDifference:()=>x0,squeeze:()=>Zf,stack:()=>Wu,step:()=>dp,stridedSlice:()=>MN,string:()=>_S,sub:()=>Hn,sum:()=>er,sumOutType:()=>bg,tan:()=>R1,tanh:()=>Ih,tensor:()=>al,tensor1d:()=>bo,tensor2d:()=>jf,tensor3d:()=>Ac,tensor4d:()=>RN,tensor5d:()=>DN,tensor6d:()=>ud,tensorScatterUpdate:()=>kN,tensor_util:()=>Fe,test_util:()=>Ae,tidy:()=>Lt,tile:()=>Cl,time:()=>kw,topk:()=>b0,train:()=>mp,transpose:()=>ui,truncatedNormal:()=>w0,unique:()=>D1,unregisterGradient:()=>mo,unregisterKernel:()=>Bf,unsortedSegmentSum:()=>wm,unstack:()=>Al,upcastType:()=>$u,upperBound:()=>O1,util:()=>ze,valueAndGrad:()=>qw,valueAndGrads:()=>Ww,variable:()=>k1,variableGrads:()=>dv,version:()=>aie,version_converter:()=>L$,version_core:()=>x_,version_cpu:()=>n4,version_layers:()=>Ux,version_webgl:()=>Ez,webgl:()=>wZ,webgl_util:()=>Bn,where:()=>xo,whereAsync:()=>F1,zeros:()=>Wa,zerosLike:()=>di});var $n=nn(4291),Qe=nn(5861);class ri{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class Yn{refCount(t){return Vn("refCount")}incRef(t){return Vn("incRef")}timerAvailable(){return!0}time(t){return Vn("time")}read(t){return Vn("read")}readSync(t){return Vn("readSync")}readToGPU(t,e){return Vn("readToGPU")}numDataIds(){return Vn("numDataIds")}disposeData(t,e){return Vn("disposeData")}write(t,e,r){return Vn("write")}move(t,e,r,i,s){return Vn("move")}createTensorFromGPUData(t,e,r){return Vn("createTensorFromGPUData")}memory(){return Vn("memory")}floatPrecision(){return Vn("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Vn("dispose")}}function Vn(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Tt(n){let t=n.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,nt(n,t,e)}function We(n,t){if(n.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${t.length}`);let e=n.length,r=0;for(;e>0;)r=Math.random()*e|0,e--,nt(n,e,r),nt(t,e,r)}function Oe(n,t,e){return Math.max(n,Math.min(t,e))}function De(n){return n%2==0?n:n+1}function nt(n,t,e){const r=n[t];n[t]=n[e],n[e]=r}function Te(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}function tt(n,t){const e=Math.random();return t*e+(1-e)*n}function mt(n,t){let e=0;for(let r=0;r<n.length;r++){const i=Number(n[r])-Number(t[r]);e+=i*i}return e}function K(n,t){if(!n)throw new Error("string"==typeof t?t:t())}function xt(n,t,e=""){K(Kt(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function on(n){K(null!=n,()=>"The input to the tensor constructor must be a non-null value.")}function ft(n){if(0===n.length)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function Xt(n){return 0===n.length}function Kt(n,t){if(n===t)return!0;if(null==n||null==t||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function Pn(n){return n%1==0}function xr(n){if(null!=Math.tanh)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;{const t=Math.exp(2*n);return(t-1)/(t+1)}}function br(n){const t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function oi(n){const t=new Uint32Array(n);for(let e=0;e<n;++e)t[e]=e;return Tt(t),t}function qi(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function ks(n,t=(i=>0),e,r){return new Promise((i,s)=>{let a=0;const o=()=>{if(n())return void i();a++;const l=t(a);null!=e&&a>=e?s():null!=r?r(o,l):setTimeout(o,l)};o()})}function ls(n,t){let e=1,r=-1;for(let s=0;s<n.length;++s)if(n[s]>=0)e*=n[s];else if(-1===n[s]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(n[s]<0)throw Error(`Shapes can not be < 0. Found ${n[s]} at dim ${s}`);if(-1===r){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(0===e)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const i=n.slice();return i[r]=t/e,i}function ar(n,t){const e=t.length;return K((n=null==n?t.map((r,i)=>i):[].concat(n)).every(r=>r>=-e&&r<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),K(n.every(r=>Pn(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?e+r:r)}function Kr(n,t){const e=[],r=[],i=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||i?null:ar(t,n).sort();let a=0;for(let o=0;o<n.length;++o){if(null!=s){if(s[a]===o&&1!==n[o])throw new Error(`Can't squeeze axis ${o} since its dim '${n[o]}' is not 1`);(null==s[a]||s[a]>o)&&1===n[o]&&(e.push(n[o]),r.push(o)),s[a]<=o&&a++}1!==n[o]&&(e.push(n[o]),r.push(o))}return{newShape:e,keptDims:r}}function hi(n,t){return Dr(n,t)}function Dr(n,t){let e=null;if(null==n||"float32"===n)e=new Float32Array(t);else if("int32"===n)e=new Int32Array(t);else if("bool"===n)e=new Uint8Array(t);else{if("string"!==n)throw new Error(`Unknown data type ${n}`);e=new Array(t)}return e}function pn(n,t){for(let e=0;e<n.length;e++){const r=n[e];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function Yu(n){return"bool"===n||"complex64"===n||"float32"===n||"int32"===n||"string"===n}function co(n,t){return!("complex64"===t||"float32"===t&&"complex64"!==n||"int32"===t&&"float32"!==n&&"complex64"!==n||"bool"===t&&"bool"===n)}function Zn(n){if("float32"===n||"int32"===n)return 4;if("complex64"===n)return 8;if("bool"===n)return 1;throw new Error(`Unknown dtype ${n}`)}function Cs(n){if(null==n)return 0;let t=0;return n.forEach(e=>t+=e.length),t}function da(n){return"string"==typeof n||n instanceof String}function Wo(n){return"boolean"==typeof n}function fu(n){return"number"==typeof n}function Hc(n){return Array.isArray(n)?Hc(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":fu(n)?"float32":da(n)?"string":Wo(n)?"bool":"float32"}function Ao(n){return!!(n&&n.constructor&&n.call&&n.apply)}function oh(n,t){for(let e=t;e<n;++e)if(n%e==0)return e;return n}function zn(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let r=t-3;r>=0;--r)e[r]=e[r+1]*n[r+1];return e}function Xc(n,t,e,r=!1){const i=new Array;if(1===t.length){const s=t[0]*(r?2:1);for(let a=0;a<s;a++)i[a]=e[n+a]}else{const s=t[0],a=t.slice(1),o=a.reduce((l,p)=>l*p)*(r?2:1);for(let l=0;l<s;l++)i[l]=Xc(n+l*o,a,e,r)}return i}function Za(n,t,e=!1){if(0===n.length)return t[0];const r=n.reduce((i,s)=>i*s)*(e?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return Xc(0,n,t,e)}function Zu(n,t){if(Array.isArray(n))return n;if("float32"===t)return n instanceof Float32Array?n:new Float32Array(n);if("int32"===t)return n instanceof Int32Array?n:new Int32Array(n);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${t}`)}function Ur(n,t){const e=Ki(n,t);for(let r=0;r<e.length;r++)e[r]=1;return e}function Ki(n,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t)return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function oa(n,t){const e=n.reduce((r,i)=>r*i,1);if(null==t||"float32"===t)return Za(n,new Float32Array(e));if("int32"===t)return Za(n,new Int32Array(e));if("bool"===t)return Za(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function cs(n){n.forEach(t=>{K(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Yi(n,t,e){if(0===t)return 0;if(1===t)return n[0];let r=n[n.length-1];for(let i=0;i<n.length-1;++i)r+=e[i]*n[i];return r}function Ia(n,t,e){if(0===t)return[];if(1===t)return[n];const r=new Array(t);for(let i=0;i<r.length-1;++i)r[i]=Math.floor(n/e[i]),n-=r[i]*e[i];return r[r.length-1]=n,r}function Or(n){return n&&n.then&&"function"==typeof n.then}const ua="tfjsflags";class _s{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=fn,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(Pt().getBool("IS_TEST")||Pt().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,r){if(this.flagRegistry[t]={evaluationFn:e,setHook:r},null!=this.urlFlags[t]){const i=this.urlFlags[t];Pt().getBool("IS_TEST")||Pt().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${i}.`),this.set(t,i)}}getAsync(t){var e=this;return(0,Qe.Z)(function*(){return t in e.flags||(e.flags[t]=yield e.evaluateFlag(t)),e.flags[t]})()}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(Or(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);ua in t&&t[ua].split(",").forEach(r=>{const[i,s]=r.split(":");this.urlFlags[i]=function Wi(n,t){const e=t.toLowerCase();return"true"===e||"false"===e?"true"===e:""+ +e===e?+e:t}(0,s)})}}function fn(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>(function is(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}(t,r[0],r[1]),r.join("="))),t}function Pt(){return ma}let Ns,ma=null;function Kc(){if(null==Ns){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");n=self}Ns=n}return Ns}function fr(n,t){const e=function Ba(){const n=Kc();return null==n._tfGlobals&&(n._tfGlobals=new Map),n._tfGlobals}();if(e.has(n))return e.get(n);{const r=t();return e.set(n,r),e.get(n)}}const ga="Abs",To="Acos",ml="Acosh",Ju="Add",kl="AddN",Vr="All",Ks="Any",Ho="ArgMax",Af="ArgMin",Tf="Asin",Gr="Asinh",ja="Atan",jn="Atanh",Yc="Atan2",Mr="AvgPool",Mf="AvgPoolGrad",hn="AvgPool3D",Ys="AvgPool3DGrad",fs="BatchMatMul",Ja="BatchToSpaceND",mc="Bincount",Bd="BroadcastTo",en="BroadcastArgs",rr="Cast",As="Ceil",Qa="ClipByValue",Pl="Complex",Zi="ComplexAbs",ci="Concat",kr="Conv2D",ys="Conv2DBackpropFilter",uh="Conv2DBackpropInput",lh="Conv3D",Ca="Conv3DBackpropFilterV2",hu="Conv3DBackpropInputV2",eo="Cos",Jr="Cosh",Zc="Cumprod",Zs="Cumsum",gl="CropAndResize",Qu="DenseBincount",Qi="DepthToSpace",la="DepthwiseConv2dNative",Fl="DepthwiseConv2dNativeBackpropFilter",Mo="DepthwiseConv2dNativeBackpropInput",Tu="Diag",Mu="Dilation2D",Ll="Dilation2DBackpropInput",Ts="Dilation2DBackpropFilter",Rf="RealDiv",Ro="Einsum",hs="Elu",Gs="EluGrad",gc="Erf",Hh="Equal",yl="Exp",ch="ExpandDims",Df="Expm1",Aa="FFT",Ru="Fill",ya="FlipLeftRight",el="Floor",Do="FloorDiv",yc="FusedBatchNorm",ss="GatherV2",Wn="GatherNd",fh="Greater",$l="GreaterEqual",va="Identity",Xo="IFFT",vl="Imag",Bl="IsFinite",jc="IsInf",Of="IsNan",Yr="LeakyRelu",pu="Less",as="LessEqual",Jc="LinSpace",Ta="Log",kf="Log1p",Fr="LogicalAnd",xl="LogicalNot",Hi="LogicalOr",Xh="LogicalXor",to="LogSoftmax",bl="LowerBound",vc="LRN",Qr="LRNGrad",Gn="MatrixBandPart",Ps="Max",Ko="Maximum",no="MaxPool",os="MaxPoolGrad",_r="MaxPool3D",Cr="MaxPool3DGrad",Qc="MaxPoolWithArgmax",Oo="Mean",js="Min",Yo="Minimum",Js="MirrorPad",fo="Mod",Zo="Multinomial",du="Multiply",mu="Neg",qs="NotEqual",Kh="NonMaxSuppressionV3",Pf="NonMaxSuppressionV4",xa="NonMaxSuppressionV5",Du="OnesLike",ko="OneHot",hh="Pack",ba="PadV2",fg="Pool",zl="Pow",Ul="Prelu",ph="Prod",Yh="RaggedGather",Vl="RaggedRange",jo="RaggedTensorToTensor",Qs="Range",xc="Real",ea="Reciprocal",Po="Relu",tl="Reshape",ef="ResizeNearestNeighbor",es="ResizeNearestNeighborGrad",ir="ResizeBilinear",Ou="ResizeBilinearGrad",Ss="Relu6",ho="Reverse",Ms="Round",dh="Rsqrt",ku="ScatterNd",bc="TensorScatterUpdate",ca="SearchSorted",ta="Select",Pr="Selu",po="Slice",wc="Sin",Pu="Sinh",Fu="Sign",wa="Sigmoid",Ff="Softplus",Rs="Sqrt",ot="Sum",Fo="SpaceToBatchND",Ws="SplitV",za="Softmax",wl="SparseFillEmptyRows",Gl="SparseReshape",Jo="SparseSegmentMean",ql="SparseSegmentSum",Ma="SparseToDense",Lo="SquaredDifference",Zr="Square",Qn="StaticRegexReplace",nl="StridedSlice",_a="StringNGrams",rl="StringSplit",Lf="StringToHashBucketFast",il="Sub",gu="Tan",vs="Tanh",ps="Tile",_l="TopK",Ua="Transform",Wl="Transpose",tf="Unique",Hs="Unpack",nf="UnsortedSegmentSum",$o="UpperBound",mh="ZerosLike",Hl="Step",Bo="FromPixels",Op="RotateWithOffset",Qo="_FusedMatMul",Xl="FusedConv2D",Nl="FusedDepthwiseConv2D";function eu(...n){Pt().getBool("IS_TEST")||Pt().getBool("PROD")||console.warn(...n)}function $f(...n){Pt().getBool("IS_TEST")||Pt().getBool("PROD")||console.log(...n)}const Lu=fr("kernelRegistry",()=>new Map),_c=fr("gradRegistry",()=>new Map);function Nc(n,t){const e=go(n,t);return Lu.get(e)}function Kl(n){return _c.get(n)}function vr(n){const t=Lu.entries(),e=[];for(;;){const{done:r,value:i}=t.next();if(r)break;const[s,a]=i,[o]=s.split("_");o===n&&e.push(a)}return e}function sl(n){const{kernelName:t,backendName:e}=n,r=go(t,e);Lu.has(r)&&eu(`The kernel '${t}' for backend '${e}' is already registered`),Lu.set(r,n)}function Sl(n){const{kernelName:t}=n;_c.has(t)&&Pt().getBool("DEBUG")&&eu(`Overriding the gradient for '${t}'`),_c.set(t,n)}function Bf(n,t){const e=go(n,t);if(!Lu.has(e))throw new Error(`The kernel '${n}' for backend '${t}' is not registered`);Lu.delete(e)}function mo(n){if(!_c.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);_c.delete(n)}function hg(n,t){vr(n).forEach(r=>{sl(Object.assign({},r,{backendName:t}))})}function go(n,t){return`${t}_${n}`}function Es(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var zd=nn(7658);const u=nn.n(zd)()||zd;function h(n){return u.fromString(n,!0,16)}const x=h("c3a5c85c97cb3127"),_=h("b492b66fbe98f273"),M=h("9ae16a3b2f90404f");function z(n){return n.xor(n.shru(47))}function q(n,t,e){const r=n.slice(t,t+e);return u.fromBytes(Array.from(r),!0,!0)}function me(n,t){return q(n,t,8)}function Ze(n,t){return q(n,t,4)}function lt(n,t){return 0===t?n:n.shru(t).or(n.shl(64-t))}function Vt(n,t,e=h("9ddfea08eb382d69")){let r=n.xor(t).mul(e);r=r.xor(r.shru(47));let i=t.xor(r).mul(e);return i=i.xor(i.shru(47)),i=i.mul(e),i}function wn(n,t,e,r){return function Yt(n,t,e,r,i,s){i=i.add(n),s=lt(s.add(i).add(r),21);const a=i;return i=(i=i.add(t)).add(e),s=s.add(lt(i,44)),[i.add(r),s.add(a)]}(me(n,t),me(n,t+8),me(n,t+16),me(n,t+24),e,r)}function fi(n,t=n.length){const e=u.fromNumber(81,!0);if(t<=32)return t<=16?function En(n,t=n.length){if(t>=8){const e=M.add(2*t),r=me(n,0).add(M),i=me(n,t-8);return Vt(lt(i,37).mul(e).add(r),lt(r,25).add(i).mul(e),e)}if(t>=4){const e=M.add(2*t);return Vt(Ze(n,0).shl(3).add(t),Ze(n,t-4),e)}if(t>0){const a=t+(n[t-1]<<2);return z(M.mul(n[0]+(n[t>>1]<<8)).xor(x.mul(a))).mul(M)}return M}(n,t):function Fn(n,t=n.length){const e=M.add(2*t),r=me(n,0).mul(_),i=me(n,8),s=me(n,t-8).mul(e),a=me(n,t-16).mul(M);return Vt(lt(r.add(i),43).add(lt(s,30)).add(a),r.add(lt(i.add(M),18)).add(s),e)}(n,t);if(t<=64)return function or(n,t=n.length){const e=M.add(2*t),r=me(n,0).mul(M),i=me(n,8),s=me(n,t-8).mul(e),a=me(n,t-16).mul(M),o=lt(r.add(i),43).add(lt(s,30)).add(a),l=Vt(o,r.add(lt(i.add(M),18)).add(s),e),p=me(n,16).mul(e),g=me(n,24),v=o.add(me(n,t-32)).mul(e),w=l.add(me(n,t-24)).mul(e);return Vt(lt(p.add(g),43).add(lt(v,30)).add(w),p.add(lt(g.add(r),18)).add(v),e)}(n,t);let r=e,i=e.mul(_).add(113),s=z(i.mul(M).add(113)).mul(M),a=[u.UZERO,u.UZERO],o=[u.UZERO,u.UZERO];r=r.mul(M).add(me(n,0));let l=0;const p=64*(t-1>>6),g=p+(t-1&63)-63;do{r=lt(r.add(i).add(a[0]).add(me(n,l+8)),37).mul(_),i=lt(i.add(a[1]).add(me(n,l+48)),42).mul(_),r=r.xor(o[1]),i=i.add(a[0]).add(me(n,l+40)),s=lt(s.add(o[0]),33).mul(_),a=wn(n,l,a[1].mul(_),r.add(o[0])),o=wn(n,l+32,s.add(o[1]),i.add(me(n,l+16))),[s,r]=[r,s],l+=64}while(l!==p);const v=_.add(s.and(255).shl(1));return l=g,o[0]=o[0].add(t-1&63),a[0]=a[0].add(o[0]),o[0]=o[0].add(a[0]),r=lt(r.add(i).add(a[0]).add(me(n,l+8)),37).mul(v),i=lt(i.add(a[1]).add(me(n,l+48)),42).mul(v),r=r.xor(o[1].mul(9)),i=i.add(a[0].mul(9).add(me(n,l+40))),s=lt(s.add(o[0]),33).mul(v),a=wn(n,l,a[1].mul(v),r.add(o[0])),o=wn(n,l+32,s.add(o[1]),i.add(me(n,l+16))),[s,r]=[r,s],Vt(Vt(a[0],o[0],v).add(z(i).mul(x)).add(s),Vt(a[1],o[1],v).add(r),v)}function ji(n,t){return"string"===t?sf(n):io([n],t)}function io(n,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=af(n)),Pt().getBool("DEBUG")&&pn(n,t),function ro(n,t){return n instanceof Float32Array&&"float32"===t||n instanceof Int32Array&&"int32"===t||n instanceof Uint8Array&&"bool"===t}(n,t))return n;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t){const e=new Uint8Array(n.length);for(let r=0;r<e.length;++r)0!==Math.round(n[r])&&(e[r]=1);return e}throw new Error(`Unknown data type ${t}`)}function Fs(){return Pt().platform.now()}function Ud(n,t){return Pt().platform.fetch(n,t)}function sf(n,t="utf-8"){return t=t||"utf-8",Pt().platform.encode(n,t)}function Va(n,t="utf-8"){return t=t||"utf-8",Pt().platform.decode(n,t)}function yo(n){return null!=Pt().platform.isTypedArray?Pt().platform.isTypedArray(n):Es(n)}function af(n,t=[],e=!1){if(null==t&&(t=[]),"boolean"==typeof n||"number"==typeof n||"string"==typeof n||Or(n)||null==n||yo(n)&&e)t.push(n);else if(Array.isArray(n)||yo(n))for(let r=0;r<n.length;++r)af(n[r],t,e);else{let r=-1;for(const i of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(i)&&(r=Math.max(r,Number(i)));for(let i=0;i<=r;i++)af(n[i],t,e)}return t}class F2{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new $2)}profileKernel(t,e,r){let i;const s=()=>{i=r()};let a;const o=Fs();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(const p of i)p.dataSync();a=Promise.resolve({kernelMs:Fs()-o})}if(Pt().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let p=0;p<i.length;p++){const g=i[p];g.data().then(v=>{L2(v,g.dtype,t)})}return{kernelName:t,outputs:i,inputs:e,timeMs:a.then(p=>p.kernelMs),extraInfo:a.then(p=>null!=p.getExtraProfileInfo?p.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:r,timeMs:i,inputs:s,extraInfo:a}=t;r.forEach(o=>{Promise.all([o.data(),i,a]).then(l=>{this.logger.logKernelProfile(e,o,l[0],l[1],s,l[2])})})}}function L2(n,t,e){if("float32"!==t)return!1;for(let r=0;r<n.length;r++){const i=n[r];if(isNaN(i)||!isFinite(i))return console.warn(`Found ${i} in the result of '${e}'`),!0}return!1}class $2{logKernelProfile(t,e,r,i,s,a){const o="number"==typeof i?qi(`${i}ms`,9):i.error,l=qi(t,25),p=e.rank,g=e.size,v=qi(e.shape.toString(),14);let w="";for(const N in s){const D=s[N];if(null!=D){const O=D.shape||e.shape,k=O.length;w+=`${N}: ${k}D ${k>0?O:""} `}}console.log(`%c${l}\t%c${o}\t%c${p}D ${v}\t%c${g}\t%c${w}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const lw=20,Vd=3,jy=7;function U2(n,t,e,r){const i=zn(t),s=function V2(n,t,e,r){const i=ft(t),s=r[r.length-1],a=new Array(s).fill(0),o=t.length,l="complex64"===e?dg(n):n;if(o>1)for(let p=0;p<i/s;p++){const g=p*s;for(let v=0;v<s;v++)a[v]=Math.max(a[v],Gd(l[g+v],0,e).length)}return a}(n,t,e,i),a=t.length,o=pg(n,t,e,i,s),l=["Tensor"];return r&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${a}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map(p=>"    "+p).join("\n")),l.join("\n")}function Gd(n,t,e){let r;return r=Array.isArray(n)?`${parseFloat(n[0].toFixed(jy))} + ${parseFloat(n[1].toFixed(jy))}j`:da(n)?`'${n}'`:"bool"===e?cw(n):parseFloat(n.toFixed(jy)).toString(),qi(r,t)}function cw(n){return 0===n?"false":"true"}function pg(n,t,e,r,i,s=!0){const a="complex64"===e?2:1,o=t[0],l=t.length;if(0===l)return"complex64"===e?[Gd(dg(n)[0],0,e)]:"bool"===e?[cw(n[0])]:[n[0].toString()];if(1===l){if(o>lw){let L=Array.from(n.slice(0,Vd*a)),$=Array.from(n.slice((o-Vd)*a,o*a));return"complex64"===e&&(L=dg(L),$=dg($)),["["+L.map((U,V)=>Gd(U,i[V],e)).join(", ")+", ..., "+$.map((U,V)=>Gd(U,i[o-Vd+V],e)).join(", ")+"]"]}return["["+("complex64"===e?dg(n):Array.from(n)).map((k,L)=>Gd(k,i[L],e)).join(", ")+"]"]}const p=t.slice(1),g=r.slice(1),v=r[0]*a,w=[];if(o>lw){for(let O=0;O<Vd;O++){const k=O*v;w.push(...pg(n.slice(k,k+v),p,e,g,i,!1))}w.push("...");for(let O=o-Vd;O<o;O++){const k=O*v;w.push(...pg(n.slice(k,k+v),p,e,g,i,O===o-1))}}else for(let O=0;O<o;O++){const k=O*v;w.push(...pg(n.slice(k,k+v),p,e,g,i,O===o-1))}const N=2===l?",":"";w[0]="["+(o>0?w[0]+N:"");for(let O=1;O<w.length-1;O++)w[O]=" "+w[O]+N;let D=",\n";for(let O=2;O<l;O++)D+="\n";return w[w.length-1]=" "+w[w.length-1]+"]"+(s?"":D),w}function dg(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}class Ga{constructor(t,e,r){if(this.dtype=e,this.shape=t.slice(),this.size=ft(t),null!=r){const i=r.length;K(i===this.size,()=>`Length of values '${i}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Dr(e,this.size),this.strides=zn(t)}set(t,...e){0===e.length&&(e=[0]),K(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const r=this.locToIndex(e);this.values[r]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const i of t){if(i<0||i>=this.shape[e])throw new Error(`Requested out of range element at ${t}.   Buffer shape=${this.shape}`);e++}let r=t[t.length-1];for(let i=0;i<t.length-1;++i)r+=this.strides[i]*t[i];return this.values[r]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let r=0;r<t.length-1;++r)e+=this.strides[r]*t[r];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let r=0;r<e.length-1;++r)e[r]=Math.floor(t/this.strides[r]),t-=e[r]*this.strides[r];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Sc().makeTensor(this.values,this.shape,this.dtype)}}let Sc=null,kp=null,fw=null;class Xi{constructor(t,e,r,i){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=ft(t),this.strides=zn(t),this.dataId=r,this.id=i,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var t=this;return(0,Qe.Z)(function*(){const e=yield t.data();return kp.buffer(t.shape,t.dtype,e)})()}bufferSync(){return kp.buffer(this.shape,this.dtype,this.dataSync())}array(){var t=this;return(0,Qe.Z)(function*(){const e=yield t.data();return Za(t.shape,e,"complex64"===t.dtype)})()}arraySync(){return Za(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var t=this;return(0,Qe.Z)(function*(){t.throwIfDisposed();const e=Sc().read(t.dataId);if("string"===t.dtype){const r=yield e;try{return r.map(i=>Va(i))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e})()}dataToGPU(t){return this.throwIfDisposed(),Sc().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Sc().readSync(this.dataId);if("string"===this.dtype)try{return t.map(e=>Va(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}bytes(){var t=this;return(0,Qe.Z)(function*(){t.throwIfDisposed();const e=yield Sc().read(t.dataId);return"string"===t.dtype?e:new Uint8Array(e.buffer)})()}dispose(){this.isDisposed||(Sc().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return kp.print(this,t)}clone(){return this.throwIfDisposed(),kp.clone(this)}toString(t=!1){return U2(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),kp.cast(this,t)}variable(t=!0,e,r){return this.throwIfDisposed(),Sc().makeVariable(this,t,e,r)}}function Jt(){return fr("Tensor",()=>Xi)}Object.defineProperty(Xi,Symbol.hasInstance,{value:n=>!!n&&null!=n.data&&null!=n.dataSync&&null!=n.throwIfDisposed}),Jt();class qd extends Xi{constructor(t,e,r,i){super(t.shape,t.dtype,t.dataId,i),this.trainable=e,this.name=r}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Kt(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Sc().disposeTensor(this),this.dataId=t.dataId,Sc().incRef(this,null)}dispose(){Sc().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(qd,Symbol.hasInstance,{value:n=>n instanceof Xi&&null!=n.assign&&n.assign instanceof Function});var mg=(()=>{return(n=mg||(mg={})).R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6",mg;var n})(),gg=(()=>{return(n=gg||(gg={})).float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64",gg;var n})(),yg=(()=>{return(n=yg||(yg={})).float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64",yg;var n})(),vg=(()=>{return(n=vg||(vg={})).float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64",vg;var n})(),xg=(()=>{return(n=xg||(xg={})).float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64",xg;var n})();const H2={float32:vg,int32:gg,bool:yg,complex64:xg};function $u(n,t){if("string"===n||"string"===t){if("string"===n&&"string"===t)return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return H2[n][t]}function bg(n){return $u(n,"int32")}function hw(n){return null!=n&&"object"==typeof n&&"texture"in n&&n.texture instanceof WebGLTexture}function pw(n){return typeof GPUBuffer<"u"&&null!=n&&"object"==typeof n&&"buffer"in n&&n.buffer instanceof GPUBuffer}function fa(n,t){if(n.dtype===t.dtype)return[n,t];const e=$u(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function dw(n,t){K(n.dtype===t.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${t.dtype}) input must match`)}function wg(n,t){return t.some(e=>e.id===n.id)}function zf(n){const t=[];return mw(n,t,new Set),t}function mw(n,t,e){if(null==n)return;if(n instanceof Xi)return void t.push(n);if(!function X2(n){return Array.isArray(n)||"object"==typeof n}(n))return;const r=n;for(const i in r){const s=r[i];e.has(s)||(e.add(s),mw(s,t,e))}}function Jy(n){return null!=n.kernelName}class gw{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}let K2=(()=>{class n{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new gw}ready(){var e=this;return(0,Qe.Z)(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const r=e.getSortedBackends();for(let i=0;i<r.length;i++){const s=r[i];if(yield e.initializeBackend(s).success)return void(yield e.setBackend(s))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:r}=this.initializeBackend(e);if(r)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,r,i=1){return e in this.registryFactory?(eu(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:r,priority:i},!0)}setBackend(e){var r=this;return(0,Qe.Z)(function*(){if(null==r.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(r.backendName=e,null==r.registry[e]){r.backendInstance=null;const{success:i,asyncInit:s}=r.initializeBackend(e);if(!(s?yield i:i))return!1}return r.backendInstance=r.registry[e],r.setupRegisteredKernels(),r.profiler=new F2(r.backendInstance),!0})()}setupRegisteredKernels(){vr(this.backendName).forEach(r=>{null!=r.setupFunc&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){vr(e).forEach(i=>{null!=i.disposeFunc&&i.disposeFunc(this.registry[e])})}initializeBackend(e){const r=this.registryFactory[e];if(null==r)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const i=r.factory();if(!i||i instanceof Yn||"function"!=typeof i.then)return this.registry[e]=i,{success:!0,asyncInit:!1};{const s=++this.pendingBackendInitId,a=i.then(o=>!(s<this.pendingBackendInitId||(this.registry[e]=o,this.pendingBackendInit=null,0))).catch(o=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,eu(`Initialization of backend ${e} failed`),eu(o.stack||o.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}}catch(i){return eu(`Initialization of backend ${e} failed`),eu(i.stack||i.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,r)=>this.registryFactory[r].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let r=0;r<e.length;r++){const i=e[r],{success:s,asyncInit:a}=this.initializeBackend(i);if(a||s)return{name:i,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,r){const i=this.state.tensorInfo.get(r),s=i.backend,a=this.readSync(r),o=s.refCount(r);s.disposeData(r,!0),i.backend=e,e.move(r,a,i.shape,i.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,r){let s,i=null;if(null==r){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");r=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof r)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");i=e}return this.scopedRun(()=>this.startScope(i),()=>this.endScope(s),()=>(s=r(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,r,i){e();try{const s=i();return r(),s}catch(s){throw r(),s}}nextTensorId(){return n.nextTensorId++}nextVariableId(){return n.nextVariableId++}clone(e){const r=gt.runKernel(va,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[r],o=>({x:()=>gt.runKernel(rr,{x:o},{dtype:"float32"})}),[],{}),r}runKernel(e,r,i){if(null==Nc(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:r,attrs:i})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,r,i){const s=this.backend.numDataIds();let a=0;i.forEach(p=>{a+="complex64"===p.dtype?3:1});const l=s-r-a-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let r,i=[];const s=this.isTapeOn(),a=this.state.numBytes,o=this.state.numTensors;let l,p;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const g=Jy(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Jy(e)){const{kernelName:O,inputs:k,attrs:L}=e,$=Nc(O,this.backendName);K(null!=$,()=>`Cannot find registered kernel '${O}' for backend '${this.backendName}'`),l=()=>{const U=this.backend.numDataIds();p=$.kernelFunc({inputs:k,attrs:L,backend:this.backend});const V=Array.isArray(p)?p:[p];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(O,U,V);const W=V.map(ce=>null!=ce.rank?ce:this.makeTensorFromTensorInfo(ce));if(s){const ce=this.getTensorsForGradient(O,k,W);i=this.saveTensorsForBackwardMode(ce)}return W}}else{const{forwardFunc:O}=e,k=L=>{s&&(i=L.map($=>this.keep(this.clone($))))};l=()=>{const L=this.backend.numDataIds();p=this.tidy(()=>O(this.backend,k));const $=Array.isArray(p)?p:[p];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(g,L,$),$}}const{inputs:v,attrs:w}=e,N=Jy(e)?null:e.backwardsFunc;let D;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(D=this.profiler.profileKernel(g,v,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(D),r=D.outputs):r=l()}),s&&this.addTapeNode(g,v,r,N,i,w),this.state.profiling&&this.state.activeProfile.kernels.push({name:g,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(v).map(O=>null!=v[O]?v[O].shape:null),outputShapes:r.map(O=>O.shape),kernelTimeMs:D.timeMs,extraInfo:D.extraInfo}),Array.isArray(p)?r:r[0]}saveTensorsForBackwardMode(e){return e.map(i=>this.keep(this.clone(i)))}getTensorsForGradient(e,r,i){const s=Kl(e);if(null!=s){const a=s.inputsToSave||[],o=s.outputsToSave||[];let l;s.saveAllInputs?(K(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(r).map(g=>r[g])):l=a.map(g=>r[g]);const p=i.filter((g,v)=>o[v]);return l.concat(p)}return[]}makeTensor(e,r,i,s){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");s=s||this.backend;let a=e;"string"===(i=i||"float32")&&da(e[0])&&(a=e.map(p=>sf(p)));const o=s.write(a,r,i),l=new Xi(r,i,o,this.nextTensorId());if(this.trackTensor(l,s),"string"===i){const p=this.state.tensorInfo.get(o),g=Cs(a);this.state.numBytes+=g-p.bytes,p.bytes=g}return l}makeTensorFromDataId(e,r,i,s){return this.makeTensorFromTensorInfo({dataId:e,shape:r,dtype:i=i||"float32"},s)}makeTensorFromTensorInfo(e,r){const{dataId:i,shape:s,dtype:a}=e,o=new Xi(s,a,i,this.nextTensorId());return this.trackTensor(o,r),o}makeVariable(e,r=!0,i,s){i=i||this.nextVariableId().toString(),null!=s&&s!==e.dtype&&(e=e.cast(s));const a=new qd(e,r,i,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,r){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let i=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(i=e.size*Zn(e.dtype)),this.state.numBytes+=i,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:r||this.backend,dtype:e.dtype,shape:e.shape,bytes:i})),e instanceof qd||this.track(e)}incRef(e,r){this.trackTensor(e,r),this.backend.incRef(e.dataId)}removeDataId(e,r){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===r&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const r=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const i=e.size*Zn(e.dtype);this.state.numBytes-=i}r.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,r.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var r=this;return(0,Qe.Z)(function*(){r.state.profiling=!0;const i=r.state.numBytes,s=r.state.numTensors;r.state.activeProfile.kernels=[],r.state.activeProfile.result=yield e(),r.state.profiling=!1,r.state.activeProfile.peakBytes=Math.max(...r.state.activeProfile.kernels.map(a=>a.totalBytesSnapshot)),r.state.activeProfile.newBytes=r.state.numBytes-i,r.state.activeProfile.newTensors=r.state.numTensors-s;for(const a of r.state.activeProfile.kernels)a.kernelTimeMs=yield a.kernelTimeMs,a.extraInfo=yield a.extraInfo;return r.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,r,i,s,a,o){const l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:r,outputs:i,saved:a},p=Kl(e);null!=p&&(s=p.gradFunc),null!=s&&(l.gradient=g=>(g=g.map((v,w)=>{if(null==v){const N=i[w],D=Ki(N.size,N.dtype);return this.makeTensor(D,N.shape,N.dtype)}return v}),s(g.length>1?g:g[0],a,o))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(r.name=e),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(e){const r=zf(e),i=new Set(r.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){const o=this.state.activeScope.track[a];!o.kept&&!i.has(o.id)&&o.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(a=>{!a.kept&&a.scopeId===s.id&&this.track(a)})}gradients(e,r,i,s=!1){if(K(r.length>0,()=>"gradients() received an empty list of xs."),null!=i&&"float32"!==i.dtype)throw new Error(`dy must have 'float32' dtype, but has '${i.dtype}'`);const a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));K(a instanceof Xi,()=>"The result y returned by f() must be a tensor.");const o=function B2(n,t,e){const r={},i={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<n.length;l++){const p=n[l],g=p.inputs;for(const v in g){const w=g[v];let N=!1;for(let D=0;D<t.length;D++)if(r[w.id]){p.outputs.forEach(O=>r[O.id]=!0),N=!0,i[p.id]=!0;break}if(N)break}}const s={};s[e.id]=!0;const a={};for(let l=n.length-1;l>=0;l--){const p=n[l],g=p.inputs;for(let v=0;v<p.outputs.length;v++)if(s[p.outputs[v].id]){for(const w in g)s[g[w].id]=!0,a[p.id]=!0;break}}const o=[];for(let l=0;l<n.length;l++){const p=n[l];if(i[p.id]&&a[p.id]){const g={};for(const w in p.inputs){const N=p.inputs[w];r[N.id]&&(g[w]=N)}const v=Object.assign({},p);v.inputs=g,v.outputs=p.outputs,o.push(v)}}return o}(this.state.activeTape,r,a);if(!s&&0===o.length&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[a.id]=i??function Y2(n){const t=Ur(ft(n),"float32");return gt.makeTensor(t,n,"float32")}(a.shape),function z2(n,t,e,r){for(let i=t.length-1;i>=0;i--){const s=t[i],a=[];if(s.outputs.forEach(l=>{const p=n[l.id];a.push(null!=p?p:null)}),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const o=s.gradient(a);for(const l in s.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);const p=e(()=>o[l]());if("float32"!==p.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${p.dtype}'`);const g=s.inputs[l];if(!Kt(p.shape,g.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${p.shape}', which does not match the shape of the input '${g.shape}'`);if(null==n[g.id])n[g.id]=p;else{const v=n[g.id];n[g.id]=r(v,p),v.dispose()}}}}(l,o,g=>this.tidy(g),Z2);const p=r.map(g=>l[g.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(g=>{for(const v of g.saved)v.dispose()}),this.state.activeTape=null),{value:a,grads:p}})}customGrad(e){return K(Ao(e),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{let i;K(r.every(l=>l instanceof Xi),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const s={};return r.forEach((l,p)=>{s[p]=l}),this.runKernelFunc({forwardFunc:(l,p)=>(i=e(...r,p),K(i.value instanceof Xi,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),K(Ao(i.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),i.value),backwardsFunc:(l,p)=>{const g=i.gradFunc(l,p),v=Array.isArray(g)?g:[g];K(v.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),K(v.every(N=>N instanceof Xi),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const w={};return v.forEach((N,D)=>{w[D]=()=>N}),w},inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,r){return this.state.tensorInfo.get(e).backend.readToGPU(e,r)}time(e){var r=this;return(0,Qe.Z)(function*(){const i=Fs(),s=yield r.backend.time(e);return s.wallMs=Fs()-i,s})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new gw;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return n.nextTensorId=0,n.nextVariableId=0,n})();function yw(){const n=Kc();if(null==n._tfengine){const t=new _s(n);n._tfengine=new K2(t)}return function ju(n){ma=n}(n._tfengine.ENV),function G2(n){Sc=n}(()=>n._tfengine),n._tfengine}const gt=yw();function Z2(n,t){return gt.runKernel(Ju,{a:n,b:t})}let Qy;function Br(n){Qy=n}function Pp(n){if(void 0!==Qy)return Qy;if(n||function j2(){return typeof navigator<"u"&&null!=navigator}()){if(n||(n=navigator),"ReactNative"===n.product)return!0;const t=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");return t?/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4)):n.userAgentData&&n.userAgentData.mobile}return!1}function gh(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}const Bu=Pt();function of(n,t){let e=n;if(yo(n))return"string"===t?[]:[n.length];if(hw(n))return[n.height,n.width*(n.channels||"RGBA").length];if(pw(n))return[n.buffer.size/(null==t?4:Zn(t))];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(e)||yo(e)&&"string"!==t;)r.push(e.length),e=e[0];return Array.isArray(n)&&Pt().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&vw(n,r,[]),r}function vw(n,t,e){if(e=e||[],!Array.isArray(n)&&!yo(n))return void K(0===t.length,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);K(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),K(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const r=t.slice(1);for(let i=0;i<n.length;++i)vw(n[i],r,e.concat(i))}function xw(n,t,e,r){if("string_or_numeric"!==n){if(null==n)throw new Error("Expected dtype cannot be null.");if("numeric"!==n&&n!==t||"numeric"===n&&"string"===t)throw new Error(`Argument '${e}' passed to '${r}' must be ${n} tensor, but got ${t} tensor`)}}function Xe(n,t,e,r="numeric"){if(n instanceof Xi)return xw(r,n.dtype,t,e),n;let i=Hc(n);if("string"!==i&&["bool","int32","float32"].indexOf(r)>=0&&(i=r),xw(r,i,t,e),null==n||!yo(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${null==n?"null":n.constructor.name}'`);const s=of(n,i);!yo(n)&&!Array.isArray(n)&&(n=[n]);const o="string"!==i?io(n,i):af(n,[],!0);return gt.makeTensor(o,s,i)}function Wd(n,t,e,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((s,a)=>Xe(s,`${t}[${a}]`,e,r))}Bu.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),Bu.registerFlag("IS_BROWSER",()=>gh()),Bu.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),Bu.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),Bu.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),Bu.registerFlag("PROD",()=>!1),Bu.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Bu.getBool("DEBUG")),Bu.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),Bu.registerFlag("IS_TEST",()=>!1),Bu.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Bu.getBool("DEBUG")),Bu.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),Bu.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),Bu.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);const ev="__op";function yt(n){const t=Object.keys(n);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const r=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e+=ev;const i=(...s)=>{gt.startScope(e);try{const a=r(...s);return Or(a)&&console.error("Cannot return a Promise inside of tidy."),gt.endScope(a),a}catch(a){throw gt.endScope(null),a}};return Object.defineProperty(i,"name",{value:e,configurable:!0}),i}const Uf=yt({complex_:function J2(n,t){const e=Xe(n,"real","complex"),r=Xe(t,"imag","complex");return xt(e.shape,r.shape,`real and imag shapes, ${e.shape} and ${r.shape}, must match in call to tf.complex().`),gt.runKernel(Pl,{real:e,imag:r})}});function yh(n,t,e,r){if(null==r)r=Hc(n);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(pw(n)||hw(n)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return gt.backend.createTensorFromGPUData(n,t||e,r)}if(!yo(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){cs(t);const i=ft(t),s=ft(e);K(i===s,()=>`Based on the provided shape, [${t}], the tensor should have ${i} values but has ${s}`);for(let a=0;a<e.length;++a){const l=a!==e.length-1||e[a]!==ft(t.slice(a));K(e[a]===t[a]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!yo(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n="string"!==r?io(n,r):af(n,[],!0),gt.makeTensor(n,t,r)}function al(n,t,e){return yh(n,t,of(n,e),e)}const Hd={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},_g=4;function tv(n,t){return Ng.apply(this,arguments)}function Ng(){return Ng=(0,Qe.Z)(function*(n,t){const e=[],r=[],i=Array.isArray(n)?n.map(a=>a.name):Object.keys(n);for(let a=0;a<i.length;++a){const o=i[a],l=Array.isArray(n)?n[a].tensor:n[o];if("float32"!==l.dtype&&"int32"!==l.dtype&&"bool"!==l.dtype&&"string"!==l.dtype&&"complex64"!==l.dtype)throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);const p={name:o,shape:l.shape,dtype:l.dtype};if("string"===l.dtype){const g=new Promise(function(){var v=(0,Qe.Z)(function*(w){const N=yield l.bytes(),D=N.reduce((L,$)=>L+$.length,0)+_g*N.length,O=new Uint8Array(D);let k=0;for(let L=0;L<N.length;L++){const $=N[L],U=new Uint8Array(new Uint32Array([$.length]).buffer);O.set(U,k),k+=_g,O.set($,k),k+=$.length}w(O)});return function(w){return v.apply(this,arguments)}}());r.push(g)}else r.push(l.data());null!=t&&(p.group=t),e.push(p)}return{data:Q2(yield Promise.all(r)),specs:e}}),Ng.apply(this,arguments)}function nv(n,t){const e={};let r,i=0;for(const s of t){const a=s.name,o=s.dtype,l=s.shape,p=ft(l);let g;if("quantization"in s){const v=s.quantization;if("uint8"===v.dtype||"uint16"===v.dtype){if(!("min"in v)||!("scale"in v))throw new Error(`Weight ${s.name} with quantization ${v.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==v.dtype)throw new Error(`Weight ${s.name} has unknown quantization dtype ${v.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==o)throw new Error(`Weight ${s.name} is quantized with ${v.dtype} which only supports weights of type float32 not ${o}.`)}const w=Hd[v.dtype],N=n.slice(i,i+p*w),D="uint8"===v.dtype?new Uint8Array(N):new Uint16Array(N);if("float32"===o)if("uint8"===v.dtype||"uint16"===v.dtype){g=new Float32Array(D.length);for(let O=0;O<D.length;O++)g[O]=D[O]*v.scale+v.min}else{if("float16"!==v.dtype)throw new Error(`Unsupported quantization type ${v.dtype} for weight type float32.`);void 0===r&&(r=_w()),g=r(D)}else{if("int32"!==o)throw new Error(`Unsupported dtype in weight '${a}': ${o}`);if("uint8"!==v.dtype&&"uint16"!==v.dtype)throw new Error(`Unsupported quantization type ${v.dtype} for weight type int32.`);g=new Int32Array(D.length);for(let O=0;O<D.length;O++)g[O]=Math.round(D[O]*v.scale+v.min)}i+=p*w}else if("string"===o){const v=ft(s.shape);g=[];for(let w=0;w<v;w++){const N=new Uint32Array(n.slice(i,i+_g))[0];i+=_g;const D=new Uint8Array(n.slice(i,i+N));g.push(D),i+=N}}else{const v=Hd[o],w=n.slice(i,i+p*v);if("float32"===o)g=new Float32Array(w);else if("int32"===o)g=new Int32Array(w);else if("bool"===o)g=new Uint8Array(w);else{if("complex64"!==o)throw new Error(`Unsupported dtype in weight '${a}': ${o}`);{g=new Float32Array(w);const N=new Float32Array(g.length/2),D=new Float32Array(g.length/2);for(let L=0;L<N.length;L++)N[L]=g[2*L],D[L]=g[2*L+1];const O=al(N,l,"float32"),k=al(D,l,"float32");e[a]=Uf(O,k),O.dispose(),k.dispose()}}i+=p*v}"complex64"!==o&&(e[a]=al(g,l,o))}return e}function Q2(n){if(null===n)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(s=>{if(t+=s.byteLength,e.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});const r=new Uint8Array(t);let i=0;return e.forEach(s=>{r.set(new Uint8Array(s.buffer),i),i+=s.byteLength}),r.buffer}const ii=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function bw(n){return ii?Buffer.byteLength(n):new Blob([n]).size}function Xd(n){if(1===n.length)return n[0];let t=0;n.forEach(i=>{t+=i.byteLength});const e=new Uint8Array(t);let r=0;return n.forEach(i=>{e.set(new Uint8Array(i),r),r+=i.byteLength}),e.buffer}function ww(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const e=n.split("/");return e[e.length-1]}function Zh(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return null!=n.signature&&(e.signature=n.signature),null!=n.userDefinedMetadata&&(e.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(e.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(e.initializerSignature=n.initializerSignature),null!=n.trainingConfig&&(e.trainingConfig=n.trainingConfig),e}function Hr(n,t,e){const r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(null!=n.trainingConfig&&(r.trainingConfig=n.trainingConfig),null!=n.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=e}return null!=n.signature&&(r.signature=n.signature),null!=n.userDefinedMetadata&&(r.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(r.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(r.initializerSignature=n.initializerSignature),r}function Yl(n,t){return ei.apply(this,arguments)}function ei(){return(ei=(0,Qe.Z)(function*(n,t){let e,r;return null!=n.weightsManifest&&([e,r]=yield t(n.weightsManifest)),Hr(n,e,r)})).apply(this,arguments)}function Fp(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==n.modelTopology?0:bw(JSON.stringify(n.modelTopology)),weightSpecsBytes:null==n.weightSpecs?0:bw(JSON.stringify(n.weightSpecs)),weightDataBytes:null==n.weightData?0:n.weightData.byteLength}}function Sg(n){const t=[];for(const e of n)t.push(...e.weights);return t}function _w(){const n=function Is(){const n=e=>{let r=e<<13,i=0;for(;!(8388608&r);)i-=8388608,r<<=1;return r&=-8388609,i+=947912704,r|i},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function Lp(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}(),e=function rv(){const n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}();return r=>{const i=new ArrayBuffer(4*r.length),s=new Uint32Array(i);for(let a=0;a<r.length;a++){const o=r[a];s[a]=n[e[o>>10]+(1023&o)]+t[o>>10]}return new Float32Array(i)}}class Xs{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Xs.instance&&(Xs.instance=new Xs),Xs.instance}static registerSaveRouter(t){Xs.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Xs.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Xs.getHandlers(t,"save")}static getLoadHandlers(t,e){return Xs.getHandlers(t,"load",e)}static getHandlers(t,e,r){const i=[];return("load"===e?Xs.getInstance().loadRouters:Xs.getInstance().saveRouters).forEach(a=>{const o=a(t,r);null!==o&&i.push(o)}),i}}const Nw=n=>Xs.registerSaveRouter(n),eA=n=>Xs.registerLoadRouter(n),Kd=n=>Xs.getSaveHandlers(n),iv=(n,t)=>Xs.getLoadHandlers(n,t),Yd="tensorflowjs",ti="models_store",jh="model_info_store";function Ig(){if(!Pt().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Sw(n){const t=n.result;t.createObjectStore(ti,{keyPath:"modelPath"}),t.createObjectStore(jh,{keyPath:"modelPath"})}let Ec=(()=>{class n{constructor(e){if(this.indexedDB=Ig(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var r=this;return(0,Qe.Z)(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return r.databaseAction(r.modelPath,e)})()}load(){var e=this;return(0,Qe.Z)(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,r){return new Promise((i,s)=>{const a=this.indexedDB.open(Yd,1);a.onupgradeneeded=()=>Sw(a),a.onsuccess=()=>{const o=a.result;if(null==r){const l=o.transaction(ti,"readonly"),g=l.objectStore(ti).get(this.modelPath);g.onsuccess=()=>{if(null==g.result)return o.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));i(g.result.modelArtifacts)},g.onerror=v=>(o.close(),s(g.error)),l.oncomplete=()=>o.close()}else{const l=Fp(r),p=o.transaction(jh,"readwrite");let v,w,g=p.objectStore(jh);try{v=g.put({modelPath:this.modelPath,modelArtifactsInfo:l})}catch(N){return s(N)}v.onsuccess=()=>{w=o.transaction(ti,"readwrite");const N=w.objectStore(ti);let D;try{D=N.put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:l})}catch(O){return s(O)}D.onsuccess=()=>i({modelArtifactsInfo:l}),D.onerror=O=>{g=p.objectStore(jh);const k=g.delete(this.modelPath);k.onsuccess=()=>(o.close(),s(D.error)),k.onerror=L=>(o.close(),s(D.error))}},v.onerror=N=>(o.close(),s(v.error)),p.oncomplete=()=>{null==w?o.close():w.oncomplete=()=>o.close()}}},a.onerror=o=>s(a.error)})}}return n.URL_SCHEME="indexeddb://",n})();const Zd=n=>Pt().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Ec.URL_SCHEME)?function jd(n){return new Ec(n)}(n.slice(Ec.URL_SCHEME.length)):null;Xs.registerSaveRouter(Zd),Xs.registerLoadRouter(Zd);class HL{constructor(){this.indexedDB=Ig()}listModels(){var t=this;return(0,Qe.Z)(function*(){return new Promise((e,r)=>{const i=t.indexedDB.open(Yd,1);i.onupgradeneeded=()=>Sw(i),i.onsuccess=()=>{const s=i.result,a=s.transaction(jh,"readonly"),l=a.objectStore(jh).getAll();l.onsuccess=()=>{const p={};for(const g of l.result)p[g.modelPath]=g.modelArtifactsInfo;e(p)},l.onerror=p=>(s.close(),r(l.error)),a.oncomplete=()=>s.close()},i.onerror=s=>r(i.error)})})()}removeModel(t){var e=this;return(0,Qe.Z)(function*(){return t=function WL(n){return n.startsWith(Ec.URL_SCHEME)?n.slice(Ec.URL_SCHEME.length):n}(t),new Promise((r,i)=>{const s=e.indexedDB.open(Yd,1);s.onupgradeneeded=()=>Sw(s),s.onsuccess=()=>{const a=s.result,o=a.transaction(jh,"readwrite"),l=o.objectStore(jh),p=l.get(t);let g;p.onsuccess=()=>{if(null==p.result)return a.close(),i(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const v=l.delete(t),w=()=>{g=a.transaction(ti,"readwrite");const D=g.objectStore(ti).delete(t);D.onsuccess=()=>r(p.result.modelArtifactsInfo),D.onerror=O=>i(p.error)};v.onsuccess=w,v.onerror=N=>(w(),a.close(),i(p.error))}},p.onerror=v=>(a.close(),i(p.error)),o.oncomplete=()=>{null==g?a.close():g.oncomplete=()=>a.close()}},s.onerror=a=>i(s.error)})})()}}const Vf="/",Jh="tensorflowjs_models",Ew="info",tA="model_topology",nA="weight_specs",rA="weight_data",iA="model_metadata";function av(n){return{info:[Jh,n,Ew].join(Vf),topology:[Jh,n,tA].join(Vf),weightSpecs:[Jh,n,nA].join(Vf),weightData:[Jh,n,rA].join(Vf),modelMetadata:[Jh,n,iA].join(Vf)}}function ov(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function aA(n){const t=n.split(Vf);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(Vf)}let Qh=(()=>{class n{constructor(e){if(!Pt().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=av(this.modelPath)}save(e){var r=this;return(0,Qe.Z)(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const i=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),a=Fp(e);try{return r.LS.setItem(r.keys.info,JSON.stringify(a)),r.LS.setItem(r.keys.topology,i),r.LS.setItem(r.keys.weightSpecs,s),r.LS.setItem(r.keys.weightData,function VL(n){if(ii)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let r=0,i=t.length;r<i;r++)e+=String.fromCharCode(t[r]);return btoa(e)}(e.weightData)),r.LS.setItem(r.keys.modelMetadata,JSON.stringify({format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0})),{modelArtifactsInfo:a}}catch{throw ov(r.keys),new Error(`Failed to save model '${r.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}})()}load(){var e=this;return(0,Qe.Z)(function*(){const r=JSON.parse(e.LS.getItem(e.keys.info));if(null==r)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==r.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const i={},s=JSON.parse(e.LS.getItem(e.keys.topology));if(null==s)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);i.modelTopology=s;const a=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==a)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);i.weightSpecs=a;const o=e.LS.getItem(e.keys.modelMetadata);if(null!=o){const p=JSON.parse(o);i.format=p.format,i.generatedBy=p.generatedBy,i.convertedBy=p.convertedBy,null!=p.signature&&(i.signature=p.signature),null!=p.userDefinedMetadata&&(i.userDefinedMetadata=p.userDefinedMetadata),null!=p.modelInitializer&&(i.modelInitializer=p.modelInitializer),null!=p.initializerSignature&&(i.initializerSignature=p.initializerSignature),null!=p.trainingConfig&&(i.trainingConfig=p.trainingConfig)}const l=e.LS.getItem(e.keys.weightData);if(null==l)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return i.weightData=function GL(n){if(ii){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let r=0;r<t.length;++r)e.set([t.charCodeAt(r)],r);return e.buffer}(l),i})()}}return n.URL_SCHEME="localstorage://",n})();const uA=n=>Pt().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Qh.URL_SCHEME)?function Iw(n){return new Qh(n)}(n.slice(Qh.URL_SCHEME.length)):null;Xs.registerSaveRouter(uA),Xs.registerLoadRouter(uA);class Cw{constructor(){K(Pt().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),K(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var t=this;return(0,Qe.Z)(function*(){const e={},r=Jh+Vf,i=Vf+Ew;for(let s=0;s<t.LS.length;++s){const a=t.LS.key(s);a.startsWith(r)&&a.endsWith(i)&&(e[aA(a)]=JSON.parse(t.LS.getItem(a)))}return e})()}removeModel(t){var e=this;return(0,Qe.Z)(function*(){const r=av(t=function oA(n){return n.startsWith(Qh.URL_SCHEME)?n.slice(Qh.URL_SCHEME.length):n}(t));if(null==e.LS.getItem(r.info))throw new Error(`Cannot find model at path '${t}'`);const i=JSON.parse(e.LS.getItem(r.info));return ov(r),i})()}}const $p="://";class yu{constructor(){this.managers={}}static getInstance(){return null==yu.instance&&(yu.instance=new yu),yu.instance}static registerManager(t,e){K(null!=t,()=>"scheme must not be undefined or null."),t.endsWith($p)&&(t=t.slice(0,t.indexOf($p))),K(t.length>0,()=>"scheme must not be an empty string.");const r=yu.getInstance();K(null==r.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=e}static getManager(t){const e=yu.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(yu.getInstance().managers)}}function Bp(n){if(-1===n.indexOf($p))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${yu.getSchemes().join(",")}`);return{scheme:n.split($p)[0],path:n.split($p)[1]}}function Aw(n,t){return Tw.apply(this,arguments)}function Tw(){return(Tw=(0,Qe.Z)(function*(n,t,e=!1){K(n!==t,()=>`Old path and new path are the same: '${n}'`);const r=Xs.getLoadHandlers(n);K(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),K(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);const i=r[0],s=Xs.getSaveHandlers(t);K(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),K(s.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);const a=s[0],o=Bp(n).scheme,l=Bp(n).path,p=o===Bp(n).scheme,g=yield i.load();e&&p&&(yield yu.getManager(o).removeModel(l));const v=yield a.save(g);return e&&!p&&(yield yu.getManager(o).removeModel(l)),v.modelArtifactsInfo})).apply(this,arguments)}function XL(){return Jd.apply(this,arguments)}function Jd(){return(Jd=(0,Qe.Z)(function*(){const n=yu.getSchemes(),t={};for(const e of n){const r=yield yu.getManager(e).listModels();for(const i in r)t[e+$p+i]=r[i]}return t})).apply(this,arguments)}function KL(n){return Cg.apply(this,arguments)}function Cg(){return(Cg=(0,Qe.Z)(function*(n){const t=Bp(n);return yu.getManager(t.scheme).removeModel(t.path)})).apply(this,arguments)}function lA(n,t){return uv.apply(this,arguments)}function uv(){return(uv=(0,Qe.Z)(function*(n,t){return Aw(n,t,!1)})).apply(this,arguments)}function lv(n,t){return zp.apply(this,arguments)}function zp(){return(zp=(0,Qe.Z)(function*(n,t){return Aw(n,t,!0)})).apply(this,arguments)}class cA{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){typeof window>"u"||!Pt().getBool("USE_SETTIMEOUTCUSTOM")?setTimeout(t,e):(this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{r.source===window&&r.data.name===this.messageName&&(r.stopPropagation(),(0,this.functionRefs[r.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0)))}isTypedArray(t){return Es(t)}}if(Pt().get("IS_BROWSER")){Pt().setPlatform("browser",new cA);try{yu.registerManager(Qh.URL_SCHEME,new Cw)}catch{}try{yu.registerManager(Ec.URL_SCHEME,new HL)}catch{}}let ep;function zr(n,t="float32",e){return t=t||"float32",cs(n),new Ga(n,t,e)}Pt().get("IS_NODE")&&!Pt().get("IS_BROWSER")&&Pt().setPlatform("node",new class Ag{constructor(){this.util=nn(8628),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=Pt().global.fetch?Pt().global.fetch(t,e):(null==ep&&(ep=nn(5410)),ep(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}});const _n=yt({cast_:function Mw(n,t){const e=Xe(n,"x","cast");if(!Yu(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==e.dtype||"string"!==t&&"string"===e.dtype)throw new Error("Only strings can be casted to strings");return gt.runKernel(rr,{x:e},{dtype:t})}}),Ic=yt({clone_:function Gf(n){const e={x:Xe(n,"x","clone","string_or_numeric")};return gt.runKernel(va,e)}});function Tg(n,t=!1){console.log(n.toString(t))}function Rw(){Pt().set("PROD",!0)}function fA(){Pt().set("DEBUG",!0)}function Dw(){Pt().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function fv(n){Pt().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function em(){gt.disposeVariables()}function Zl(){return gt}function tm(){return gt.memory()}function Ow(n){return gt.profile(n)}function Lt(n,t){return gt.tidy(n,t)}function Lr(n){zf(n).forEach(e=>e.dispose())}function so(n){return gt.keep(n)}function kw(n){return gt.time(n)}function Pw(n){return gt.setBackend(n)}function hA(){return gt.ready()}function Fw(){return gt.backendName}function Lw(n){gt.removeBackend(n)}function hv(n){return gt.findBackend(n)}function pA(n){return gt.findBackendFactory(n)}function Mg(n,t,e=1){return gt.registerBackend(n,t,e)}function pv(){return gt.backend}function $w(n,t){Pt().setPlatform(n,t)}yw(),function q2(n){kp=n}({buffer:zr,cast:_n,clone:Ic,print:Tg}),function W2(n){fw=n}(fv);const gn=yt({add_:function Bw(n,t){let e=Xe(n,"a","add"),r=Xe(t,"b","add");return[e,r]=fa(e,r),gt.runKernel(Ju,{a:e,b:r})}}),Rg=yt({floorDiv_:function zw(n,t){let e=Xe(n,"a","floorDiv"),r=Xe(t,"b","floorDiv");return[e,r]=fa(e,r),gt.runKernel(Do,{a:e,b:r})}}),ur=yt({div_:function dA(n,t){let e=Xe(n,"a","div"),r=Xe(t,"b","div");return[e,r]=fa(e,r),"int32"===e.dtype&&"int32"===r.dtype?Rg(e,r):gt.runKernel(Rf,{a:e,b:r},{})}}),_t=yt({mul_:function mA(n,t){let e=Xe(n,"a","mul"),r=Xe(t,"b","mul");return[e,r]=fa(e,r),gt.runKernel(du,{a:e,b:r})}}),zo=yt({sqrt_:function Uw(n){const e={x:Xe(n,"x","sqrt","float32")};return gt.runKernel(Rs,e)}}),Nr=yt({square_:function gA(n){const t=Xe(n,"x","square");return gt.runKernel("Square",{x:t},{})}}),di=yt({zerosLike_:function yA(n){const e={x:Xe(n,"x","zerosLike")};return gt.runKernel(mh,e)}});function Vw(n){return K(Ao(n),()=>"The f passed in grad(f) must be a function"),(t,e)=>{const r=Xe(t,"x","tf.grad","string_or_numeric"),i=null!=e?Xe(e,"dy","tf.grad"):null;return gt.tidy(()=>{const{value:s,grads:a}=gt.gradients(()=>n(r),[r],i);return null!=i&&xt(s.shape,i.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),nm(a),a[0]})}}function Gw(n){return K(Ao(n),()=>"The f passed in grads(f) must be a function"),(t,e)=>{K(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const r=Wd(t,"args","tf.grads","string_or_numeric"),i=null!=e?Xe(e,"dy","tf.grads"):null;return gt.tidy(()=>{const{value:s,grads:a}=gt.gradients(()=>n(...r),r,i);return null!=i&&xt(s.shape,i.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),nm(a),a})}}function qw(n){return K(Ao(n),()=>"The f passed in valueAndGrad(f) must be a function"),(t,e)=>{K(t instanceof Xi,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),K(null==e||e instanceof Xi,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:r,value:i}=gt.gradients(()=>n(t),[t],e);return nm(r),{grad:r[0],value:i}}}function Ww(n){return K(Ao(n),()=>"The f passed in valueAndGrads(f) must be a function"),(t,e)=>{K(Array.isArray(t)&&t.every(i=>i instanceof Xi),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),K(null==e||e instanceof Xi,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const r=gt.gradients(()=>n(...t),t,e);return null!=e&&xt(r.value.shape,e.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),nm(r.grads),r}}function dv(n,t){K(Ao(n),()=>"The f passed in variableGrads(f) must be a function"),K(null==t||Array.isArray(t)&&t.every(p=>p instanceof qd),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=null!=t;if(!e){t=[];for(const p in gt.registeredVariables)t.push(gt.registeredVariables[p])}const r=e?t.filter(p=>!p.trainable):null,i=t.length;K((t=t.filter(p=>p.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);const{value:a,grads:o}=gt.gradients(n,t,null,!0);K(o.some(p=>null!=p),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),K(0===a.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const l={};return t.forEach((p,g)=>{null!=o[g]&&(l[p.name]=o[g])}),r?.forEach(p=>l[p.name]=null),{value:a,grads:l}}function Cc(n){return gt.customGrad(n)}function nm(n){if(n.filter(e=>null==e).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}function mr(n,t){if((yo(n)&&"string"!==t||Array.isArray(n))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&yo(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return yh(n,[],[],t)}class xh{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class El{constructor(){this.classNameMap={}}static getMap(){return null==El.instance&&(El.instance=new El),El.instance}static register(t){El.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function yn(n){K(null!=n.className,()=>"Class being registered does not have the static className property defined."),K("string"==typeof n.className,()=>"className is required to be a string, but got type "+typeof n.className),K(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),El.register(n)}class uf extends xh{minimize(t,e=!1,r){const{value:i,grads:s}=this.computeGradients(t,r);if(null!=r){const a=r.map(o=>({name:o.name,tensor:s[o.name]}));this.applyGradients(a)}else this.applyGradients(s);return Lr(s),e?i:(i.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return dv(t,e)}dispose(){null!=this.iterations_&&Lr(this.iterations_)}saveIterations(){var t=this;return(0,Qe.Z)(function*(){return null==t.iterations_&&(t.iterations_=0),{name:"iter",tensor:mr(t.iterations_,"int32")}})()}getWeights(){return(0,Qe.Z)(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(t){var e=this;return(0,Qe.Z)(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${e.getClassName()}`)})()}extractIterations(t){var e=this;return(0,Qe.Z)(function*(){return e.iterations_=(yield t[0].tensor.data())[0],t.slice(1)})()}}Object.defineProperty(uf,Symbol.hasInstance,{value:n=>null!=n.minimize&&null!=n.computeGradients&&null!=n.applyGradients});class mv extends uf{static get className(){return"Adadelta"}constructor(t,e,r=null){super(),this.learningRate=t,this.rho=e,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==r&&(this.epsilon=gt.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,i)=>{const s=gt.registeredVariables[r];null==this.accumulatedGrads[i]&&(this.accumulatedGrads[i]={originalName:`${r}/accum_grad`,variable:Lt(()=>di(s).variable(!1))}),null==this.accumulatedUpdates[i]&&(this.accumulatedUpdates[i]={originalName:`${r}/accum_var`,variable:Lt(()=>di(s).variable(!1))});const o=Array.isArray(t)?t[i].tensor:t[r];if(null==o)return;const l=this.accumulatedGrads[i].variable,p=this.accumulatedUpdates[i].variable;Lt(()=>{const g=gn(_t(l,this.rho),_t(Nr(o),1-this.rho)),v=_t(ur(zo(gn(p,this.epsilon)),zo(gn(l,this.epsilon))),o),w=gn(_t(p,this.rho),_t(Nr(v),1-this.rho));l.assign(g),p.assign(w);const N=gn(_t(v,-this.learningRate),s);s.assign(N)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Lr(this.accumulatedGrads.map(t=>t.variable)),Lr(this.accumulatedUpdates.map(t=>t.variable)))}getWeights(){var t=this;return(0,Qe.Z)(function*(){const e=[...t.accumulatedGrads,...t.accumulatedUpdates];return[yield t.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(t){var e=this;return(0,Qe.Z)(function*(){const r=(t=yield e.extractIterations(t)).length/2;e.accumulatedGrads=t.slice(0,r).map(s=>({originalName:s.name,variable:s.tensor.variable(!1)})),e.accumulatedUpdates=t.slice(r,2*r).map(s=>({originalName:s.name,variable:s.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}function tp(n,t,e){return cs(n),e=e||Hc(t),gt.runKernel(Ru,{},{shape:n,value:t,dtype:e})}class Dg extends uf{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,i)=>{const s=gt.registeredVariables[r];null==this.accumulatedGrads[i]&&(this.accumulatedGrads[i]={originalName:`${r}/accumulator`,variable:Lt(()=>tp(s.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(t)?t[i].tensor:t[r];if(null==a)return;const o=this.accumulatedGrads[i].variable;Lt(()=>{const l=gn(o,Nr(a));o.assign(l);const p=gn(_t(ur(a,zo(gn(l,gt.backend.epsilon()))),-this.learningRate),s);s.assign(p)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Lr(this.accumulatedGrads.map(t=>t.variable))}getWeights(){var t=this;return(0,Qe.Z)(function*(){return[yield t.saveIterations()].concat(t.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(t){var e=this;return(0,Qe.Z)(function*(){t=yield e.extractIterations(t),e.accumulatedGrads=t.map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}const lf=yt({pow_:function Hw(n,t){let e=Xe(n,"base","pow"),r=Xe(t,"exp","pow");return[e,r]=fa(e,r),gt.runKernel(zl,{a:e,b:r})}}),Hn=yt({sub_:function Xw(n,t){let e=Xe(n,"a","sub"),r=Xe(t,"b","sub");return[e,r]=fa(e,r),gt.runKernel(il,{a:e,b:r})}});class Og extends uf{static get className(){return"Adam"}constructor(t,e,r,i=null){super(),this.learningRate=t,this.beta1=e,this.beta2=r,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Lt(()=>{this.accBeta1=mr(e).variable(),this.accBeta2=mr(r).variable()}),null==i&&(this.epsilon=gt.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);Lt(()=>{const r=Hn(1,this.accBeta1),i=Hn(1,this.accBeta2);e.forEach((s,a)=>{const o=gt.registeredVariables[s];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:Lt(()=>di(o).variable(!1))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${s}/v`,variable:Lt(()=>di(o).variable(!1))});const p=Array.isArray(t)?t[a].tensor:t[s];if(null==p)return;const g=this.accumulatedFirstMoment[a].variable,v=this.accumulatedSecondMoment[a].variable,w=gn(_t(g,this.beta1),_t(p,1-this.beta1)),N=gn(_t(v,this.beta2),_t(Nr(p),1-this.beta2)),D=ur(w,r),O=ur(N,i);g.assign(w),v.assign(N);const k=gn(_t(ur(D,gn(zo(O),this.epsilon)),-this.learningRate),o);o.assign(k)}),this.accBeta1.assign(_t(this.accBeta1,this.beta1)),this.accBeta2.assign(_t(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Lr(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedSecondMoment&&Lr(this.accumulatedSecondMoment.map(t=>t.variable))}getWeights(){var t=this;return(0,Qe.Z)(function*(){const e=[...t.accumulatedFirstMoment,...t.accumulatedSecondMoment];return[yield t.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(t){var e=this;return(0,Qe.Z)(function*(){t=yield e.extractIterations(t),Lt(()=>{e.accBeta1.assign(lf(e.beta1,e.iterations_+1)),e.accBeta2.assign(lf(e.beta2,e.iterations_+1))});const r=t.length/2;e.accumulatedFirstMoment=t.slice(0,r).map(s=>({originalName:s.name,variable:s.tensor.variable(!1)})),e.accumulatedSecondMoment=t.slice(r,2*r).map(s=>({originalName:s.name,variable:s.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}const Ra=yt({abs_:function vA(n){const t=Xe(n,"x","abs");return gt.runKernel("complex64"===t.dtype?Zi:ga,{x:t})}});function np(n,t){const e=n.length,r=[];for(let i=0;i<e;i++){const s=e-1-i;(t[t.length-1-i]||1)>1&&1===(n[s]||1)&&r.unshift(s)}return r}function qa(n,t){const e=[];for(let r=0;r<t.length;r++){const i=n[n.length-r-1],s=t.length-r-1;(null==i||1===i&&t[s]>1)&&e.unshift(s)}return e}function $r(n,t){const e=Math.max(n.length,t.length),r=new Array(e);for(let i=0;i<e;i++){let s=n[n.length-i-1];null==s&&(s=1);let a=t[t.length-i-1];if(null==a&&(a=1),1===s)r[e-i-1]=a;else if(1===a)r[e-i-1]=s;else{if(s!==a)throw Error(`Operands could not be broadcast together with shapes ${n} and ${t}.`);r[e-i-1]=s}}return r}const cf=yt({maximum_:function xA(n,t){let e=Xe(n,"a","maximum"),r=Xe(t,"b","maximum");return[e,r]=fa(e,r),"bool"===e.dtype&&(e=_n(e,"int32"),r=_n(r,"int32")),$r(e.shape,r.shape),gt.runKernel(Ko,{a:e,b:r})}});class kg extends uf{static get className(){return"Adamax"}constructor(t,e,r,i=null,s=0){super(),this.learningRate=t,this.beta1=e,this.beta2=r,this.epsilon=i,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Lt(()=>{this.iteration=mr(0).variable(),this.accBeta1=mr(e).variable()}),null==i&&(this.epsilon=gt.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);Lt(()=>{const r=Hn(1,this.accBeta1),i=ur(-this.learningRate,gn(_t(this.iteration,this.decay),1));e.forEach((s,a)=>{const o=gt.registeredVariables[s];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:di(o).variable(!1)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${s}/v`,variable:di(o).variable(!1)});const p=Array.isArray(t)?t[a].tensor:t[s];if(null==p)return;const g=this.accumulatedFirstMoment[a].variable,v=this.accumulatedWeightedInfNorm[a].variable,w=gn(_t(g,this.beta1),_t(p,1-this.beta1)),N=_t(v,this.beta2),D=Ra(p),O=cf(N,D);g.assign(w),v.assign(O);const k=gn(_t(ur(i,r),ur(w,gn(O,this.epsilon))),o);o.assign(k)}),this.iteration.assign(gn(this.iteration,1)),this.accBeta1.assign(_t(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Lr(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedWeightedInfNorm&&Lr(this.accumulatedWeightedInfNorm.map(t=>t.variable))}getWeights(){return(0,Qe.Z)(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(t){return(0,Qe.Z)(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}class Pg extends uf{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,i)=>{const s=Array.isArray(t)?t[i].tensor:t[r];if(null==s)return;const a=gt.registeredVariables[r];Lt(()=>{const o=gn(_t(this.c,s),a);a.assign(o)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=so(mr(-t))}dispose(){this.c.dispose()}getWeights(){var t=this;return(0,Qe.Z)(function*(){return[yield t.saveIterations()]})()}setWeights(t){var e=this;return(0,Qe.Z)(function*(){if(0!==(t=yield e.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}class gv extends Pg{static get className(){return"Momentum"}constructor(t,e,r=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=r,this.accumulations=[],this.m=mr(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,i)=>{const s=gt.registeredVariables[r];null==this.accumulations[i]&&(this.accumulations[i]={originalName:`${r}/momentum`,variable:Lt(()=>di(s).variable(!1))});const a=this.accumulations[i].variable,o=Array.isArray(t)?t[i].tensor:t[r];null!=o&&Lt(()=>{let l;const p=gn(_t(this.m,a),o);l=gn(_t(this.c,this.useNesterov?gn(o,_t(p,this.m)):p),s),a.assign(p),s.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Lr(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}getWeights(){var t=this;return(0,Qe.Z)(function*(){return[yield t.saveIterations()].concat(t.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(t){var e=this;return(0,Qe.Z)(function*(){t=yield e.extractIterations(t),e.accumulations=t.map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}class Fg extends uf{static get className(){return"RMSProp"}constructor(t,e=.9,r=0,i=null,s=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=r,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==i&&(this.epsilon=gt.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,i)=>{const s=gt.registeredVariables[r],a=!1;null==this.accumulatedMeanSquares[i]&&(this.accumulatedMeanSquares[i]={originalName:`${r}/rms`,variable:Lt(()=>di(s).variable(a))}),null==this.accumulatedMoments[i]&&(this.accumulatedMoments[i]={originalName:`${r}/momentum`,variable:Lt(()=>di(s).variable(a))}),null==this.accumulatedMeanGrads[i]&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${r}/mg`,variable:Lt(()=>di(s).variable(a))});const o=Array.isArray(t)?t[i].tensor:t[r];if(null==o)return;const l=this.accumulatedMeanSquares[i].variable,p=this.accumulatedMoments[i].variable;Lt(()=>{const g=gn(_t(l,this.decay),_t(Nr(o),1-this.decay));if(this.centered){const v=this.accumulatedMeanGrads[i].variable,w=gn(_t(v,this.decay),_t(o,1-this.decay)),N=ur(_t(o,this.learningRate),zo(Hn(g,gn(Nr(w),this.epsilon)))),D=gn(_t(p,this.momentum),N);l.assign(g),v.assign(w),p.assign(D);const O=Hn(s,D);s.assign(O)}else{const v=gn(_t(l,this.decay),_t(Nr(o),1-this.decay)),w=gn(_t(p,this.momentum),ur(_t(o,this.learningRate),zo(gn(v,this.epsilon))));l.assign(v),p.assign(w);const N=Hn(s,w);s.assign(N)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Lr(this.accumulatedMeanSquares.map(t=>t.variable)),null!=this.accumulatedMeanGrads&&this.centered&&Lr(this.accumulatedMeanGrads.map(t=>t.variable)),null!=this.accumulatedMoments&&Lr(this.accumulatedMoments.map(t=>t.variable))}getWeights(){var t=this;return(0,Qe.Z)(function*(){const e=[...t.accumulatedMeanSquares,...t.accumulatedMoments];return t.centered&&e.push(...t.accumulatedMeanGrads),[yield t.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(t){var e=this;return(0,Qe.Z)(function*(){t=yield e.extractIterations(t);const r=e.centered?t.length/3:t.length/2,i=!1;e.accumulatedMeanSquares=t.slice(0,r).map(s=>({originalName:s.name,variable:s.tensor.variable(i)})),e.accumulatedMoments=t.slice(r,2*r).map(s=>({originalName:s.name,variable:s.tensor.variable(i)})),e.centered&&(e.accumulatedMeanGrads=t.slice(2*r,3*r).map(s=>({originalName:s.name,variable:s.tensor.variable(i)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}const bA=[mv,Dg,Og,kg,gv,Fg,Pg];function yv(n){return new Promise(t=>setTimeout(t)).then(n)}let vv=(()=>{class n{constructor(e){if(!Pt().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(n.URL_SCHEME)&&(e=e.slice(n.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}save(e){var r=this;return(0,Qe.Z)(function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const i=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const a=Zh(e,[{paths:["./"+r.weightDataFileName],weights:e.weightSpecs}]),o=window.URL.createObjectURL(new Blob([JSON.stringify(a)],{type:"application/json"})),l=null==r.modelJsonAnchor?document.createElement("a"):r.modelJsonAnchor;if(l.download=r.modelJsonFileName,l.href=o,yield yv(()=>l.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const p=null==r.weightDataAnchor?document.createElement("a"):r.weightDataAnchor;p.download=r.weightDataFileName,p.href=i,yield yv(()=>p.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Fp(e)}}})()}}return n.URL_SCHEME="downloads://",n})();class SA{constructor(t){if(null==t||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}load(){var t=this;return(0,Qe.Z)(function*(){return new Promise((e,r)=>{const i=new FileReader;i.onload=s=>{const a=JSON.parse(s.target.result),o=a.modelTopology;if(null==o)return void r(new Error(`modelTopology field is missing from file ${t.jsonFile.name}`));if(null==a.weightsManifest)return void r(new Error(`weightManifest field is missing from file ${t.jsonFile.name}`));if(0===t.weightsFiles.length)return void e({modelTopology:o});const p=Yl(a,g=>t.loadWeights(g));e(p)},i.onerror=s=>r(`Failed to read model topology and weights manifest JSON from file '${t.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),i.readAsText(t.jsonFile)})})()}loadWeights(t){const e=[],r=[];for(const a of t)e.push(...a.weights),r.push(...a.paths);const i=this.checkManifestAndWeightFiles(t),s=r.map(a=>this.loadWeightsFile(a,i[a]));return Promise.all(s).then(a=>[e,Xd(a)])}loadWeightsFile(t,e){return new Promise((r,i)=>{const s=new FileReader;s.onload=a=>{r(a.target.result)},s.onerror=a=>i(`Failed to weights data from file of path '${t}'.`),s.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){const e=[],r=this.weightsFiles.map(s=>ww(s.name)),i={};for(const s of t)s.paths.forEach(a=>{const o=ww(a);if(-1!==e.indexOf(o))throw new Error(`Duplicate file basename found in weights manifest: '${o}'`);if(e.push(o),-1===r.indexOf(o))throw new Error(`Weight file with basename '${o}' is not provided.`);i[a]=this.weightsFiles[r.indexOf(o)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return i}}function CA(n){return new SA(n)}function Yw(n,t,e,r){(function a(l){K(null!=l&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")})(n),function o(l,p){K(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),K(p>=0&&p<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${p}`),K(p>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${p}`)}(e=e??0,r=r??1);let i=0;return Promise.all(n.map(l=>(l.then(p=>{const g=e+ ++i/n.length*(r-e);return t(g),p}),l)))}function Zw(n,t){return xv.apply(this,arguments)}function xv(){return(xv=(0,Qe.Z)(function*(n,t){null==t&&(t={});const e=null==t.fetchFunc?Pt().platform.fetch:t.fetchFunc,r=n.map(v=>e(v,t.requestInit,{isBinary:!0})),o=(null==t.onProgress?yield Promise.all(r):yield Yw(r,t.onProgress,0,.5)).map(v=>v.arrayBuffer());return null==t.onProgress?yield Promise.all(o):yield Yw(o,t.onProgress,.5,1)})).apply(this,arguments)}function bv(n){return wv.apply(this,arguments)}function wv(){return(wv=(0,Qe.Z)(function*(n,t="",e,r){return jw(a=>Zw(a,{requestInit:r}))(n,t,e)})).apply(this,arguments)}function jw(n){return function(){var t=(0,Qe.Z)(function*(e,r="",i){const s=e.map(()=>!1),a={},o=null!=i?i.map(()=>!1):[],l=[];if(e.forEach((D,O)=>{let k=0;D.weights.forEach(L=>{const U=Hd["quantization"in L?L.quantization.dtype:L.dtype]*ft(L.shape),V=()=>{s[O]=!0,null==a[O]&&(a[O]=[]),a[O].push({manifestEntry:L,groupOffset:k,sizeBytes:U})};null!=i?i.forEach((W,ce)=>{W===L.name&&(V(),o[ce]=!0)}):V(),l.push(L.name),k+=U})}),!o.every(D=>D)){const D=i.filter((O,k)=>!o[k]);throw new Error(`Could not find weights in manifest with names: ${D.join(", ")}. \nManifest JSON has weights with names: ${l.join(", ")}.`)}const p=s.reduce((D,O,k)=>(O&&D.push(k),D),[]),g=[];p.forEach(D=>{e[D].paths.forEach(O=>{const k=r+(r.endsWith("/")?"":"/")+O;g.push(k)})});const v=yield n(g),w={};let N=0;return p.forEach(D=>{const O=e[D].paths.length;let k=0;for(let W=0;W<O;W++)k+=v[N+W].byteLength;const L=new ArrayBuffer(k),$=new Uint8Array(L);let U=0;for(let W=0;W<O;W++){const ce=new Uint8Array(v[N+W]);$.set(ce,U),U+=ce.byteLength}a[D].forEach(W=>{const ve=nv(L.slice(W.groupOffset,W.groupOffset+W.sizeBytes),[W.manifestEntry]);for(const Ee in ve)w[Ee]=ve[Ee]}),N+=O}),w});return function(e){return t.apply(this,arguments)}}()}Xs.registerSaveRouter(n=>Pt().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(vv.URL_SCHEME)?function IA(n="model"){return new vv(n)}(n.slice(vv.URL_SCHEME.length)):null);let Jw=(()=>{class n{constructor(e,r){if(this.DEFAULT_METHOD="POST",null==r&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.onProgress=r.onProgress,this.weightUrlConverter=r.weightUrlConverter,null!=r.fetchFunc?(K("function"==typeof r.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=Pt().platform.fetch,K(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&K(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=r.requestInit&&null!=r.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{}}save(e){var r=this;return(0,Qe.Z)(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const i=Object.assign({method:r.DEFAULT_METHOD},r.requestInit);i.body=new FormData;const a=Zh(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);i.body.append("model.json",new Blob([JSON.stringify(a)],{type:"application/json"}),"model.json"),null!=e.weightData&&i.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const o=yield r.fetch(r.path,i);if(o.ok)return{modelArtifactsInfo:Fp(e),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)})()}load(){var e=this;return(0,Qe.Z)(function*(){const r=yield e.fetch(e.path,e.requestInit);if(!r.ok)throw new Error(`Request to ${e.path} failed with status code ${r.status}. Please verify this URL points to the model JSON of the model to load.`);let i;try{i=yield r.json()}catch{let l=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?l+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":l+=" Please make sure the server is serving valid JSON for this request.",new Error(l)}if(null==i.modelTopology&&null==i.weightsManifest)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);return Yl(i,o=>e.loadWeights(o))})()}loadWeights(e){var r=this;return(0,Qe.Z)(function*(){const i=Array.isArray(r.path)?r.path[1]:r.path,[s,a]=function MA(n){const t=n.lastIndexOf("/"),e=n.lastIndexOf("?");return[n.substring(0,t)+"/",e>t?n.substring(e):""]}(i),o=r.weightPathPrefix||s,l=Sg(e),p=[],g=[];for(const w of e)for(const N of w.paths)null!=r.weightUrlConverter?g.push(r.weightUrlConverter(N)):p.push(o+N+a);return r.weightUrlConverter&&p.push(...yield Promise.all(g)),[l,Xd(yield Zw(p,{requestInit:r.requestInit,fetchFunc:r.fetch,onProgress:r.onProgress}))]})()}}return n.URL_SCHEME_REGEX=/^https?:\/\//,n})();function rp(n){return null!=n.match(Jw.URL_SCHEME_REGEX)}const Qw=(n,t)=>{if(typeof fetch>"u"&&(null==t||null==t.fetchFunc))return null;{let e=!0;if(e=Array.isArray(n)?n.every(r=>rp(r)):rp(n),e)return rm(n,t)}return null};function rm(n,t){return new Jw(n,t)}function im(n,t){return rm(n,t)}Xs.registerSaveRouter(Qw),Xs.registerLoadRouter(Qw);class _v{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class e_{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class RA{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function DA(n,t,e,r){return new RA(qf(...arguments))}function qf(n,t,e,r){return 1===arguments.length?null!=n.modelTopology||null!=n.weightSpecs?new _v(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new _v({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new _v({modelTopology:n,weightSpecs:t,weightData:e,trainingConfig:r}))}function t_(n){return new e_(n)}function n_(n){return new e_(n)}const ni=yt({matMul_:function r_(n,t,e=!1,r=!1){let i=Xe(n,"a","matMul"),s=Xe(t,"b","matMul");return[i,s]=fa(i,s),gt.runKernel(fs,{a:i,b:s},{transposeA:e,transposeB:r})}}),ip=yt({oneHot_:function i_(n,t,e=1,r=0,i="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const a={indices:Xe(n,"indices","oneHot","int32")};return gt.runKernel(ko,a,{dtype:i,depth:t,onValue:e,offValue:r})}}),Up=yt({imag_:function s_(n){const e={input:Xe(n,"input","imag")};return gt.runKernel(vl,e)}}),Ls=yt({neg_:function OA(n){const e={x:Xe(n,"x","neg")};return gt.runKernel(mu,e)}}),Vp=yt({real_:function a_(n){const e={input:Xe(n,"input","real")};return gt.runKernel(xc,e)}}),ui=yt({transpose_:function kA(n,t,e){const r=Xe(n,"x","transpose");if(null==t&&(t=r.shape.map((a,o)=>o).reverse()),K(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(a=>{K(a>=0&&a<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();const i={x:r},s={perm:t};return"complex64"===r.dtype?Lt(()=>{let a=Vp(r),o=Up(r);return a=gt.runKernel(Wl,{x:a},s),o=gt.runKernel(Wl,{x:o},s),e&&(o=Ls(o)),Uf(a,o)}):gt.runKernel(Wl,i,s)}}),FA=yt({confusionMatrix_:function PA(n,t,e){const r=Xe(n,"labels","confusionMatrix"),i=Xe(t,"predictions","confusionMatrix");K(null==e||e>0&&Number.isInteger(e),()=>`If provided, numClasses must be a positive integer, but got ${e}`),K(1===r.rank,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),K(1===i.rank,()=>`Expected the rank of predictions to be 1, but got ${i.rank}`),K(r.shape[0]===i.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${i.shape[0]}. Labels and predictions should have the same number of elements.`),K(e>0&&Number.isInteger(e),()=>`numClasses is required to be a positive integer, but got ${e}`);const s=ip(_n(r,"int32"),e),a=ip(_n(i,"int32"),e),o=ui(s),l=ni(o,a);return _n(l,"int32")}});function Ac(n,t,e){if(on(n),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=of(n,e);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return yh(n,t,r,e)}let bh;function Nv(n,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==n)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,r=!1,i=!1,s=!1,a=!1,o=!1;if(n.data instanceof Uint8Array)e=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)i=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)s=!0;else if(null!=n.getContext)a=!0;else{if(!(typeof ImageBitmap<"u"&&n instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);o=!0}if(null!=Nc(Bo,gt.backendName))return gt.runKernel(Bo,{pixels:n},{numChannels:t});const[p,g]=i?[n.videoWidth,n.videoHeight]:[n.width,n.height];let v,w;if(a)v=n.getContext("2d").getImageData(0,0,p,g).data;else if(r||e)v=n.data;else if(s||i||o){if(null==bh)if(typeof document>"u"){if(!(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u"))throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");bh=new OffscreenCanvas(1,1).getContext("2d")}else bh=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});bh.canvas.width=p,bh.canvas.height=g,bh.drawImage(n,0,0,p,g),v=bh.getImageData(0,0,p,g).data}if(4===t)w=new Int32Array(v);else{const D=p*g;w=new Int32Array(D*t);for(let O=0;O<D;O++)for(let k=0;k<t;++k)w[O*t+k]=v[4*O+k]}return Ac(w,[g,p,t],"int32")}function zA(n){return Sv.apply(this,arguments)}function Sv(){return(Sv=(0,Qe.Z)(function*(n,t=3){let e=null;if(Pt().getBool("WRAP_TO_IMAGEBITMAP")&&function BA(n){return function $A(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}()&&!(n instanceof ImageBitmap)&&function o_(n){return null!=n&&0!==n.width&&0!==n.height}(n)&&!function LA(n){return null!=n&&n.data instanceof Uint8Array}(n)}(n)){let r;try{r=yield createImageBitmap(n,{premultiplyAlpha:"none"})}catch{r=null}e=null!=r&&r.width===n.width&&r.height===n.height?r:n}else e=n;return Nv(e,t)})).apply(this,arguments)}function u_(n,t){return Ev.apply(this,arguments)}function Ev(){return(Ev=(0,Qe.Z)(function*(n,t){let e=Xe(n,"img","toPixels");if(!(n instanceof Xi)){const p=e;e=_n(p,"int32"),p.dispose()}if(2!==e.rank&&3!==e.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);const[r,i]=e.shape.slice(0,2),s=2===e.rank?1:e.shape[2];if(s>4||2===s)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`);const a=yield e.data(),o="float32"===e.dtype?255:1,l=new Uint8ClampedArray(i*r*4);for(let p=0;p<r*i;++p){const g=[0,0,0,255];for(let w=0;w<s;w++){const N=a[p*s+w];if("float32"===e.dtype){if(N<0||N>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${N}.`)}else if("int32"===e.dtype&&(N<0||N>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${N}.`);1===s?(g[0]=N*o,g[1]=N*o,g[2]=N*o):g[w]=N*o}const v=4*p;l[v+0]=Math.round(g[0]),l[v+1]=Math.round(g[1]),l[v+2]=Math.round(g[2]),l[v+3]=Math.round(g[3])}if(null!=t){t.width=i,t.height=r;const p=t.getContext("2d"),g=new ImageData(l,i,r);p.putImageData(g,0,0)}return e!==n&&e.dispose(),l})).apply(this,arguments)}const l_=yt({fromPixels_:Nv});function sm(n,t){const e=n.shape.length,r=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${e}`);if(0===ft(n.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const i=t.shape,s=i[i.length-1];let a=1;for(let v=0;v<i.length-1;++v)a*=i[v];const o=n.shape,l=i.slice();l.pop();let p=1;for(let v=s;v<e;++v)p*=o[v],l.push(o[v]);const g=[...zn(n.shape).map(v=>v/p),1].slice(0,s);return[l,a,p,g]}function Iv(n,t,e){const r=t.rank>1?t.shape[t.rank-1]:1,i=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${i}.`;if(e.rank<i)throw new Error(s+` update.rank < ${i}. `);if(n.length<r+(e.rank-i))throw new Error(s+` Output shape length < ${r+(e.rank-i)}`);if(e.rank!==i+n.length-r)throw new Error(s+" update.rank != "+(i+n.length-r));for(let a=0;a<i;++a)if(e.shape[a]!==t.shape[a])throw new Error(s+` updates.shape[${a}] (${e.shape[a]}) != indices.shape[${a}] (${t.shape[a]}).`);for(let a=0;a<e.rank-i;++a)if(e.shape[a+i]!==n[a+r])throw new Error(s+` updates.shape[${a+i}] (${e.shape[a+i]}) != shape[${a+i}] (${n[a+i]})`)}function Lg(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(0===e.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===n.size)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}Iv(e,t,n)}function Wf(n,t,e){const r=t.shape.length,i=r>1?t.shape[r-1]:1,s=e.length;let a=1;for(let v=i;v<s;++v)a*=e[v];const o=i<1?1:i;return{sliceRank:i,numUpdates:ft(t.shape)/o,sliceSize:a,strides:[...zn(e.slice(0,i)),1],outputSize:ft(e)}}const Cv=-2,UA=-1;function $g(n,t,e){const r=n.shape.length;K(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),K(r===e.length,()=>`Error in slice${r}D: Length of size ${e} must match the rank of the array (${r}).`);for(let i=0;i<r;++i)K(t[i]+e[i]<=n.shape[i],()=>`Error in slice${r}D: begin[${i}] + size[${i}] (${t[i]+e[i]}) would overflow input.shape[${i}] (${n.shape[i]})`)}function VA(n){const t=[];let e=0;for(;n>0;)1&n&&t.push(e),n/=2,e++;return t}function Av(n,t,e){const r=[];for(let i=0;i<n.length;i++)r[i]=Math.ceil((t[i]-n[i])/e[i]);return r}function Tv(n,t,e,r){const i=[...n];for(let s=i.length;s<r.length;s++)i.push(1);for(let s=0;s<e;s++)0===s?i[t]=1:(i.splice(t,0,1),i.pop());return i}function c_(n,t,e){return e<=n?e:e-(t-1)}function f_(n,t){const e=[];for(let r=0;r<n;r++)e.push(t+r);return e}function ff(n,t,e,r,i,s,a,o,l){const p=n.length;let g=new Array(p),v=new Array(p),w=new Array(p);if(t.length&&e>0){const N=t[0],D=e+1;g=h_(a,N,D,r,n),v=am(o,N,D,i,n),w=Tv(s,N,D,n)}else for(let N=0;N<p;N++)g[N]=d_(a,r,s,n,N,l),v[N]=GA(o,i,s,n,N,l),w[N]=p_(s,N,l);return{begin:g,end:v,strides:w}}function h_(n,t,e,r,i){const s=[...i],a=f_(e,t);for(let o=0;o<s.length;o++)if(a.indexOf(o)>-1)s[o]=0;else{const l=c_(t,e,o);let p=r[l];n&1<<l&&(p=0),s[o]=p}return s}function am(n,t,e,r,i){const s=[...i],a=f_(e,t);for(let o=0;o<s.length;o++)if(a.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{const l=c_(t,e,o);let p=r[l];n&1<<l&&(p=Number.MAX_SAFE_INTEGER),s[o]=p}for(let o=0;o<s.length;o++)s[o]<0&&(s[o]+=i[o]),s[o]=Oe(0,s[o],i[o]);return s}function p_(n,t,e){let r=n[t];return(e&1<<t||null==r)&&(r=1),r}function d_(n,t,e,r,i,s){let a=t[i];(n&1<<i||s&1<<i||null==a)&&(a=(e[i]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[i];return a<0&&(a+=l),a=Oe(0,a,l-1),a}function GA(n,t,e,r,i,s){let a=t[i];const o=e[i]||1;(n&1<<i||s&1<<i||null==a)&&(a=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[i];return a<0&&(a+=l),a=o>0?Oe(0,a,l):Oe(-1,a,l-1),a}function Mv(n,t,e){let r=e.length;for(let i=0;i<e.length;i++)if(e[i]>1){r=i;break}for(let i=r+1;i<e.length;i++)if(t[i]>0||e[i]!==n[i])return!1;return!0}function Rv(n,t){let e=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)e+=n[r]*t[r];return e}function Bg(n,t,e){let r;const i=n.shape.length;let s;return r="number"==typeof t?[t,...new Array(i-1).fill(0)]:t.length<i?t.concat(new Array(i-t.length).fill(0)):t.slice(),r.forEach(a=>{K(-1!==a,()=>"slice() does not support negative begin indexing.")}),s=null==e?new Array(i).fill(-1):"number"==typeof e?[e,...new Array(i-1).fill(-1)]:e.length<i?e.concat(new Array(i-e.length).fill(-1)):e,s=s.map((a,o)=>a>=0?a:(K(-1===a,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${o}.`),n.shape[o]-r[o])),[r,s]}function Dv(n,t,e,r,i,s,a,o,l){let p;if(null==r?(p=new Array(t.length),p.fill(1)):p=r,null!=a&&a&a-1)throw new Error("Multiple ellipses in slice is not allowed.");let g=!1;const v={dims:p.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:p.slice(),beginMask:i,endMask:s,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l};for(let U=0;U<v.dims;U++)g&&1<<U&o&&v.numAddAxisAfterEllipsis++,1<<U&a&&(g=!0);g||(v.ellipsisMask|=1<<v.dims,v.dims++);const w={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function qA(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=null!=n.begin,t.endValid=null!=n.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const i=Math.min(t.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<i;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=r}else if(1<<r&n.newAxisMask)t.finalShapeGatherIndices.push(Cv),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=n.begin&&(t.begin[e]=n.begin[r]),null!=n.end&&(t.end[e]=n.end[r]),t.strides[e]=n.strides[r],n.beginMask&1<<r&&(t.beginMask|=1<<e),n.endMask&1<<r&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(UA),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[e]=r,e++}}(v,w);let N=!0,D=!0,O=!0;const k=[],L=[];for(let U=0;U<n.length;++U){if(0===w.strides[U])throw Error(`strides[${U}] must be non-zero`);const V=!!(w.shrinkAxisMask&1<<U),W=n[U];if(-1===W){k.push(V?1:-1);continue}const ce=[w.beginMask&1<<U,w.endMask&1<<U],ve=[w.strides[U]>0?0:-1,w.strides[U]>0?W:W-1];if(V&&w.strides[U]<=0)throw Error("only stride 1 allowed on non-range indexing.");O=O&&1===w.strides[U];const Ee=!!(w.beginMask&1<<U&&w.endMask&1<<U);if(w.beginValid&&w.endValid){if(V){const Mt=w.begin[U]<0?W+w.begin[U]:w.begin[U];if(w.begin[U]=Mt,w.end[U]=w.begin[U]+1,Mt<0||Mt>=W)throw Error(`slice index ${w.begin[U]} of dimension ${U} out of bounds.`)}else w.begin[U]=hf(w.begin[U],0,w.strides[U],W,ce,ve),w.end[U]=hf(w.end[U],1,w.strides[U],W,ce,ve);const ut=1===w.strides[U]&&0===w.begin[U]&&w.end[U]===W;N=N&&ut,D=D&&(0===U&&1===w.strides[U]||ut)}else N=N&&1===w.strides[U]&&Ee,D=D&&(0===U&&1===w.strides[U]||Ee);let ge,it=!1;if(w.beginValid&&w.endValid?(ge=w.end[U]-w.begin[U],it=!0):V?(ge=1,it=!0):Ee&&W>=0&&(ge=w.strides[U]<0?-W:W,it=!0),it){let ut;ut=0===ge||ge<0!=w.strides[U]<0?0:Math.trunc(ge/w.strides[U])+(ge%w.strides[U]!=0?1:0),k.push(ut)}else k.push(-1)}for(let U=0;U<w.finalShapeGatherIndices.length;++U){const V=w.finalShapeGatherIndices[U];V>=0?L.push(k[V]):V===Cv&&L.push(1)}return{finalShapeSparse:L.filter((U,V)=>w.finalShapeGatherIndices[V]!==Cv),finalShape:L,isIdentity:N,sliceDim0:D,isSimpleSlice:O,begin:w.begin,end:w.end,strides:w.strides}}function hf(n,t,e,r,i,s){if(i[t])return e>0?s[t]:s[t+1&1];{const a=n<0?r+n:n;return a<s[0]?s[0]:a>s[1]?s[1]:a}}const Gp=.001,m_=.1;function g_(n,t,e){return null==e&&(e=Ov()),kv(n,t,(r,i)=>Pv(r,i,e))}function Ov(){return 32===gt.backend.floatPrecision()?Gp:m_}function kv(n,t,e){let r=!0;if((yo(n)||yo(t))&&(r=!1),yo(n)&&yo(t)&&(r=!0),r){const a=n.constructor.name,o=t.constructor.name;if(a!==o)throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${o}`)}if(Array.isArray(n)&&Array.isArray(t)){const a=of(n),o=of(t);if(!Kt(a,o))throw new Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${o}]`)}const i=yo(n)?n:af(n),s=yo(t)?t:af(t);if(i.length!==s.length)throw new Error(`Arrays have different lengths actual: ${i.length} vs expected: ${s.length}.\nActual:   ${i}.\nExpected: ${s}.`);for(let a=0;a<s.length;++a){const o=i[a],l=s[a];if(!e(o,l))throw new Error(`Arrays differ: actual[${a}] = ${o}, expected[${a}] = ${l}.\nActual:   ${i}.\nExpected: ${s}.`)}typeof expect<"u"&&expect().nothing()}function y_(n,t){n().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function WA(n,t){const e="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return da(n)||da(n[0])||da(t)||da(t[0])?kv(n,e,(r,i)=>r==i):kv(n,t,(r,i)=>Pv(r,i,0))}function HA(n,t,e){if(null==e&&(e=Ov()),!Pv(n,t,e))throw new Error(`Numbers differ: actual === ${n}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function Pv(n,t,e){return!isFinite(n)&&!isFinite(t)||!(isNaN(n)||isNaN(t)||Math.abs(n-t)>e)}function XA(n,t,e){for(let r=0;r<n.length;r++)if(n[r]<t||n[r]>e)throw new Error(`Value out of range:${n[r]} low: ${t}, high: ${e}`)}function KA(n,t){const e=new Float32Array(n),r=new Float32Array(t);if(e.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${e.length}`);for(let i=0;i<r.length;i++)if(e[i]!==r[i])throw new Error(`Expected ArrayBuffer value at ${i} to be ${r[i]} but got ${e[i]} instead`)}function Fv(n){for(let t=0;t<n.length;t++){const e=n[t];Array.isArray(e)?Fv(e):n[t]=sf(e)}return n}function v_(n){const t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(n),new Promise(e=>{t.addEventListener("loadeddata",r=>e(t)),t.load()})}function YA(n){return Lv.apply(this,arguments)}function Lv(){return(Lv=(0,Qe.Z)(function*(n){yield n.play(),"requestVideoFrameCallback"in n&&(yield new Promise(t=>{n.requestVideoFrameCallback(t)}))})).apply(this,arguments)}const x_="4.4.0";class $v{static sgd(t){return new Pg(t)}static momentum(t,e,r=!1){return new gv(t,e,r)}static rmsprop(t,e=.9,r=0,i=null,s=!1){return new Fg(t,e,r,i,s)}static adam(t=.001,e=.9,r=.999,i=null){return new Og(t,e,r,i)}static adadelta(t=.001,e=.95,r=null){return new mv(t,e,r)}static adamax(t=.002,e=.9,r=.999,i=null,s=0){return new kg(t,e,r,i,s)}static adagrad(t,e=.1){return new Dg(t,e)}}const Bv=yt({acos_:function ZA(n){const e={x:Xe(n,"x","acos")};return gt.runKernel(To,e)}}),zv=yt({acosh_:function b_(n){const e={x:Xe(n,"x","acosh")};return gt.runKernel(ml,e)}}),Uv=yt({addN_:function jA(n){K(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),K(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const t=n.map((i,s)=>Xe(i,`tensors${s}`,"addN")),e=t[0];return t.forEach(i=>{if(i.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(i=>{if(!Kt(i.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),gt.runKernel(kl,t)}}),zg=yt({all_:function JA(n,t=null,e=!1){const i={x:Xe(n,"x","all","bool")};return gt.runKernel(Vr,i,{axis:t,keepDims:e})}}),om=yt({any_:function w_(n,t=null,e=!1){const i={x:Xe(n,"x","any","bool")};return gt.runKernel(Ks,i,{axis:t,keepDims:e})}}),wh=yt({argMax_:function QA(n,t=0){const r={x:Xe(n,"x","argMax")};return gt.runKernel(Ho,r,{axis:t})}}),Vv=yt({argMin_:function eT(n,t=0){const r={x:Xe(n,"x","argMin")};return gt.runKernel(Af,r,{axis:t})}}),Gv=yt({asin_:function um(n){const e={x:Xe(n,"x","asin")};return gt.runKernel(Tf,e)}}),Ug=yt({asinh_:function __(n){const e={x:Xe(n,"x","asinh")};return gt.runKernel(Gr,e)}}),Vg=yt({atan_:function N_(n){const e={x:Xe(n,"x","atan")};return gt.runKernel(ja,e)}}),qv=yt({atan2_:function S_(n,t){let e=Xe(n,"a","atan2"),r=Xe(t,"b","atan2");return[e,r]=fa(e,r),gt.runKernel(Yc,{a:e,b:r})}}),Gg=yt({atanh_:function tT(n){const e={x:Xe(n,"x","atanh")};return gt.runKernel(jn,e)}});function lm(n,t,e,r,i="NHWC",s){return vo(n,[...t,n[3]],e,s,r,null,null,Hf(i))}function jl(n,t,e,r,i,s,a="channelsLast"){const[o,l]=qp(t);let p;if("channelsLast"===a)p=[o,l,n[3],n[3]];else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);p=[o,l,n[1],n[1]]}return vo(n,p,e,r,i,s,!1,a)}function pf(n,t,e,r,i,s,a="NDHWC"){const[o,l,p]=Hv(t);let g,v;if("NDHWC"===a)v="channelsLast",g=[o,l,p,n[4],n[4]];else{if("NCDHW"!==a)throw new Error(`Unknown dataFormat ${a}`);v="channelsFirst",g=[o,l,p,n[1],n[1]]}return _h(n,g,e,r,i,!1,v,s)}function vo(n,t,e,r,i,s,a=!1,o="channelsLast"){let[l,p,g,v]=[-1,-1,-1,-1];if("channelsLast"===o)[l,p,g,v]=n;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,v,p,g]=n}const[w,N,,D]=t,[O,k]=qp(e),[L,$]=qp(r),U=Wp(w,L),V=Wp(N,$),{padInfo:W,outHeight:ce,outWidth:ve}=function I_(n,t,e,r,i,s,a,o,l){let p,g,v;if("number"==typeof n){p={top:n,bottom:n,left:n,right:n,type:0===n?"VALID":"NUMBER"};const N=function Wv(n,t,e,r,i){null==r&&(r=Nh(n,t,e));const a=n[1];return[Hp((n[0]-t+2*r)/e+1,i),Hp((a-t+2*r)/e+1,i)]}([t,e],s,r,n,o);g=N[0],v=N[1]}else if("same"===n){g=Math.ceil(t/r),v=Math.ceil(e/i);const w=Math.max(0,(g-1)*r+s-t),N=Math.max(0,(v-1)*i+a-e),D=Math.floor(w/2),O=w-D,k=Math.floor(N/2);p={top:D,bottom:O,left:k,right:N-k,type:"SAME"}}else if("valid"===n)p={top:0,bottom:0,left:0,right:0,type:"VALID"},g=Math.ceil((t-s+1)/r),v=Math.ceil((e-a+1)/i);else{if("object"!=typeof n)throw Error(`Unknown padding parameter: ${n}`);{const w="channelsLast"===l?n[1][0]:n[2][0],N="channelsLast"===l?n[1][1]:n[2][1],D="channelsLast"===l?n[2][0]:n[3][0],O="channelsLast"===l?n[2][1]:n[3][1];p={top:w,bottom:N,left:D,right:O,type:0===w&&0===N&&0===D&&0===O?"VALID":"EXPLICIT"},g=Hp((t-s+w+N)/r+1,o),v=Hp((e-a+D+O)/i+1,o)}}return{padInfo:p,outHeight:g,outWidth:v}}(i,p,g,O,k,U,V,s,o),Ee=a?D*v:D;let ge;return"channelsFirst"===o?ge=[l,Ee,ce,ve]:"channelsLast"===o&&(ge=[l,ce,ve,Ee]),{batchSize:l,dataFormat:o,inHeight:p,inWidth:g,inChannels:v,outHeight:ce,outWidth:ve,outChannels:Ee,padInfo:W,strideHeight:O,strideWidth:k,filterHeight:w,filterWidth:N,effectiveFilterHeight:U,effectiveFilterWidth:V,dilationHeight:L,dilationWidth:$,inShape:n,outShape:ge,filterShape:t}}function _h(n,t,e,r,i,s=!1,a="channelsLast",o){let[l,p,g,v,w]=[-1,-1,-1,-1,-1];if("channelsLast"===a)[l,p,g,v,w]=n;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,w,p,g,v]=n}const[N,D,O,,k]=t,[L,$,U]=Hv(e),[V,W,ce]=Hv(r),ve=Wp(N,V),Ee=Wp(D,W),ge=Wp(O,ce),{padInfo:it,outDepth:ut,outHeight:Mt,outWidth:Ot}=function qg(n,t,e,r,i,s,a,o,l,p,g){let v,w,N,D;if("valid"===n&&(n=0),"number"==typeof n){v={top:n,bottom:n,left:n,right:n,front:n,back:n,type:0===n?"VALID":"NUMBER"};const k=function E_(n,t,e,r,i,s){null==i&&(i=Nh(n,t[0],r[0]));const a=[0,0,0,e];for(let o=0;o<3;o++)n[o]+2*i>=t[o]&&(a[o]=Hp((n[o]-t[o]+2*i)/r[o]+1,s));return a}([t,e,r,1],[o,l,p],1,[i,s,a],n,g);w=k[0],N=k[1],D=k[2]}else{if("same"!==n)throw Error(`Unknown padding parameter: ${n}`);{w=Math.ceil(t/i),N=Math.ceil(e/s),D=Math.ceil(r/a);const O=(w-1)*i+o-t,k=(N-1)*s+l-e,L=(D-1)*a+p-r,$=Math.floor(O/2),U=O-$,V=Math.floor(k/2),W=k-V,ce=Math.floor(L/2);v={top:V,bottom:W,left:ce,right:L-ce,front:$,back:U,type:"SAME"}}}return{padInfo:v,outDepth:w,outHeight:N,outWidth:D}}(i,p,g,v,L,$,U,ve,Ee,ge,o),vt=s?k*w:k;let Rt;return"channelsFirst"===a?Rt=[l,vt,ut,Mt,Ot]:"channelsLast"===a&&(Rt=[l,ut,Mt,Ot,vt]),{batchSize:l,dataFormat:a,inDepth:p,inHeight:g,inWidth:v,inChannels:w,outDepth:ut,outHeight:Mt,outWidth:Ot,outChannels:vt,padInfo:it,strideDepth:L,strideHeight:$,strideWidth:U,filterDepth:N,filterHeight:D,filterWidth:O,effectiveFilterDepth:ve,effectiveFilterHeight:Ee,effectiveFilterWidth:ge,dilationDepth:V,dilationHeight:W,dilationWidth:ce,inShape:n,outShape:Rt,filterShape:t}}function Nh(n,t,e,r=1){const i=Wp(t,r);return Math.floor((n[0]*(e-1)-e+i)/2)}function qp(n){return"number"==typeof n?[n,n,n]:2===n.length?[n[0],n[1],1]:n}function Hv(n){return"number"==typeof n?[n,n,n]:n}function Wp(n,t){return t<=1?n:n+(n-1)*(t-1)}function Hp(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function Sh(n){const[t,e,r]=qp(n);return 1===t&&1===e&&1===r}function Uo(n,t){return Sh(n)||Sh(t)}function Eh(n){return qp(n).every(t=>t>0)}function Hf(n){if("NHWC"===n)return"channelsLast";if("NCHW"===n)return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function vu(n,t,e){if(null!=e){if("string"==typeof t)throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if("number"==typeof t)K(Pn(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else{if("object"!=typeof t)throw Error(`Error in ${n}: Unknown padding parameter: ${t}`);t.forEach(r=>{r.forEach(i=>{K(Pn(i),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${i}.`)})})}}}const St=yt({reshape_:function C_(n,t){const r={x:Xe(n,"x","reshape","string_or_numeric")};return gt.runKernel(tl,r,{shape:t})}}),Xp=yt({avgPool_:function nT(n,t,e,r,i){const s=Xe(n,"x","avgPool","float32");K(Uo(e,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`);let o=s,l=!1;3===s.rank&&(l=!0,o=St(s,[1,s.shape[0],s.shape[1],s.shape[2]])),K(4===o.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),vu("avgPool",r,i);let v=gt.runKernel(Mr,{x:o},{filterSize:t,strides:e,pad:r,dimRoundingMode:i});return v=_n(v,s.dtype),l?St(v,[v.shape[1],v.shape[2],v.shape[3]]):v}}),Xv=yt({avgPool3d_:function rT(n,t,e,r,i,s="NDHWC"){const a=Xe(n,"x","avgPool3d","float32");let o=a,l=!1;4===a.rank&&(l=!0,o=St(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),K(5===o.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),K("NDHWC"===s,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),K("number"==typeof e&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),vu("avgPool3d",r,i);let v=gt.runKernel(hn,{x:o},{filterSize:t,strides:e,pad:r,dimRoundingMode:i,dataFormat:s});return v=_n(v,o.dtype),l?St(v,[v.shape[1],v.shape[2],v.shape[3],v.shape[4]]):v}}),Da=yt({concat_:function iT(n,t=0){K(n.length>=1,()=>"Pass at least one tensor to concat");const e=Wd(n,"tensors","concat","string_or_numeric");return"complex64"===e[0].dtype&&e.forEach(s=>{if("complex64"!==s.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${s.dtype}. `)}),1===e.length?Ic(e[0]):gt.runKernel(ci,e,{axis:t})}}),Tc=yt({sigmoid_:function sT(n){const e={x:Xe(n,"x","sigmoid","float32")};return gt.runKernel(wa,e)}}),li=yt({slice_:function aT(n,t,e){const r=Xe(n,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");return gt.runKernel(po,{x:r},{begin:t,size:e})}}),Ih=yt({tanh_:function A_(n){const e={x:Xe(n,"x","tanh","float32")};return gt.runKernel(vs,e)}}),Kv=yt({basicLSTMCell_:function T_(n,t,e,r,i,s){const a=Xe(n,"forgetBias","basicLSTMCell"),o=Xe(t,"lstmKernel","basicLSTMCell"),l=Xe(e,"lstmBias","basicLSTMCell"),p=Xe(r,"data","basicLSTMCell"),g=Xe(i,"c","basicLSTMCell"),v=Xe(s,"h","basicLSTMCell"),w=Da([p,v],1),N=ni(w,o),D=gn(N,l),k=D.shape[1]/4,L=[D.shape[0],k],$=li(D,[0,0],L),U=li(D,[0,k],L),V=li(D,[0,2*k],L),W=li(D,[0,3*k],L),ce=gn(_t(Tc($),Ih(U)),_t(g,Tc(gn(a,V))));return[ce,_t(Ih(ce),Tc(W))]}}),cm=yt({batchToSpaceND_:function M_(n,t,e){const r=Xe(n,"x","batchToSpaceND"),i=t.reduce((o,l)=>o*l);return K(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),K(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),K(r.shape[0]%i==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${i}`),gt.runKernel(Ja,{x:r},{blockShape:t,crops:e})}});function oT(n){let t;return t=0===n.rank||1===n.rank?St(n,[1,1,1,n.size]):2===n.rank?St(n,[1,1,n.shape[0],n.shape[1]]):3===n.rank?St(n,[1,n.shape[0],n.shape[1],n.shape[2]]):n,t}const Kp=yt({batchNorm_:function uT(n,t,e,r,i,s){null==s&&(s=.001);const a=Xe(n,"x","batchNorm"),o=Xe(t,"mean","batchNorm"),l=Xe(e,"variance","batchNorm");let p,g;null!=i&&(p=Xe(i,"scale","batchNorm")),null!=r&&(g=Xe(r,"offset","batchNorm")),K(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),K(null==g||o.rank===g.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),K(null==p||o.rank===p.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const w={x:oT(a),scale:p,offset:g,mean:o,variance:l},D=gt.runKernel(yc,w,{varianceEpsilon:s});return St(D,a.shape)}}),Yv=yt({batchNorm2d_:function lT(n,t,e,r,i,s){const a=Xe(n,"x","batchNorm"),o=Xe(t,"mean","batchNorm"),l=Xe(e,"variance","batchNorm");let p,g;return null!=i&&(p=Xe(i,"scale","batchNorm")),null!=r&&(g=Xe(r,"offset","batchNorm")),K(2===a.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),K(2===o.rank||1===o.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),K(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=p&&K(2===p.rank||1===p.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${p.rank}.`),null!=g&&K(2===g.rank||1===g.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${g.rank}.`),Kp(a,o,l,g,p,s)}}),Wg=yt({batchNorm3d_:function cT(n,t,e,r,i,s){const a=Xe(n,"x","batchNorm"),o=Xe(t,"mean","batchNorm"),l=Xe(e,"variance","batchNorm");let p,g;return null!=i&&(p=Xe(i,"scale","batchNorm")),null!=r&&(g=Xe(r,"offset","batchNorm")),K(3===a.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),K(3===o.rank||1===o.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),K(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=p&&K(3===p.rank||1===p.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${p.rank}.`),null!=g&&K(3===g.rank||1===g.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${g.rank}.`),Kp(a,o,l,g,p,s)}}),Zv=yt({batchNorm4d_:function fT(n,t,e,r,i,s){const a=Xe(n,"x","batchNorm"),o=Xe(t,"mean","batchNorm"),l=Xe(e,"variance","batchNorm");let p,g;return null!=i&&(p=Xe(i,"scale","batchNorm")),null!=r&&(g=Xe(r,"offset","batchNorm")),K(4===a.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),K(4===o.rank||1===o.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),K(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=p&&K(4===p.rank||1===p.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${p.rank}.`),null!=g&&K(4===g.rank||1===g.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${g.rank}.`),Kp(a,o,l,g,p,s)}}),jv=yt({bincount_:function R_(n,t,e){const r=Xe(n,"x","bincount"),i=Xe(t,"weights","bincount");return K("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),K(e>=0,()=>`size must be non-negative, but got ${e}.`),K(i.size===r.size||0===i.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${i.shape}.`),gt.runKernel(mc,{x:r,weights:i},{size:e})}}),Jv=yt({broadcastArgs_:function Yp(n,t){const e=Xe(n,"s0","broadcastArgs","int32"),r=Xe(t,"s1","broadcastArgs","int32");if(1!==e.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);return gt.runKernel(en,{s0:e,s1:r})}}),sp=yt({broadcastTo_:function hT(n,t){let e=Xe(n,"broadcastTo","x");const r=e.shape;if(cs(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const p=e.shape.slice();for(;p.length<t.length;)p.unshift(1);e=St(e,p)}const i=e.shape,s=Array.from(t);for(let p=t.length-1;p>=0;p--)if(i[p]===t[p])s[p]=1;else if(1!==e.shape[p])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);return 0===s.map((p,g)=>p>1?g:-1).filter(p=>p>=0).length?Ic(e):gt.runKernel(ps,{x:e},{reps:s})}}),Qv=yt({ceil_:function D_(n){const e={x:Xe(n,"x","ceil","float32")};return gt.runKernel(As,e)}}),xu=yt({clipByValue_:function pT(n,t,e){const r=Xe(n,"x","clipByValue");return K(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e?tp(r.shape,t,r.dtype):gt.runKernel(Qa,{x:r},{clipValueMin:t,clipValueMax:e})}}),Hg=yt({concat1d_:function e1(n){return Da(n,0)}}),t1=yt({concat2d_:function dT(n,t){return Da(n,t)}}),Xg=yt({concat3d_:function ZL(n,t){return Da(n,t)}}),n1=yt({concat4d_:function mT(n,t){return Da(n,t)}}),Xf=yt({conv2d_:function O_(n,t,e,r,i="NHWC",s=[1,1],a){const o=Xe(n,"x","conv2d","float32"),l=Xe(t,"filter","conv2d","float32");let p=o,g=!1;3===o.rank&&(g=!0,p=St(o,[1,o.shape[0],o.shape[1],o.shape[2]])),K(4===p.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${p.rank}.`),K(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),vu("conv2d",r,a);const v="NHWC"===i?p.shape[3]:p.shape[1];K(v===l.shape[2],()=>`Error in conv2d: depth of input (${v}) must match input depth for filter ${l.shape[2]}.`),K(Uo(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),K(Eh(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),K(Eh(e),()=>"Error in conv2D: Strides should be larger than 0.");const D=gt.runKernel(kr,{x:p,filter:l},{strides:e,pad:r,dataFormat:i,dilations:s,dimRoundingMode:a});return g?St(D,[D.shape[1],D.shape[2],D.shape[3]]):D}}),fm=yt({conv1d_:function gT(n,t,e,r,i="NWC",s=1,a){const o=Xe(n,"x","conv1d"),l=Xe(t,"filter","conv1d");let p=o,g=!1;2===o.rank&&(g=!0,p=St(o,[1,o.shape[0],o.shape[1]])),K(3===p.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${p.rank}.`),K(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),vu("conv1d",r,a),K(p.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${p.shape[2]}) must match input depth for filter ${l.shape[1]}.`),K(Uo(e,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${s}'`),K(Eh(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),K(Eh(e),()=>"Error in conv1D: Stride should be larger than 0."),K("NWC"===i,()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);const v=St(l,[1,l.shape[0],l.shape[1],l.shape[2]]),w=St(p,[p.shape[0],1,p.shape[1],p.shape[2]]),k=Xf(w,v,[1,e],r,"NHWC",[1,s],a);return St(k,g?[k.shape[2],k.shape[3]]:[k.shape[0],k.shape[2],k.shape[3]])}}),r1=yt({conv2DBackpropInput_:function yT(n,t,e,r,i,s="NHWC",a){K(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let o=n,l=t,p=!1;3===t.rank&&(p=!0,l=St(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,n[0],n[1],n[2]]),K(4===o.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),K(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),K(4===e.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const g="NHWC"===s?o[3]:o[1],v="NHWC"===s?l.shape[3]:l.shape[1];K(g===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${g}) must match input depth for filter ${e.shape[2]}.`),K(v===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${v}) must match output depth for filter ${e.shape[3]}.`),vu("conv2dDerInput",i,a);const D=gt.runKernel(uh,{dy:l,filter:e},{strides:r,pad:i,dataFormat:s,dimRoundingMode:a,inputShape:o});return p?St(D,[D.shape[1],D.shape[2],D.shape[3]]):D}}),Kg=yt({conv2dTranspose_:function k_(n,t,e,r,i,s){const a=Xe(n,"x","conv2dTranspose"),o=Xe(t,"filter","conv2dTranspose");return r1(e,a,o,r,i,"NHWC",s)}}),i1=yt({conv3d_:function vT(n,t,e,r,i="NDHWC",s=[1,1,1]){const a=Xe(n,"x","conv3d"),o=Xe(t,"filter","conv3d");let l=a,p=!1;4===a.rank&&(p=!0,l=St(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),K(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),K(5===o.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),K(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),K(Uo(e,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),K("NDHWC"===i,()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`),K(Eh(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),K(Eh(e),()=>"Error in conv3D: Strides should be larger than 0.");const w=gt.runKernel(lh,{x:l,filter:o},{strides:e,pad:r,dataFormat:i,dilations:s});return p?St(w,[w.shape[1],w.shape[2],w.shape[3],w.shape[4]]):w}}),P_=yt({conv3DBackpropInput_:function xT(n,t,e,r,i){K(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let s=n,a=t,o=!1;4===t.rank&&(o=!0,a=St(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,n[0],n[1],n[2],n[3]]);const l=s[4],p=a.shape[4];K(5===s.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),K(5===a.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),K(5===e.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),K(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),K(p===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${p}) must match output depth for filter ${e.shape[4]}.`);const w=gt.runKernel(hu,{dy:a,filter:e},{pad:i,strides:r,inputShape:s});return o?St(w,[w.shape[1],w.shape[2],w.shape[3],w.shape[4]]):w}}),s1=yt({conv3dTranspose_:function F_(n,t,e,r,i){const s=Xe(n,"x","conv3dTranspose"),a=Xe(t,"filter","conv3dTranspose");return P_(e,s,a,r,i)}}),Zp=yt({cos_:function bT(n){const e={x:Xe(n,"x","cos","float32")};return gt.runKernel(eo,e)}}),Yg=yt({cosh_:function wT(n){const e={x:Xe(n,"x","cosh","float32")};return gt.runKernel(Jr,e)}}),hm=yt({cumprod_:function L_(n,t=0,e=!1,r=!1){const s={x:Xe(n,"x","cumprod")};return gt.runKernel(Zc,s,{axis:t,exclusive:e,reverse:r})}}),pm=yt({cumsum_:function _T(n,t=0,e=!1,r=!1){const s={x:Xe(n,"x","cumsum")};return gt.runKernel(Zs,s,{axis:t,exclusive:e,reverse:r})}}),Zg=yt({denseBincount_:function NT(n,t,e,r=!1){const i=Xe(n,"x","denseBincount"),s=Xe(t,"weights","denseBincount");return K("int32"===i.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),K(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),K(e>=0,()=>`size must be non-negative, but got ${e}.`),K(s.size===i.size||0===s.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${s.shape}.`),gt.runKernel(Qu,{x:i,weights:s},{size:e,binaryOutput:r})}}),a1=yt({depthToSpace_:function $_(n,t,e="NHWC"){const r=Xe(n,"x","depthToSpace","float32"),i="NHWC"===e?r.shape[1]:r.shape[2],s="NHWC"===e?r.shape[2]:r.shape[3],a="NHWC"===e?r.shape[3]:r.shape[1];return K(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),K(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${t}  for depthToSpace with input shape\n    ${r.shape}`),K(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t} for depthToSpace with input shape\n        ${r.shape}`),K(a%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${a} for depthToSpace with input shape ${r.shape}`),gt.runKernel(Qi,{x:r},{blockSize:t,dataFormat:e})}}),ap=yt({depthwiseConv2d_:function ST(n,t,e,r,i="NHWC",s=[1,1],a){const o=Xe(n,"x","depthwiseConv2d","float32"),l=Xe(t,"filter","depthwiseConv2d","float32");let p=o,g=!1;3===o.rank&&(g=!0,p=St(o,[1,o.shape[0],o.shape[1],o.shape[2]])),K(4===p.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),K(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const v="NHWC"===i?p.shape[3]:p.shape[1];K(v===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${v}) must match the inChannels dimension in filter ${l.shape[2]}.`),vu("depthwiseConv2d",r,a);const D=gt.runKernel(la,{x:p,filter:l},{strides:e,pad:r,dataFormat:i,dilations:s,dimRoundingMode:a});return g?St(D,[D.shape[1],D.shape[2],D.shape[3]]):D}}),B_=yt({diag_:function ET(n){const e={x:Xe(n,"x","diag")};return gt.runKernel(Tu,e)}}),o1=yt({dilation2d_:function z_(n,t,e,r,i=[1,1],s="NHWC"){const a=Xe(n,"x","dilation2d"),o=Xe(t,"filter","dilation2d");K(3===a.rank||4===a.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),K(3===o.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),K("NHWC"===s,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=a,p=!1;3===a.rank&&(l=St(a,[1,a.shape[0],a.shape[1],a.shape[2]]),p=!0),K(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);const w=gt.runKernel(Mu,{x:l,filter:o},{strides:e,pad:r,dilations:i});return p?St(w,[w.shape[1],w.shape[2],w.shape[3]]):w}}),zu=yt({equal_:function IT(n,t){let e=Xe(n,"a","equal","string_or_numeric"),r=Xe(t,"b","equal","string_or_numeric");return[e,r]=fa(e,r),$r(e.shape,r.shape),gt.runKernel(Hh,{a:e,b:r})}}),xo=yt({where_:function CT(n,t,e){const r=Xe(t,"a","where"),i=Xe(e,"b","where"),s=Xe(n,"condition","where","bool"),a=$r($r(s.shape,r.shape),i.shape),o=sp(s,a),l=sp(r,a),p=sp(i,a);return gt.runKernel(ta,{condition:o,t:l,e:p})}}),u1=yt({divNoNan_:function jg(n,t){let e=Xe(n,"a","div"),r=Xe(t,"b","div");[e,r]=fa(e,r);const i=ur(e,r),s=di(i),a=zu(r,s);return xo(a,s,i)}}),l1=yt({dot_:function U_(n,t){const e=Xe(n,"t1","dot"),r=Xe(t,"t2","dot");K(!(1!==e.rank&&2!==e.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${r.rank}.`);const i=1===e.rank?e.size:e.shape[1],s=1===r.rank?r.size:r.shape[0];if(K(i===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${s}.`),1===e.rank&&1===r.rank){const a=St(e,[1,-1]),o=St(r,[-1,1]),l=ni(a,o);return St(l,[])}if(1===e.rank&&2===r.rank){const a=St(e,[1,-1]),o=St(r,[r.shape[0],r.shape[1]]),l=ni(a,o);return St(l,[l.size])}if(2===e.rank&&1===r.rank){const a=St(r,[-1,1]),o=ni(e,a);return St(o,[o.size])}{const a=St(r,[r.shape[0],r.shape[1]]);return ni(e,a)}}}),c1=yt({einsum_:function AT(n,...t){const e=t.map((i,s)=>Xe(i,`tensors${s}`,"einsum"));return gt.runKernel(Ro,e,{equation:n})}}),jp=yt({elu_:function TT(n){const e={x:Xe(n,"x","elu","float32")};return gt.runKernel(hs,e)}}),f1=yt({erf_:function V_(n){let t=Xe(n,"x","erf");return K("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=_n(t,"float32")),gt.runKernel(gc,{x:t})}});function h1(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function p1(n,t,e){const r=n.length+t.length,i=[];let s=0,a=0;for(let o=0;o<r;o++)-1===e.indexOf(o)?i.push(n[s++]):i.push(t[a++]);return i}function ao(n,t){const e=[],r=n.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&e.push(n[s]);return[e,t.map(s=>n[s])]}function Oa(n,t){return p1(n,t.map(r=>1),t)}function Vo(n,t,e){K(h1(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function na(n,t){if(h1(n,t))return null;const e=[];for(let r=0;r<t;++r)-1===n.indexOf(r)&&e.push(r);return n.forEach(r=>e.push(r)),e}function Ch(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function ka(n,t){const e=[];for(let r=t-n;r<t;++r)e.push(r);return e}const Il=yt({max_:function G_(n,t=null,e=!1){const i={x:Xe(n,"x","max")};return gt.runKernel(Ps,i,{reductionIndices:t,keepDims:e})}}),op=yt({min_:function MT(n,t=null,e=!1){const i={x:Xe(n,"x","min")};return gt.runKernel(js,i,{axis:t,keepDims:e})}}),er=yt({sum_:function RT(n,t=null,e=!1){let r=Xe(n,"x","sum");return"bool"===r.dtype&&(r=_n(r,"int32")),gt.runKernel(ot,{x:r},{axis:t,keepDims:e})}});function W_(n,t,e=null){if(0===n.rank)return Ra(n);if(1!==n.rank&&null===e)return W_(St(n,[-1]),t,e);if(1===n.rank||"number"==typeof e||Array.isArray(e)&&1===e.length){if(1===t)return er(Ra(n),e);if(t===1/0)return Il(Ra(n),e);if(t===-1/0)return op(Ra(n),e);if("euclidean"===t||2===t)return zo(er(lf(Ra(n),mr(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&2===e.length){if(1===t)return Il(er(Ra(n),e[0]),e[1]-1);if(t===1/0)return Il(er(Ra(n),e[1]),e[0]);if(t===-1/0)return op(er(Ra(n),e[1]),e[0]);if("fro"===t||"euclidean"===t)return zo(er(Nr(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const Jp=yt({norm_:function q_(n,t="euclidean",e=null,r=!1){const i=W_(n=Xe(n,"x","norm"),t,e);let s=i.shape;if(r){const a=ar(e,n.shape);s=Oa(i.shape,a)}return St(i,s)}}),d1=yt({euclideanNorm_:function H_(n,t=null,e=!1){return Jp(n,"euclidean",t,e)}}),Uu=yt({exp_:function DT(n){const e={x:Xe(n,"x","exp")};return gt.runKernel(yl,e)}}),tu=yt({expandDims_:function OT(n,t=0){const e=Xe(n,"x","expandDims","string_or_numeric");return K(t<=e.rank,()=>"Axis must be <= rank of the tensor"),gt.runKernel(ch,{input:e},{dim:t})}}),m1=yt({expm1_:function X_(n){const e={x:Xe(n,"x","expm1")};return gt.runKernel(Df,e)}}),Cl=yt({tile_:function kT(n,t){const e=Xe(n,"x","tile","string_or_numeric");return K(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`),gt.runKernel(ps,{x:e},{reps:t})}}),Jg=yt({eye_:function PT(n,t,e,r="float32"){null==t&&(t=n);const i=zr([n,t],r),s=n<=t?n:t;for(let o=0;o<s;++o)i.set(1,o,o);const a=St(i.toTensor(),[n,t]);if(null==e)return a;if(1===e.length)return Cl(tu(a,0),[e[0],1,1]);if(2===e.length)return Cl(tu(tu(a,0),0),[e[0],e[1],1,1]);if(3===e.length)return Cl(tu(tu(tu(a,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}}),Qp=yt({floor_:function FT(n){const e={x:Xe(n,"x","floor","float32")};return gt.runKernel(el,e)}}),up=yt({gather_:function LT(n,t,e=0,r=0){const i=Xe(n,"x","gather"),s=Xe(t,"indices","gather","int32");return gt.runKernel(ss,{x:i,indices:s},{axis:e,batchDims:r})}}),bu=yt({greater_:function $T(n,t){let e=Xe(n,"a","greater","string_or_numeric"),r=Xe(t,"b","greater","string_or_numeric");return[e,r]=fa(e,r),$r(e.shape,r.shape),gt.runKernel(fh,{a:e,b:r})}}),Kf=yt({greaterEqual_:function K_(n,t){let e=Xe(n,"a","greaterEqual","string_or_numeric"),r=Xe(t,"b","greaterEqual","string_or_numeric");return[e,r]=fa(e,r),$r(e.shape,r.shape),gt.runKernel($l,{a:e,b:r})}}),Qg=yt({isFinite_:function BT(n){const e={x:Xe(n,"x","isFinite")};return gt.runKernel(Bl,e)}}),g1=yt({isInf_:function zT(n){const e={x:Xe(n,"x","isInf")};return gt.runKernel(jc,e)}}),y1=yt({isNaN_:function UT(n){const e={x:Xe(n,"x","isNaN")};return gt.runKernel(Of,e)}}),ed=yt({leakyRelu_:function VT(n,t=.2){const r={x:Xe(n,"x","leakyRelu")};return gt.runKernel(Yr,r,{alpha:t})}}),td=yt({less_:function GT(n,t){let e=Xe(n,"a","less","string_or_numeric"),r=Xe(t,"b","less","string_or_numeric");return[e,r]=fa(e,r),$r(e.shape,r.shape),gt.runKernel(pu,{a:e,b:r})}}),Ah=yt({lessEqual_:function Y_(n,t){let e=Xe(n,"a","lessEqual","string_or_numeric"),r=Xe(t,"b","lessEqual","string_or_numeric");return[e,r]=fa(e,r),$r(e.shape,r.shape),gt.runKernel(as,{a:e,b:r})}});function Z_(n,t,e){if(e<=0)throw new Error("The number of values should be positive.");return gt.runKernel(Jc,{},{start:n,stop:t,num:e})}const v1=yt({localResponseNormalization_:function j_(n,t=5,e=1,r=1,i=.5){const s=Xe(n,"x","localResponseNormalization");K(4===s.rank||3===s.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`),K(Pn(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let a=s,o=!1;3===s.rank&&(o=!0,a=St(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const g=gt.runKernel(vc,{x:a},{depthRadius:t,bias:e,alpha:r,beta:i});return o?St(g,[g.shape[1],g.shape[2],g.shape[3]]):g}}),ol=yt({log_:function qT(n){const e={x:Xe(n,"x","log","float32")};return gt.runKernel(Ta,e)}}),Vu=yt({log1p_:function WT(n){const e={x:Xe(n,"x","log1p")};return gt.runKernel(kf,e)}}),lp=yt({softplus_:function HT(n){const e={x:Xe(n,"x","softplus")};return gt.runKernel(Ff,e)}}),x1=yt({logSigmoid_:function Gu(n){const t=Xe(n,"x","logSigmoid");return Cc(r=>({value:Ls(lp(Ls(r))),gradFunc:a=>_t(a,Tc(Ls(r)))}))(t)}}),cp=yt({logSoftmax_:function XT(n,t=-1){const e=Xe(n,"logits","logSoftmax");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return Cc((i,s)=>{const o=Il(i,t,!0),l=Hn(i,o),p=Hn(_n(l,"float32"),ol(er(Uu(l),t,!0)));return s([p]),{value:p,gradFunc:(v,w)=>{const[N]=w,O=Uu(N);return Hn(v,_t(er(v,t,!0),O))}}})(e)}}),e0=yt({logSumExp_:function KT(n,t=null,e=!1){const r=Xe(n,"x","logSumExp"),i=ar(t,r.shape),s=Il(r,i,!0),a=Hn(r,s),o=Uu(a),l=er(o,i),p=ol(l),g=gn(St(s,p.shape),p);if(e){const v=Oa(g.shape,i);return St(g,v)}return g}}),Jl=yt({logicalAnd_:function nu(n,t){const e=Xe(n,"a","logicalAnd","bool"),r=Xe(t,"b","logicalAnd","bool");return $r(e.shape,r.shape),gt.runKernel(Fr,{a:e,b:r})}}),Pa=yt({logicalNot_:function YT(n){const e={x:Xe(n,"x","logicalNot","bool")};return gt.runKernel(xl,e)}}),t0=yt({logicalOr_:function ZT(n,t){const e=Xe(n,"a","logicalOr","bool"),r=Xe(t,"b","logicalOr","bool");return $r(e.shape,r.shape),gt.runKernel(Hi,{a:e,b:r})}}),b1=yt({logicalXor_:function Ds(n,t){const e=Xe(n,"a","logicalXor","bool"),r=Xe(t,"b","logicalXor","bool");return $r(e.shape,r.shape),Jl(t0(n,t),Pa(Jl(n,t)))}}),n0=2147483648,dm=yt({searchSorted_:function Ji(n,t,e="left"){const r=Xe(n,"sortedSequence","searchSorted"),i=Xe(t,"values","searchSorted"),a=i.shape[i.shape.length-1],o=St(r,[-1,r.shape[r.shape.length-1]]),l=St(i,[-1,a]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(ft(l.shape)>=n0)throw new Error(`values tensor size must less than ${n0}`);if(o.shape[1]>=n0)throw new Error(`trailing dim_size must less than ${n0} for int32 output type, was ${o.shape[1]}`);return gt.runKernel(ca,{sortedSequence:o,values:l},{side:e})}});function J_(n,t){return dm(n,t,"left")}const mm=yt({maxPool_:function jT(n,t,e,r,i){const s=Xe(n,"x","maxPool");let o=s,l=!1;3===s.rank&&(l=!0,o=St(s,[1,s.shape[0],s.shape[1],s.shape[2]])),K(4===o.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),K(Uo(e,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`),vu("maxPool",r,i);const v=gt.runKernel(no,{x:o},{filterSize:t,strides:e,pad:r,dimRoundingMode:i});return l?St(v,[v.shape[1],v.shape[2],v.shape[3]]):v}}),df=yt({maxPool3d_:function JT(n,t=[1,1,1],e,r,i,s="NDHWC"){const a=Xe(n,"x","maxPool3d");let o=a,l=!1;4===a.rank&&(l=!0,o=St(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),K(5===o.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),K("NDHWC"===s,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),vu("maxPool3d",r,i);const v=gt.runKernel(_r,{x:o},{filterSize:t,strides:e,pad:r,dimRoundingMode:i,dataFormat:s});return l?St(v,[v.shape[1],v.shape[2],v.shape[3],v.shape[4]]):v}}),Q_=yt({maxPoolWithArgmax_:function QT(n,t,e,r,i=!1){const a={x:Xe(n,"x","maxPoolWithArgmax")},l=gt.runKernel(Qc,a,{filterSize:t,strides:e,pad:r,includeBatchInIndex:i});return{result:l[0],indexes:l[1]}}}),ra=yt({mean_:function r0(n,t=null,e=!1){const i={x:Xe(n,"x","mean")};return gt.runKernel(Oo,i,{axis:t,keepDims:e})}});function Wa(n,t="float32"){if(cs(n),"complex64"===t){const r=Wa(n,"float32"),i=Wa(n,"float32");return Uf(r,i)}const e=Ki(ft(n),t);return gt.makeTensor(e,n,t)}function ul(n,t="float32"){if(cs(n),"complex64"===t){const r=ul(n,"float32"),i=Wa(n,"float32");return Uf(r,i)}const e=Ur(ft(n),t);return gt.makeTensor(e,n,t)}function eM(n,t,{indexing:e="xy"}={}){if("xy"!==e&&"ij"!==e)throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(void 0===n)return[];let r=Xe(n,"x","meshgrid",n instanceof Xi?n.dtype:"float32");if(void 0===t)return[r];let i=Xe(t,"y","meshgrid",t instanceof Xi?t.dtype:"float32");const s=ft(r.shape),a=ft(i.shape);return"xy"===e?(r=St(r,[1,-1]),i=St(i,[-1,1]),[ni(ul([a,1],r.dtype),r),ni(i,ul([1,s],i.dtype))]):(r=St(r,[-1,1]),i=St(i,[1,-1]),[ni(r,ul([1,a],r.dtype)),ni(ul([s,1],i.dtype),i)])}const Th=yt({minimum_:function eN(n,t){let e=Xe(n,"a","minimum"),r=Xe(t,"b","minimum");return[e,r]=fa(e,r),"bool"===e.dtype&&(e=_n(e,"int32"),r=_n(r,"int32")),$r(e.shape,r.shape),gt.runKernel(Yo,{a:e,b:r})}}),nN=yt({mirrorPad_:function tN(n,t,e){K("reflect"===e||"symmetric"===e,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const r=Xe(n,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");K(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);const i="reflect"===e?1:0;for(let o=0;o<r.rank;o++)K(2===t[o].length,()=>"Invalid number of paddings. Must be length of 2 each."),K(t[o][0]>=0&&t[o][0]<=r.shape[o]-i&&t[o][1]>=0&&t[o][1]<=r.shape[o]-i,()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-i} or less than 0 for input of shape ${r.shape}`);return gt.runKernel(Js,{x:r},{paddings:t,mode:e})}}),w1=yt({mod_:function jL(n,t){let e=Xe(n,"a","mod"),r=Xe(t,"b","mod");return[e,r]=fa(e,r),gt.runKernel(fo,{a:e,b:r})}}),gm=yt({moments_:function tM(n,t=null,e=!1){const r=ar(t,(n=Xe(n,"x","moments")).shape),i=ra(n,r,e);let s=i.shape;e||(s=Oa(i.shape,r));const a=Nr(Hn(_n(n,"float32"),St(i,s)));return{mean:i,variance:ra(a,r,e)}}}),iN=yt({multiRNNCell_:function rN(n,t,e,r){const i=Xe(t,"data","multiRNNCell"),s=Wd(e,"c","multiRNNCell"),a=Wd(r,"h","multiRNNCell");let o=i;const l=[];for(let v=0;v<n.length;v++){const w=n[v](o,s[v],a[v]);l.push(w[0]),l.push(w[1]),o=w[1]}const p=[],g=[];for(let v=0;v<l.length;v+=2)p.push(l[v]),g.push(l[v+1]);return[p,g]}}),wu=yt({multinomial_:function nM(n,t,e,r=!1){const i=Xe(n,"logits","multinomial"),s=i.size,a=i.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);e=e||Math.random();const l={logits:1===a?St(i,[1,-1]):i},g=gt.runKernel(Zo,l,{numSamples:t,seed:e,normalized:r});return 1===a?St(g,[g.size]):g}}),fp=yt({notEqual_:function sN(n,t){let e=Xe(n,"a","notEqual","string_or_numeric"),r=Xe(t,"b","notEqual","string_or_numeric");return[e,r]=fa(e,r),$r(e.shape,r.shape),gt.runKernel(qs,{a:e,b:r})}}),qu=yt({onesLike_:function rM(n){const e={x:Xe(n,"x","onesLike")};return gt.runKernel(Du,e)}}),aN=yt({outerProduct_:function iM(n,t){const e=Xe(n,"v1","outerProduct"),r=Xe(t,"v2","outerProduct");K(1===e.rank&&1===r.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${r.rank}.`);const i=St(e,[-1,1]),s=St(r,[1,-1]);return ni(i,s)}}),Yf=yt({pad_:function oN(n,t,e=0){const r=Xe(n,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return gt.runKernel(ba,{x:r},{paddings:t,constantValue:e})}}),uN=yt({pad1d_:function sM(n,t,e=0){return K(2===t.length,()=>"Invalid number of paddings. Must be length of 2."),Yf(n,[t],e)}}),Mc=yt({pad2d_:function aM(n,t,e=0){return K(2===t.length&&2===t[0].length&&2===t[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),Yf(n,t,e)}}),cN=yt({pad3d_:function lN(n,t,e=0){return K(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),Yf(n,t,e)}}),uM=yt({pad4d_:function oM(n,t,e=0){return K(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),Yf(n,t,e)}}),ym=yt({spaceToBatchND_:function fN(n,t,e){const r=Xe(n,"x","spaceToBatchND");return K(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),K(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),K(r.shape.reduce((a,o,l)=>l>0&&l<=t.length?a&&(o+e[l-1][0]+e[l-1][1])%t[l-1]==0:a,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`),gt.runKernel(Fo,{x:r},{blockShape:t,paddings:e})}}),_1=yt({pool_:function lM(n,t,e,r,i,s,a){null==i&&(i=[1,1]),null==s&&(s=1),0===r&&(r="valid");const o=Xe(n,"x","maxPool");let l=o,p=!1;3===o.rank&&(p=!0,l=St(o,[1,o.shape[0],o.shape[1],o.shape[2]])),K(Uo(s,i),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${i}'`);const g=jl(l.shape,t,s,i,r),v=[g.dilationHeight,g.dilationWidth];let w;w="same"===r?function cM(n,t){const r=n.map((a,o)=>a+(a-1)*(t[o]-1)).map(a=>a-1),i=r.map(a=>Math.floor(a/2)),s=r.map((a,o)=>a-i[o]);return r.map((a,o)=>[i[o],s[o]])}([g.filterHeight,g.filterWidth],v):[[0,0],[0,0]];const N=1===v[0]&&1===v[1],[D,O]=function hN(n,t,e){const r=e.map(g=>g[0]),i=e.map(g=>g[1]),s=n.concat(r,i),a=t.map((g,v)=>(g-s[v]%g)%g),o=i.map((g,v)=>g+a[v]),l=t.map((g,v)=>[r[v],o[v]]),p=t.map((g,v)=>[0,a[v]]);return[l,p]}([g.inHeight,g.inWidth],v,w),k=N?r:"valid",L=N?l:ym(l,v,D),U=("avg"===e?()=>Xp(L,t,s,k,a):()=>mm(L,t,s,k,a))(),V=N?U:cm(U,v,O);return p?St(V,[V.shape[1],V.shape[2],V.shape[3]]):V}}),nd=yt({prelu_:function fM(n,t){const e=Xe(n,"x","prelu"),r=Xe(t,"alpha","prelu");return gt.runKernel(Ul,{x:e,alpha:r})}}),N1=yt({prod_:function hM(n,t=null,e=!1){let r=Xe(n,"x","prod");return"bool"===r.dtype&&(r=_n(r,"int32")),gt.runKernel(ph,{x:r},{axis:t,keepDims:e})}}),pN=yt({raggedGather_:function pM(n,t,e,r){const i=n.map((g,v)=>Xe(g,`tensors${v}`,"raggedGather","int32")),s=Xe(t,"paramsDenseValues","raggedGather"),a=Xe(e,"indices","raggedGather","int32"),p=gt.runKernel(Yh,{paramsNestedSplits:i,paramsDenseValues:s,indices:a},{outputRaggedRank:r});return{outputNestedSplits:p.slice(0,p.length-1),outputDenseValues:p[p.length-1]}}}),S1=yt({raggedRange_:function hp(n,t,e){const r=Xe(n,"starts","raggedRange"),i=Xe(t,"limits","raggedRange",r.dtype),s=Xe(e,"deltas","raggedRange",r.dtype),o=gt.runKernel(Vl,{starts:r,limits:i,deltas:s});return{rtNestedSplits:o[0],rtDenseValues:o[1]}}}),dN=yt({raggedTensorToTensor_:function dM(n,t,e,r,i){const s=Xe(n,"shape","raggedTensorToTensor","int32"),a=Xe(t,"values","raggedTensorToTensor"),o=Xe(e,"defaultValue","raggedTensorToTensor",a.dtype),l=r.map((v,w)=>Xe(v,`tensors${w}`,"raggedTensorToTensor","int32"));return gt.runKernel(jo,{shape:s,values:a,defaultValue:o,rowPartitionTensors:l},{rowPartitionTypes:i})}}),E1=yt({rand_:function i0(n,t,e){cs(n);const r=ft(n);let i=null;if(null==e||"float32"===e)i=new Float32Array(r);else if("int32"===e)i=new Int32Array(r);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);i=new Uint8Array(r)}for(let s=0;s<r;s++)i[s]=t();return gt.makeTensor(i,n,e)}});var rd=nn(340);class I1{constructor(t,e,r,i,s){this.mean=t,this.stdDev=e,this.dtype=r,this.nextVal=NaN,this.truncated=i,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const a=s||Math.random();this.random=rd.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const i=this.nextVal;return this.nextVal=NaN,i}let t,e,r=!1;for(;!r;){let i,s,a;do{i=2*this.random()-1,s=2*this.random()-1,a=i*i+s*s}while(a>=1||0===a);const o=Math.sqrt(-2*Math.log(a)/a);t=this.mean+this.stdDev*i*o,e=this.mean+this.stdDev*s*o,(!this.truncated||this.isValidTruncated(t))&&(r=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class mM{constructor(t,e,r,i){this.alpha=t,this.beta=1/e,this.dtype=r;const s=i||Math.random();this.randu=rd.alea(s.toString()),this.randn=new I1(0,1,r,!1,this.randu()),this.d=t<1?t+2/3:t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,r,i,s,a;for(;;){do{i=this.randn.nextValue(),a=1+this.c*i}while(a<=0);if(a*=a*a,t=i*i,e=1-.331*t*t,r=.5*t+this.d*(1-a+Math.log(a)),s=this.randu(),s<e||Math.log(s)<r)break}return a*=1/this.beta*this.d,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(t){return"float32"===this.dtype?t:Math.round(t)}}class gM{constructor(t=0,e=1,r,i){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=r,null==i&&(i=Math.random()),"number"==typeof i&&(i=i.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=rd.alea(i)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const A1=yt({randomGamma_:function bM(n,t,e=1,r="float32",i){if(cs(n),null==e&&(e=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const s=new mM(t,e,r,i),a=zr(n,r);for(let o=0;o<a.values.length;o++)a.values[o]=s.nextValue();return a.toTensor()}}),s0=yt({randomNormal_:function wM(n,t=0,e=1,r,i){if(cs(n),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const s=new I1(t,e,r,!1,i),a=zr(n,r);for(let o=0;o<a.values.length;o++)a.values[o]=s.nextValue();return a.toTensor()}}),yN=yt({randomStandardNormal_:function gN(n,t,e){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return s0(n,0,1,t,e)}}),Mh=yt({randomUniform_:function _M(n,t=0,e=1,r="float32",i){cs(n);const s=zr(n,r),a=new gM(t,e,null,i);for(let o=0;o<s.values.length;o++)s.values[o]=a.nextValue();return s.toTensor()}});function pp(n,t,e=1,r="float32"){if(0===e)throw new Error("Cannot have a step of zero");return gt.runKernel(Qs,{},{start:n,stop:t,step:e,dtype:r})}const a0=yt({reciprocal_:function NM(n){const e={x:Xe(n,"x","reciprocal")};return gt.runKernel(ea,e)}}),Rc=yt({relu_:function SM(n){const e={x:Xe(n,"x","relu")};return gt.runKernel(Po,e)}}),o0=yt({relu6_:function vN(n){const e={x:Xe(n,"x","relu6")};return gt.runKernel(Ss,e)}}),Ql=yt({reverse_:function EM(n,t){const r={x:Xe(n,"x","reverse")};return gt.runKernel(ho,r,{dims:t})}}),bN=yt({reverse1d_:function xN(n){const t=Xe(n,"x","reverse");return K(1===t.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),Ql(t,0)}}),CM=yt({reverse2d_:function IM(n,t){const e=Xe(n,"x","reverse");return K(2===e.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),Ql(e,t)}}),_N=yt({reverse3d_:function wN(n,t){const e=Xe(n,"x","reverse");return K(3===e.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),Ql(e,t)}}),T1=yt({reverse4d_:function AM(n,t){const e=Xe(n,"x","reverse");return K(4===e.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),Ql(e,t)}}),u0=yt({round_:function NN(n){const e={x:Xe(n,"x","round")};return gt.runKernel(Ms,e)}}),vm=yt({rsqrt_:function TM(n){const e={x:Xe(n,"x","rsqrt","float32")};return gt.runKernel(dh,e)}}),l0=yt({selu_:function MM(n){const e={x:Xe(n,"x","selu")};return gt.runKernel(Pr,e)}}),c0=yt({separableConv2d_:function SN(n,t,e,r,i,s=[1,1],a="NHWC"){const o=Xe(n,"x","separableConv2d"),l=Xe(t,"depthwiseFilter","separableConv2d"),p=Xe(e,"pointwiseFilter","separableConv2d");let g=o,v=!1;if(3===o.rank&&(v=!0,g=St(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===a)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");K(4===g.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${g.rank}.`),K(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),K(4===p.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),K(1===p.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${p.shape[0]}.`),K(1===p.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${p.shape[1]}.`);const w=l.shape[2],N=l.shape[3];K(p.shape[2]===w*N,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${w*N}, but got ${p.shape[2]}.`);const D=ap(g,l,r,i,a,s),k=Xf(D,p,1,"valid",a);return v?St(k,[k.shape[1],k.shape[2],k.shape[3]]):k}});function f0(){return(f0=(0,Qe.Z)(function*(n,t){const e=Xe(n,"x","setdiff1d"),r=Xe(t,"y","setdiff1d");K(e.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${r.dtype}).`),K(1===e.rank,()=>`x should be 1D tensor, but got x (${e.shape}).`),K(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);const i=yield e.data(),s=yield r.data(),a=new Set(s);let o=0;for(let g=0;g<i.length;g++)a.has(i[g])||o++;const l=new Ga([o],e.dtype),p=new Ga([o],"int32");for(let g=0,v=0;g<i.length;g++)a.has(i[g])||(l.values[v]=i[g],p.values[v]=g,v++);return[l.toTensor(),p.toTensor()]})).apply(this,arguments)}const EN=function RM(n,t){return f0.apply(this,arguments)},h0=yt({sign_:function DM(n){const e={x:Xe(n,"x","sign")};return gt.runKernel(Fu,e)}}),p0=yt({sin_:function OM(n){const e={x:Xe(n,"x","sin","float32")};return gt.runKernel(wc,e)}}),m0=yt({sinh_:function d0(n){const e={x:Xe(n,"x","sinh")};return gt.runKernel(Pu,e)}}),g0=yt({slice1d_:function kM(n,t,e){const r=Xe(n,"x","slice1d");return K(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),li(r,[t],[e])}}),y0=yt({slice2d_:function IN(n,t,e){const r=Xe(n,"x","slice2d");return K(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),li(r,t,e)}}),id=yt({slice3d_:function PM(n,t,e){const r=Xe(n,"x","slice3d");return K(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),li(r,t,e)}}),sd=yt({slice4d_:function FM(n,t,e){const r=Xe(n,"x","slice4d");return K(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),li(r,t,e)}}),xm=yt({softmax_:function LM(n,t=-1){const e=Xe(n,"logits","softmax","float32");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);return gt.runKernel(za,{logits:e},{dim:t})}}),ad=yt({fft_:function M1(n){return K("complex64"===n.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`),gt.runKernel(Aa,{input:n})}}),od=yt({ifft_:function $M(n){return K("complex64"===n.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`),gt.runKernel(Xo,{input:n})}}),v0=yt({irfft_:function CN(n){const t=n.shape[n.shape.length-1],e=n.size/t;let r;if(t<=2){const i=St(n,[e,t]);r=od(i)}else{const i=[e,2*(t-1)],s=St(Vp(n),[e,t]),a=St(Up(n),[e,t]),o=Ql(li(s,[0,1],[e,t-2]),1),l=_t(Ql(li(a,[0,1],[e,t-2]),1),mr(-1)),p=Da([s,o],1),g=Da([a,l],1),v=St(Uf(p,g),[i[0],i[1]]);r=od(v)}if(r=Vp(r),3===n.rank&&0!==n.shape[0]){const i=r,s=n.shape[0];r=St(r,[s,r.shape[0]/s,r.shape[1]]),i.dispose()}return r}}),_u=yt({split_:function BM(n,t,e=0){const i={x:Xe(n,"x","split")};return gt.runKernel(Ws,i,{numOrSizeSplits:t,axis:e})}}),bm=yt({rfft_:function zM(n,t){K("float32"===n.dtype,()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const r=n.size/e;let i;if(null!=t&&t<e){const D=n.shape.map(k=>0),O=n.shape.map(k=>k);O[n.shape.length-1]=t,i=li(n,D,O),e=t}else if(null!=t&&t>e){const D=n.shape.map(O=>O);D[n.shape.length-1]=t-e,i=Da([n,Wa(D)],n.shape.length-1),e=t}else i=n;const s=di(i),a=St(Uf(i,s),[r,e]),o=ad(a),l=Math.floor(e/2)+1,p=Vp(o),g=Up(o),v=_u(p,[l,e-l],p.shape.length-1),w=_u(g,[l,e-l],g.shape.length-1),N=i.shape.slice();return N[i.shape.length-1]=l,St(Uf(v[0],w[0]),N)}}),x0=yt({squaredDifference_:function AN(n,t){let e=Xe(n,"a","squaredDifference"),r=Xe(t,"b","squaredDifference");return[e,r]=fa(e,r),$r(e.shape,r.shape),gt.runKernel(Lo,{a:e,b:r},{})}}),Zf=yt({squeeze_:function UM(n,t){const e=Xe(n,"x","squeeze","string_or_numeric");return St(e,Kr(e.shape,t).newShape)}}),Wu=yt({stack_:function VM(n,t=0){const e=Wd(n,"tensors","stack","string_or_numeric");return K(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&K(t<=e[0].rank,()=>"Axis must be <= rank of the tensor"),gt.runKernel(hh,e,{axis:t})}}),dp=yt({step_:function TN(n,t=0){const r={x:Xe(n,"x","step")};return gt.runKernel(Hl,r,{alpha:t})}}),MN=yt({stridedSlice_:function GM(n,t,e,r,i=0,s=0,a=0,o=0,l=0){const g={x:Xe(n,"x","stridedSlice","string_or_numeric")};return gt.runKernel(nl,g,{begin:t,end:e,strides:r,beginMask:i,endMask:s,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l})}}),R1=yt({tan_:function qM(n){const e={x:Xe(n,"x","tan","float32")};return gt.runKernel(gu,e)}});function bo(n,t){on(n);const e=of(n,t);if(1!==e.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return yh(n,null,e,t)}function jf(n,t,e){if(on(n),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=of(n,e);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return yh(n,t,r,e)}function RN(n,t,e){if(on(n),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=of(n,e);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return yh(n,t,r,e)}function DN(n,t,e){if(on(n),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=of(n,e);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return yh(n,t,r,e)}function ud(n,t,e){if(on(n),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=of(n,e);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return yh(n,t=t||r,r,e)}const kN=yt({tensorScatterUpdate_:function ON(n,t,e){const r=Xe(n,"tensor","tensorScatterupdate"),i=Xe(t,"indices","tensorScatterupdate","int32"),s=Xe(e,"updates","tensorScatterupdate");if(Lg(s,i,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);return gt.runKernel(bc,{tensor:r,indices:i,updates:s},{})}}),b0=yt({topk_:function WM(n,t=1,e=!0){const r=Xe(n,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const i=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${t}`);const s={x:r},a={k:t,sorted:e},[o,l]=gt.runKernel(_l,s,a);return{values:o,indices:l}}}),w0=yt({truncatedNormal_:function HM(n,t=0,e=1,r,i){if(cs(n),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const s=new I1(t,e,r,!0,i),a=zr(n,r);for(let o=0;o<a.values.length;o++)a.values[o]=s.nextValue();return a.toTensor()}}),D1=yt({unique_:function PN(n,t=0){const e=Xe(n,"x","unique","string_or_numeric");K(e.rank>0,()=>"The input tensor must be at least 1D");const r={x:e},i={axis:t},[s,a]=gt.runKernel(tf,r,i);return{values:s,indices:a}}}),wm=yt({unsortedSegmentSum_:function XM(n,t,e){const r=Xe(n,"x","unsortedSegmentSum"),i=Xe(t,"segmentIds","unsortedSegmentSum","int32");return K(Pn(e),()=>"numSegments must be of dtype int"),gt.runKernel(nf,{x:r,segmentIds:i},{numSegments:e})}}),Al=yt({unstack_:function KM(n,t=0){const e=Xe(n,"x","unstack","string_or_numeric");return K(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`),gt.runKernel(Hs,{value:e},{axis:t})}});function O1(n,t){return dm(n,t,"right")}function k1(n,t=!0,e,r){return gt.makeVariable(n,t,e,r)}function _0(n,t){const e=[];for(let s=0;s<t.length;s++)t[s]&&e.push(s);const r=zr(n,"int32"),i=zr([e.length,n.length],"int32");for(let s=0;s<e.length;s++){const a=r.indexToLoc(e[s]);i.values.set(a,s*n.length)}return i.toTensor()}function P1(){return(P1=(0,Qe.Z)(function*(n){const t=Xe(n,"condition","whereAsync","bool"),e=yield t.data(),r=_0(t.shape,e);return n!==t&&t.dispose(),r})).apply(this,arguments)}const F1=function YM(n){return P1.apply(this,arguments)};function L1(){return(L1=(0,Qe.Z)(function*(n,t,e){const r=Xe(n,"tensor","boolMask"),i=Xe(t,"mask","boolMask","bool"),s=e??0,a=i.rank,o=r.shape;K(a>0,()=>"mask cannot be scalar"),xt(o.slice(s,s+a),i.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let O=s;O<s+a;O++)l*=o[O];const p=o.slice(0,s).concat([l],o.slice(s+a)),g=St(r,p),v=St(i,[-1]),w=yield F1(v),N=Zf(w,[1]),D=up(g,N,s);return n!==r&&r.dispose(),t!==i&&i.dispose(),N.dispose(),g.dispose(),v.dispose(),w.dispose(),D})).apply(this,arguments)}const LN=function FN(n,t,e){return L1.apply(this,arguments)},$N=yt({movingAverage_:function ld(n,t,e,r,i=!0){const s=Xe(n,"v","movingAverage"),a=Xe(t,"x","movingAverage"),o=Xe(e,"decay","movingAverage");dw(s,a),K(Kt(s.shape,a.shape),()=>"Shape mismatch in v and x");const l=mr(1),p=Hn(l,o);let g=_t(Hn(a,s),p);if(i){K(null!=r,()=>"When using zeroDebias: true, step is required.");const v=Xe(r,"step","movingAverage");g=ur(g,Hn(l,lf(o,v)))}return gn(s,g)}}),BN=yt({scatterND_:function ZM(n,t,e){cs(e);const r=Xe(n,"indices","scatterND","int32"),i=Xe(t,"updates","scatterND");return Lg(i,r,e),gt.runKernel(ku,{indices:r,updates:i},{shape:e})}}),UN=yt({sparseToDense_:function jM(n,t,e,r=0){cs(e);const i=Xe(n,"sparseIndices","sparseToDense","int32"),s=Xe(t,"sparseValues","sparseToDense","string_or_numeric"),a=Xe(r,"defaultValue","sparseToDense",s.dtype);return function zN(n,t,e,r){if("int32"!==n.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const i=n.rank>0?n.shape[0]:1,s=n.rank>1?n.shape[1]:1;if(e.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${s}.`);if(0!==t.rank&&(1!==t.rank||t.size!==i))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${i}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(i,s,e,a),gt.runKernel(Ma,{sparseIndices:i,sparseValues:s,defaultValue:a},{outputShape:e})}}),$1=yt({gatherND_:function cd(n,t){const e=Xe(t,"indices","gatherND","int32"),i={params:Xe(n,"x","gatherND","string_or_numeric"),indices:e};return gt.runKernel(Wn,i)}}),N0=yt({dropout_:function QM(n,t,e,r){const i=Xe(n,"x","dropout");if(K("float32"===i.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`),K(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return n instanceof Xi?i.clone():i;const s=function JM(n,t){if(null==t)return n.shape.slice();if(Kt(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let r=0;r<n.shape.length;r++)e.push(null==t[r]&&null!=n.shape[r]?n.shape[r]:t[r]);return e}return t}(i,e),a=1-t,o=ur(Qp(gn(Mh(s,0,1,"float32",r),a)),a);return _t(i,o)}});function B1(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function S0(n,t,e){const r=1-n%2,i=new Float32Array(n);for(let s=0;s<n;++s){const a=2*Math.PI*s/(n+r-1);i[s]=t-e*Math.cos(a)}return bo(i,"float32")}function _m(){return(_m=(0,Qe.Z)(function*(n,t,e=1){const r=Xe(n,"predictions","inTopK"),i=Xe(t,"targets","inTopK");K(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),K(r.rank-1===i.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${i.rank}`),xt(r.shape.slice(0,r.shape.length-1),i.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const s=r.shape[r.shape.length-1];K(e>0&&e<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${e}`);const a=yield r.data(),o=yield i.data(),[l,p]=[a.length/s,s],g=hi("bool",l);for(let v=0;v<l;v++){const w=v*p,N=a.subarray(w,w+p),D=[];for(let O=0;O<N.length;O++)D.push({value:N[O],index:O});D.sort((O,k)=>k.value-O.value),g[v]=0;for(let O=0;O<e;O++)if(D[O].index===o[v]){g[v]=1;break}}return n!==r&&r.dispose(),t!==i&&i.dispose(),al(g,i.shape,"bool")})).apply(this,arguments)}const VN=function QL(n,t){return _m.apply(this,arguments)},GN=yt({conv2DBackpropFilter_:function eR(n,t,e,r,i,s="NHWC",a){let o=n;3===n.rank&&(o=St(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;3===l.rank&&(l=St(t,[1,t.shape[0],t.shape[1],t.shape[2]])),K(4===o.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),K(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),K(4===e.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const p="NHWC"===s?o.shape[3]:o.shape[1],g="NHWC"===s?l.shape[3]:l.shape[1];return K(p===e[2],()=>`Error in conv2dDerFilter: depth of input ${p}) must match input depth in filter (${e[2]}.`),K(g===e[3],()=>`Error in conv2dDerFilter: depth of dy (${g}) must match output depth for filter (${e[3]}).`),vu("conv2dDerFilter",i,a),gt.runKernel(ys,{x:o,dy:l},{strides:r,pad:i,dataFormat:s,dimRoundingMode:a,filterShape:e})}});function Nm(n,t,e){if(null==e||"linear"===e)return n;if("relu"===e)return _t(n,dp(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function E0(n,t){let e=t;const r=qa(n.shape,t.shape);return r.length>0&&(e=er(e,r)),St(e,n.shape)}function I0(n,t,e,r){if("linear"===t)return n;if("relu"===t)return Rc(n);if("elu"===t)return jp(n);if("relu6"===t)return o0(n);if("prelu"===t)return nd(n,e);if("leakyrelu"===t)return ed(n,r);if("sigmoid"===t)return Tc(n);throw new Error(`Unknown fused activation ${t}.`)}const Sm=(n,t)=>!(n>0)||"linear"===t,qN=yt({fusedConv2d_:function tR({x:n,filter:t,strides:e,pad:r,dataFormat:i="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:p,leakyreluAlpha:g}){if(!1===Sm(gt.state.gradientDepth,l=l||"linear")){K("NHWC"===i,()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let ce=Xf(n,t,e,r,i,s,a);return null!=o&&(ce=gn(ce,o)),I0(ce,l,p,g)}const v=Xe(n,"x","conv2d","float32"),w=Xe(t,"filter","conv2d","float32");let N=v,D=!1;3===v.rank&&(D=!0,N=St(v,[1,v.shape[0],v.shape[1],v.shape[2]])),K(4===N.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${N.rank}.`),K(4===w.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${w.rank}.`),vu("fused conv2d",r,a);const O="NHWC"===i?N.shape[3]:N.shape[1];K(w.shape[2]===O,()=>`Error in conv2d: depth of input (${O}) must match input depth for filter ${w.shape[2]}.`),K(Uo(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`);const k=vo(N.shape,w.shape,e,s,r,a);let L,$;if(null!=o&&(L=Xe(o,"bias","fused conv2d"),[L]=fa(L,v),"NHWC"===i?$r(k.outShape,L.shape):(K(L.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${L.shape.length}.`),K(0===L.shape.length||L.shape[0]===k.outChannels||1===L.shape[0],()=>`Error in fused conv2d: bias shape (${L.shape}) is not compatible with the number of output channels (${k.outChannels})`))),null!=p){const ce=p.shape;if(K(ce.length<=1||3===ce.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${ce.length}.`),1===ce.length)K(1===ce[0]||ce[0]===k.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${ce}) is not compatible with the number of output channels (${k.outChannels}).`);else if(3===ce.length)try{$r(ce,k.outShape)}catch{throw Error(`Error in fused conv2d: PReLU activation weights (${ce}) is not compatible with the output shape of the conv2d (${k.outShape}).`)}$=Xe(p,"prelu weights","fused conv2d")}const U=(ce,ve)=>{K("NHWC"===i,()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);const[Ee,ge,it,ut]=ve,Mt=Nm(ce,it,l);K(Sh(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const Rt=[r1(ge.shape,Mt,Ee,e,r),GN(ge,Mt,Ee.shape,e,r)];if(null!=ut){const Dt=E0(ut,Mt);Rt.push(Dt)}return Rt},V={x:N,filter:w,bias:L,preluActivationWeights:$},W={strides:e,pad:r,dataFormat:i,dilations:s,dimRoundingMode:a,activation:l,leakyreluAlpha:g};return null==o?Cc((ve,Ee,ge)=>{let it=gt.runKernel(Xl,V,W);return ge([Ee,ve,it]),D&&(it=St(it,[it.shape[1],it.shape[2],it.shape[3]])),{value:it,gradFunc:U}})(N,w):Cc((ve,Ee,ge,it)=>{let ut=gt.runKernel(Xl,V,W);return it([Ee,ve,ut,ge]),D&&(ut=St(ut,[ut.shape[1],ut.shape[2],ut.shape[3]])),{value:ut,gradFunc:U}})(N,w,L)}}),HN=yt({depthwiseConv2dNativeBackpropFilter_:function WN(n,t,e,r,i,s=[1,1],a){let o=n;3===n.rank&&(o=St(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;return 3===l.rank&&(l=St(t,[1,t.shape[0],t.shape[1],t.shape[2]])),gt.runKernel(Fl,{x:o,dy:l},{strides:r,pad:i,dimRoundingMode:a,dilations:s,filterShape:e})}}),XN=yt({depthwiseConv2dNativeBackpropInput_:function nR(n,t,e,r,i,s=[1,1],a){let o=t,l=!1;3===t.rank&&(l=!0,o=St(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const v=gt.runKernel(Mo,{dy:o,filter:e},{strides:r,pad:i,dimRoundingMode:a,dilations:s,inputShape:n});return l?St(v,[v.shape[1],v.shape[2],v.shape[3]]):v}}),KN=yt({fusedDepthwiseConv2d_:function rR({x:n,filter:t,strides:e,pad:r,dataFormat:i="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:p,leakyreluAlpha:g}){if(!1===Sm(gt.state.gradientDepth,l)){let W=ap(n,t,e,r,i,s,a);return null!=o&&(W=gn(W,o)),I0(W,l,p,g)}const v=Xe(n,"x","depthwiseConv2d","float32"),w=Xe(t,"filter","depthwiseConv2d","float32");let N=v,D=!1;3===v.rank&&(D=!0,N=St(v,[1,v.shape[0],v.shape[1],v.shape[2]])),K(4===N.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${N.rank}.`),K(4===w.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${w.rank}.`),K(N.shape[3]===w.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${N.shape[3]}) must match the inChannels dimension in filter ${w.shape[2]}.`),null==s&&(s=[1,1]),K(Uo(e,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),vu("fused depthwiseConv2d",r,a);const O=vo(N.shape,w.shape,e,s,r,a,!0);let k,L;null!=o&&(k=Xe(o,"bias","fused conv2d"),[k]=fa(k,v),$r(O.outShape,k.shape)),null!=p&&(L=Xe(p,"prelu weights","fused depthwiseConv2d"));const $=(W,ce)=>{K(Sh(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);const[ve,Ee,ge,it]=ce,ut=Nm(W,ge,l),Mt=XN(Ee.shape,ut,ve,e,r,s,a),Ot=HN(Ee,ut,ve.shape,e,r,s,a);return null!=it?[Mt,Ot,E0(k,ut)]:[Mt,Ot]},U={x:N,filter:w,bias:k,preluActivationWeights:L},V={strides:e,pad:r,dataFormat:i,dilations:s,dimRoundingMode:a,activation:l,leakyreluAlpha:g};return null==o?Cc((ce,ve,Ee)=>{let ge=gt.runKernel(Nl,U,V);return Ee([ve,ce,ge]),D&&(ge=St(ge,[ge.shape[1],ge.shape[2],ge.shape[3]])),{value:ge,gradFunc:$}})(N,w):Cc((ce,ve,Ee,ge)=>{let it=gt.runKernel(Nl,U,V);return ge([ve,ce,it,Ee]),D&&(it=St(it,[it.shape[1],it.shape[2],it.shape[3]])),{value:it,gradFunc:$}})(N,w,k)}}),z1=yt({fusedMatMul_:function YN({a:n,b:t,transposeA:e=!1,transposeB:r=!1,bias:i,activation:s="linear",preluActivationWeights:a,leakyreluAlpha:o=.2}){if(!1===Sm(gt.state.gradientDepth,s)){let ut=ni(n,t,e,r);return null!=i&&(ut=gn(ut,i)),I0(ut,s,a,o)}let l=Xe(n,"a","fused matMul"),p=Xe(t,"b","fused matMul");[l,p]=fa(l,p);const g=e?l.shape[l.rank-2]:l.shape[l.rank-1],v=r?p.shape[p.rank-1]:p.shape[p.rank-2],w=e?l.shape[l.rank-1]:l.shape[l.rank-2],N=r?p.shape[p.rank-2]:p.shape[p.rank-1],D=l.shape.slice(0,-2),O=p.shape.slice(0,-2),k=ft(D),L=ft(O);K(g===v,()=>`Error in fused matMul: inner shapes (${g}) and (${v}) of Tensors with shapes ${l.shape} and ${p.shape} and transposeA=${e} and transposeB=${r} must match.`);const U=$r(l.shape.slice(0,-2),p.shape.slice(0,-2)).concat([w,N]),V=St(l,e?[k,g,w]:[k,w,g]),W=St(p,r?[L,N,v]:[L,v,N]);let ce,ve;null!=i&&(ce=Xe(i,"bias","fused matMul"),[ce]=fa(ce,l),$r(U,ce.shape)),null!=a&&(ve=Xe(a,"prelu weights","fused matMul"));const Ee=(ut,Mt)=>{const[Ot,vt,Rt,Dt]=Mt,Ht=Nm(St(ut,Rt.shape),Rt,s);let Bt,Wt;return e||r?!e&&r?(Bt=ni(Ht,vt,!1,!1),Wt=ni(Ht,Ot,!0,!1)):e&&!r?(Bt=ni(vt,Ht,!1,!0),Wt=ni(Ot,Ht,!1,!1)):(Bt=ni(vt,Ht,!0,!0),Wt=ni(Ht,Ot,!0,!0)):(Bt=ni(Ht,vt,!1,!0),Wt=ni(Ot,Ht,!0,!1)),null!=i?[Bt,Wt,E0(Dt,Ht)]:[Bt,Wt]},ge={a:V,b:W,bias:ce,preluActivationWeights:ve},it={transposeA:e,transposeB:r,activation:s,leakyreluAlpha:o};return null==i?Cc((Mt,Ot,vt)=>{const Rt=gt.runKernel(Qo,ge,it);return vt([Mt,Ot,Rt]),{value:St(Rt,U),gradFunc:Ee}})(V,W):Cc((Mt,Ot,vt,Rt)=>{const Dt=gt.runKernel(Qo,ge,it);return Rt([Mt,Ot,Dt,vt]),{value:St(Dt,U),gradFunc:Ee}})(V,W,ce)}}),ZN=yt({hammingWindow_:function iR(n){return S0(n,.54,.46)}}),jN=yt({hannWindow_:function sR(n){return S0(n,.5,.5)}}),QN=yt({frame_:function JN(n,t,e,r=!1,i=0){let s=0;const a=[];for(;s+t<=n.size;)a.push(li(n,s,t)),s+=e;if(r)for(;s<n.size;){const o=s+t-n.size,l=Da([li(n,s,t-o),tp([o],i)]);a.push(l),s+=e}return 0===a.length?jf([],[0,t]):St(Da(a),[a.length,t])}}),fd=yt({stft_:function aR(n,t,e,r,i=jN){null==r&&(r=B1(t));const s=QN(n,t,e),a=_t(s,i(t));return bm(a,r)}}),oR=yt({cropAndResize_:function eS(n,t,e,r,i="bilinear",s=0){const a=Xe(n,"image","cropAndResize"),o=Xe(t,"boxes","cropAndResize","float32"),l=Xe(e,"boxInd","cropAndResize","int32"),p=o.shape[0];return K(4===a.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),K(2===o.rank&&4===o.shape[1],()=>`Error in cropAndResize: boxes must be have size [${p},4] but had shape ${o.shape}.`),K(1===l.rank&&l.shape[0]===p,()=>`Error in cropAndResize: boxInd must be have size [${p}] but had shape ${o.shape}.`),K(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),K(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),K("bilinear"===i||"nearest"===i,()=>`method must be bilinear or nearest, but was ${i}`),gt.runKernel(gl,{image:a,boxes:o,boxInd:l},{method:i,extrapolationValue:s,cropSize:r})}}),lR=yt({flipLeftRight_:function uR(n){const t=Xe(n,"image","flipLeftRight","float32");return K(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),gt.runKernel(ya,{image:t},{})}}),cR=yt({grayscaleToRGB_:function C0(n){const t=Xe(n,"image","grayscaleToRGB"),e=t.rank-1,r=t.shape[e];K(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),K(1===r,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const i=new Array(t.rank);return i.fill(1,0,e),i[e]=3,Cl(t,i)}}),tS=yt({rotateWithOffset_:function fR(n,t,e=0,r=.5){const i=Xe(n,"image","rotateWithOffset","float32");return K(4===i.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`),gt.runKernel(Op,{image:i},{radians:t,fillValue:e,center:r})}});function hd(n,t,e,r,i,s){null==r&&(r=.5),null==i&&(i=Number.NEGATIVE_INFINITY),null==s&&(s=0);const a=n.shape[0];return e=Math.min(e,a),K(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),K(2===n.rank,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),K(4===n.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),K(1===t.rank,()=>"scores must be a 1D tensor"),K(t.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${t.shape[0]}`),K(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:e,iouThreshold:r,scoreThreshold:i,softNmsSigma:s}}const nS=yt({nonMaxSuppression_:function hR(n,t,e,r=.5,i=Number.NEGATIVE_INFINITY){const s=Xe(n,"boxes","nonMaxSuppression","float32"),a=Xe(t,"scores","nonMaxSuppression","float32"),o=hd(s,a,e,r,i);return gt.runKernel(Kh,{boxes:s,scores:a},{maxOutputSize:e=o.maxOutputSize,iouThreshold:r=o.iouThreshold,scoreThreshold:i=o.scoreThreshold})}});function pR(n,t,e){const r=function dR(n,t,e){return function mR(n,t,e){let r=0,i=n.length,s=0,a=!1;for(;r<i;){s=r+(i-r>>>1);const o=e(t,n[s]);o>0?r=s+1:(i=s,a=!o)}return a?r:-r-1}(n,t,e||rS)}(n,t,e);n.splice(r<0?-(r+1):r,0,t)}function rS(n,t){return n>t?1:n<t?-1:0}function A0(n,t,e,r,i){return U1(n,t,e,r,i,0)}function Em(n,t,e,r,i,s){return U1(n,t,e,r,i,0,!1,s,!0)}function T0(n,t,e,r,i,s){return U1(n,t,e,r,i,s,!0)}function U1(n,t,e,r,i,s,a=!1,o=!1,l=!1){const p=[];for(let k=0;k<t.length;k++)t[k]>i&&p.push({score:t[k],boxIndex:k,suppressBeginIndex:0});p.sort(iS);const g=s>0?-.5/s:0,v=[],w=[];for(;v.length<e&&p.length>0;){const k=p.pop(),{score:L,boxIndex:$,suppressBeginIndex:U}=k;if(L<i)break;let V=!1;for(let W=v.length-1;W>=U;--W){const ce=V1(n,$,v[W]);if(ce>=r){V=!0;break}if(k.score=k.score*gR(r,g,ce),k.score<=i)break}k.suppressBeginIndex=v.length,V||(k.score===L?(v.push($),w.push(k.score)):k.score>i&&pR(p,k,iS))}const N=v.length,D=e-N;o&&D>0&&(v.push(...new Array(D).fill(0)),w.push(...new Array(D).fill(0)));const O={selectedIndices:v};return a&&(O.selectedScores=w),l&&(O.validOutputs=N),O}function V1(n,t,e){const r=n.subarray(4*t,4*t+4),i=n.subarray(4*e,4*e+4),s=Math.min(r[0],r[2]),a=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),p=Math.min(i[0],i[2]),g=Math.min(i[1],i[3]),v=Math.max(i[0],i[2]),w=Math.max(i[1],i[3]),N=(o-s)*(l-a),D=(v-p)*(w-g);if(N<=0||D<=0)return 0;const O=Math.max(s,p),k=Math.max(a,g),L=Math.min(o,v),$=Math.min(l,w),U=Math.max(L-O,0)*Math.max($-k,0);return U/(N+D-U)}function gR(n,t,e){const r=Math.exp(t*e*e);return e<=n?r:0}function iS(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}function M0(){return(M0=(0,Qe.Z)(function*(n,t,e,r=.5,i=Number.NEGATIVE_INFINITY){const s=Xe(n,"boxes","nonMaxSuppressionAsync"),a=Xe(t,"scores","nonMaxSuppressionAsync"),o=hd(s,a,e,r,i);e=o.maxOutputSize,r=o.iouThreshold,i=o.scoreThreshold;const l=yield Promise.all([s.data(),a.data()]),p=l[0],g=l[1],{selectedIndices:v}=A0(p,g,e,r,i);return s!==n&&s.dispose(),a!==t&&a.dispose(),bo(v,"int32")})).apply(this,arguments)}const sS=yt({nonMaxSuppressionWithScore_:function xR(n,t,e,r=.5,i=Number.NEGATIVE_INFINITY,s=0){const a=Xe(n,"boxes","nonMaxSuppression"),o=Xe(t,"scores","nonMaxSuppression"),l=hd(a,o,e,r,i,s),v=gt.runKernel(xa,{boxes:a,scores:o},{maxOutputSize:e=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:i=l.scoreThreshold,softNmsSigma:s=l.softNmsSigma});return{selectedIndices:v[0],selectedScores:v[1]}}});function G1(){return(G1=(0,Qe.Z)(function*(n,t,e,r=.5,i=Number.NEGATIVE_INFINITY,s=0){const a=Xe(n,"boxes","nonMaxSuppressionAsync"),o=Xe(t,"scores","nonMaxSuppressionAsync"),l=hd(a,o,e,r,i,s);e=l.maxOutputSize,r=l.iouThreshold,i=l.scoreThreshold,s=l.softNmsSigma;const p=yield Promise.all([a.data(),o.data()]),g=p[0],v=p[1],{selectedIndices:w,selectedScores:N}=T0(g,v,e,r,i,s);return a!==n&&a.dispose(),o!==t&&o.dispose(),{selectedIndices:bo(w,"int32"),selectedScores:bo(N)}})).apply(this,arguments)}const _R=yt({nonMaxSuppressionPadded_:function wR(n,t,e,r=.5,i=Number.NEGATIVE_INFINITY,s=!1){const a=Xe(n,"boxes","nonMaxSuppression"),o=Xe(t,"scores","nonMaxSuppression"),l=hd(a,o,e,r,i,null),D=gt.runKernel(Pf,{boxes:a,scores:o},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:s});return{selectedIndices:D[0],validOutputs:D[1]}}});function R0(){return(R0=(0,Qe.Z)(function*(n,t,e,r=.5,i=Number.NEGATIVE_INFINITY,s=!1){const a=Xe(n,"boxes","nonMaxSuppressionAsync"),o=Xe(t,"scores","nonMaxSuppressionAsync"),l=hd(a,o,e,r,i,null),p=l.maxOutputSize,g=l.iouThreshold,v=l.scoreThreshold,[w,N]=yield Promise.all([a.data(),o.data()]),{selectedIndices:D,validOutputs:O}=Em(w,N,p,g,v,s);return a!==n&&a.dispose(),o!==t&&o.dispose(),{selectedIndices:bo(D,"int32"),validOutputs:mr(O,"int32")}})).apply(this,arguments)}const q1=yt({resizeBilinear_:function SR(n,t,e=!1,r=!1){const i=Xe(n,"images","resizeBilinear");K(3===i.rank||4===i.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`),K(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),K(!1===r||!1===e,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=i,a=!1;3===i.rank&&(a=!0,s=St(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const[]=t,p=gt.runKernel(ir,{images:s},{alignCorners:e,halfPixelCenters:r,size:t});return a?St(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),oS=yt({resizeNearestNeighbor_:function ER(n,t,e=!1,r=!1){const i=Xe(n,"images","resizeNearestNeighbor");K(3===i.rank||4===i.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`),K(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),K("float32"===i.dtype||"int32"===i.dtype,()=>"`images` must have `int32` or `float32` as dtype"),K(!1===r||!1===e,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=i,a=!1;3===i.rank&&(a=!0,s=St(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const[]=t,p=gt.runKernel(ef,{images:s},{alignCorners:e,halfPixelCenters:r,size:t});return a?St(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),CR=yt({threshold_:function uS(n,t="binary",e=!1,r=.5){const i=Xe(n,"image","threshold"),l=i.shape[0]*i.shape[1];let g,v,w,N,p=_t(bo([r]),255);if(K(3===i.rank,()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`),K(3===i.shape[2]||1===i.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`),K("int32"===i.dtype||"float32"===i.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`),K("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===i.shape[2]){[g,v,w]=_u(i,[1,1,1],-1);const k=_t(g,.2989),L=_t(v,.587),$=_t(w,.114);N=gn(gn(k,L),$)}else N=n;"otsu"===t&&(p=function IR(n,t){let s,a,o,l,p,g,e=bo([-1]),r=bo([0]),i=bo([0]);for(let v=0;v<n.size-1;v++){s=li(n,0,v+1),a=li(n,v+1),p=ur(er(s),t),g=ur(er(a),t);const w=er(_t(s,pp(0,s.size)));o=ur(w,er(s));const N=tp(a.shape,s.size),D=gn(pp(0,a.size),N),O=_t(a,D);l=ur(er(O),er(a));const k=Hn(o,l),L=Hn(o,l),$=_t(p,g);i=_t(_t($,k),L);const U=bu(i,r);r=xo(U,i,r),e=xo(U,bo([v]),e)}return e}(jv(_n(u0(N),"int32"),al([]),256),l));const D=e?Ah(N,p):bu(N,p);return _n(_t(D,255),"int32")}}),AR=yt({transform_:function lS(n,t,e="nearest",r="constant",i=0,s){const a=Xe(n,"image","transform","float32"),o=Xe(t,"transforms","transform","float32");return K(4===a.rank,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),K(2===o.rank&&(o.shape[0]===a.shape[0]||1===o.shape[0])&&8===o.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),K(null==s||2===s.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`),gt.runKernel(Ua,{image:a,transforms:o},{interpolation:e,fillMode:r,fillValue:i,outputShape:s})}}),cS=yt({bandPart_:function TR(n,t,e){const r=Xe(n,"a","bandPart");K(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const i=r.shape,[s,a]=r.shape.slice(-2);let o,l;"number"==typeof t?(K(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),K(t<=s,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`),o=Xe(t<0?s:t,"numLower","bandPart")):(K("int32"===t.dtype,()=>"bandPart(): numLower's dtype must be an int32."),o=xo(td(t,0),s,Th(t,s))),"number"==typeof e?(K(e%1==0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),K(e<=a,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${a}).`),l=Xe(e<0?a:e,"numUpper","bandPart")):(K("int32"===e.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),l=xo(td(e,0),a,Th(e,a)));const p=St(pp(0,s,1,"int32"),[-1,1]),g=pp(0,a,1,"int32"),v=Hn(p,g),w=Jl(Ah(v,o),Kf(v,Ls(l))),N=Wa([s,a],r.dtype);return St(Wu(Al(St(r,[-1,s,a])).map(D=>xo(w,D,N))),i)}}),RR=yt({gramSchmidt_:function MR(n){let t;if(Array.isArray(n)){t=!1,K(null!=n&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const i=n[0].shape[0];for(let s=1;s<n.length;++s)K(n[s].shape[0]===i,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[s].shape[0]} vs. ${i})`)}else t=!0,n=_u(n,n.shape[0],0).map(i=>Zf(i,[0]));K(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],r=n;for(let i=0;i<n.length;++i)e.push(gt.tidy(()=>{let s=r[i];if(i>0)for(let a=0;a<i;++a){const o=_t(er(_t(e[a],s)),e[a]);s=Hn(s,o)}return ur(s,Jp(s,"euclidean"))}));return t?Wu(e,0):e}});function hS(n,t=!1){return gt.tidy(()=>{K(2===n.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],r=n.shape[1];let i=Jg(e),s=Ic(n);const a=jf([[1]],[1,1]);let o=Ic(a);const l=e>=r?r:e;for(let p=0;p<l;++p){const g=s,v=o,w=i;[o,s,i]=gt.tidy(()=>{const N=li(s,[p,p],[e-p,1]),D=Jp(N),O=li(s,[p,p],[1,1]),k=xo(bu(O,0),jf([[-1]]),jf([[1]])),L=Hn(O,_t(k,D)),$=ur(N,L);o=1===$.shape[0]?Ic(a):Da([a,li($,[1,0],[$.shape[0]-1,$.shape[1]])],0);const U=Ls(ur(ni(k,L),D)),V=li(s,[p,0],[e-p,r]),W=_t(U,o),ce=ui(o);if(0===p)s=Hn(V,ni(W,ni(ce,V)));else{const ge=Hn(V,ni(W,ni(ce,V)));s=Da([li(s,[0,0],[p,r]),ge],0)}const ve=ui(W),Ee=li(i,[0,p],[e,i.shape[1]-p]);if(0===p)i=Hn(Ee,ni(ni(Ee,o),ve));else{const ge=Hn(Ee,ni(ni(Ee,o),ve));i=Da([li(i,[0,0],[e,p]),ge],1)}return[o,s,i]}),Lr([g,v,w])}return!t&&e>r&&(i=li(i,[0,0],[e,r]),s=li(s,[0,0],[r,r])),[i,s]})}const DR=yt({qr_:function fS(n,t=!1){if(K(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),2===n.rank)return hS(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((l,p)=>l*p),r=Al(St(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),i=[],s=[];return r.forEach(l=>{const[p,g]=hS(l,t);i.push(p),s.push(g)}),[St(Wu(i,0),n.shape),St(Wu(s,0),n.shape)]}}});var Go=(()=>{return(n=Go||(Go={}))[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",Go;var n})();const Jf=yt({computeWeightedLoss_:function OR(n,t,e=Go.SUM_BY_NONZERO_WEIGHTS){const r=Xe(n,"losses","computeWeightedLoss");let i=null;null!=t&&(i=Xe(t,"weights","computeWeightedLoss"));const s=null==i?r:_t(r,i);if(e===Go.NONE)return s;if(e===Go.SUM)return er(s);if(e===Go.MEAN){if(null==i)return ra(s);{const a=r.size/i.size,o=ur(er(s),er(i));return a>1?ur(o,mr(a)):o}}if(e===Go.SUM_BY_NONZERO_WEIGHTS){if(null==i)return ur(er(s),mr(r.size));{const a=_t(i,ul(r.shape)),o=_n(er(fp(a,mr(0))),"float32");return ur(er(s),o)}}throw Error(`Unknown reduction: ${e}`)}}),kR=yt({absoluteDifference_:function pS(n,t,e,r=Go.SUM_BY_NONZERO_WEIGHTS){const i=Xe(n,"labels","absoluteDifference"),s=Xe(t,"predictions","absoluteDifference");let a=null;null!=e&&(a=Xe(e,"weights","absoluteDifference")),xt(i.shape,s.shape,"Error in absoluteDifference: ");const o=Ra(Hn(i,s));return Jf(o,a,r)}}),FR=yt({cosineDistance_:function PR(n,t,e,r,i=Go.SUM_BY_NONZERO_WEIGHTS){const s=Xe(n,"labels","cosineDistance"),a=Xe(t,"predictions","cosineDistance");let o=null;null!=r&&(o=Xe(r,"weights","cosineDistance")),xt(s.shape,a.shape,"Error in cosineDistance: ");const l=mr(1),p=Hn(l,er(_t(s,a),e,!0));return Jf(p,o,i)}}),LR=yt({hingeLoss_:function dS(n,t,e,r=Go.SUM_BY_NONZERO_WEIGHTS){let i=Xe(n,"labels","hingeLoss");const s=Xe(t,"predictions","hingeLoss");let a=null;null!=e&&(a=Xe(e,"weights","hingeLoss")),xt(i.shape,s.shape,"Error in hingeLoss: ");const o=mr(1);i=Hn(_t(mr(2),i),o);const l=Rc(Hn(o,_t(i,s)));return Jf(l,a,r)}}),BR=yt({huberLoss_:function $R(n,t,e,r=1,i=Go.SUM_BY_NONZERO_WEIGHTS){const s=Xe(n,"labels","huberLoss"),a=Xe(t,"predictions","huberLoss");let o=null;null!=e&&(o=Xe(e,"weights","huberLoss")),xt(s.shape,a.shape,"Error in huberLoss: ");const l=mr(r),p=Ra(Hn(a,s)),g=Th(p,l),v=Hn(p,g),w=gn(_t(mr(.5),Nr(g)),_t(l,v));return Jf(w,o,i)}}),zR=yt({logLoss_:function Rh(n,t,e,r=1e-7,i=Go.SUM_BY_NONZERO_WEIGHTS){const s=Xe(n,"labels","logLoss"),a=Xe(t,"predictions","logLoss");let o=null;null!=e&&(o=Xe(e,"weights","logLoss")),xt(s.shape,a.shape,"Error in logLoss: ");const l=mr(1),p=mr(r),g=Ls(_t(s,ol(gn(a,p)))),v=_t(Hn(l,s),ol(gn(Hn(l,a),p))),w=Hn(g,v);return Jf(w,o,i)}}),VR=yt({meanSquaredError_:function UR(n,t,e,r=Go.SUM_BY_NONZERO_WEIGHTS){const i=Xe(n,"labels","meanSquaredError"),s=Xe(t,"predictions","meanSquaredError");let a=null;null!=e&&(a=Xe(e,"weights","meanSquaredError")),xt(i.shape,s.shape,"Error in meanSquaredError: ");const o=x0(i,s);return Jf(o,a,r)}}),WR=yt({sigmoidCrossEntropy_:function qR(n,t,e,r=0,i=Go.SUM_BY_NONZERO_WEIGHTS){let s=Xe(n,"multiClassLabels","sigmoidCrossEntropy");const a=Xe(t,"logits","sigmoidCrossEntropy");let o=null;if(null!=e&&(o=Xe(e,"weights","sigmoidCrossEntropy")),xt(s.shape,a.shape,"Error in sigmoidCrossEntropy: "),r>0){const p=mr(r),g=mr(1),v=mr(.5);s=gn(_t(s,Hn(g,p)),_t(v,p))}const l=function GR(n,t){const e=Xe(n,"labels","sigmoidCrossEntropyWithLogits"),r=Xe(t,"logits","sigmoidCrossEntropyWithLogits");xt(e.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const i=Rc(r),s=_t(r,e),a=Vu(Uu(Ls(Ra(r))));return gn(Hn(i,s),a)}(s,a);return Jf(l,o,i)}}),KR=yt({softmaxCrossEntropy_:function XR(n,t,e,r=0,i=Go.SUM_BY_NONZERO_WEIGHTS){let s=Xe(n,"onehotLabels","softmaxCrossEntropy");const a=Xe(t,"logits","softmaxCrossEntropy");let o=null;if(null!=e&&(o=Xe(e,"weights","softmaxCrossEntropy")),xt(s.shape,a.shape,"Error in softmaxCrossEntropy: "),r>0){const p=mr(r),g=mr(1),v=mr(s.shape[1]);s=gn(_t(s,Hn(g,p)),ur(p,v))}const l=function HR(n,t,e=-1){if(-1===e&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return Cc((i,s,a)=>{const l=e0(s,[e],!0),p=Hn(_n(s,"float32"),l);a([i,p]);const g=Ls(_t(p,i));return{value:er(g,[e]),gradFunc:(N,D)=>{const[O,k]=D,L=Oa(N.shape,[e]);return[_t(St(N,L),Hn(_n(O,"float32"),Uu(k))),_t(St(N,L),Hn(Uu(k),_n(O,"float32")))]}}})(n,t)}(s,a);return Jf(l,o,i)}}),xS={fft:ad,ifft:od,rfft:bm,irfft:v0},bS={hammingWindow:ZN,hannWindow:jN,frame:QN,stft:fd},ec={flipLeftRight:lR,grayscaleToRGB:cR,resizeNearestNeighbor:oS,resizeBilinear:q1,rotateWithOffset:tS,cropAndResize:oR,nonMaxSuppression:nS,nonMaxSuppressionAsync:function yR(n,t,e){return M0.apply(this,arguments)},nonMaxSuppressionWithScore:sS,nonMaxSuppressionWithScoreAsync:function bR(n,t,e){return G1.apply(this,arguments)},nonMaxSuppressionPadded:_R,nonMaxSuppressionPaddedAsync:function e3(n,t,e){return R0.apply(this,arguments)},threshold:CR,transform:AR},H1={bandPart:cS,gramSchmidt:RR,qr:DR},wS={absoluteDifference:kR,computeWeightedLoss:Jf,cosineDistance:FR,hingeLoss:LR,huberLoss:BR,logLoss:zR,meanSquaredError:VR,sigmoidCrossEntropy:WR,softmaxCrossEntropy:KR},X1={sparseFillEmptyRows:yt({sparseFillEmptyRows_:function YR(n,t,e,r){const i=Xe(n,"indices","sparseFillEmptyRows","int32"),s=Xe(t,"values","sparseFillEmptyRows"),a=Xe(e,"denseShape","sparseFillEmptyRows","int32"),o=Xe(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==i.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${i.shape}`);if(1!==s.rank)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==a.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const p=gt.runKernel(wl,{indices:i,values:s,denseShape:a,defaultValue:o});return{outputIndices:p[0],outputValues:p[1],emptyRowIndicator:p[2],reverseIndexMap:p[3]}}}),sparseReshape:yt({sparseReshape_:function mS(n,t,e){const r=Xe(n,"inputIndices","sparseReshape","int32"),i=Xe(t,"inputShape","sparseReshape","int32"),s=Xe(e,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==i.rank)throw new Error(`Input shape should be Tensor1D but received shape ${i.shape}`);if(1!==s.rank)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);const o=gt.runKernel(Gl,{inputIndices:r,inputShape:i,newShape:s});return{outputIndices:o[0],outputShape:o[1]}}}),sparseSegmentMean:yt({sparseSegmentMean_:function ZR(n,t,e){const r=Xe(n,"data","sparseSegmentMean"),i=Xe(t,"indices","sparseSegmentMean","int32"),s=Xe(e,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${i.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${s.shape}`);return gt.runKernel(Jo,{data:r,indices:i,segmentIds:s})}}),sparseSegmentSum:yt({sparseSegmentSum_:function JR(n,t,e){const r=Xe(n,"data","sparseSegmentSum"),i=Xe(t,"indices","sparseSegmentSum","int32"),s=Xe(e,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${i.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${s.shape}`);return gt.runKernel(ql,{data:r,indices:i,segmentIds:s})}})},_S={stringNGrams:yt({stringNGrams_:function eD(n,t,e,r,i,s,a,o){const l=Xe(n,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const p=Xe(t,"dataSplits","stringNGrams");if("int32"!==p.dtype)throw new Error("Data splits must be of datatype int32");const w=gt.runKernel(_a,{data:l,dataSplits:p},{separator:e,nGramWidths:r,leftPad:i,rightPad:s,padWidth:a,preserveShortSequences:o});return{nGrams:w[0],nGramsSplits:w[1]}}}),stringSplit:yt({stringSplit_:function nD(n,t,e=!0){const r=Xe(n,"input","stringSplit","string"),i=Xe(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==i.rank)throw new Error(`Delimiter should be a scalar but received shape ${i.shape}`);const o=gt.runKernel(rl,{input:r,delimiter:i},{skipEmpty:e});return{indices:o[0],values:o[1],shape:o[2]}}}),stringToHashBucketFast:yt({stringToHashBucketFast_:function yS(n,t){const e=Xe(n,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");return gt.runKernel(Lf,{input:e},r)}}),staticRegexReplace:yt({staticRegexReplace_:function sD(n,t,e,r=!0){const i=Xe(n,"input","staticRegexReplace","string");return gt.runKernel(Qn,{x:i},{pattern:t,rewrite:e,replaceGlobal:r})}})},mp=$v,NS=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function K1(){return new Promise(n=>NS(()=>n()))}function Y1(n,t){const e=n[0].length;n.forEach((i,s)=>{K(i.length===e,()=>`Error in concat${e}D: rank of tensors[${s}] must be the same as the rank of the rest (${e})`)}),K(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const r=n[0];n.forEach((i,s)=>{for(let a=0;a<e;a++)K(a===t||i[a]===r[a],()=>`Error in concat${e}D: Shape of tensors[${s}] (${i}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function tc(n,t){const e=n[0].slice();for(let r=1;r<n.length;r++)e[t]+=n[r][t];return e}var nc=(()=>{return(n=nc||(nc={}))[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS",nc;var n})();function SS(n,t,e){let r=new Array;if(null==e&&null==t)return r;if(null==t)for(;r.length<n+e.length;)r.push(-1);else r=t.slice();if(null==e)return r;if(n+e.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+e.length}, but shape.rank = ${r.length}`);for(let i=1;i<e.length;++i){const s=e[i],a=r[r.length-e.length+i],o=r[a];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${i+n}] = ${s} but shape[${i+n}] = ${o}`)}else r[a]=s}return r}function ES(n){const t={FIRST_DIM_SIZE:nc.FIRST_DIM_SIZE,VALUE_ROWIDS:nc.VALUE_ROWIDS,ROW_LENGTHS:nc.ROW_LENGTHS,ROW_SPLITS:nc.ROW_SPLITS,ROW_LIMITS:nc.ROW_LIMITS,ROW_STARTS:nc.ROW_STARTS},e=[];for(const r of n){if(!(r in t))break;e.push(t[r])}return e}function Z1(n){return 0===n.length?0:n[0]===nc.FIRST_DIM_SIZE?n.length-1:n.length}function IS(n,t){if(null==n||null==t)return;const e=n.length,r=t.length;if(e>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${r})`);for(let i=0;i<Math.min(e,r-1);++i){const s=n[i],a=t[i+1];if(s>=0&&a>=0&&1!==s&&s!==a)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${i-n.length}] = ${s} but ragged tensor input.flatValues.shape[${i-n.length}] = ${a}`)}}const j1=30;function Im(n){return n<=j1?n:oh(n,Math.floor(Math.sqrt(n)))}function J1(n,t,e){return[e*("number"==typeof n?n:n[0]),t*("number"==typeof n?n:n[1])]}function Cm(n,t,e,r=!0){let i=[];if(r)i=i.concat(t.slice(0)),i.push(n[0]/e),i=i.concat(n.slice(1));else{i=i.concat(n[0]);const s=t.length;for(let a=0;a<s;++a)i=i.concat([n[a+1]/t[a],t[a]]);i=i.concat(n.slice(s+1))}return i}function pd(n,t,e=!0){const r=[];if(e){r.push(t);for(let i=t+1;i<n;++i)i<=2*t?(r.push(i),r.push(i-(t+1))):r.push(i)}else{const i=[],s=[];for(let a=1;a<n;++a)a>=2*t+1||a%2==1?s.push(a):i.push(a);r.push(...i),r.push(0),r.push(...s)}return r}function Am(n,t,e,r=!0){const i=[];i.push(r?n[0]/e:n[0]*e);for(let s=1;s<n.length;++s)i.push(s<=t.length?r?t[s-1]*n[s]:n[s]/t[s-1]:n[s]);return i}function Q1(n,t){const e=[0];for(let r=0;r<t;++r)e.push(n[r][0]);return e}function D0(n,t,e){const r=n.slice(0,1);for(let i=0;i<e;++i)r.push(n[i+1]-t[i][0]-t[i][1]);return r}const O0=1.7580993408473768,k0=1.0507009873554805,P0=.3275911,ex=.254829592,tx=-.284496736,nx=1.421413741,rx=-1.453152027,ix=1.061405429;function Dc(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const e=new Float32Array(2*n.length);for(let r=0;r<e.length;r+=2)e[r]=n[r/2],e[r+1]=t[r/2];return e}function CS(n){const t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)t[r/2]=n[r],e[r/2]=n[r+1];return{real:t,imag:e}}function AS(n){const t=Math.ceil(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let i=0;i<n.length;i+=4)e[Math.floor(i/4)]=n[i],r[Math.floor(i/4)]=n[i+1];return{real:e,imag:r}}function TS(n){const t=Math.floor(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let i=2;i<n.length;i+=4)e[Math.floor(i/4)]=n[i],r[Math.floor(i/4)]=n[i+1];return{real:e,imag:r}}function sx(n,t){return{real:n[2*t],imag:n[2*t+1]}}function MS(n,t,e,r){n[2*r]=t,n[2*r+1]=e}function RS(n,t){const e=new Float32Array(n/2),r=new Float32Array(n/2);for(let i=0;i<Math.ceil(n/2);i++){const s=(t?2:-2)*Math.PI*(i/n);e[i]=Math.cos(s),r[i]=Math.sin(s)}return{real:e,imag:r}}function DS(n,t,e){const r=(e?2:-2)*Math.PI*(n/t);return{real:Math.cos(r),imag:Math.sin(r)}}const ax="->",aD=/->/g,OS=",",kS="...";function ox(n,t){const e=((n=n.replace(/\s/g,"")).length-n.replace(aD,"").length)/ax.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${ax}").`);const[r,i]=n.split(ax);K(-1===r.indexOf(kS),()=>`The ellipsis notation ("${kS}") is not supported yet.`);const s=r.split(OS),a=s.length;if(t!==a)throw new Error(`Expected ${a} input tensors, received ${t}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let w=0;w<i.length;++w){const N=i[w];if(!s.some(D=>-1!==D.indexOf(N)))throw new Error(`Output subscripts contain the label ${N} not present in the input subscripts.`);-1===o.indexOf(N)&&o.push(N)}for(let w=0;w<r.length;++w){const N=r[w];-1===o.indexOf(N)&&N!==OS&&o.push(N)}const l=new Array(s.length);for(let w=0;w<a;++w){if(new Set(s[w].split("")).size!==s[w].length)throw new Error(`Found duplicate axes in input component ${s[w]}. Support for duplicate axes in input is not implemented yet.`);l[w]=[];for(let N=0;N<s[w].length;++N)l[w].push(o.indexOf(s[w][N]))}const p=o.length,v=[];for(let w=i.length;w<p;++w)v.push(w);return{allDims:o,summedDims:v,idDims:l}}function F0(n,t){let e=new Array(n);e.fill(-1);for(let i=0;i<t.length;++i)e[t[i]]=i;const r=[];for(let i=0;i<n;++i)-1===e[i]&&r.push(i);return e=e.filter(i=>-1!==i),{permutationIndices:e,expandDims:r}}function ux(n,t,e){const r=new Array(n);for(let i=0;i<e.length;++i){const s=e[i].shape;for(let a=0;a<t[i].length;++a)void 0===r[t[i][a]]?r[t[i][a]]=s[a]:K(r[t[i][a]]===s[a],()=>`Expected dimension ${r[t[i][a]]} at axis ${a} of input shaped ${JSON.stringify(s)}, but got dimension ${s[a]}`)}}function lx(n,t){const e=n,r=[];let i=0;0===n.length&&e.push(-1),i=n.length+1;for(let a=0;a<i;++a)r.push([]);const s=[];for(let a=0;a<e.length;++a){const l=oD(t,e[a]);for(const p of l)-1===s.indexOf(p)&&(r[a].push(p),s.push(p))}return{path:e,steps:r}}function L0(n){return n.every((t,e)=>t===e)}function oD(n,t){const e=[];for(let r=0;r<n.length;++r)(0===n[r].length||-1!==n[r].indexOf(t)||-1===t)&&e.push(r);return e}function cx(n,t,e=0){let r=[];if("number"==typeof t)K(n.shape[e]%t==0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(n.shape[e]/t);else{K(t.reduce((a,o)=>(-1===o&&(a+=1),a),0)<=1,()=>"There should be only one negative value in split array.");const s=t.indexOf(-1);if(-1!==s){const a=t.reduce((o,l)=>l>0?o+l:o);t[s]=n.shape[e]-a}K(n.shape[e]===t.reduce((a,o)=>a+o),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function fx(n){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${n}`}function PS(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function FS(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}function LS(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function $S(n,t){return`size ${n} must be non-negative, not ${t}`}function BS(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function hx(n,t){return`Input to reshape is a SparseTensor with ${ft(n)}\n  dense values, but the requested shape requires a multiple of ${ft(t)}. inputShape=${n} outputShape= ${t}`}function zS(n,t){return`Input to reshape is a tensor with ${ft(n)} dense values, but the requested shape has ${ft(t)}. inputShape=${n} outputShape=${t}`}function px(){return"segment ids must be >= 0"}function dx(){return"segment ids are not increasing"}function US(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function VS(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}function mx(n,t){let r,e=!1;for(n<=j1?(r=n,e=!0):r=oh(n,Math.floor(Math.sqrt(n)));!e;)r>t||r===n?e=!0:r=oh(n,r+1);return r}function GS(n,t,e){const r=[],i=n.length;for(let s=0;s<i;s++)r.push(s!==t?n[s]:e);return r}function gx(n,t,e,r){const i=t.shape.length,s=n.shape.length;if(0!==r&&(r<-i||r>i))throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${r}`);if(r<0&&(r+=i),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${s}).`);if(e<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${e}).`);for(let v=0;v<r;++v)if(n.shape[v]!==t.shape[v])throw new Error(`x.shape[${v}]: ${n.shape[v]} should be equal to indices.shape[${v}]: ${t.shape[v]}.`);const a=n.shape[e],o=[];let l=1,p=1,g=1;for(let v=0;v<r;++v)o.push(n.shape[v]),l*=n.shape[v];for(let v=r;v<e;v++)o.push(n.shape[v]),p*=n.shape[v];for(let v=r;v<i;v++)o.push(t.shape[v]);for(let v=e+1;v<s;v++)o.push(n.shape[v]),g*=n.shape[v];return{batchSize:l,sliceSize:g,outerSize:p,dimSize:a,outputShape:o}}function mf(n){try{return n.map(t=>Va(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function qS(n){return n.map(t=>sf(t))}!function wA(){for(const n of bA)yn(n)}();const WS={kernelName:ga,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>_t(n,dp(_n(e,"float32"),-1))}}},HS={kernelName:To,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=Nr(_n(e,"float32")),i=zo(Hn(mr(1),r));return Ls(ur(n,i))}}}},uD={kernelName:ml,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=zo(Hn(Nr(_n(e,"float32")),1));return ur(n,r)}}}},lD={kernelName:Ju,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,i=$r(e.shape,r.shape);return{a:()=>{let o=n;const l=qa(e.shape,i);return l.length>0&&(o=er(o,l)),St(o,e.shape)},b:()=>{let o=n;const l=qa(r.shape,i);return l.length>0&&(o=er(o,l)),St(o,r.shape)}}}},XS={kernelName:kl,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((r,i)=>{e[i]=()=>n.clone()}),e}},cD={kernelName:Ho,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>di(e)}}},fD={kernelName:Af,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>di(e)}}},KS={kernelName:Tf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ur(n,zo(Hn(mr(1),Nr(_n(e,"float32")))))}}},hD={kernelName:Gr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=zo(gn(mr(1),Nr(_n(e,"float32"))));return ur(n,r)}}}},pD={kernelName:Yc,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,i=$r(e.shape,r.shape);return{a:()=>{const o=gn(Nr(e),Nr(r));let l=_t(n,ur(r,o));const p=qa(e.shape,i);return p.length>0&&(l=er(l,p)),St(l,e.shape)},b:()=>{const o=gn(Nr(e),Nr(r));let l=Ls(_t(n,ur(e,o)));const p=qa(r.shape,i);return p.length>0&&(l=er(l,p)),St(l,r.shape)}}}},YS={kernelName:ja,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ur(n,gn(Nr(_n(e,"float32")),1))}}},dD={kernelName:jn,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ur(n,Hn(mr(1),Nr(_n(e,"float32"))))}}},ZS=yt({avgPool3dGrad_:function mD(n,t,e,r,i,s){const a=Xe(n,"dy","avgPool3dGrad"),o=Xe(t,"input","avgPool3dGrad");let l=a,p=o,g=!1;4===o.rank&&(g=!0,l=St(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),p=St(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),K(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),K(5===p.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),vu("avgPool3dGrad",i,s);const N=gt.runKernel(Ys,{dy:l,input:p},{filterSize:e,strides:r,pad:i,dimRoundingMode:s});return g?St(N,[N.shape[1],N.shape[2],N.shape[3],N.shape[4]]):N}}),gD={kernelName:hn,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{filterSize:i,strides:s,pad:a,dimRoundingMode:o}=e;return{x:()=>ZS(n,r,i,s,a,o)}}},jS=yt({avgPoolGrad_:function yD(n,t,e,r,i){const s=Xe(n,"dy","avgPoolGrad"),a=Xe(t,"input","avgPoolGrad");K(a.rank===s.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${s.rank})`);let o=a,l=s,p=!1;3===a.rank&&(p=!0,o=St(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=St(s,[1,s.shape[0],s.shape[1],s.shape[2]])),K(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),K(4===o.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const w=gt.runKernel(Mf,{dy:l,input:o},{filterSize:e,strides:r,pad:i});return p?St(w,[w.shape[1],w.shape[2],w.shape[3]]):w}}),vD={kernelName:Mr,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{filterSize:i,strides:s,pad:a}=e;return{x:()=>jS(n,r,i,s,a)}}},xD={kernelName:fs,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[r,i]=t,{transposeA:s,transposeB:a}=e;return s||a?!s&&a?{a:()=>ni(n,i,!1,!1),b:()=>ni(n,r,!0,!1)}:s&&!a?{a:()=>ni(i,n,!1,!0),b:()=>ni(r,n,!1,!1)}:{a:()=>ni(i,n,!0,!0),b:()=>ni(n,r,!0,!0)}:{a:()=>ni(n,i,!1,!0),b:()=>ni(r,n,!0,!1)}}},JS={kernelName:Ja,gradFunc:(n,t,e)=>{const{blockShape:r,crops:i}=e;return{x:()=>ym(n,r,i)}}},bD={kernelName:Bd,gradFunc:(n,t,e)=>{const i=e.inputShape,s=e.shape,a=Array.from(s);for(let l=i.length-1;l>=0;l--)if(i[l]===s[l])a[l]=1;else if(1!==i[l])throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${s}].`);const o=[];for(let l=0;l<a.length;l++)a[l]>1&&o.push(l);return{x:()=>er(n,o,!0)}}},wD={kernelName:rr,gradFunc:n=>({x:()=>n.clone()})},QS={kernelName:As,gradFunc:n=>({x:()=>di(n)})},_D={kernelName:Qa,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{clipValueMin:i,clipValueMax:s}=e;return{x:()=>xo(Jl(Kf(r,i),Ah(r,s)),n,di(n))}}},ND={kernelName:Zi,inputsToSave:["x"],gradFunc:WS.gradFunc},eE={kernelName:ci,saveAllInputs:!0,gradFunc:(n,t,e)=>{const r=t.map(l=>l.shape),{axis:i}=e,s=ar(i,t[0].shape)[0],a=r.map(l=>l[s]);return _u(n,a,s).map(l=>()=>l)}},SD={kernelName:kr,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[r,i]=t,{dilations:s,strides:a,pad:o,dataFormat:l}=e;return K(Sh(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>r1(r.shape,n,i,a,o,l),filter:()=>GN(r,n,i.shape,a,o,l)}}},ED={kernelName:uh,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[r,i]=t,{strides:s,pad:a,dataFormat:o,dimRoundingMode:l}=e;return{dy:()=>Xf(n,i,s,a,o,1,l),filter:()=>GN(n,r,i.shape,s,a,o,l)}}},CD=yt({conv3DBackpropFilter_:function ID(n,t,e,r,i){let s=n;4===n.rank&&(s=St(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let a=t;return 4===a.rank&&(a=St(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),K(5===s.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),K(5===a.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),K(5===e.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),K(s.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${e[3]}.`),K(a.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${e[4]}).`),gt.runKernel(Ca,{x:s,dy:a},{strides:r,pad:i,filterShape:e})}}),AD={kernelName:lh,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:r,strides:i,pad:s}=e;K(Sh(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[a,o]=t;return{x:()=>P_(a.shape,n,o,i,s),filter:()=>CD(a,n,o.shape,i,s)}}},tE={kernelName:eo,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>_t(Ls(p0(_n(e,"float32"))),n)}}},TD={kernelName:Jr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>_t(m0(_n(e,"float32")),n)}}},MD={kernelName:Zs,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:i,exclusive:s,reverse:a}=e;return{x:()=>{const o=na([i],r.rank);let l=pm(n,i,s,!a);return null!=o&&(l=ui(l,o)),l}}}},Tm={kernelName:la,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:r,strides:i,pad:s,dimRoundingMode:a}=e,o=r??[1,1];K(Sh(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[l,p]=t;return K(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),K(4===p.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${p.rank}.`),K(l.shape[3]===p.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),K(Uo(i,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${o}'.`),vu("depthwiseConv2d",s,a),{x:()=>XN(l.shape,n,p,i,s,o,a),filter:()=>HN(l,n,p.shape,i,s,o,a)}}},RD={kernelName:Mu,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[r,i]=t,s={x:r,filter:i,dy:n},a={x:r,filter:i,dy:n};return{x:()=>gt.runKernel(Ll,s,e),filter:()=>gt.runKernel(Ts,a,e)}}},DD={kernelName:hs,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,r={dy:n,y:e};return{x:()=>gt.runKernel(Gs,r)}}},OD={kernelName:gc,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,r=_t(Uu(Ls(Nr(e))),2/Math.sqrt(Math.PI));return{x:()=>_t(n,r)}}},nE={kernelName:yl,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>_t(n,e)}}},yx={kernelName:ch,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>St(n,e.shape)}}},kD={kernelName:Df,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>_t(n,Uu(e))}}},PD={kernelName:el,gradFunc:n=>({x:()=>di(n)})},FD={kernelName:Do,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,i=$r(e.shape,r.shape);return{a:()=>{const o=ur(n,_n(r,"float32")),l=qa(e.shape,i);return l.length>0?St(er(o,l),e.shape):o},b:()=>{let o=_t(n,_n(e,"float32"));const l=qa(r.shape,i);l.length>0&&(o=St(er(o,l),r.shape));const p=Nr(r);return Ls(ur(o,_n(p,"float32")))}}}},rE={kernelName:yc,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:r}=e,[i,s,a,o]=t,l=o??mr(1),p=qa(s.shape,i.shape),g=[];if(1===s.rank){for(let V=0;V<i.shape.length-1;++V)g.push(i.shape[V]);g.push(1)}const v=Hn(i,s),w=_t(n,l),N=vm(gn(a,mr(r))),D=_t(_t(_t(N,N),N),mr(-.5));return{x:()=>St(_t(_t(n,1===s.rank?Cl(St(N,[1,1,1,s.shape[0]]),g):N),l),i.shape),mean:()=>{let V=_t(_t(N,mr(-1)),w);return 1===s.rank&&(V=er(V,p)),St(V,s.shape)},variance:()=>{let V=_t(_t(D,v),w);return 1===s.rank&&(V=er(V,p)),St(V,s.shape)},scale:()=>{const V=_t(v,N);let W=_t(n,V);return 1===s.rank&&(W=er(W,p)),St(W,s.shape)},offset:()=>{let V=n;return 1===s.rank&&(V=er(V,p)),St(V,s.shape)}}}},LD={kernelName:ss,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[r,i]=t,{axis:s}=e,a=ar(s,r.shape)[0];return{x:()=>{const l=r.shape,p=i.size,g=l.slice(0,a),v=g.length,w=l.slice(s,l.length).slice(1),N=w.length,D=iE(0,v),O=iE(v+1,v+1+N),k=vx([g,[p],w]),L=St(n,k),$=St(i,[p]),U=vx([[v],D,O]),V=ui(L,U);let W=wm(V,$,r.shape[a]);const ce=Ch(U);return W=ui(W,ce),W},indices:()=>i}}};function iE(n,t){const e=[];for(let r=n;r<t;++r)e.push(r);return e}function vx(n){const t=[];for(let e=0;e<n.length;++e)for(let r=0;r<n[e].length;++r)t.push(n[e][r]);return t}const $D={kernelName:$l,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>di(e),b:()=>di(r)}}},BD={kernelName:va,gradFunc:n=>({x:()=>_n(n,"float32")})},sE={kernelName:Bl,gradFunc:n=>({x:()=>di(n)})},zD={kernelName:jc,gradFunc:n=>({x:()=>di(n)})},UD={kernelName:Of,gradFunc:n=>({x:()=>di(n)})},aE={kernelName:Yr,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{alpha:i}=e,s=bu(r,0);return{x:()=>xo(s,n,_t(n,i))}}},VD={kernelName:kf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ur(n,gn(e,1))}}},GD={kernelName:Ta,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ur(n,_n(e,"float32"))}}},oE={kernelName:to,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r]=t,{axis:i}=e;return{logits:()=>{const a=Uu(r);return Hn(n,_t(er(n,i,!0),a))}}}},WD=yt({localResponseNormalizationBackprop_:function qD(n,t,e,r=5,i=1,s=1,a=.5){return gt.runKernel(Qr,{x:n,y:t,dy:e},{depthRadius:r,bias:i,alpha:s,beta:a})}}),HD={kernelName:vc,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,i]=t,{depthRadius:s,bias:a,alpha:o,beta:l}=e;return{x:()=>WD(r,i,n,s,a,o,l)}}};function uE(n,t,e,r){return t.rank<e.rank&&(t=St(t,Oa(t.shape,r))),n.rank<e.rank&&(n=St(n,Oa(n.shape,r))),{x:()=>_t(n,_n(zu(e,t),n.dtype))}}const lE={kernelName:Ps,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const r=e,{reductionIndices:i}=r,s=t[0],l=uE(n,t[1],s,ar(i,s.shape));return{x:()=>l.x()}}},cE={kernelName:Ko,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>_t(n,_n(Kf(e,r),"float32")),b:()=>_t(n,_n(td(e,r),"float32"))}}},KD=yt({maxPool3dGrad_:function XD(n,t,e,r,i,s,a){const o=Xe(n,"dy","maxPool3dGrad"),l=Xe(t,"input","maxPool3dGrad"),p=Xe(e,"output","maxPool3dGrad");let g=o,v=l,w=p,N=!1;4===l.rank&&(N=!0,g=St(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),v=St(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),w=St(p,[1,p.shape[0],p.shape[1],p.shape[2],p.shape[3]])),K(5===g.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${g.rank}.`),K(5===v.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${v.rank}.`),K(5===w.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${w.rank}.`),vu("maxPool3dGrad",s,a);const k=gt.runKernel(Cr,{dy:g,input:v,output:w},{filterSize:r,strides:i,pad:s,dimRoundingMode:a});return N?St(k,[k.shape[1],k.shape[2],k.shape[3],k.shape[4]]):k}}),fE={kernelName:_r,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,i]=t,{filterSize:s,strides:a,pad:o,dimRoundingMode:l}=e;return{x:()=>KD(n,r,i,s,a,o,l)}}},ZD=yt({maxPoolGrad_:function YD(n,t,e,r,i,s,a){const o=Xe(n,"dy","maxPoolGrad"),l=Xe(t,"input","maxPoolGrad"),p=Xe(e,"output","maxPoolGrad");return K(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),K(4===o.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),K(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),vu("maxPoolGrad",s,a),gt.runKernel(os,{dy:o,input:l,output:p},{filterSize:r,strides:i,pad:s,dimRoundingMode:a})}}),yE={kernelName:ba,inputsToSave:["x"],gradFunc:(n,t,e)=>{const r=t[0],{paddings:i}=e,s=i.map(a=>a[0]);return{x:()=>li(n,s,r.shape)}}};const EE={kernelName:Fo,gradFunc:(n,t,e)=>{const{blockShape:r,paddings:i}=e;return{x:()=>cm(n,r,i)}}},$0={kernelName:Ws,gradFunc:(n,t,e)=>{const{axis:r}=e;return{x:()=>Da(n,r)}}},TO=[WS,HS,uD,lD,XS,cD,fD,KS,hD,pD,YS,dD,gD,vD,xD,JS,bD,wD,QS,_D,ND,eE,ED,SD,AD,tE,TD,MD,Tm,RD,{kernelName:Rf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,i=$r(e.shape,r.shape);return{a:()=>{const o=ur(n,_n(r,"float32")),l=qa(e.shape,i);return l.length>0?St(er(o,l),e.shape):o},b:()=>{let o=_t(n,_n(e,"float32"));const l=qa(r.shape,i);l.length>0&&(o=St(er(o,l),r.shape));const p=Nr(r);return Ls(ur(o,_n(p,"float32")))}}}},DD,OD,nE,yx,kD,FD,PD,rE,LD,$D,BD,sE,zD,UD,aE,VD,GD,oE,HD,lE,lE,cE,fE,{kernelName:no,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,i]=t,{filterSize:s,strides:a,pad:o}=e;return{x:()=>ZD(n,r,i,s,a,o)}}},{kernelName:Oo,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:i}=e,s=ar(i,r.shape),l=ft(ao(r.shape,s)[1]);return{x:()=>{const g=r.shape.slice();s.forEach(N=>{g[N]=1});const v=St(n,g);return ur(_t(v,ul(r.shape,"float32")),l)}}}},{kernelName:js,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const r=e,{axis:i}=r,[s,a]=t,l=uE(n,a,s,ar(i,s.shape));return{x:()=>l.x()}}},{kernelName:Yo,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>_t(n,_n(Ah(e,r),"float32")),b:()=>_t(n,_n(bu(e,r),"float32"))}}},{kernelName:Js,inputsToSave:["x"],gradFunc:(n,t,e)=>{const r=t[0],{paddings:i}=e,s=i.map(a=>a[0]);return{x:()=>li(n,s,r.shape)}}},{kernelName:fo,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,i=$r(e.shape,r.shape);return{a:()=>{const o=qa(e.shape,i);return o.length>0?St(er(n,o),e.shape):n},b:()=>{const o=_t(n,Ls(Qp(ur(e,r)))),l=qa(r.shape,i);return l.length>0?St(er(o,l),r.shape):o}}}},{kernelName:du,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,i=$r(e.shape,r.shape);return{a:()=>{const o=_t(n,_n(r,"float32")),l=qa(e.shape,i);return l.length>0?St(er(o,l),e.shape):o},b:()=>{const o=_t(n,_n(e,"float32")),l=qa(r.shape,i);return l.length>0?St(er(o,l),r.shape):o}}}},{kernelName:mu,gradFunc:n=>({x:()=>Ls(n)})},{kernelName:ko,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>Wa(e.shape,"float32")}}},{kernelName:Du,gradFunc:n=>({x:()=>di(n)})},{kernelName:hh,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:r}=e;return Al(n,r).map(s=>()=>s)}},yE,yE,{kernelName:zl,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,r,i]=t,s=e,a=r,o=$r(s.shape,a.shape);return{a:()=>{const g=_n(a,"float32");let v=_t(n,_t(g,lf(s,Hn(g,mr(1)))));const w=qa(s.shape,o);return w.length>0&&(v=er(v,w)),St(v,s.shape)},b:()=>{const g=bu(s,0),v=xo(g,ol(s),di(s));let w=_t(n,_t(i,v));const N=qa(a.shape,o);return N.length>0&&(w=er(w,N)),St(w,a.shape)}}}},{kernelName:Ul,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,r]=t,i=bu(e,0);return{x:()=>xo(i,n,_t(n,r)),alpha:()=>{let s=xo(i,di(n),_t(n,e));const a=qa(r.shape,n.shape);return a.length>0&&(s=er(s,a)),St(s,r.shape)}}}},{kernelName:ph,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:i}=e;let s=[];return s=null==i?r.shape.map((a,o)=>o):"number"==typeof i?[i]:i,{x:()=>function sO(n,t,e){const r=n.shape.length,i=r-e.length,s=na(e,r);let a=n;null!=s&&(a=ui(n,s));const o=a.shape.slice(),p=o.splice(r-e.length,e.length).reduce((w,N)=>w*N,1);o.push(p);let v=function iO(n,t,e){const r=n.shape.slice();r[e]=1;const i=St(t,r),s=hm(n,e,!0,!1),a=hm(n,e,!0,!0),o=_t(s,a);return _t(i,o)}(a.reshape(o),t,i);if(v=v.reshape(a.shape),null!=s){const w=Ch(s);v=ui(v,w)}return v}(r,n,s)}}},{kernelName:ea,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ur(n,Ls(Nr(e)))}}},{kernelName:Ss,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,r=_t(Ah(e,6),dp(e));return{x:()=>_t(n,_n(r,"float32"))}}},{kernelName:Po,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>_t(n,_n(dp(e),"float32"))}}},{kernelName:tl,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>St(n,e.shape)}}},{kernelName:ir,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[r]=t,i={dy:n,images:r};return{images:()=>gt.runKernel(Ou,i,e)}}},{kernelName:ef,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[r]=t,i={dy:n,images:r};return{images:()=>gt.runKernel(es,i,e)}}},{kernelName:ho,gradFunc:(n,t,e)=>{const{dims:r}=e,i=ar(r,n.shape);return{x:()=>Ql(n,i)}}},{kernelName:Ms,gradFunc:n=>({x:()=>di(n)})},{kernelName:dh,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ls(ur(n,_t(lf(e,1.5),2)))}}},{kernelName:ta,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>_n(di(e),"float32"),t:()=>_t(n,_n(e,n.dtype)),e:()=>_t(n,_n(Pa(e),n.dtype))}}},{kernelName:Pr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=bu(e,mr(0)),i=mr(O0),s=mr(k0),a=_t(n,s),o=_t(_t(n,i),Uu(_n(e,"float32")));return xo(r,a,o)}}}},{kernelName:wa,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>_t(n,_t(e,Hn(mr(1),e)))}}},{kernelName:Fu,gradFunc:n=>({x:()=>di(n)})},{kernelName:wc,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>_t(Zp(_n(e,"float32")),n)}}},{kernelName:Pu,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>_t(Yg(_n(e,"float32")),n)}}},{kernelName:po,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{begin:i,size:s}=e,a=r.shape,[o,l]=Bg(r,i,s),p=[];for(let g=0;g<n.rank;g++)p.push([o[g],a[g]-o[g]-l[g]]);return{x:()=>Yf(n,p)}}},{kernelName:za,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r]=t,{dim:i}=e,a=_t(n,r);return{logits:()=>Hn(a,_t(er(a,[i],!0),r))}}},{kernelName:Ff,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>_t(n,Tc(e))}}},EE,EE,$0,$0,{kernelName:Rs,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ur(n,_t(zo(_n(e,"float32")),2))}}},{kernelName:Lo,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,i=mr(2);return{a:()=>_t(n,_t(i,Hn(e,r))),b:()=>_t(n,_t(i,Hn(r,e)))}}},{kernelName:Zr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>_t(n,_t(_n(e,"float32"),2))}}},{kernelName:Hl,gradFunc:n=>({x:()=>di(n)})},{kernelName:il,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,i=$r(e.shape,r.shape);return{a:()=>{let o=n;const l=qa(e.shape,i);return l.length>0&&(o=er(o,l)),St(o,e.shape)},b:()=>{let o=n;const l=qa(r.shape,i);return l.length>0&&(o=er(o,l)),St(Ls(o),r.shape)}}}},{kernelName:ot,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,i=r.shape.slice(),{axis:s}=e;ar(s,r.shape).forEach(p=>{i[p]=1});const o=St(n,i),l=_t(o,ul(r.shape,"float32"));return{x:()=>l}}},{kernelName:gu,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ur(n,Nr(Zp(e)))}}},{kernelName:vs,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>_t(Hn(mr(1),Nr(e)),n)}}},{kernelName:ps,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{reps:i}=e;return{x:()=>{let a=di(r);if(1===r.rank)for(let o=0;o<i[0];++o)a=gn(a,li(n,[o*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let o=0;o<i[0];++o)for(let l=0;l<i[1];++l)a=gn(a,li(n,[o*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let o=0;o<i[0];++o)for(let l=0;l<i[1];++l)for(let p=0;p<i[2];++p)a=gn(a,li(n,[o*r.shape[0],l*r.shape[1],p*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let o=0;o<i[0];++o)for(let l=0;l<i[1];++l)for(let p=0;p<i[2];++p)for(let g=0;g<i[3];++g)a=gn(a,li(n,[o*r.shape[0],l*r.shape[1],p*r.shape[2],g*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return a}}}},{kernelName:Wl,gradFunc:(n,t,e)=>{const r=e,{perm:i}=r,s=Ch(i);return{x:()=>ui(n,s)}}},{kernelName:Hs,gradFunc:(n,t,e)=>{const r=e,{axis:i}=r;return{value:()=>Wu(n,i)}}},{kernelName:nf,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>function ME(n,t){const e=cf(t,di(t)),r=up(n,e);let i=Kf(t,mr(0,"int32"));const s=r.rank-i.rank;for(let o=0;o<s;++o)i=tu(i,o+1);i=Jl(i,ul(r.shape,"bool"));const a=di(r);return xo(i,r,a)}(n,e)}}},{kernelName:mh,gradFunc:n=>({x:()=>di(n)})}];for(const n of TO)Sl(n);Jt().prototype.abs=function(){return this.throwIfDisposed(),Ra(this)},Jt().prototype.acos=function(){return this.throwIfDisposed(),Bv(this)},Jt().prototype.acosh=function(){return this.throwIfDisposed(),zv(this)},Jt().prototype.add=function(n){return this.throwIfDisposed(),gn(this,n)},Jt().prototype.all=function(n,t){return this.throwIfDisposed(),zg(this,n,t)},Jt().prototype.any=function(n,t){return this.throwIfDisposed(),om(this,n,t)},Jt().prototype.argMax=function(n){return this.throwIfDisposed(),wh(this,n)},Jt().prototype.argMin=function(n){return this.throwIfDisposed(),Vv(this,n)},Jt().prototype.asScalar=function(){return this.throwIfDisposed(),K(1===this.size,()=>"The array must have only 1 element."),St(this,[])},Jt().prototype.asType=function(n){return this.throwIfDisposed(),_n(this,n)},Jt().prototype.as1D=function(){return this.throwIfDisposed(),St(this,[this.size])},Jt().prototype.as2D=function(n,t){return this.throwIfDisposed(),St(this,[n,t])},Jt().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),St(this,[n,t,e])},Jt().prototype.as4D=function(n,t,e,r){return this.throwIfDisposed(),St(this,[n,t,e,r])},Jt().prototype.as5D=function(n,t,e,r,i){return this.throwIfDisposed(),St(this,[n,t,e,r,i])},Jt().prototype.asin=function(){return this.throwIfDisposed(),Gv(this)},Jt().prototype.asinh=function(){return this.throwIfDisposed(),Ug(this)},Jt().prototype.atan=function(){return this.throwIfDisposed(),Vg(this)},Jt().prototype.atan2=function(n){return this.throwIfDisposed(),qv(this,n)},Jt().prototype.atanh=function(){return this.throwIfDisposed(),Gg(this)},Jt().prototype.avgPool=function(n,t,e,r){return this.throwIfDisposed(),Xp(this,n,t,e,r)},Jt().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),cm(this,n,t)},Jt().prototype.batchNorm=function(n,t,e,r,i){return this.throwIfDisposed(),Kp(this,n,t,e,r,i)},Jt().prototype.broadcastTo=function(n){return this.throwIfDisposed(),sp(this,n)},Jt().prototype.cast=function(n){return this.throwIfDisposed(),_n(this,n)},Jt().prototype.ceil=function(){return this.throwIfDisposed(),Qv(this)},Jt().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),xu(this,n,t)},Jt().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof Xi&&(n=[n]),Da([this,...n],t)},Jt().prototype.conv1d=function(n,t,e,r,i,s){return this.throwIfDisposed(),fm(this,n,t,e,r,i,s)},Jt().prototype.conv2dTranspose=function(n,t,e,r,i){return this.throwIfDisposed(),Kg(this,n,t,e,r,i)},Jt().prototype.conv2d=function(n,t,e,r,i,s){return this.throwIfDisposed(),Xf(this,n,t,e,r,i,s)},Jt().prototype.cos=function(){return this.throwIfDisposed(),Zp(this)},Jt().prototype.cosh=function(){return this.throwIfDisposed(),Yg(this)},Jt().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),hm(this,n,t,e)},Jt().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),pm(this,n,t,e)},Jt().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),a1(this,n,t)},Jt().prototype.depthwiseConv2d=function(n,t,e,r,i,s){return this.throwIfDisposed(),ap(this,n,t,e,r,i,s)},Jt().prototype.dilation2d=function(n,t,e,r,i){return this.throwIfDisposed(),o1(this,n,t,e,r,i)},Jt().prototype.divNoNan=function(n){return this.throwIfDisposed(),u1(this,n)},Jt().prototype.div=function(n){return this.throwIfDisposed(),ur(this,n)},Jt().prototype.dot=function(n){return this.throwIfDisposed(),l1(this,n)},Jt().prototype.elu=function(){return this.throwIfDisposed(),jp(this)},Jt().prototype.equal=function(n){return this.throwIfDisposed(),zu(this,n)},Jt().prototype.erf=function(){return this.throwIfDisposed(),f1(this)},Jt().prototype.euclideanNorm=function(n,t){return this.throwIfDisposed(),d1(this,n,t)},Jt().prototype.exp=function(){return this.throwIfDisposed(),Uu(this)},Jt().prototype.expandDims=function(n){return this.throwIfDisposed(),tu(this,n)},Jt().prototype.expm1=function(){return this.throwIfDisposed(),m1(this)},Jt().prototype.fft=function(){return this.throwIfDisposed(),ad(this)},Jt().prototype.flatten=function(){return this.throwIfDisposed(),St(this,[this.size])},Jt().prototype.floor=function(){return this.throwIfDisposed(),Qp(this)},Jt().prototype.floorDiv=function(n){return this.throwIfDisposed(),Rg(this,n)},Jt().prototype.gather=function(n,t,e){return this.throwIfDisposed(),up(this,n,t,e)},Jt().prototype.greaterEqual=function(n){return this.throwIfDisposed(),Kf(this,n)},Jt().prototype.greater=function(n){return this.throwIfDisposed(),bu(this,n)},Jt().prototype.ifft=function(){return this.throwIfDisposed(),od(this)},Jt().prototype.irfft=function(){return this.throwIfDisposed(),v0(this)},Jt().prototype.isFinite=function(){return this.throwIfDisposed(),Qg(this)},Jt().prototype.isInf=function(){return this.throwIfDisposed(),g1(this)},Jt().prototype.isNaN=function(){return this.throwIfDisposed(),y1(this)},Jt().prototype.leakyRelu=function(n){return this.throwIfDisposed(),ed(this,n)},Jt().prototype.lessEqual=function(n){return this.throwIfDisposed(),Ah(this,n)},Jt().prototype.less=function(n){return this.throwIfDisposed(),td(this,n)},Jt().prototype.localResponseNormalization=function(n,t,e,r){return this.throwIfDisposed(),v1(this,n,t,e,r)},Jt().prototype.logSigmoid=function(){return this.throwIfDisposed(),x1(this)},Jt().prototype.logSoftmax=function(n){return this.throwIfDisposed(),cp(this,n)},Jt().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),e0(this,n,t)},Jt().prototype.log=function(){return this.throwIfDisposed(),ol(this)},Jt().prototype.log1p=function(){return this.throwIfDisposed(),Vu(this)},Jt().prototype.logicalAnd=function(n){return this.throwIfDisposed(),Jl(this,n)},Jt().prototype.logicalNot=function(){return this.throwIfDisposed(),Pa(this)},Jt().prototype.logicalOr=function(n){return this.throwIfDisposed(),t0(this,n)},Jt().prototype.logicalXor=function(n){return this.throwIfDisposed(),b1(this,n)},Jt().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),ni(this,n,t,e)},Jt().prototype.maxPool=function(n,t,e,r){return this.throwIfDisposed(),mm(this,n,t,e,r)},Jt().prototype.max=function(n,t){return this.throwIfDisposed(),Il(this,n,t)},Jt().prototype.maximum=function(n){return this.throwIfDisposed(),cf(this,n)},Jt().prototype.mean=function(n,t){return this.throwIfDisposed(),ra(this,n,t)},Jt().prototype.min=function(n,t){return this.throwIfDisposed(),op(this,n,t)},Jt().prototype.minimum=function(n){return this.throwIfDisposed(),Th(this,n)},Jt().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),nN(this,n,t)},Jt().prototype.mod=function(n){return this.throwIfDisposed(),w1(this,n)},Jt().prototype.mul=function(n){return this.throwIfDisposed(),_t(this,n)},Jt().prototype.neg=function(){return this.throwIfDisposed(),Ls(this)},Jt().prototype.norm=function(n,t,e){return this.throwIfDisposed(),Jp(this,n,t,e)},Jt().prototype.notEqual=function(n){return this.throwIfDisposed(),fp(this,n)},Jt().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),ip(this,n,t,e)},Jt().prototype.onesLike=function(){return this.throwIfDisposed(),qu(this)},Jt().prototype.pad=function(n,t){return this.throwIfDisposed(),Yf(this,n,t)},Jt().prototype.pool=function(n,t,e,r,i,s){return this.throwIfDisposed(),_1(this,n,t,e,r,i,s)},Jt().prototype.pow=function(n){return this.throwIfDisposed(),lf(this,n)},Jt().prototype.prelu=function(n){return this.throwIfDisposed(),nd(this,n)},Jt().prototype.prod=function(n,t){return this.throwIfDisposed(),N1(this,n,t)},Jt().prototype.reciprocal=function(){return this.throwIfDisposed(),a0(this)},Jt().prototype.relu=function(){return this.throwIfDisposed(),Rc(this)},Jt().prototype.relu6=function(){return this.throwIfDisposed(),o0(this)},Jt().prototype.reshapeAs=function(n){return this.throwIfDisposed(),St(this,n.shape)},Jt().prototype.reshape=function(n){return this.throwIfDisposed(),St(this,n)},Jt().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),q1(this,n,t,e)},Jt().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),oS(this,n,t,e)},Jt().prototype.reverse=function(n){return this.throwIfDisposed(),Ql(this,n)},Jt().prototype.rfft=function(){return this.throwIfDisposed(),bm(this)},Jt().prototype.round=function(){return this.throwIfDisposed(),u0(this)},Jt().prototype.rsqrt=function(){return this.throwIfDisposed(),vm(this)},Jt().prototype.selu=function(){return this.throwIfDisposed(),l0(this)},Jt().prototype.separableConv2d=function(n,t,e,r,i,s){return this.throwIfDisposed(),c0(this,n,t,e,r,i,s)},Jt().prototype.sigmoid=function(){return this.throwIfDisposed(),Tc(this)},Jt().prototype.sign=function(){return this.throwIfDisposed(),h0(this)},Jt().prototype.sin=function(){return this.throwIfDisposed(),p0(this)},Jt().prototype.sinh=function(){return this.throwIfDisposed(),m0(this)},Jt().prototype.slice=function(n,t){return this.throwIfDisposed(),li(this,n,t)},Jt().prototype.softmax=function(n){return this.throwIfDisposed(),xm(this,n)},Jt().prototype.softplus=function(){return this.throwIfDisposed(),lp(this)},Jt().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),ym(this,n,t)},Jt().prototype.split=function(n,t){return this.throwIfDisposed(),_u(this,n,t)},Jt().prototype.sqrt=function(){return this.throwIfDisposed(),zo(this)},Jt().prototype.square=function(){return this.throwIfDisposed(),Nr(this)},Jt().prototype.squaredDifference=function(n){return this.throwIfDisposed(),x0(this,n)},Jt().prototype.squeeze=function(n){return this.throwIfDisposed(),Zf(this,n)},Jt().prototype.stack=function(n,t){this.throwIfDisposed();const e=n instanceof Xi?[this,n]:[this,...n];return Wu(e,t)},Jt().prototype.step=function(n){return this.throwIfDisposed(),dp(this,n)},Jt().prototype.stridedSlice=function(n,t,e,r,i,s,a,o){return this.throwIfDisposed(),MN(this,n,t,e,r,i,s,a,o)},Jt().prototype.sub=function(n){return this.throwIfDisposed(),Hn(this,n)},Jt().prototype.sum=function(n,t){return this.throwIfDisposed(),er(this,n,t)},Jt().prototype.tan=function(){return this.throwIfDisposed(),R1(this)},Jt().prototype.tanh=function(){return this.throwIfDisposed(),Ih(this)},Jt().prototype.tile=function(n){return this.throwIfDisposed(),Cl(this,n)},Jt().prototype.toBool=function(){return this.throwIfDisposed(),_n(this,"bool")},Jt().prototype.toFloat=function(){return this.throwIfDisposed(),_n(this,"float32")},Jt().prototype.toInt=function(){return this.throwIfDisposed(),_n(this,"int32")},Jt().prototype.topk=function(n,t){return this.throwIfDisposed(),b0(this,n,t)},Jt().prototype.transpose=function(n){return this.throwIfDisposed(),ui(this,n)},Jt().prototype.unique=function(n){return this.throwIfDisposed(),D1(this,n)},Jt().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),wm(this,n,t)},Jt().prototype.unstack=function(n){return this.throwIfDisposed(),Al(this,n)},Jt().prototype.where=function(n,t){return this.throwIfDisposed(),xo(n,this,t)},Jt().prototype.zerosLike=function(){return this.throwIfDisposed(),di(this)};class Oc extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Oc.prototype)}}class rc extends Error{constructor(t){super(t),Object.setPrototypeOf(this,rc.prototype)}}class It extends Error{constructor(t){super(t),Object.setPrototypeOf(this,It.prototype)}}class qr extends Error{constructor(t){super(t),Object.setPrototypeOf(this,qr.prototype)}}class xx extends Error{constructor(t){super(t),Object.setPrototypeOf(this,xx.prototype)}}class RE extends Error{constructor(t){super(t),Object.setPrototypeOf(this,RE.prototype)}}class Sn{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=t}}function ds(n,t){if(Array.isArray(n)){let e=[];for(let r=0;r<t;r++)e=e.concat(n);return e}{const e=new Array(t);return e.fill(n),e}}function ic(n,t){if(!n)throw new xx(t)}function MO(n,t){let e=0;for(const r of n)r===t&&e++;return e}function ll(n){return 1===n.length?n[0]:n}function us(n){return Array.isArray(n)?n:[n]}function Dh(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function dd(n){return n.length<=1||-1===n.indexOf("_")?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let kc={};function Mm(n){if(null==n)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function DE(n){if(null!=n&&"object"==typeof n)if(Array.isArray(n))n.forEach(t=>DE(t));else{const t=Object.keys(n);for(const e of t){const r=n[e];null!=r&&"object"==typeof r&&(Array.isArray(r)||"ndarray"!==r.type||"number"!=typeof r.value?DE(r):n[e]=r.value)}}}function B0(n,t={},e={},r="object",i=!1){if("string"==typeof n){let a;if(n in e)a=e[n];else if(n in kc)a=kc[n];else if(a=t[n],null==a)throw new It(`Unknown ${r}: ${n}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{const s=n;if(null==s.className||null==s.config)throw new It(`${r}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);const a=s.className;let o,l;if(a in e?[o,l]=e[a]:a in kc?[o,l]=kc.className:a in t&&([o,l]=t[a]),null==o)throw new It(`Unknown ${r}: ${a}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const p={};for(const N of Object.keys(kc))p[N]=kc[N];for(const N of Object.keys(e))p[N]=e[N];s.config.customObjects=p;const v=Object.assign({},kc);for(const N of Object.keys(e))kc[N]=e[N];DE(s.config);const w=l(o,s.config,e,i);return kc=Object.assign({},v),w}{const p=Object.assign({},kc);for(const v of Object.keys(e))kc[v]=e[v];const g=new o(s.config);return kc=Object.assign({},p),g}}}function bx(n,t){return-1*function n3(n,t){return n<t?-1:n>t?1:0}(n,t)}function gp(n){if(null==n)return n;const t=[];for(const e of n)-1===t.indexOf(e)&&t.push(e);return t}function RO(n){if(null==n)throw new It(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function md(n,t,e){if(null!=e&&n.indexOf(e)<0)throw new It(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function OE(n,t,e=0,r=1/0){return ic(e>=0),ic(r>=e),Array.isArray(n)&&n.length>=e&&n.length<=r&&n.every(i=>typeof i===t)}function pr(n,t){Array.isArray(n)?(K(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,r)=>pr(e,`element ${r+1} of ${t}`))):K(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${DO(n)}.`)}function DO(n){return null===n?"null":Array.isArray(n)?"["+n.map(t=>DO(t)).join(",")+"]":"string"==typeof n?`"${n}"`:`${n}`}function OO(n){return"relu"===n?"relu":"linear"===n?"linear":"elu"===n?"elu":null}let i3=0;function Et(){return i3++}const z0={};function wx(n=""){return n in z0||(z0[n]=0),z0[n]+=1,n+z0[n].toString()}const sc=["channelsFirst","channelsLast"],s3=["nearest","bilinear"],a3=["valid","same","causal"],o3=["max","avg"],wo=["sum","mul","concat","ave"],Rm=new Map;function Ha(n){md(sc,"DataFormat",n)}function ac(n){md(a3,"PaddingMode",n)}function Dm(n){md(o3,"PoolMode",n)}const U0=[],PO="/";function gd(n,t){U0.push(n);try{const e=t();return U0.pop(),e}catch(e){throw U0.pop(),e}}function V0(n){if(!FO(n))throw new Error("Not a valid tensor name: '"+n+"'");return function _x(){return 0===U0.length?"":U0.join(PO)+PO}()+n}function yd(n){if(!FO(n))throw new Error("Not a valid tensor name: '"+n+"'");Rm.has(n)||Rm.set(n,0);const t=Rm.get(n);if(Rm.set(n,Rm.get(n)+1),t>0){const e=`${n}_${t}`;return Rm.set(e,1),e}return n}const u3=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function FO(n){return!!n.match(u3)}function l3(n){return n===parseInt(n.toString(),10)}function yp(n,t,e){null==t&&(t=0),null==e&&(e=n.length);let r=1;for(let i=t;i<e;++i)r*=n[i];return r}function si(n){if(0===n.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const r=n[e];r<t&&(t=r)}return t}function vp(n){if(0===n.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const r=n[e];r>t&&(t=r)}return t}function cl(n,t){if(t<n)throw new It(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let r=n;r<t;++r)e.push(r);return e}let Nx;function _o(){return null==Nx&&(Nx=pv().epsilon()),Nx}function Qf(n,t){return _n(n,t)}function q0(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),St(n,e)}function oc(n,t,e){return Lt(()=>{switch(n.rank){case 1:return g0(n,t,e);case 2:return y0(n,[t,0],[e,n.shape[1]]);case 3:return id(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return sd(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return li(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return li(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new It(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function PE(n,t,e){return Lt(()=>{switch(n.rank){case 1:return g0(n,t,e);case 2:return y0(n,[0,t],[n.shape[0],e]);case 3:return id(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return sd(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new It(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Sx(n,t,e,r){return Lt(()=>{switch(n.rank){case 1:return g0(n,t,e);case 2:switch(r){case 1:return oc(n,t,e);case 2:return PE(n,t,e);default:throw new It(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return oc(n,t,e);case 2:return id(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return PE(n,t,e);default:throw new It(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return oc(n,t,e);case 2:return sd(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return sd(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return PE(n,t,e);default:throw new It(`The axis is not within the rank of the tensor ${r}`)}default:throw new It(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function FE(n,t=-1){let e;return t<0&&(e=n[0].rank,t=0!==e?e:0),t===n[0].rank&&(t=-1),Da(n,t)}function zO(n,t){switch(n.rank){case 1:return Hg([n,t]);case 2:return t1([n,t],0);case 3:return Xg([n,t],0);case 4:return n1([n,t],0);default:throw new It(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function Ex(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new It(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return Cl(n,t)}function Ix(n,t=0,e=1,r,i){return s0(n,t,e,r,i)}function gf(n,t,e,r){if(n.rank<2||t.rank<2)throw new qr(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3&&n.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new qr(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`);if(2===n.rank&&2===t.rank)return z1({a:n,b:t,transposeA:!1,transposeB:!1,bias:r?LE(n.rank,r,"channelsLast"):null,activation:e});{const i=n.shape.slice(),s=i.pop();n=St(n,[-1,s]);const a=t.shape.slice(),o=a.pop(),l=a.pop(),p=[...a,o],g=Array.from({length:t.rank},(D,O)=>0===O?t.rank-2:O<=t.rank-2?O-1:O);t=St(ui(t,g),[l,-1]);const v=[...i,...p];return St(z1({a:n,b:t,transposeA:!1,transposeB:!1,bias:r?LE(n.rank,r,"channelsLast"):null,activation:e}),v)}}function VO(n,t,e){return Lt(()=>(t=Array.isArray(t)?bo(t,"int32"):_n(t,"int32"),up(n,t,e)))}function W0(n){return _t(n,n)}function LE(n,t,e){const r=t.shape;if(1!==t.rank&&t.rank!==n)throw new It(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(5===n){if("channelsFirst"===e)return St(t,1===r.length?[1,r[0],1,1,1]:[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===e)return St(t,1===r.length?[1,1,1,1,r[0]]:[1].concat(r))}else if(4===n){if("channelsFirst"===e)return St(t,1===r.length?[1,r[0],1,1]:[1,r[2],r[0],r[1]]);if("channelsLast"===e)return St(t,1===r.length?[1,1,1,r[0]]:[1].concat(r))}else if(3===n){if("channelsFirst"===e)return St(t,1===r.length?[1,r[0],1]:[1,r[1],r[0]]);if("channelsLast"===e)return St(t,1===r.length?[1,1,r[0]]:[1].concat(r))}else if(n<3)return t;throw new It(`Unsupported input rank by biasAdd: ${t.rank}`)}function yf(n,t,e){return Lt(()=>(null==e&&(e="channelsLast"),Ha(e),gn(n,LE(n.rank,t,e))))}function $E(n,t,e,r){return Lt(()=>N0(n,t,e,r))}function H0(n,t,e=!1){return e?n():t()}const m3=["fanIn","fanOut","fanAvg"],BE=["normal","uniform","truncatedNormal"];class Pc extends xh{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}let GO=(()=>{class n extends Pc{apply(e,r){return Wa(e,r)}}return n.className="Zeros",n})();yn(GO);let zE=(()=>{class n extends Pc{apply(e,r){return ul(e,r)}}return n.className="Ones",n})();yn(zE);let qO=(()=>{class n extends Pc{constructor(e){if(super(),"object"!=typeof e)throw new It(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new It(`config must have value set but got ${e}`);this.value=e.value}apply(e,r){return Lt(()=>_t(mr(this.value),ul(e,r)))}getConfig(){return{value:this.value}}}return n.className="Constant",n})();yn(qO);let Oh=(()=>{class n extends Pc{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,r){return Mh(e,this.minval,this.maxval,r,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return n.className="RandomUniform",n})();yn(Oh);let WO=(()=>{class n extends Pc{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new qr(`randomNormal does not support dType ${r}.`);return Ix(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="RandomNormal",n})();yn(WO);let eh=(()=>{class n extends Pc{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new qr(`truncatedNormal does not support dType ${r}.`);return w0(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="TruncatedNormal",n})();yn(eh);let HO=(()=>{class n extends Pc{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,r){return Lt(()=>{if(2!==e.length||e[0]!==e[1])throw new It("Identity matrix initializer can only be used for 2D square matrices.");return _t(this.gain,Jg(e[0]))})}getConfig(){return{gain:this.gain}}}return n.className="Identity",n})();yn(HO);let Hu=(()=>{class n extends Pc{constructor(e){if(super(),e.scale<0)throw new It(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,function Cx(n){md(m3,"FanMode",n)}(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,function g3(n){md(BE,"Distribution",n)}(this.distribution),this.seed=e.seed}apply(e,r){const i=function y3(n,t="channelsLast"){let e,r;if(Ha(t),2===n.length)e=n[0],r=n[1];else if(-1!==[3,4,5].indexOf(n.length)){if("channelsFirst"===t){const i=yp(n,2);e=n[1]*i,r=n[0]*i}else if("channelsLast"===t){const i=yp(n,0,n.length-2);e=n[n.length-2]*i,r=n[n.length-1]*i}}else{const i=yp(n);e=Math.sqrt(i),r=Math.sqrt(i)}return[e,r]}(e),s=i[0],a=i[1];let o=this.scale;if(o/="fanIn"===this.mode?Math.max(1,s):"fanOut"===this.mode?Math.max(1,a):Math.max(1,(s+a)/2),"normal"===this.distribution){const l=Math.sqrt(o);if("float32"!==(r=r||"float32")&&"int32"!==r)throw new qr(`${this.getClassName()} does not support dType ${r}.`);return w0(e,0,l,r,this.seed)}{const l=Math.sqrt(3*o);return Mh(e,-l,l,r,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return n.className="VarianceScaling",n})();yn(Hu);let kh=(()=>{class n extends Hu{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Hu.className}}return n.className="GlorotUniform",n})();yn(kh);let Dn=(()=>{class n extends Hu{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Hu.className}}return n.className="GlorotNormal",n})();yn(Dn);let UE=(()=>{class n extends Hu{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Hu.className}}return n.className="HeNormal",n})();yn(UE);let Ax=(()=>{class n extends Hu{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Hu.className}}return n.className="HeUniform",n})();yn(Ax);let VE=(()=>{class n extends Hu{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Hu.className}}return n.className="LeCunNormal",n})();yn(VE);let bp=(()=>{class n extends Hu{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Hu.className}}return n.className="LeCunUniform",n})();yn(bp);let XO=(()=>{class n extends Pc{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,r){return Lt(()=>{if(e.length<2)throw new qr("Shape must be at least 2D.");if("int32"!==r&&"float32"!==r&&void 0!==r)throw new TypeError(`Unsupported data type ${r}.`);const i=ft(e.slice(0,-1)),s=e[e.length-1],a=i*s;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);const l=Ix([Math.max(s,i),Math.min(s,i)],0,1,r,this.seed),p=H1.qr(l,!1);let g=p[0];const w=p[1].flatten().stridedSlice([0],[Math.min(s,i)*Math.min(s,i)],[Math.min(s,i)+1]);return g=_t(g,w.sign()),i<s&&(g=g.transpose()),_t(mr(this.gain),g.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}return n.className="Orthogonal",n})();yn(XO);const GE={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function KO(n,t={}){return B0(n,El.getMap().classNameMap,t,"initializer")}function mi(n){return Mm(n)}function ts(n){if("string"==typeof n){const t=n in GE?GE[n]:n;if("GlorotNormal"===t)return new Dn;if("GlorotUniform"===t)return new kh;if("HeNormal"===t)return new UE;if("HeUniform"===t)return new Ax;if("LeCunNormal"===t)return new VE;if("LeCunUniform"===t)return new bp;{const e={};return e.className=t,e.config={},KO(e)}}return n instanceof Pc?n:KO(n)}function qE(n){return Array.isArray(n)&&Array.isArray(n[0])}function uc(n){return 0===n.length?[]:Array.isArray(n[0])?n:[n]}function tr(n){let t;if(Array.isArray(n)){if(1!==n.length)throw new It(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function ns(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(1===n.length)return n[0];throw new It(`Expected exactly 1 Shape; got ${n.length}`)}return n}function Om(n){let t=0;for(const e of n)t+=0===e.shape.length?1:e.shape.reduce((r,i)=>r*i);return t}const WE="Variable";class So{constructor(t,e="float32",r=WE,i=!0,s=null){this.dtype=e??"float32",this.shape=t.shape,this.id=Et(),this.originalName=V0(r=r??WE),this.name=yd(this.originalName),this.trainable_=i,this.constraint=s,this.val=k1(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function v3(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function Tx(n){return n.map(t=>t.read())}function xd(n){n.forEach(t=>{t[0].write(t[1])})}class oo{constructor(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null!=t.shape?t.shape.length:t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class vf{constructor(t,e,r,i,s,a,o){this.dtype=t,this.shape=e,this.sourceLayer=r,this.inputs=i,this.callArgs=s,this.outputTensorIndex=o,this.id=Et(),null!=a&&(this.originalName=V0(a),this.name=yd(this.originalName)),this.rank=e.length}}let w3=0;class Mx{constructor(t,e){this.callArgs=e,this.id=w3++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const r of t.inboundLayers)r?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)t.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let XE=0;class ai extends xh{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=XE++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const r=this.getClassName();e=Dh(r)+"_"+wx(r)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let r;if(null!=t.batchInputShape)r=t.batchInputShape;else if(null!=t.inputShape){let s=null;null!=t.batchSize&&(s=t.batchSize),r=[s].concat(t.inputShape)}this.batchInputShape=r;let i=t.dtype;null==i&&(i=t.inputDType),null==i&&(i="float32"),this.dtype=i}this.initialWeights=null!=t.weights?t.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new rc(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new It(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return ll(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return ll(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Oc(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Oc(`Layer ${this.name} is not connected, no input to return.`);return ll(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Oc(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Oc(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return ll(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=us(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=us(this.inputSpec);if(t.length!==e.length)throw new It(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let r=0;r<t.length;r++){const i=t[r],s=e[r];if(null==s)continue;const a=i.rank;if(null!=s.ndim&&a!==s.ndim)throw new It(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${a}`);if(null!=s.maxNDim&&a>s.maxNDim)throw new It(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${a}`);if(null!=s.minNDim&&a<s.minNDim)throw new It(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${a}.`);if(null!=s.dtype&&i.dtype!==s.dtype)throw new It(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${i.dtype}.`);if(s.axes){const o=i.shape;for(const l in s.axes){const p=Number(l),g=s.axes[l];if(null!=g&&-1===[g,null].indexOf(p>=0?o[p]:o[o.length+p]))throw new It(`Input ${r} is incompatible with layer ${this.name}: expected axis ${p} of input shape to have value ${g} but got shape ${o}.`)}}if(null!=s.shape)for(let o=0;o<s.shape.length;++o){const l=s.shape[o],p=i.shape[o];if(null!=l&&null!=p&&l!==p)throw new It(`Input ${r} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${i.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const r=us(t);let i=!0;for(const a of r)if(!(a instanceof vf)){i=!1;break}let s=!0;for(const a of r)if(a instanceof vf){s=!1;break}if(i===s)throw new It("Arguments to apply() must be all SymbolicTensors or all Tensors");return gd(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const a=[];for(const o of us(t))a.push(o.shape);this.build(ll(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&s&&(this._refCount=1)}if(this.assertInputCompatibility(t),s){let a=this.call(t,e);const o=us(a),l=[];for(let p of o)-1!==r.indexOf(p)&&(p=p.clone()),l.push(p);if(a=ll(l),null!=this.activityRegularizer)throw new qr("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}{const a=function jO(n){n=us(n);const t=[];for(const e of n)t.push(e.shape);return ll(t)}(t),o=this.computeOutputShape(a);let l;const p="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?a[0]:a),l=null!=o&&o.length>0&&Array.isArray(o[0])?o.map((g,v)=>new vf(p,g,this,us(t),e,this.name,v)):new vf(p,o,this,us(t),e,this.name),this.addInboundNode(t,l,null,null,a,o,e),this._refCount++,null!=this.activityRegularizer)throw new qr("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((r,i)=>{null!=r&&null!=t[i]&&t[i]!==r&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Oc(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const r=JSON.stringify(e.outputShapes);-1===t.indexOf(r)&&t.push(r)}if(1===t.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Oc(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new rc(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Om(this.weights)}build(t){this.built=!0}getWeights(t=!1){return Tx(t?this.trainableWeights:this.weights)}setWeights(t){Lt(()=>{const e=this.weights;if(e.length!==t.length)throw new It(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const r=[],i=Tx(e);for(let s=0;s<i.length;++s){const a=i[s],o=e[s],l=t[s];if(!Kt(a.shape,l.shape))throw new It(`Layer weight shape ${a.shape} not compatible with provided weight shape ${l.shape}`);r.push([o,l])}xd(r)})}addWeight(t,e,r,i,s,a,o,l){if(-1!==this._addedWeightNames.indexOf(t))throw new It(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==r&&(r="float32"),this.fastWeightInitDuringBuild&&(i=null!=l?l():ts("zeros"));const p=i.apply(e,r),g=new So(p,r,t,a,o);return p.dispose(),null!=s&&this.addLoss(()=>s.apply(g.read())),null==a&&(a=!0),a?this._trainableWeights.push(g):this._nonTrainableWeights.push(g),g}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=us(t),null!=this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(r=>{if(null!=r)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(t,e,r,i,s,a,o=null){const l=us(t);e=us(e),r=us(r),i=us(i),s=uc(s),a=uc(a);const p=[],g=[],v=[];for(const w of l)p.push(w.sourceLayer),g.push(w.nodeIndex),v.push(w.tensorIndex);new Mx({outboundLayer:this,inboundLayers:p,nodeIndices:g,tensorIndices:v,inputTensors:l,outputTensors:e,inputMasks:r,outputMasks:i,inputShapes:s,outputShapes:a},o);for(let w=0;w<e.length;w++)e[w].sourceLayer=this,e[w].nodeIndex=this.inboundNodes.length-1,e[w].tensorIndex=w}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function QO(n,t,e){if((null==t||null!=e&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),0===t.inboundNodes.length)return[n];{const r=t.inboundNodes[e];if(0===r.inboundLayers.length)return r.inputTensors;{const i=[];for(let s=0;s<r.inboundLayers.length;s++){const p=QO(r.inputTensors[s],r.inboundLayers[s],r.nodeIndices[s]);for(const g of p)-1===i.indexOf(g)&&i.push(g)}return i}}}let K0=(()=>{class n extends ai{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:wx("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new It("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let r=e.batchInputShape;if(null==r){if(null==e.inputShape)throw new It("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new It("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const i=e.dtype||"float32";this.batchInputShape=r,this.dtype=i,this.inputSpec=[{shape:r}];const s=new vf(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new Mx({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]})}apply(e,r){throw new It(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return n.className="InputLayer",n})();function ek(n){if(null==n.batchShape&&null==n.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=n.batchShape&&null!=n.shape)throw new It("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;null!=n.shape&&null==t&&(t=[null].concat(n.shape));let e=n.dtype;return null==e&&(e="float32"),new K0({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}yn(K0);class th{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof th)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,r){if(null!=this.id2Value[t.id])throw new It(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function _3(n,t){if(null==n.dtype||n.dtype===t.dtype)return t;try{return _n(t,n.dtype)}catch{throw new It(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=r&&(this.id2Mask[t.id]=r),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof vf){if(null==this.id2Value[t.id])throw new It(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new It(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof vf){if(null==this.id2Value[t.id])throw new It(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new It(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&Lr(this.id2Mask)}}const Rx=new Sn,Dx=new Sn;function Pm(n,t,e,r){const i=null!=e&&e.training,s=Array.isArray(n),a=s?n:[n],o=a.map(D=>D.name),l=[],p=t.names();for(const D of o)-1!==p.indexOf(D)?l.push(t.getValue(D)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const g=o.join(",")+"|"+t.names().sort().join(",");let w,v=Rx.get(g);if(null==v){const D=function N3(n,t){K(null!=n&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],r={};if(1===n.length){const i=tk(n[0],t);e=i.sorted,r=i.recipientMap}else{const i=new Set;for(const s of n){const{sorted:a,recipientMap:o}=tk(s,t);for(const l of a)i.has(l.name)||(e.push(l),i.add(l.name));for(const l in o)null==r[l]&&(r[l]=new Set),o[l].forEach(p=>r[l].add(p))}}return{sorted:e,recipientCounts:KE(r)}}(a,t);v=D.sorted,w=D.recipientCounts,Rx.put(g,v),Dx.put(g,w)}w={},i||Object.assign(w,Dx.get(g));const N=new th(t);for(let D=0;D<v.length;++D){if(null!=r){const ge=tm().numTensors;ge>r.maxNumTensors&&(r.maxNumTensors=ge),ge<r.minNumTensors&&(r.minNumTensors=ge)}const O=v[D],k=O.sourceLayer;if(k instanceof K0)continue;const L=[],$=[],U=[];let V=!1;for(const ge of O.inputs){const it=N.getValue(ge),ut=N.getMask(ge);L.push(it),$.push(ut),null!=ut&&(V=!0),i||(w[ge.name]--,0===w[ge.name]&&!t.hasKey(ge)&&-1===o.indexOf(ge.name)&&!it.isDisposed&&!0!==ge.sourceLayer.stateful&&U.push(it))}V&&((e=e||{}).mask=$[0]);const W=us(k.apply(L,e));let ce=null;k.supportsMasking&&(ce=k.computeMask(L,$));const ve=Nu(O),Ee=Array.isArray(ve)?ve:[ve];for(let ge=0;ge<Ee.length;++ge){N.hasKey(Ee[ge])||N.add(Ee[ge],W[ge],Array.isArray(ce)?ce[0]:ce);const it=o.indexOf(Ee[ge].name);-1!==it&&(l[it]=W[ge])}i||Lr(U)}return N.disposeMasks(),s?l:l[0]}function KE(n){const t={};for(const e in n)t[e]=n[e].size;return t}function tk(n,t){const e=new Set,r=[],i={};for(const o of t.names())e.add(o);const s=[],a=[];for(s.push(n);s.length>0;){const o=s[s.length-1];if(e.has(o.name)){s.pop();continue}const l=a[a.length-1]===s.length-1;if(0===o.inputs.length||l)s.pop(),r.push(o),e.add(o.name),l&&a.pop();else{a.push(s.length-1);for(const p of o.inputs)null==i[p.name]&&(i[p.name]=new Set),i[p.name].add(o.name),!e.has(p.name)&&s.push(p)}}return{sorted:r,recipientMap:i}}function Nu(n){let t;if(1===n.sourceLayer.inboundNodes.length)t=n.sourceLayer.output;else{let e=null;for(let r=0;r<n.sourceLayer.inboundNodes.length;++r)for(const i of n.sourceLayer.inboundNodes[r].outputTensors)if(i.id===n.id){e=r;break}t=n.sourceLayer.getOutputAt(e)}return t}function YE(n,t){return Lt(()=>zo(er(_t(n,n),t,!0)))}Pt().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function Ox(n){Rx?.setMaxEntries(n),Dx?.setMaxEntries(n)});class Y0 extends xh{getConfig(){return{}}}let xf=(()=>{class n extends Y0{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Lt(()=>{const r=YE(e,this.axis),i=xu(r,0,this.maxValue);return _t(e,ur(i,gn(_o(),r)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return n.className="MaxNorm",n})();yn(xf);let nk=(()=>{class n extends Y0{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Lt(()=>ur(e,gn(_o(),YE(e,this.axis))))}getConfig(){return{axis:this.axis}}}return n.className="UnitNorm",n})();yn(nk);let ZE=(()=>{class n extends Y0{apply(e){return Rc(e)}}return n.className="NonNeg",n})();yn(ZE);let rk=(()=>{class n extends Y0{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Lt(()=>{const r=YE(e,this.axis),i=gn(_t(this.rate,xu(r,this.minValue,this.maxValue)),_t(1-this.rate,r));return _t(e,ur(i,gn(_o(),r)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return n.className="MinMaxNorm",n})();yn(rk);const Z0={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Eo(n){return Mm(n)}function jE(n,t={}){return B0(n,El.getMap().classNameMap,t,"constraint")}function ha(n){return null==n?null:"string"==typeof n?jE({className:n in Z0?Z0[n]:n,config:{}}):n instanceof Y0?n:jE(n)}function S3(n){return new xf(n)}function nh(n){return new nk(n)}function JE(){return new ZE}function E3(n){return new rk(n)}function I3(){return new GO}function ru(){return new zE}function ik(n){return new qO(n)}function QE(n){return new Oh(n)}function C3(n){return new WO(n)}function A3(n){return new eh(n)}function sk(n){return new HO(n)}function ak(n){return new Hu(n)}function T3(n){return new kh(n)}function ok(n){return new Dn(n)}function M3(n){return new UE(n)}function uk(n){return new Ax(n)}function R3(n){return new VE(n)}function D3(n){return new bp(n)}function lk(n){return new XO(n)}function wp(n){return eI.apply(this,arguments)}function eI(){return(eI=(0,Qe.Z)(function*(n){if(null==n)return;const t=[],e=[],r=[];for(const i in n){const s=n[i];if("number"!=typeof s){const a=s;t.push(a.data()),e.push(i),r.push(a)}}if(t.length>0){const i=yield Promise.all(t);for(let s=0;s<i.length;++s)n[e[s]]=i[s][0];Lr(r)}})).apply(this,arguments)}function tI(n){if(null!=n)for(const t in n){const e=n[t];"number"!=typeof e&&e.dispose()}}class iu{constructor(){this.validationData=null}setParams(t){this.params=t}onEpochBegin(t,e){return(0,Qe.Z)(function*(){})()}onEpochEnd(t,e){return(0,Qe.Z)(function*(){})()}onBatchBegin(t,e){return(0,Qe.Z)(function*(){})()}onBatchEnd(t,e){return(0,Qe.Z)(function*(){})()}onTrainBegin(t){return(0,Qe.Z)(function*(){})()}onTrainEnd(t){return(0,Qe.Z)(function*(){})()}setModel(t){}}class fk{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}onEpochBegin(t,e){var r=this;return(0,Qe.Z)(function*(){null==e&&(e={});for(const i of r.callbacks)yield i.onEpochBegin(t,e)})()}onEpochEnd(t,e){var r=this;return(0,Qe.Z)(function*(){null==e&&(e={});for(const i of r.callbacks)yield i.onEpochEnd(t,e)})()}onBatchBegin(t,e){var r=this;return(0,Qe.Z)(function*(){null==e&&(e={});for(const i of r.callbacks)yield i.onBatchBegin(t,e)})()}onBatchEnd(t,e){var r=this;return(0,Qe.Z)(function*(){null==e&&(e={});for(const i of r.callbacks)yield i.onBatchEnd(t,e)})()}onTrainBegin(t){var e=this;return(0,Qe.Z)(function*(){null==t&&(t={});for(const r of e.callbacks)yield r.onTrainBegin(t)})()}onTrainEnd(t){var e=this;return(0,Qe.Z)(function*(){null==t&&(t={});for(const r of e.callbacks)yield r.onTrainEnd(t)})()}}class k3 extends iu{constructor(){super()}onEpochBegin(t){var e=this;return(0,Qe.Z)(function*(){e.seen=0,e.totals={}})()}onBatchEnd(t,e){var r=this;return(0,Qe.Z)(function*(){null==e&&(e={});const i=null==e.size?0:e.size;r.seen+=i;for(const s in e){const a=e[s];if("number"==typeof a)r.totals.hasOwnProperty(s)||(r.totals[s]=0),r.totals[s]=r.totals[s]+a*i;else{let o;s in r.totals?o=r.totals[s]:r.totals[s]=0;const l=Lt(()=>gn(r.totals[s],_t(a,i)));r.totals[s]=l,o?.dispose()}}})()}onEpochEnd(t,e){var r=this;return(0,Qe.Z)(function*(){if(null!=e)for(const i of r.params.metrics)null!=r.totals[i]&&("number"==typeof r.totals[i]?e[i]=r.totals[i]/r.seen:Lt(()=>{const s=_t(ur(1,r.seen),r.totals[i]);e[i]=s,r.totals[i].dispose(),so(e[i])}))})()}}class hk extends iu{onTrainBegin(t){var e=this;return(0,Qe.Z)(function*(){e.epoch=[],e.history={}})()}onEpochEnd(t,e){var r=this;return(0,Qe.Z)(function*(){null==e&&(e={}),r.epoch.push(t);for(const i in e)null==r.history[i]&&(r.history[i]=[]),r.history[i].push(e[i])})()}syncData(){var t=this;return(0,Qe.Z)(function*(){const e=[],r=[],i=[];for(const a in t.history){const o=t.history[a];for(let l=0;l<o.length;++l)"number"!=typeof o[l]&&(e.push(o[l].data()),r.push(a),i.push(l))}const s=yield Promise.all(e);for(let a=0;a<s.length;++a)t.history[r[a]][i[a]].dispose(),t.history[r[a]][i[a]]=s[a][0]})()}}class nI extends iu{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||K1,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");fu(this.yieldEvery)&&(this.maybeWait=function r3(n,t,e){let i,r=null!=e?e():Fs();return(...a)=>{const o=null!=e?e():Fs();return o-r<t||(r=o,i=n(...a)),i}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}maybeWait(t,e,r){var i=this;return(0,Qe.Z)(function*(){const s=[];null!=i.yield&&(yield wp(r),s.push(i.yield(t,e,r))),s.push(i.nextFrameFunc()),yield Promise.all(s)})()}onEpochBegin(t,e){var r=this;return(0,Qe.Z)(function*(){r.currentEpoch=t,null!=r.epochBegin&&(yield wp(e),yield r.epochBegin(t,e))})()}onEpochEnd(t,e){var r=this;return(0,Qe.Z)(function*(){const i=[];null!=r.epochEnd&&(yield wp(e),i.push(r.epochEnd(t,e))),"epoch"===r.yieldEvery&&i.push(r.nextFrameFunc()),yield Promise.all(i)})()}onBatchBegin(t,e){var r=this;return(0,Qe.Z)(function*(){null!=r.batchBegin&&(yield wp(e),yield r.batchBegin(t,e))})()}onBatchEnd(t,e){var r=this;return(0,Qe.Z)(function*(){const i=[];null!=r.batchEnd&&(yield wp(e),i.push(r.batchEnd(t,e))),"batch"===r.yieldEvery?i.push(r.nextFrameFunc()):fu(r.yieldEvery)&&i.push(r.maybeWait(r.currentEpoch,t,e)),yield Promise.all(i)})()}onTrainBegin(t){var e=this;return(0,Qe.Z)(function*(){null!=e.trainBegin&&(yield wp(t),yield e.trainBegin(t))})()}onTrainEnd(t){var e=this;return(0,Qe.Z)(function*(){null!=e.trainEnd&&(yield wp(t),yield e.trainEnd(t))})()}}function j0(n,t){return null==n&&(n={}),n instanceof iu?[n]:Array.isArray(n)&&n[0]instanceof iu?n:us(n).map(r=>new nI(r,t))}let pk=(()=>{class n{constructor(){}static registerCallbackConstructor(e,r){K(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),n.checkForDuplicate(r),null==n.constructors[e]&&(n.constructors[e]=[]),n.constructors[e].push(r)}static checkForDuplicate(e){for(const r in n.constructors)n.constructors[+r].forEach(s=>{if(s===e)throw new It("Duplicate callback constructor.")})}static clear(){n.constructors={}}static createCallbacks(e){const r=[];for(const i in n.constructors){const s=+i;e>=s&&r.push(...n.constructors[s])}return r.map(i=>new i)}}return n.constructors={},n})();function dk(n,t,e,r,i,s,a,o,l){const p=new hk,g=[new k3,...pk.createCallbacks(t)];null!=n&&g.push(...n),g.push(p);const v=new fk(g);return v.setParams({epochs:e,initialEpoch:r,samples:i,steps:s,batchSize:a,verbose:t,doValidation:o,metrics:l}),{callbackList:v,history:p}}function bf(n,t={},e=!1){return B0(n,El.getMap().classNameMap,t,"layer",e)}function kx(n,t){return Lt(()=>{"float32"!==n.dtype&&(n=_n(n,"float32"));const e=er(W0(n),t,!0),r=tp(e.shape,_o()),i=zo(cf(e,r));return ur(n,i)})}function bd(n,t){return Lt(()=>ra(W0(Hn(t,n)),-1))}function Px(n,t){return Lt(()=>ra(Ra(Hn(t,n)),-1))}function wd(n,t){return Lt(()=>{const e=Hn(n,t),r=xu(Ra(n),_o(),Number.MAX_VALUE),i=Ra(ur(e,r));return _t(100,ra(i,-1))})}function J0(n,t,e=!1){return Lt(()=>{if(e)t=xm(t);else{const r=er(t,t.shape.length-1,!0);t=ur(t,r)}return t=xu(t,_o(),1-_o()),Ls(er(_t(_n(n,"float32"),ol(t)),t.shape.length-1))})}function Q0(n,t,e=!1){return Lt(()=>{const r=_n(Qp(function Xa(n){const t=[yp(n.shape)];return St(n,t)}(n)),"int32"),i=(t=xu(t,_o(),1-_o())).shape;return J0(St(ip(r,i[i.length-1]),i),t,e)})}function Ar(n,t){return Lt(()=>{let e;return e=xu(t,_o(),1-_o()),e=ol(ur(e,Hn(1,e))),ra(function L3(n,t){if(!Kt(n.shape,t.shape))throw new It(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return Lt(()=>{const e=Rc(t),r=Ls(Ra(t));return gn(Hn(e,_t(t,n)),Vu(Uu(r)))})}(n,e),-1)})}function rI(n,t){return Lt(()=>{const e=kx(n,-1),r=kx(t,-1),i=_t(e,r);return Ls(er(i,-1))})}const ey={meanSquaredError:bd,meanAbsoluteError:Px,meanAbsolutePercentageError:wd,meanSquaredLogarithmicError:function P3(n,t){return Lt(()=>{const e=xu(t,_o(),Number.MAX_VALUE),r=ol(gn(1,e)),i=xu(n,_o(),Number.MAX_VALUE),s=ol(gn(1,i));return ra(W0(Hn(r,s)),-1)})},squaredHinge:function _d(n,t){return Lt(()=>{const e=cf(0,Hn(1,_t(n,t)));return ra(W0(e),-1)})},hinge:function F3(n,t){return Lt(()=>{const e=cf(0,Hn(1,_t(n,t)));return ra(e,-1)})},categoricalHinge:function Fm(n,t){return Lt(()=>{const e=er(_t(n,t),-1),r=Il(_t(Hn(1,n),t),-1);return cf(0,gn(1,Hn(r,e)))})},logcosh:function mk(n,t){return Lt(()=>{const e=Math.log(2),r=Hn(t,n),i=Hn(gn(r,lp(_t(-2,r))),e);return ra(i,-1)})},categoricalCrossentropy:J0,sparseCategoricalCrossentropy:Q0,binaryCrossentropy:Ar,kullbackLeiblerDivergence:function $3(n,t){return Lt(()=>{const e=xu(n,_o(),1),r=xu(t,_o(),1);return er(_t(n,ol(ur(e,r))),-1)})},poisson:function B3(n,t){return Lt(()=>{const e=ol(gn(_o(),t));return ra(Hn(t,_t(n,e)),-1)})},cosineProximity:rI};function iI(n){if("string"==typeof n){if(n in ey)return ey[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new It(t)}return n}function sI(n,t){return Lt(()=>{const e=_t(.5,qu(t)),r=Qf(bu(t,e),n.dtype);return ra(zu(n,r),-1)})}function aI(n,t){return Lt(()=>Qf(zu(wh(n,-1),wh(t,-1)),"float32"))}function gk(n,t){return Lt(()=>_n(er(Jl(zu(n,1),zu(t,1))),"float32"))}function yk(n,t){return Lt(()=>{const e=gk(n,t),r=function U3(n,t){return Lt(()=>_n(er(Jl(zu(n,0),zu(t,1))),"float32"))}(n,t),i=gn(e,r);return _n(xo(bu(i,0),ur(e,i),0),"float32")})}function vk(n,t){return Ar(n,t)}function xk(n,t){return n.rank===t.rank&&(n=Zf(n,[n.rank-1])),(t=wh(t,-1)).dtype!==n.dtype&&(t=_n(t,n.dtype)),_n(zu(n,t),"float32")}const oI=J0,wk=Q0,Fx={binaryAccuracy:sI,categoricalAccuracy:aI,precision:yk,categoricalCrossentropy:oI,sparseCategoricalCrossentropy:wk,mse:bd,MSE:bd,mae:Px,MAE:Px,mape:wd,MAPE:wd,cosine:rI};function Lm(n){if("string"==typeof n&&n in Fx)return Fx[n];if("string"!=typeof n&&null!=n)return n;throw new It(`Unknown metric ${n}`)}function Lx(n){if(ic(null!==n,`Unknown LossOrMetricFn ${n}`),"string"==typeof n)return n;{let t;for(const e of Object.keys(ey))if(ey[e]===n){t=e;break}if(void 0!==t)return t;for(const e of Object.keys(Fx))if(Fx[e]===n){t=e;break}return void 0!==t?t:n.name}}const _k=1048576;function Nk(n,t,e=!1){if(null==n||"object"!=typeof n||Object.getPrototypeOf(n)!==Object.prototype||!Bx(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const r=JSON.stringify(n);r.length>_k&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${_k}.`)}}function Bx(n){if(null===n)return!0;if("object"==typeof n){if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if("string"!=typeof e||!Bx(n[e]))return!1;return!0}if(Array.isArray(n)){for(const t of n)if(!Bx(t))return!1;return!0}return!1}{const t=typeof n;return"string"===t||"number"===t||"boolean"===t}}function zx(n,t,e=console.log){let r="";for(let i=0;i<n.length;++i)i>0&&(r=r.slice(0,r.length-1)+" "),r+=n[i],r=r.slice(0,t[i]),r+=" ".repeat(t[i]-r.length);e(r)}function J3(n,t,e){let r,i;try{i=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}zx([`${n.name} (${n.getClassName()})`,i,r,n.countParams().toString()],t,e)}function Q3(n,t,e,r){let i,s;try{s=n.inboundNodes.map(v=>JSON.stringify(v.inputShapes)).join(",")}catch{s="multiple"}try{i=JSON.stringify(n.outputShape)}catch{i="multiple"}const a=[];for(const v of n.inboundNodes)if(!(null!=e&&e.length>0&&-1===e.indexOf(v)))for(let w=0;w<v.inboundLayers.length;++w)a.push(`${v.inboundLayers[w].name}[${v.nodeIndices[w]}][${v.tensorIndices[w]}]`);const o=n.name,l=n.getClassName(),p=0===a.length?"":a[0];zx([`${o} (${l})`,s,i,n.countParams().toString(),p],t,r);for(let v=1;v<a.length;++v)zx(["","","","",a[v]],t,r)}function Sk(n,t,e){return("inboundNodes"===n||"outputLayers"===n||"inputLayers"===n)&&0===t&&"string"==typeof e}function $m(n,t){if(null===n)return null;if("string"==typeof n)return dd(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],r=n.length;for(let i=0;i<r;++i){const s=n[i];Sk(t,i,s)?e.push(s):e.push($m(s,t))}return e}{const e={};for(const r of Object.keys(n)){const i=n[r];if("name"===r&&"string"==typeof i)e[r]=i;else{const s=dd(r);e[s]=$m(i,s)}}return e}}function uI(n,t){if(null==n)return null;if("string"==typeof n)return Dh(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],r=n.length;for(let i=0;i<r;++i){const s=n[i];Sk(t,i,s)?e.push(s):e.push(uI(s,t))}return e}{const e={};for(const r of Object.keys(n)){const i=n[r];e[Dh(r)]="name"!==r&&"className"!==r||"string"!=typeof i?uI(i,r):i}return e}}const Ux="4.4.0";class Fc extends ai{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const $=this.getClassName().toLowerCase();this.name=wx($)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],gp(this.inputs).length!==this.inputs.length)throw new It(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map($=>$.name)}`);gp(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map($=>$.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const $ of this.outputs){const V=$.nodeIndex,W=$.tensorIndex;this.outputLayers.push($.sourceLayer),this.outputLayersNodeIndices.push(V),this.outputLayersTensorIndices.push(W)}for(const $ of this.inputs){const U=$.sourceLayer,V=$.nodeIndex,W=$.tensorIndex;ic(0===V,"input layer has >1 nodes"),ic(0===W,"input layer has >1 tensors"),this.inputLayers.push(U),this.inputLayersNodeIndices.push(V),this.inputLayersTensorIndices.push(W)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let $=0;$<this.inputLayers.length;$++){const U=this.inputLayers[$];if(!(U instanceof K0))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${$} (0-based) originates from layer type ${U.getClassName()}.`);this.inputNames.push(U.name),this.feedInputShapes.push(U.batchInputShape),this.feedInputNames.push(U.name)}for(const $ of this.outputLayers)this.outputNames.push($.name);this.internalInputShapes=this.inputs.map($=>$.shape),this.internalOutputShapes=this.outputs.map($=>$.shape);const e={},r={},i={},s={},a={},o=[],l=($,U,V,W,ce,ve)=>{(null==W||null==ce||null==ve)&&(W=$.sourceLayer,ce=$.nodeIndex,ve=$.tensorIndex);const Ee=W.inboundNodes[ce];if(-1!==V.indexOf(Ee))throw new rc(`The tensor ${$.name} at layer "${W.name}" is part of a cycle.`);if(-1!==U.indexOf(Ee))return;this.containerNodes.add(Fc.nodeKey(W,ce)),W.id in a||(a[W.id]=Object.keys(a).length),-1===V.indexOf(Ee)&&V.push(Ee);const ge=Ee.inboundLayers.length;for(let it=0;it<ge;it++)l(Ee.inputTensors[it],U,V,Ee.inboundLayers[it],Ee.nodeIndices[it],Ee.tensorIndices[it]);for(U.push(Ee);V.indexOf(Ee)>=0;)V.splice(V.indexOf(Ee),1);o.push(Ee)},p=[],g=[];for(const $ of this.outputs)l($,p,g);const v=o.slice().reverse();for(const $ of v){r[$.id]=$,$.id in e||(e[$.id]=0);let U=e[$.id];U=Math.max(U,null==i[$.outboundLayer.id]?0:i[$.outboundLayer.id]),i[$.outboundLayer.id]=U,s[$.outboundLayer.id]=$.outboundLayer,e[$.id]=U;for(let W=0;W<$.inboundLayers.length;W++){const Ee=$.inboundLayers[W].inboundNodes[$.nodeIndices[W]];e[Ee.id]=Math.max(U+1,null==e[Ee.id]?0:e[Ee.id]),r[Ee.id]=Ee}}const w={};for(const $ in e){const U=e[$];U in w||(w[U]=[]),w[U].push(r[$])}const N={};for(const $ in i){const U=i[$];U in N||(N[U]=[]),N[U].push(s[$])}let D=Object.keys(N).map($=>parseInt($,10)).sort(bx);this.layers=[];for(const $ of D){const U=N[$];U.sort((V,W)=>{const ce=a[V.id],ve=a[W.id];return ce<ve?-1:ce>ve?1:0});for(const V of U)V instanceof Fc&&this.internalContainerRefs.push(V),this.layers.push(V)}this.layersByDepth=N,D=Object.keys(w).map($=>parseInt($,10)).sort(bx);const O=this.inputs.slice(),k=[];for(const $ of D)for(const U of w[$]){const V=U.outboundLayer;if(null!=V){for(const W of U.inputTensors)if(-1===O.indexOf(W))throw new rc(`Graph disconnected: cannot obtain value for tensor ${W} at layer "${V.name}". The following previous layers were accessed without issue: ${k}`);for(const W of U.outputTensors)O.push(W);k.push(V.name)}}this.nodesByDepth=w;const L=this.layers.map($=>$.name);for(const $ of L){const U=L.filter(V=>V===$).length;if(1!==U)throw new rc(`The name "${$}" is used ${U} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(L))}this.outboundNodes=[],this.inboundNodes=[],new Mx({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map($=>null),outputMasks:this.outputs.map($=>null),inputShapes:this.inputs.map($=>$.shape),outputShapes:this.outputs.map($=>$.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new It("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const r of this.layers)e.push(...r.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const r={};let i=0;for(const a of this.layers)for(const o of a.weights){if(null!=r[o.originalName])throw new It(`Duplicate weight name: ${o.originalName}`);r[o.originalName]=o,i++}const s=[];for(const a in t){let o=a;if(null==r[a]){const l=a.split("/");o=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(null!=r[o])s.push([r[o],t[a]]);else if(e)throw new It(`Provided weight data has no target variable: ${a}`);delete r[o]}if(e){const a=[];for(const o in r)a.push(o);if(a.length>0)throw new It(`${a.length} of ${i} weights are not set: ${a}`)}xd(s)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${Ux}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){const r=uI(this.updatedConfig());return e?JSON.stringify(r):r}call(t,e){return Lt(()=>{t=us(t);const r=new th;for(let i=0;i<this.inputs.length;++i)r.add(this.inputs[i],t[i]);return Pm(this.outputs,r,e)})}computeMask(t,e){return Lt(()=>{let r;return t=us(t),r=null==e?ds(null,t.length):us(e),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){const e=uc(t);if(e.length!==this.inputLayers.length)throw new It(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let o=0;o<e.length;o++)r[this.inputLayers[o].name+"_0_0"]=e[o];const i=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(bx);if(i.length>1)for(const o of i){const l=this.nodesByDepth[o];for(const p of l){const g=p.outboundLayer;if(-1!==this.inputLayers.map(O=>O.id).indexOf(g.id))continue;const v=[];for(let O=0;O<p.inboundLayers.length;O++)v.push(r[`${p.inboundLayers[O].name}_${p.nodeIndices[O]}_${p.tensorIndices[O]}`]);const N=uc(g.computeOutputShape(ll(v))),D=g.inboundNodes.indexOf(p);for(let O=0;O<N.length;O++)r[`${g.name}_${D}_${O}`]=N[O]}}const s=[],a=[];for(let o=0;o<this.outputLayers.length;o++)a.push(`${this.outputLayers[o].name}_${this.outputLayersNodeIndices[o]}_${this.outputLayersTensorIndices[o]}`);for(let o=0;o<a.length;o++){const l=a[o];ic(l in r),s.push(r[l])}return ll(s)}runInternalGraph(t,e){null==e&&(e=ds(null,t.length));const r={};for(let l=0;l<this.inputs.length;++l)r[this.inputs[l].id]=[t[l],e[l]];const i=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(bx);for(const l of i){const p=this.nodesByDepth[l];for(const g of p){const v=g.outboundLayer,w=g.inputTensors,N=g.outputTensors,D=new Array;for(const O of w)O.id in r&&D.push(r[O.id]);if(D.length===w.length){let k,L,$,U,O={};if(null!=g.callArgs&&(O=g.callArgs),1===D.length){const[V,W]=D[0];null==O.mask&&(O.mask=W),$=us(v.call(V,O)),U=us(v.computeMask(V,W)),k=[V],L=[W]}else k=D.map(V=>V[0]),L=D.map(V=>V[1]),null==O.mask&&(O.mask=L),$=us(v.call(k,O)),U=us(v.computeMask(k,L));if(v.activityRegularizer)throw new qr("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let V=0;V<N.length;++V)r[N[V].id]=[$[V],U[V]]}}}const s=[],a=[],o=[];for(const l of this.outputs){ic(l.id in r,`Could not compute output ${l.name} : ${l.id}`);const[p,g]=r[l.id];o.push(p.shape),s.push(p),a.push(g)}return[s,a,o]}buildNodeConversionMap(t){const e={};let r;for(const i of this.layers){r=i instanceof Fc?1:0;for(let s=0;s<i.inboundNodes.length;s++){const a=Fc.nodeKey(i,s);this.containerNodes.has(a)&&(e[a]=r,r+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new It(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==t)throw new It("Provide either a layer name or layer index");for(const r of this.layers)if(r.name===t)return r;throw new It(`No such layer: ${t}`)}calculateLosses(){return Lt(()=>{const t=[];for(const e of this.layers)for(let r=0;r<e.inboundNodes.length;++r){const i=Fc.nodeKey(e,r);this.containerNodes.has(i)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),r=[];for(const a of this.layers){const o=a.getClassName(),l=a.getConfig(),p=[];for(let v=0;v<a.inboundNodes.length;v++){const w=a.inboundNodes[v],N=Fc.nodeKey(a,v);let D={};if(this.containerNodes.has(N)){if(w.callArgs)try{JSON.stringify(w.callArgs),D=w.callArgs}catch{console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${w.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),D={}}if(w.inboundLayers.length>0){const O=[];for(let k=0;k<w.inboundLayers.length;k++){const L=w.inboundLayers[k],U=w.tensorIndices[k];let W=e[Fc.nodeKey(L,w.nodeIndices[k])];null==W&&(W=0),O.push([L.name,W,U,D])}p.push(O)}}}const g={};g.name=a.name,g.className=o,g.config=l,g.inboundNodes=p,r.push(g)}t.layers=r;const i=[];for(let a=0;a<this.inputLayers.length;a++){const o=this.inputLayers[a],p=Fc.nodeKey(o,this.inputLayersNodeIndices[a]);if(!this.containerNodes.has(p))continue;let g=e[p];null==g&&(g=0),i.push([o.name,g,this.inputLayersTensorIndices[a]])}t.inputLayers=i;const s=[];for(let a=0;a<this.outputLayers.length;a++){const o=this.outputLayers[a],p=Fc.nodeKey(o,this.outputLayersNodeIndices[a]);if(!this.containerNodes.has(p))continue;let g=e[p];null==g&&(g=0),s.push([o.name,g,this.outputLayersTensorIndices[a]])}return t.outputLayers=s,t}static fromConfig(t,e,r={},i=!1){const s={},a={};function o(k,L){k.name in a?a[k.name].push(L):a[k.name]=[L]}function l(k,L){const $=[];let U;for(const V of L){const W=V[0],ce=V[1],ve=V[2];if(U=null==V[3]?{}:V[3],!(W in s))return void o(k,L);const Ee=s[W];if(Ee.inboundNodes.length<=ce)return void o(k,L);$.push(Ee.inboundNodes[ce].outputTensors[ve])}$.length>0&&k.apply(ll($),U)}function p(k){const L=k.name,$=bf(k,null!=e.customObjects?e.customObjects:{});$.setFastWeightInitDuringBuild(i),s[L]=$,k.inboundNodes.forEach(V=>{if(!(V instanceof Array))throw new It(`Corrupted configuration, expected array for nodeData: ${V}`);o($,V)})}const g=e.name,v=e.layers;for(const k of v)p(k);for(;!RO(a);)for(const k of v){const L=s[k.name];if(L.name in a){const $=a[L.name];delete a[L.name];for(const U of $)l(L,U)}}const w=[],N=[],D=e.inputLayers;for(const k of D){const L=k[0],$=k[1],U=k[2];ic(L in s),w.push(s[L].inboundNodes[$].outputTensors[U])}const O=e.outputLayers;for(const k of O){const L=k[0],$=k[1],U=k[2];ic(L in s),N.push(s[L].inboundNodes[$].outputTensors[U])}return new t({inputs:w,outputs:N,name:g})}get stateful(){if(this._stateful)throw new It("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){Lt(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function Ik(n,t){return function Ek(n,t,e){const r=t.length;if(null==n||Array.isArray(n)&&0===n.length)return t.map(i=>null);if(1===r)return Array.isArray(n)&&1===n.length?n:"object"==typeof n&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==r)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return n}if("object"==typeof n&&Object.keys(n).length>0&&"object"==typeof n[Object.keys(n)[0]]){const i=[];return t.forEach(s=>{i.push(s in n?n[s]:null)}),i}throw new Error(`The model has multiple (${r}) outputs, so ${e} must be either an array with ${r} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}(n,t,"classWeight")}function Ck(n,t,e,r){return Vx.apply(this,arguments)}function Vx(){return(Vx=(0,Qe.Z)(function*(n,t,e,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=e){const i=Lt(()=>{if(1===n.shape.length)return Ic(n);if(2===n.shape.length){if(n.shape[1]>1)return wh(n,1);if(1===n.shape[1])return St(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(yield i.data());Lr(i);const a=[];return s.forEach(o=>{if(null==e[o])throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);a.push(e[o])}),bo(a,"float32")}return null})).apply(this,arguments)}function e$(n,t){return _t(n,t)}const t$=32;function ty(n,t){let e,r;e=t.xs,r=t.ys,K(null!=e&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const s=Ak("input",n.inputNames,e),a=Ak("output",n.outputNames,r),o=s[0].shape[0];K(s.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),K(a.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<s.length;l++)K(s[l].shape[0]===o,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);for(let l=0;l<a.length;l++)K(a[l].shape[0]===o,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);return{xs:s,ys:a}}function Ak(n,t,e){if(e instanceof Xi)return[e];if(Array.isArray(e))return K(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const r=[];for(const i of t){if(null==e[i])throw new It(`The feature data generated by the dataset lacks the required ${n} key '${i}'.`);r.push(e[i])}return r}}function Gx(){return(Gx=(0,Qe.Z)(function*(n,t,e){const r=null!=e.batchesPerEpoch;if(K(null!=n.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),K(null!=e,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),K(null!=e.epochs&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),K(!r||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),K(null==e.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const i=null!=e.validationData;let s,a;if(i)if(lI(e.validationData))K(null==e.validationBatches||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const k=function Tk(n){if(3===n.length)throw new qr("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}(e.validationData);s=k.xs,a=k.ys}const o=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let p;p=i?l.slice().concat(l.map(k=>"val_"+k)):l.slice();const g=j0(e.callbacks,e.yieldEvery),v=null==e.verbose?1:e.verbose,{callbackList:w,history:N}=dk(g,v,e.epochs,null,null,function r$(n,t){let e=null;return null!=t.batchesPerEpoch?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}(t,e),null,i,p);w.setModel(n),n.history=N,yield w.onTrainBegin(),n.stopTraining_=!1;let D=null==e.initialEpoch?0:e.initialEpoch,O=yield t.iterator();for(;D<e.epochs;){const k={};yield w.onEpochBegin(D);let L=0,$=0;for(r||(O=yield t.iterator());!r||L<e.batchesPerEpoch;){const U=yield O.next();if(r&&U.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${L} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=U.value){const{xs:V,ys:W}=ty(n,U.value),ce={};ce.batch=$,ce.size=V[0].shape[0],yield w.onBatchBegin($,ce);const ve=[];if(null!=e.classWeight){const it=Ik(e.classWeight,n.outputNames);for(let ut=0;ut<it.length;++ut)ve.push(yield Ck(W[ut],null,it[ut]))}const Ee=V.concat(W).concat(ve),ge=o(Ee);Lr(Ee);for(let it=0;it<l.length;++it){const Mt=ge[it];ce[l[it]]=Mt,so(Mt)}yield w.onBatchEnd($,ce),tI(ce),$++,L++}if(r?L>=e.batchesPerEpoch:U.done){if(i){let V;V=lI(e.validationData)?us(yield n.evaluateDataset(e.validationData,{batches:e.validationBatches})):us(n.evaluate(s,a,{batchSize:null==e.validationBatchSize?t$:e.validationBatchSize,verbose:0}));for(let W=0;W<n.metricsNames.length;++W)k[`val_${n.metricsNames[W]}`]=V[W]}break}if(n.stopTraining_)break}if(yield w.onEpochEnd(D,k),D++,n.stopTraining_)break}return yield w.onTrainEnd(),yield n.history.syncData(),n.history}finally{n.isTraining=!1}})).apply(this,arguments)}function lI(n){return"function"==typeof n.iterator}function cI(){return(cI=(0,Qe.Z)(function*(n,t,e){const r=null!=(e=e||{}).batches,i=n.testFunction;let s=[];if(e.verbose>0)throw new qr("Verbose mode is not implemented yet.");K(!r||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const a=function i$(n){return"function"==typeof n.next}(t)?t:yield t.iterator();let o=0,l=0;for(;!r||l<e.batches;){const p=yield a.next();if(s=Lt(()=>{if(p.value){const{xs:g,ys:v}=ty(n,p.value),w=g.concat(v),N=Lt(()=>i(w));if(Lr(w),0===l)for(let O=0;O<N.length;++O)s.push(mr(0));const D=w[0].shape[0];for(let O=0;O<N.length;++O){const k=N[O],L=s[O];s[O]=Lt(()=>gn(s[O],_t(D,k))),l>0&&Lr(L)}Lr(N),o+=D,++l}return s}),p.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let p=0;p<s.length;++p){const g=s[p];s[p]=ur(s[p],o),Lr(g)}return ll(s)})).apply(this,arguments)}function fI(n){K(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Bm(n,t,e){return null==n?[null]:Array.isArray(n)?n.map(r=>oc(r,t,e-t)):oc(n,t,e-t)}function hI(n,t){return Lt(()=>null==n?null:Array.isArray(n)?n.map(e=>hI(e,t)):VO(n,"int32"===t.dtype?t:_n(t,"int32")))}function pI(n,t){const e=[];let r=0,i=null;for(;r<n;)i=r+t,i>=n&&(i=n),e.push([r,i]),r=i;return e}function dI(n){const t=[];n instanceof Xi&&(n=[n]);for(let e=0;e<n.length;++e){const r=n[e];if(1===r.rank)t.push(q0(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function pa(n,t){if(null==n)return;const e=[];if(t instanceof Xi)e.push(t.id);else if(Array.isArray(t))t.forEach(i=>e.push(i.id));else if(null!=t)for(const i in t)e.push(t[i].id);const r=[];if(n instanceof Xi)-1===e.indexOf(n.id)&&r.push(n);else if(Array.isArray(n))n.forEach(i=>{-1===e.indexOf(i.id)&&r.push(i)});else if(null!=n)for(const i in n){const s=n[i];-1===e.indexOf(s.id)&&r.push(s)}r.forEach(i=>{i.isDisposed||i.dispose()})}function qx(n){return Array.isArray(n)}function gI(n){return!function mI(n){return n instanceof Xi}(n)&&!qx(n)}function Mk(n,t,e,r=!0,i=""){if(null==t||0===t.length){if(null!=n){let a=!1;if(qx(n)&&n.length>0)a=!0;else if(gI(n)){for(const o in n)if(n.hasOwnProperty(o)){a=!0;break}}else a=!0;if(a)throw new It(`Error when checking model ${i} expected no data, but got ${n}`)}return[]}if(null==n)return t.map(a=>null);let s;if(gI(n)){s=[];for(const a of t){if(null==n[a])throw new It(`No data provided for "${a}". Need data for each key in: ${t}`);s.push(n[a])}}else if(qx(n)){if(n.length!==t.length)throw new It(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);s=n}else{if(t.length>1)throw new It(`The model ${i} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);s=[n]}if(s=dI(s),null!=e)for(let a=0;a<t.length;++a){if(null==e[a])continue;const o=s[a];if(o.shape.length!==e[a].length)throw new It(`Error when checking ${i}: expected ${t[a]} to have ${e[a].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<e[a].length;++l){if(0===l&&!r)continue;const g=e[a][l];if(null!=g&&g>=0&&o.shape[l]!==g)throw new It(`${i} expected a batch of elements where each example has shape [${e[a].slice(1,e[a].length)}] (i.e.,tensor shape [*,${e[a].slice(1,e[a].length)}]) but the ${i} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return s}function Dk(n,t,e,r=!0,i=""){let s;if(Array.isArray(n)){if(n.length!==t.length)throw new It(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);s=n}else{if(t.length>1)throw new It(`The model expects ${t.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);s=[n]}if(null!=e)for(let a=0;a<t.length;++a){if(null==e[a])continue;const o=s[a];if(o.shape.length!==e[a].length)throw new It(`Error when checking ${i}: expected ${t[a]} to have ${e[a].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<e[a].length;++l){if(0===l&&!r)continue;const g=e[a][l];if(null!=g&&g!==o.shape[l])throw new It(`Error when checking ${i}: expected ${t[a]} to have shape ${JSON.stringify(e[a])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}let wf=(()=>{class n extends Fc{constructor(e){super(e),this.isTraining=!1}summary(e,r,i=console.log){if(!this.built)throw new It("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function Y3(n,t,e,r=console.log){const i=function j3(n){let t=!0;const e=[],r=[];for(const i in n.nodesByDepth)e.push(n.nodesByDepth[i]);for(const i of e){if(i.length>1||1===i.length&&i[0].inboundLayers.length>1){t=!1;break}r.push(...i)}if(t)for(const i of n.layers){let s=!1;for(const a of i.inboundNodes)if(-1!==r.indexOf(a)){if(s){t=!1;break}s=!0}if(!t)break}return t}(n),s=["Layer (type)","Input Shape","Output shape","Param #"];let a;if(i?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(g=>Math.floor(t*g))),!i){s.push("Receives inputs"),a=[];for(const g in n.nodesByDepth)a.push(...n.nodesByDepth[g])}r("_".repeat(t)),zx(s,e,r),r("=".repeat(t));const o=n.layers;for(let g=0;g<o.length;++g)i?J3(o[g],e,r):Q3(o[g],e,a,r),r((g===o.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const l=function Z3(n){let t;return t=Om(null!=n.collectedTrainableWeights?n.collectedTrainableWeights:n.trainableWeights),t}(n),p=Om(n.nonTrainableWeights);r(`Total params: ${l+p}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${p}`),r("_".repeat(t))}(this,e,r,i)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function $x(n){const t={Adagrad:()=>mp.adagrad(.01),Adadelta:()=>mp.adadelta(1,.95,_o()),Adam:()=>mp.adam(.001,.9,.999,_o()),Adamax:()=>mp.adamax(.002,.9,.999,_o(),0),RMSProp:()=>mp.rmsprop(.001,.9,0,_o()),SGD:()=>mp.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new It(`Unknown Optimizer ${n}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof uf))throw new It("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let r=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new It(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);r=e.loss.map(l=>iI(l))}else{const o=iI(e.loss);this.outputs.forEach(l=>{r.push(o)})}else{e.loss=e.loss;for(const o in e.loss)if(-1===this.outputNames.indexOf(o))throw new It(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)null==e.loss[o]&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),r.push(iI(e.loss[o]))}this.lossFunctions=r,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const l=this.internalOutputShapes[o];this.feedOutputNames.push(this.outputNames[o]),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[o])}const i=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],gd("loss",()=>{for(let o=0;o<this.outputs.length;++o)-1===i.indexOf(o)&&this.outputs.length>1&&(this.metricsTensors.push([this.lossFunctions[o],o]),this.metricsNames.push(this.outputNames[o]+"_loss"))});const s=function yI(n,t){if(null==n||Array.isArray(n)&&0===n.length)return t.map(r=>[]);let e;if("string"==typeof n||"function"==typeof n)e=[n];else{if(!Array.isArray(n)&&"object"!=typeof n)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);e=n}if(Array.isArray(e))return t.map(r=>e);{const r=[];for(const i of t){let s=e.hasOwnProperty(i)?e[i]:[];Array.isArray(s)||(s=[s]),r.push(s)}return r}}(e.metrics,this.outputNames),a=(o,l,p)=>{this.outputNames.length>1&&(l=this.outputNames[o]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([p,o])};gd("metric",()=>{for(let o=0;o<this.outputs.length;++o)-1===i.indexOf(o)&&(g=>{let w,N,D;for(const O of g){if("string"==typeof O&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(O)){const L=this.internalOutputShapes[o];let $;1===L[L.length-1]||this.lossFunctions[o]===Ar?-1!==["accuracy","acc"].indexOf(O)?N=sI:-1!==["crossentropy","ce"].indexOf(O)&&(N=vk):this.lossFunctions[o]===Q0?-1!==["accuracy","acc"].indexOf(O)?N=xk:-1!==["crossentropy","ce"].indexOf(O)&&(N=wk):-1!==["accuracy","acc"].indexOf(O)?N=aI:-1!==["crossentropy","ce"].indexOf(O)&&(N=oI),-1!==["accuracy","acc"].indexOf(O)?$="acc":-1!==["crossentropy","ce"].indexOf(O)&&($="ce"),D=N,w=""+$}else D=Lm(O),w=""+Lx(O);let k;gd(w,()=>{k=D}),a(o,w,k)}})(s[o])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,r,i={}){const s=null==i.batchSize?32:i.batchSize;fI(s);const o=this.standardizeUserDataXY(e,r,!0,s);try{const l=o[0].concat(o[1]);return this.makeTestFunction(),ll(this.testLoop(this.testFunction,l,s,i.verbose,i.steps))}finally{pa(o[0],e),pa(o[1],r)}}evaluateDataset(e,r){var i=this;return(0,Qe.Z)(function*(){return i.makeTestFunction(),function s$(n,t,e){return cI.apply(this,arguments)}(i,e,r)})()}checkNumSamples(e,r,i,s="steps"){let a;if(null!=i){if(a=null,null!=r)throw new It(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${r}`)}else{if(null==e)throw new It(`Either the input data should have a defined shape, or ${s} shoud be specified.`);a=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return a}execute(e,r){if(Array.isArray(r)&&0===r.length)throw new It("`outputs` is an empty Array, which is not allowed.");const i=Array.isArray(r),a=this.retrieveSymbolicTensors(i?r:[r]),o=new th;if(e instanceof Xi&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new It(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let p=0;p<this.inputs.length;++p)o.add(this.inputs[p],e[p])}else for(const p of this.inputs){const g=e[p.name];if(null==g)throw new It(`No value is provided for the model's input ${p.name}`);o.add(p,g)}const l=Pm(a,o);return i?l:l[0]}retrieveSymbolicTensors(e){const r=ds(null,e.length);let i=e.length;for(const s of this.layers){const a=Array.isArray(s.output)?s.output:[s.output],o=a.map(l=>l.name);for(let l=0;l<e.length;++l){const p=o.indexOf(e[l]);if(-1!==p&&(r[l]=a[p],i--),0===i)break}if(0===i)break}if(i>0){const s=[];throw r.forEach((a,o)=>{null==a&&s.push(e[o])}),new It(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return r}predictLoop(e,r=32,i=!1){return Lt(()=>{const s=this.checkNumSamples(e);if(i)throw new qr("Verbose predictLoop() is not implemented yet.");const a=pI(s,r),o=this.outputs.map(l=>[]);for(let l=0;l<a.length;++l)Lt(()=>{const w=Bm(e,a[l][0],a[l][1]),N=[];if(Array.isArray(w))for(let O=0;O<w.length;++O)N.push({key:this.inputs[O],value:w[O]});else N.push({key:this.inputs[0],value:w});const D=new th(N);return Pm(this.outputs,D)}).forEach((g,v)=>o[v].push(g));return ll(o.map(l=>Da(l,0)))})}predict(e,r={}){const i=dI(e);Dk(i,this.inputNames,this.feedInputShapes,!1);try{const s=null==r.batchSize?32:r.batchSize;return fI(s),this.predictLoop(i,s)}finally{pa(i,e)}}predictOnBatch(e){Dk(e,this.inputNames,this.feedInputShapes,!0);const r=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,r)}standardizeUserDataXY(e,r,i=!0,s){if(null==this.optimizer_)throw new rc("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const a=[];for(let o=0;o<this.feedOutputShapes.length;++o){const l=this.feedOutputShapes[o];a.push(this.feedLossFns[o]===Q0?l.slice(0,l.length-1).concat([1]):l)}if(function Rk(n,t,e){const r=gp(n.map(s=>s.shape[0]));r.sort();const i=gp(t.map(s=>s.shape[0]));if(i.sort(),r.length>1)throw new It(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(s=>s.shape))}`);if(i.length>1)throw new It(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(r.length>0&&i.length>0&&!Kt(r,i))throw new It(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${i[0]} target sample(s).`)}(e=Mk(e,this.feedInputNames,this.feedInputShapes,!1,"input"),r=Mk(r,this.feedOutputNames,a,!1,"target")),function Wx(n,t,e){const r=[bd,Ar,J0];for(let i=0;i<n.length;++i){const s=n[i],a=t[i],o=e[i];if(null!=a){if(a===J0&&1===s.shape[s.shape.length-1])throw new It(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(a)){const l=s.shape.slice(1),p=o.slice(1);for(let g=0;g<l.length;++g){const w=p[g];if(null!=w&&l[g]!==w)throw new It(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(r,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=s&&s>0&&e[0].shape[0]%s!=0)throw new It(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${e[0].shape[0]} sample(s).`);return[e,r]}standardizeUserData(e,r,i,s,a=!0,o){var l=this;return(0,Qe.Z)(function*(){const[p,g]=l.standardizeUserDataXY(e,r,a,o);if(null!=i)throw new Error("sample weight is not supported yet.");let v=null;if(null!=s){const w=Ik(s,l.outputNames);v=[];for(let N=0;N<w.length;++N)v.push(yield Ck(g[N],null,w[N]))}return[p,g,v]})()}testLoop(e,r,i,s=0,a){return Lt(()=>{const o=this.checkNumSamples(r,i,a,"steps"),l=[];if(s>0)throw new qr("Verbose mode is not implemented yet.");if(null!=a)throw new qr("steps mode in testLoop() is not implemented yet");{const p=pI(o,i),g=bo(cl(0,o));for(let v=0;v<p.length;++v){const w=p[v][0],N=p[v][1],D=oc(g,w,N-w),O=hI(r,D),k=e(O);if(0===v)for(let L=0;L<k.length;++L)l.push(mr(0));for(let L=0;L<k.length;++L)l[L]=gn(l[L],_t(N-w,k[L]))}for(let v=0;v<l.length;++v)l[v]=ur(l[v],o)}return l})}getDedupedMetricsNames(){const e=this.metricsNames,r=[];for(let i=0;i<e.length;++i){const s=e[i];let a=s;MO(e,s)>1&&(a+=`_${MO(e.slice(0,i),s)}`),r.push(a)}return r}makeTrainFunction(){return e=>{const r=[],i=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),o=[],p=this.collectedTrainableWeights.map(w=>w.read());return[this.optimizer_.minimize(()=>{const w=[];for(let k=0;k<this.inputs.length;++k)w.push({key:this.inputs[k],value:i[k]});const N=new th(w),D=Pm(this.outputs,N,{training:!0});let O;for(let k=0;k<this.lossFunctions.length;++k){let $=(0,this.lossFunctions[k])(s[k],D[k]);null!=a[k]&&($=e$($,a[k]));const U=ra($);r.push(U),O=0===k?$:gn(O,$)}for(let k=0;k<this.metricsTensors.length;++k){let L;if(this.outputs.length>1&&k<this.outputs.length)L=r[k];else{const U=this.metricsTensors[k][1];L=ra((0,this.metricsTensors[k][0])(s[U],D[U]))}so(L),o.push(L)}return O=ra(O),this.calculateLosses().forEach(k=>{O=gn(O,k)}),O},!0,p)].concat(o)}}makeTestFunction(){this.testFunction=e=>Lt(()=>{const r=[];let i;const s=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let g=0;g<this.inputs.length;++g)o.push({key:this.inputs[g],value:s[g]});const l=new th(o),p=Pm(this.outputs,l);for(let g=0;g<this.lossFunctions.length;++g){const w=ra((0,this.lossFunctions[g])(a[g],p[g]));i=0===g?w:gn(i,w),r.push(i)}for(let g=0;g<this.metricsTensors.length;++g){const w=this.metricsTensors[g][1],N=ra((0,this.metricsTensors[g][0])(a[w],p[w]));r.push(N)}return r})}fit(e,r,i={}){var s=this;return(0,Qe.Z)(function*(){if(s.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let a,o,l,p,g,v,w,N,D;s.isTraining=!0;try{const O=null==i.batchSize?32:i.batchSize;fI(O);const k=!1,L=yield s.standardizeUserData(e,r,i.sampleWeight,i.classWeight,k,O);a=L[0],o=L[1],D=L[2];let U,$=!1;if(null!=i.validationData&&i.validationData.length>0){if($=!0,2!==i.validationData.length)throw 3===i.validationData.length?new qr("validationData including sample weights is not supported yet."):new It(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${i.validationData} is invalid.`);g=i.validationData[0],v=i.validationData[1];const ut=!0,Mt=yield s.standardizeUserData(g,v,null,null,ut,O);w=Mt[0],N=Mt[1],U=w.concat(N)}else if(null!=i.validationSplit&&i.validationSplit>0&&i.validationSplit<1){$=!0;const ut=Math.floor(a[0].shape[0]*(1-i.validationSplit)),Mt=a[0].shape[0];w=Bm(a,ut,Mt),l=a,a=Bm(a,0,ut),N=Bm(o,ut,Mt),p=o,o=Bm(o,0,ut),U=w.concat(N)}else null!=i.validationSteps&&($=!0);const V=a.concat(o).concat(D);s.checkTrainableWeightsConsistency();const W=s.makeTrainFunction(),ce=s.getDedupedMetricsNames();let ve,Ee;$?(s.makeTestFunction(),ve=s.testFunction,Ee=ce.slice().concat(ce.map(ut=>"val_"+ut))):(ve=null,U=[],Ee=ce.slice());const ge=j0(i.callbacks,i.yieldEvery);return yield s.fitLoop(W,V,ce,O,i.epochs,i.verbose,ge,ve,U,i.shuffle,Ee,i.initialEpoch,null,null)}finally{s.isTraining=!1,pa(a,e),pa(o,r),pa(l,e),pa(p,r),pa(w,g),pa(N,v),null!=D&&Lr(D)}})()}fitLoop(e,r,i,s,a,o,l,p,g,v,w,N,D,O){var k=this;return(0,Qe.Z)(function*(){null==s&&(s=32),null==a&&(a=1),null==v&&(v=!0),null==N&&(N=0);let L=!1;if(null!=p&&null!=g&&(L=!0),null!=O&&(L=!0,null==D))throw new It("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const $=k.checkNumSamples(r,s,D,"steps_per_epoch");let U;null!=$&&(U=cl(0,$)),null==o&&(o=1);const{callbackList:V,history:W}=dk(l,o,a,N,$,D,s,L,w);V.setModel(k),k.history=W,yield V.onTrainBegin(),k.stopTraining_=!1;for(let ce=N;ce<a;++ce){yield V.onEpochBegin(ce);const ve={};if(null!=D)throw new qr("stepsPerEpoch mode is not implemented yet.");{if("batch"===v)throw new qr("batch shuffling is not implemneted yet");v&&Tt(U);const Ee=bo(U),ge=pI($,s);for(let it=0;it<ge.length;++it){const ut={};if(yield V.onBatchBegin(it,ut),Lt(()=>{const Mt=ge[it][0],Ot=ge[it][1],vt=oc(Ee,Mt,Ot-Mt);ut.batch=it,ut.size=Ot-Mt;const Rt=hI(r,vt),Dt=e(Rt);for(let Ht=0;Ht<i.length;++Ht){const Wt=Dt[Ht];ut[i[Ht]]=Wt,so(Wt)}if(it===ge.length-1&&L){const Ht=k.testLoop(p,g,s);for(let Bt=0;Bt<i.length;++Bt){const Wt=i[Bt],ln=Ht[Bt];so(ln),ve["val_"+Wt]=ln}}}),yield V.onBatchEnd(it,ut),tI(ut),k.stopTraining_)break}Ee.dispose()}if(yield V.onEpochEnd(ce,ve),k.stopTraining_)break}return yield V.onTrainEnd(),yield k.history.syncData(),k.history})()}fitDataset(e,r){var i=this;return(0,Qe.Z)(function*(){return function n$(n,t,e){return Gx.apply(this,arguments)}(i,e,r)})()}trainOnBatch(e,r){var i=this;return(0,Qe.Z)(function*(){const s=yield i.standardizeUserData(e,r),a=s[0],o=s[1],p=i.makeTrainFunction()(a.concat(o)),g=[];for(const v of p){const w=yield v.data();g.push(w[0])}return Lr(p),pa(s[0],e),pa(s[1],r),ll(g)})()}getNamedWeights(e){const r=[],i=null!=e&&e.trainableOnly,s=i?this.trainableWeights:this.weights,a=this.getWeights(i);for(let o=0;o<s.length;++o)i&&!s[o].trainable||r.push({name:s[o].originalName,tensor:a[o]});return r}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const r=tm().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=r-tm().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=Dh(this.loss);else if(Array.isArray(this.loss)){for(const r of this.loss)if("string"!=typeof r)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(r=>Dh(r))}else{const r=Object.keys(this.loss);e={};const i=this.loss;for(const s of r){if("string"!=typeof i[s])throw new Error("Serialization of non-string loss is not supported.");e[s]=Dh(i[s])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[Dh(Lx(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Dh(Lx(e)));{const e={};for(const r in this.metrics)e[r]=Dh(Lx(this.metrics[r]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const i=bf($m(e.optimizer_config));let s,a;if("string"==typeof e.loss)s=dd(e.loss);else if(Array.isArray(e.loss))s=e.loss.map(o=>dd(o));else if(null!=e.loss){s={};for(const o in e.loss)s[o]=dd(e.loss[o])}if(Array.isArray(e.metrics))a=e.metrics.map(o=>dd(o));else if(null!=e.metrics){a={};for(const o in e.metrics)a[o]=dd(e.metrics[o])}this.compile({loss:s,metrics:a,optimizer:i})}save(e,r){var i=this;return(0,Qe.Z)(function*(){if("string"==typeof e){const v=Kd(e);if(0===v.length)throw new It(`Cannot find any save handlers for URL '${e}'`);if(v.length>1)throw new It(`Found more than one (${v.length}) save handlers for URL '${e}'`);e=v[0]}if(null==e.save)throw new It("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=yield tv(i.getNamedWeights(r)),p={modelTopology:i.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${Ux}`,convertedBy:null};if(null!=r&&r.includeOptimizer&&null!=i.optimizer){p.trainingConfig=i.getTrainingConfig();const v="optimizer",{data:w,specs:N}=yield tv(yield i.optimizer.getWeights(),v);s.specs.push(...N),s.data=Xd([s.data,w])}return null!=i.userDefinedMetadata&&(Nk(i.userDefinedMetadata,i.name,!0),p.userDefinedMetadata=i.userDefinedMetadata),p.weightData=s.data,p.weightSpecs=s.specs,e.save(p)})()}setUserDefinedMetadata(e){Nk(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return n.className="Model",n})();function a$(n,t){return vI.apply(this,arguments)}function vI(){return(vI=(0,Qe.Z)(function*(n,t){"modelTopology"in n||(n={modelTopology:n});let e=n.modelTopology;null!=e.model_config&&(e=e.model_config);const i=bf($m(e),t);if(null!=n.weightsManifest){const s=yield bv(n.weightsManifest,n.pathPrefix,i.weights.map(o=>o.originalName)),a={};for(const o of i.weights)a[o.originalName]=s[o.originalName];i.loadWeights(a),Lr(s)}return i})).apply(this,arguments)}function o$(n,t){return Hx.apply(this,arguments)}function Hx(){return Hx=(0,Qe.Z)(function*(n,t){if(null==t&&(t={}),"string"==typeof n){const e=iv(n,t);if(0===e.length)e.push(im(n,t));else if(e.length>1)throw new It(`Found more than one (${e.length}) load handlers for URL '${n}'`);n=e[0]}return function u$(n,t,e){return zm.apply(this,arguments)}(n,void 0,t)}),Hx.apply(this,arguments)}function zm(){return(zm=(0,Qe.Z)(function*(n,t,e){if(null==e&&(e={}),null==n.load)throw new It("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=yield n.load();let i=r.modelTopology;null!=i.model_config&&(i=i.model_config);const s=null==e.strict||e.strict,a=null!=r.weightData&&null!=r.weightSpecs&&s,o=bf($m(i),t,a),l=r.trainingConfig;if(null!=l&&o.loadTrainingConfig(l),null!=r.userDefinedMetadata&&o.setUserDefinedMetadata(r.userDefinedMetadata),null!=r.weightData){if(null==r.weightSpecs)throw new It("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:p,optimizerWeights:g}=function ny(n,t){const e=nv(n,t),r={},i=[];return t.forEach(s=>{"optimizer"===s.group?i.push({name:s.name,tensor:e[s.name]}):r[s.name]=e[s.name]}),{modelWeights:r,optimizerWeights:i}}(r.weightData,r.weightSpecs);o.loadWeights(p,s),null!=o.optimizer&&g.length>0&&(yield o.optimizer.setWeights(g)),Lr(p),Lr(g.map(v=>v.tensor))}return o})).apply(this,arguments)}yn(wf),yn((()=>{class n extends wf{}return n.className="Functional",n})());let _p=(()=>{class n extends wf{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:wx("sequential_"),null!=e.layers)for(const r of e.layers)this.add(r)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(i=>i<0))throw new It(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const r=e instanceof n||e instanceof wf;let i;if(r){if(i=e,1!==i.outputs.length)throw new It("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==i.inputs.length)throw new It("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new It("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const s=ek({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(s)}if(r)this.outputs=i.outputs,this.inputs=i.inputs;else{if(1!==e.inboundNodes.length)throw new It(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new It("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=QO(this.outputs[0])}this.inboundNodes=[],new Mx({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:ds(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{const s=e.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,r){return null==this.model&&this.build(),this.model.call(e,r)}build(e){if(ns(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new wf({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,r,i=console.log){this.built||this.build(),super.summary(e,r,i)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,r,i={}){if(!this.built)throw new rc("The model needs to be compiled before being used.");return this.model.evaluate(e,r,i)}evaluateDataset(e,r){var i=this;return(0,Qe.Z)(function*(){if(!i.built)throw new rc("The model needs to be compiled before being used.");return i.model.evaluateDataset(e,r)})()}predict(e,r={}){return null==this.model&&this.build(),this.model.predict(e,r)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,r,i={}){var s=this;return(0,Qe.Z)(function*(){if(!s.built)throw new rc("The model needs to be compiled before being used.");return s.model.fit(e,r,i)})()}fitDataset(e,r){var i=this;return(0,Qe.Z)(function*(){if(!i.built)throw new rc("The model needs to be compiled before being used.");return i.model.fitDataset(e,r)})()}trainOnBatch(e,r){var i=this;return(0,Qe.Z)(function*(){return i.model.trainOnBatch(e,r)})()}static fromConfig(e,r,i={},s=!1){let a,o={};if(r instanceof Array){if(null==r[0].className||"Merge"===r[0].className)throw new It("Legacy serialization format not supported yet.");a=r}else K(null!=r.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),a=r.layers,delete r.layers,o=r;const l=new e(o);if(!(l instanceof n))throw new qr(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(const p of a){const v=bf(p,void 0,s);s&&v.setFastWeightInitDuringBuild(!0),l.add(v)}return l}set stopTraining(e){if(null==this.model)throw new It("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new It("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const r of this.layers){const i={};i.className=r.getClassName(),i.config=r.getConfig(),e.push(i)}return{name:this.name,layers:e}}}return n.className="Sequential",n})();function Xx(n){return new wf(n)}function xI(n){return new _p(n)}function bI(n){return ek(n)}function kk(n,t){pk.registerCallbackConstructor(n,t)}yn(_p);class Su extends xh{getConfig(){return{}}}yn((()=>{class n extends Su{apply(e,r=1){return function h3(n,t=1){if(1!==t)throw new qr(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return jp(n)}(e,r)}}return n.className="elu",n})()),yn((()=>{class n extends Su{apply(e){return l0(e)}}return n.className="selu",n})()),yn((()=>{class n extends Su{apply(e){return Rc(e)}}return n.className="relu",n})()),yn((()=>{class n extends Su{apply(e){return Lt(()=>Th(6,Rc(e)))}}return n.className="relu6",n})()),yn((()=>{class n extends Su{apply(e){return e}}return n.className="linear",n})()),yn((()=>{class n extends Su{apply(e){return Tc(e)}}return n.className="sigmoid",n})()),yn((()=>{class n extends Su{apply(e){return function d3(n){return Lt(()=>{const t=gn(.5,_t(.2,n));return xu(t,0,1)})}(e)}}return n.className="hardSigmoid",n})()),yn((()=>{class n extends Su{apply(e){return lp(e)}}return n.className="softplus",n})()),yn((()=>{class n extends Su{apply(e){return function p3(n){return Lt(()=>ur(n,gn(Ra(n),1)))}(e)}}return n.className="softsign",n})()),yn((()=>{class n extends Su{apply(e){return Ih(e)}}return n.className="tanh",n})());let wI=(()=>{class n extends Su{apply(e,r=-1){return xm(e,r)}}return n.className="softmax",n})();function _f(n){return n.getClassName()}function Um(n,t={}){return B0(n,El.getMap().classNameMap,t,"activation")}function Ph(n){if(null==n){return Um({className:"linear",config:{}})}if("string"==typeof n){const t={};return t.className=n,t.config={},Um(t)}return n instanceof Su?n:Um(n)}function _I(n){if(null!=n&&"object"!=typeof n)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}yn(wI),yn((()=>{class n extends Su{apply(e,r=-1){return cp(e,r)}}return n.className="logSoftmax",n})()),yn((()=>{class n extends Su{apply(e,r=1){return Lt(()=>_t(Tc(_t(e,r)),e))}}return n.className="swish",n})()),yn((()=>{class n extends Su{apply(e){return Lt(()=>_t(e,Ih(lp(e))))}}return n.className="mish",n})());class NI extends xh{}let ry=(()=>{class n extends NI{constructor(e){super(),_I(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return Lt(()=>{let r=Wa([1]);return this.hasL1&&(r=gn(r,er(_t(this.l1,Ra(e))))),this.hasL2&&(r=gn(r,er(_t(this.l2,W0(e))))),St(r,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,r){return new e({l1:r.l1,l2:r.l2})}}return n.className="L1L2",n})();yn(ry);const SI={l1l2:"L1L2"};function xs(n){return Mm(n)}function Vm(n,t={}){return B0(n,El.getMap().classNameMap,t,"regularizer")}function ia(n){return null==n?null:"string"==typeof n?Vm({className:n in SI?SI[n]:n,config:{}}):n instanceof NI?n:Vm(n)}let Lk=(()=>{class n extends ai{constructor(e){super(e??{}),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,r){e=tr(e);let i=Rc(e);return null!=this.maxValue&&(i=xu(i,0,this.maxValue)),i}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ReLU",n})();yn(Lk);let $k=(()=>{class n extends ai{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,r){const i=tr(e);return ed(i,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return n.className="LeakyReLU",n})();yn($k);let Bk=(()=>{class n extends ai{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=ts(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=ia(e.alphaRegularizer),this.alphaConstraint=ha(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new It(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const r=(e=ns(e)).slice(1);if(null!=this.sharedAxes)for(const s of this.sharedAxes)r[s-1]=1;this.alpha=this.addWeight("alpha",r,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const i={};if(null!=this.sharedAxes)for(let s=1;s<e.length;++s)i[s]=e[s];this.inputSpec=[new oo({ndim:e.length,axes:i})],this.built=!0}call(e,r){return e=tr(e),nd(e,this.alpha.read())}getConfig(){const e={alphaInitializer:mi(this.alphaInitializer),alphaRegularizer:xs(this.alphaRegularizer),alphaConstraint:Eo(this.alphaConstraint),sharedAxes:this.sharedAxes},r=super.getConfig();return Object.assign(e,r),e}}return n.className="PReLU",n})();yn(Bk);let zk=(()=>{class n extends ai{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new qr(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,r){const i=tr(e);return jp(i)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ELU",n})();yn(zk);let EI=(()=>{class n extends ai{constructor(e){super(e??{}),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,r){const i=tr(e);return _t(i,_n(bu(i,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ThresholdedReLU",n})();yn(EI);let II=(()=>{class n extends ai{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new wI).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,r){const i=tr(e);return this.softmax(i,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Softmax",n})();function Gm(n,t,e){if("number"==typeof n)return ds(n,t);if(n.length!==t)throw new It(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let r=0;r<t;++r){const i=n[r];if(!l3(i))throw new It(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${i}`)}return n}function Lc(n,t,e,r,i=1){if(null==n)return n;let a;return a="same"===e?n:n-(t+(t-1)*(i-1))+1,Math.floor((a+r-1)/r)}function rh(n,t,e,r){if(null==n)return null;if("valid"===r)n=n*t+vp([e-t,0]);else{if("same"!==r)throw new It(`Unsupport padding mode: ${r}.`);n*=t}return n}function CI(n,t){return Lt(()=>(Ha(t),"channelsFirst"===t?ui(n,[0,2,3,1]):n))}function Uk(n,t){return Lt(()=>(Ha(t),"channelsFirst"===t?ui(n,[0,2,3,4,1]):n))}function AI(n,t,e,r=[1,1],i="valid",s,a,o=null){return Lt(()=>{if(null==s&&(s="channelsLast"),Ha(s),3!==n.rank&&4!==n.rank)throw new It(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(3!==t.rank&&4!==t.rank)throw new It(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=CI(n,s);if("causal"===i)throw new qr("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=qN({x:l,filter:t,strides:r,pad:"same"===i?"same":"valid",dilations:a,dataFormat:"NHWC",bias:e,activation:o}),"channelsFirst"===s&&(l=ui(l,[0,3,1,2])),l})}yn(II);class Yx extends ai{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Yx.verifyArgs(e),this.rank=t,pr(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new qr(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Gm(e.kernelSize,t,"kernelSize"),this.strides=Gm(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,ac(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Ha(this.dataFormat),this.activation=Ph(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=ts(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=ha(e.biasConstraint),this.biasRegularizer=ia(e.biasRegularizer),this.activityRegularizer=ia(e.activityRegularizer),this.dilationRate=Gm(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new It(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new It(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new It(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(ic("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!OE(t.kernelSize,"number",1,3))throw new It(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:_f(this.activation),useBias:this.useBias,biasInitializer:mi(this.biasInitializer),biasRegularizer:xs(this.biasRegularizer),activityRegularizer:xs(this.activityRegularizer),biasConstraint:Eo(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class qm extends Yx{constructor(t,e){super(t,e),this.kernel=null,qm.verifyArgs(e),this.filters=e.filters,pr(this.filters,"filters"),this.kernelInitializer=ts(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=ha(e.kernelConstraint),this.kernelRegularizer=ia(e.kernelRegularizer)}build(t){t=ns(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new It(`The channel dimension of the input should be defined. Found ${t[e]}`);const r=t[e],i=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:r}}],this.built=!0}call(t,e){return Lt(()=>{let r;t=tr(t);const i=null==this.bias?null:this.bias.read(),s=OO(this.activation.getClassName());if(null!=s&&2===this.rank)r=AI(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(1===this.rank)r=function Vk(n,t,e,r=1,i="valid",s,a=1){return Lt(()=>{if(null==s&&(s="channelsLast"),Ha(s),3!==n.shape.length)throw new It(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(3!==t.shape.length)throw new It(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=e&&1!==e.shape.length)throw new It(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===s&&(n=ui(n,[0,2,1])),"causal"===i)throw new qr("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=fm(n,t,r,"same"===i?"same":"valid","NWC",a);return null!=e&&(o=yf(o,e)),o})}(t,this.kernel.read(),i,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)r=AI(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new qr("convolutions greater than 3D are not implemented yet.");r=function Gk(n,t,e,r=[1,1,1],i="valid",s,a){return Lt(()=>{if(null==s&&(s="channelsLast"),Ha(s),4!==n.rank&&5!==n.rank)throw new It(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(4!==t.rank&&5!==t.rank)throw new It(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let o=Uk(n,s);if("causal"===i)throw new qr("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=i1(o,t,r,"same"===i?"same":"valid","NDHWC",a),null!=e&&(o=yf(o,e)),"channelsFirst"===s&&(o=ui(o,[0,4,1,2,3])),o})}(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=ns(t);const e=[],r="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<r.length;++s){const a=Lc(r[s],this.kernelSize[s],this.padding,this.strides[s],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[s]);e.push(a)}let i=[t[0]];return"channelsLast"===this.dataFormat?(i=i.concat(e),i.push(this.filters)):(i.push(this.filters),i=i.concat(e)),i}getConfig(){const t={filters:this.filters,kernelInitializer:mi(this.kernelInitializer),kernelRegularizer:xs(this.kernelRegularizer),kernelConstraint:Eo(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new It(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}let TI=(()=>{class n extends qm{constructor(e){super(2,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!OE(e.kernelSize,"number",1,2))throw new It(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv2D",n})();yn(TI);let iy=(()=>{class n extends qm{constructor(e){super(3,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new It(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv3D",n})();yn(iy);let Zx=(()=>{class n extends TI{constructor(e){if(super(e),this.inputSpec=[new oo({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new It(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=ns(e)).length)throw new It("Input should have rank 4; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new It("The channel dimension of the inputs should be defined. Found `None`.");const i=e[r],s=this.kernelSize.concat([this.filters,i]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new oo({ndim:4,axes:{[r]:i}})],this.built=!0}call(e,r){return Lt(()=>{let i=tr(e);if(4!==i.shape.length)throw new It(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${i.shape.length}`);const s=i.shape;let o,l;"channelsFirst"===this.dataFormat?(o=2,l=3):(o=1,l=2);const g=s[l],w=this.kernelSize[1],D=this.strides[1],L=[s[0],rh(s[o],this.strides[0],this.kernelSize[0],this.padding),rh(g,D,w,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(i=ui(i,[0,2,3,1]));let $=Kg(i,this.kernel.read(),L,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&($=ui($,[0,3,1,2])),null!=this.bias&&($=yf($,this.bias.read(),this.dataFormat)),null!=this.activation&&($=this.activation.apply($)),$})}computeOutputShape(e){const r=(e=ns(e)).slice();let i,s,a;"channelsFirst"===this.dataFormat?(i=1,s=2,a=3):(i=3,s=1,a=2);const o=this.kernelSize[0],l=this.kernelSize[1],p=this.strides[0],g=this.strides[1];return r[i]=this.filters,r[s]=rh(r[s],p,o,this.padding),r[a]=rh(r[a],g,l,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv2DTranspose",n})();yn(Zx);let Nd=(()=>{class n extends iy{constructor(e){if(super(e),this.inputSpec=[new oo({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new It(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=ns(e)).length)throw new It("Input should have rank 5; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new It("The channel dimension of the inputs should be defined. Found `None`.");const i=e[r],s=this.kernelSize.concat([this.filters,i]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new oo({ndim:5,axes:{[r]:i}})],this.built=!0}call(e,r){return Lt(()=>{let i=tr(e);if(5!==i.shape.length)throw new It(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${i.shape.length}`);const s=i.shape;let o,l,p;"channelsFirst"===this.dataFormat?(p=2,o=3,l=4):(p=1,o=2,l=3);const v=s[o],w=s[l],D=this.kernelSize[1],O=this.kernelSize[2],L=this.strides[1],$=this.strides[2],ce=[s[0],rh(s[p],this.strides[0],this.kernelSize[0],this.padding),rh(v,L,D,this.padding),rh(w,$,O,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(i=ui(i,[0,2,3,4,1]));let ve=s1(i,this.kernel.read(),ce,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(ve=ui(ve,[0,4,1,2,3])),null!==this.bias&&(ve=yf(ve,this.bias.read(),this.dataFormat)),null!==this.activation&&(ve=this.activation.apply(ve)),ve})}computeOutputShape(e){const r=(e=ns(e)).slice();let i,s,a,o;"channelsFirst"===this.dataFormat?(i=1,s=2,a=3,o=4):(i=4,s=1,a=2,o=3);const l=this.kernelSize[0],p=this.kernelSize[1],g=this.kernelSize[2],v=this.strides[0],w=this.strides[1],N=this.strides[2];return r[i]=this.filters,r[s]=rh(r[s],v,l,this.padding),r[a]=rh(r[a],w,p,this.padding),r[o]=rh(r[o],N,g,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv3DTranspose",n})();yn(Nd);let qk=(()=>{class n extends qm{constructor(e,r){if(super(e,r),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==r.filters)throw new It("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=r.kernelInitializer||null!=r.kernelRegularizer||null!=r.kernelConstraint)throw new It("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=r.padding&&"same"!==r.padding&&"valid"!==r.padding)throw new It(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(r.padding)}`);this.depthMultiplier=null==r.depthMultiplier?1:r.depthMultiplier,this.depthwiseInitializer=ts(r.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=ia(r.depthwiseRegularizer),this.depthwiseConstraint=ha(r.depthwiseConstraint),this.pointwiseInitializer=ts(r.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=ia(r.pointwiseRegularizer),this.pointwiseConstraint=ha(r.pointwiseConstraint)}build(e){if((e=ns(e)).length<this.rank+2)throw new It(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r]||e[r]<0)throw new It(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[r])}`);const i=e[r],s=this.kernelSize.concat([i,this.depthMultiplier]),a=[];for(let l=0;l<this.rank;++l)a.push(1);a.push(i*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):null,this.inputSpec=[new oo({ndim:this.rank+2,axes:{[r]:i}})],this.built=!0}call(e,r){return Lt(()=>{let i;if(e=tr(e),1===this.rank)throw new qr("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=ui(e,[0,2,3,1])),i=c0(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(i=yf(i,this.bias.read(),this.dataFormat)),null!=this.activation&&(i=this.activation.apply(i)),"channelsFirst"===this.dataFormat&&(i=ui(i,[0,3,1,2])),i})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=mi(this.depthwiseInitializer),e.pointwiseInitializer=mi(this.pointwiseInitializer),e.depthwiseRegularizer=xs(this.depthwiseRegularizer),e.pointwiseRegularizer=xs(this.pointwiseRegularizer),e.depthwiseConstraint=Eo(this.depthwiseConstraint),e.pointwiseConstraint=Eo(this.pointwiseConstraint),e}}return n.className="SeparableConv",n})(),MI=(()=>{class n extends qk{constructor(e){super(2,e)}}return n.className="SeparableConv2D",n})();yn(MI);let jx=(()=>{class n extends qm{constructor(e){super(1,e),n.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!OE(e.kernelSize,"number",1,1))throw new It(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv1D",n})();yn(jx);let RI=(()=>{class n extends ai{constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,r){return Lt(()=>{if(e=tr(e),"channelsLast"===this.dataFormat){const i=Sx(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Sx(i,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const i=Sx(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Sx(i,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Cropping2D",n})();yn(RI);let DI=(()=>{class n extends ai{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Ha(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,function kO(n){md(s3,"InterpolationFormat",n)}(this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,r){return Lt(()=>{let i=tr(e);const s=i.shape;if("channelsFirst"===this.dataFormat){i=ui(i,[0,2,3,1]);const a=this.size[0]*s[2],o=this.size[1]*s[3],l="nearest"===this.interpolation?ec.resizeNearestNeighbor(i,[a,o]):ec.resizeBilinear(i,[a,o]);return ui(l,[0,3,1,2])}{const a=this.size[0]*s[1],o=this.size[1]*s[2];return"nearest"===this.interpolation?ec.resizeNearestNeighbor(i,[a,o]):ec.resizeBilinear(i,[a,o])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}}return n.className="UpSampling2D",n})();yn(DI);let Wk=(()=>{class n extends Yx{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=ts(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=ha(e.depthwiseConstraint),this.depthwiseRegularizer=ia(e.depthwiseRegularizer)}build(e){if((e=ns(e)).length<4)throw new It(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const r="channelsFirst"===this.dataFormat?1:3;if(null==e[r]||e[r]<0)throw new It(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[r]}).`);const i=e[r];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],i,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[i*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return Lt(()=>{let i=function y$(n,t,e=[1,1],r="valid",i,s){return Lt(()=>{null==i&&(i="channelsLast"),Ha(i);let a=CI(n,i);if(4!==n.rank)throw new It(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(4!==t.rank)throw new It(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return a=ap(a,t,e,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===i&&(a=ui(a,[0,3,1,2])),a})}(e=tr(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(i=yf(i,this.bias.read(),this.dataFormat)),null!=this.activation&&(i=this.activation.apply(i)),i})}computeOutputShape(e){e=ns(e);const i="channelsFirst"===this.dataFormat?e[3]:e[2],s="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=Lc("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),o=Lc(i,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],s,a,o]:[e[0],a,o,s]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=mi(this.depthwiseInitializer),e.depthwiseRegularizer=xs(this.depthwiseRegularizer),e.depthwiseConstraint=Eo(this.depthwiseRegularizer),e}}return n.className="DepthwiseConv2D",n})();function Hk(n,t,e,r){if(Array.isArray(n)){if(null!=t||null!=e)throw new It("When inputs is an array, neither initialState or constants should be provided");null!=r&&(e=n.slice(n.length-r,n.length),n=n.slice(0,n.length-r)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function i(s){return null==s||Array.isArray(s)?s:[s]}return{inputs:n,initialState:t=i(t),constants:e=i(e)}}function Xk(n,t,e,r=!1,i,s,a=!1,o=!1){return Lt(()=>{const l=t.shape.length;if(l<3)throw new It(`Input should be at least 3D, but is ${l}D.`);const p=[1,0].concat(cl(2,l));if(t=ui(t,p),null!=s)throw new qr("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=i&&((i=_n(_n(i,"bool"),"float32")).rank===l-1&&(i=tu(i,-1)),i=ui(i,p)),r&&(t=Ql(t,0),null!=i&&(i=Ql(i,0)));const g=[];let v,w=e;const N=t.shape[0],D=Al(t);let O,k;null!=i&&(O=Al(i));for(let L=0;L<N;++L){const $=D[L],U=Lt(()=>n($,w));if(null==i)v=U[0],w=U[1];else{const V=Lt(()=>{const W=O[L],ce=Hn(qu(W),W);return{output:gn(_t(U[0],W),_t(w[0],ce)),newStates:w.map((ge,it)=>gn(_t(U[1][it],W),_t(ge,ce)))}});v=V.output,w=V.newStates}o&&g.push(v)}return o&&(k=Wu(g,1)),[v,k,w]})}yn(Wk);let Fh=(()=>{class n extends ai{constructor(e){let r;if(super(e),null==e.cell)throw new It("cell property is missing for the constructor of RNN.");if(r=Array.isArray(e.cell)?new eb({cells:e.cell}):e.cell,null==r.stateSize)throw new It("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=r,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new oo({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?cl(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(r=>null):this.states_}setStates(e){this.states_=e}computeOutputShape(e){qE(e)&&(e=e[0]);let r=this.cell.stateSize;Array.isArray(r)||(r=[r]);const i=r[0];let s;if(s=this.returnSequences?[e[0],e[1],i]:[e[0],i],this.returnState){const a=[];for(const o of r)a.push([e[0],o]);return[s].concat(a)}return s}computeMask(e,r){return Lt(()=>{Array.isArray(r)&&(r=r[0]);const i=this.returnSequences?r:null;if(this.returnState){const s=this.states.map(a=>null);return[i].concat(s)}return i})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,r=[];for(let i=0;i<e;++i)r.push(null);return r}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new qr("Constants support is not implemented in RNN yet.");qE(e)&&(e=e[0]);const i=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new oo({shape:[i,null,...s]});const a=[e[0]].concat(e.slice(2));let o;if(this.cell.build(a),o=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Kt(this.stateSpec.map(l=>l.shape[l.shape.length-1]),o))throw new It(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=o.map(l=>new oo({shape:[null,l]}));this.stateful&&this.resetStates()}resetStates(e,r=!1){Lt(()=>{if(!this.stateful)throw new Oc("Cannot call resetStates() on an RNN Layer that is not stateful.");const i=this.inputSpec[0].shape[0];if(null==i)throw new It("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>Wa([i,s])):[Wa([i,this.cell.stateSize])];else if(null==e)Lr(this.states_),null!=this.keptStates&&(Lr(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>Wa([i,s])):this.states_[0]=Wa([i,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new It(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===r?this.keptStates.push(this.states_.slice()):Lr(this.states_);for(let s=0;s<this.states_.length;++s){const a=e[s],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,l=[i,o];if(!Kt(a.shape,l))throw new It(`State ${s} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${a.shape}`);this.states_[s]=a}}this.states_=this.states_.map(s=>so(s.clone()))})}apply(e,r){let i=null==r?null:r.initialState,s=null==r?null:r.constants;null==r&&(r={});const a=Hk(e,i,s,this.numConstants);e=a.inputs,i=a.initialState,s=a.constants;let o=[],l=[];if(null!=i){r.initialState=i,o=o.concat(i),this.stateSpec=[];for(const g of i)this.stateSpec.push(new oo({shape:g.shape}));l=l.concat(this.stateSpec)}if(null!=s&&(r.constants=s,o=o.concat(s),this.numConstants=s.length),o[0]instanceof vf){const g=[e].concat(o),v=this.inputSpec.concat(l),w=this.inputSpec;this.inputSpec=v;const N=super.apply(g,r);return this.inputSpec=w,N}return super.apply(e,r)}call(e,r){return Lt(()=>{const i=null==r?null:r.mask,s=null==r?null:r.training;let a=null==r?null:r.initialState;e=tr(e),null==a&&(a=this.stateful?this.states_:this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==o)throw new It(`RNN Layer has ${o} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:s},g=Xk((O,k)=>{const L=this.cell.call([O].concat(k),l);return[L[0],L.slice(1)]},e,a,this.goBackwards,i,null,this.unroll,this.returnSequences),v=g[0],w=g[1],N=g[2];this.stateful&&this.resetStates(N,s);const D=this.returnSequences?w:v;return this.returnState?[D].concat(N):D})}getInitialState(e){return Lt(()=>{let r=Wa(e.shape);return r=er(r,[1,2]),r=q0(r),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(i=>i>1?Ex(r,[1,i]):r):this.cell.stateSize>1?[Ex(r,[1,this.cell.stateSize])]:[r]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(r.numConstants=this.numConstants);const i=this.cell.getConfig();return this.getClassName()===n.className&&(r.cell={className:this.cell.getClassName(),config:i}),Object.assign(Object.assign(Object.assign({},i),e),r)}static fromConfig(e,r,i={}){const a=bf(r.cell,i);return new e(Object.assign(r,{cell:a}))}}return n.className="RNN",n})();yn(Fh);class sy extends ai{}let Jx=(()=>{class n extends sy{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,pr(this.units,"units"),this.activation=Ph(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=ts(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ts(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ts(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ia(e.kernelRegularizer),this.recurrentRegularizer=ia(e.recurrentRegularizer),this.biasRegularizer=ia(e.biasRegularizer),this.kernelConstraint=ha(e.kernelConstraint),this.recurrentConstraint=ha(e.recurrentConstraint),this.biasConstraint=ha(e.biasConstraint),this.dropout=si([1,vp([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=si([1,vp([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=ns(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return Lt(()=>{if(2!==e.length)throw new It(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let i=e[1];e=e[0];const s=null!=r.training&&r.training;let a;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=$c({ones:()=>qu(e),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=$c({ones:()=>qu(i),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,l=this.recurrentDropoutMask;a=gf(null!=o?_t(e,o):e,this.kernel.read()),null!=this.bias&&(a=yf(a,this.bias.read())),null!=l&&(i=_t(i,l));let p=gn(a,gf(i,this.recurrentKernel.read()));return null!=this.activation&&(p=this.activation.apply(p)),[p,p]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:_f(this.activation),useBias:this.useBias,kernelInitializer:mi(this.kernelInitializer),recurrentInitializer:mi(this.recurrentInitializer),biasInitializer:mi(this.biasInitializer),kernelRegularizer:xs(this.kernelRegularizer),recurrentRegularizer:xs(this.recurrentRegularizer),biasRegularizer:xs(this.biasRegularizer),activityRegularizer:xs(this.activityRegularizer),kernelConstraint:Eo(this.kernelConstraint),recurrentConstraint:Eo(this.recurrentConstraint),biasConstraint:Eo(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),r)}}return n.className="SimpleRNNCell",n})();yn(Jx);let ay=(()=>{class n extends Fh{constructor(e){e.cell=new Jx(e),super(e)}call(e,r){return Lt(()=>(null!=this.cell.dropoutMask&&(Lr(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Lr(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return new e(r)}}return n.className="SimpleRNN",n})();yn(ay);let Wm=(()=>{class n extends sy{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new It("GRUCell does not support reset_after parameter set to true.");this.units=e.units,pr(this.units,"units"),this.activation=Ph(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Ph(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=ts(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ts(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ts(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ia(e.kernelRegularizer),this.recurrentRegularizer=ia(e.recurrentRegularizer),this.biasRegularizer=ia(e.biasRegularizer),this.kernelConstraint=ha(e.kernelConstraint),this.recurrentConstraint=ha(e.recurrentConstraint),this.biasConstraint=ha(e.biasConstraint),this.dropout=si([1,vp([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=si([1,vp([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=ns(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return Lt(()=>{if(2!==e.length)throw new It(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const i=null!=r.training&&r.training;let s=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=$c({ones:()=>qu(e),rate:this.dropout,training:i,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=$c({ones:()=>qu(s),rate:this.recurrentDropout,training:i,count:3,dropoutFunc:this.dropoutFunc}));const o=this.recurrentDropoutMask;let l,p,g;0<this.dropout&&this.dropout<1&&(e=_t(e,this.dropoutMask[0]));let v=gf(e,this.kernel.read());this.useBias&&(v=yf(v,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=_t(s,o[0]));const w=this.recurrentKernel.read(),[N,D]=_u(w,[2*this.units,this.units],w.rank-1),O=gf(s,N),[k,L,$]=_u(v,3,v.rank-1),[U,V]=_u(O,2,O.rank-1);l=this.recurrentActivation.apply(gn(k,U)),p=this.recurrentActivation.apply(gn(L,V));const W=gf(_t(p,s),D);g=this.activation.apply(gn($,W));const ce=gn(_t(l,s),_t(gn(1,Ls(l)),g));return[ce,ce]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:_f(this.activation),recurrentActivation:_f(this.recurrentActivation),useBias:this.useBias,kernelInitializer:mi(this.kernelInitializer),recurrentInitializer:mi(this.recurrentInitializer),biasInitializer:mi(this.biasInitializer),kernelRegularizer:xs(this.kernelRegularizer),recurrentRegularizer:xs(this.recurrentRegularizer),biasRegularizer:xs(this.biasRegularizer),activityRegularizer:xs(this.activityRegularizer),kernelConstraint:Eo(this.kernelConstraint),recurrentConstraint:Eo(this.recurrentConstraint),biasConstraint:Eo(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),r)}}return n.className="GRUCell",n})();yn(Wm);let Kk=(()=>{class n extends Fh{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Wm(e),super(e)}call(e,r){return Lt(()=>(null!=this.cell.dropoutMask&&(Lr(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Lr(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return n.className="GRU",n})();yn(Kk);let Qx=(()=>{class n extends sy{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,pr(this.units,"units"),this.activation=Ph(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Ph(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=ts(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ts(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ts(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=ia(e.kernelRegularizer),this.recurrentRegularizer=ia(e.recurrentRegularizer),this.biasRegularizer=ia(e.biasRegularizer),this.kernelConstraint=ha(e.kernelConstraint),this.recurrentConstraint=ha(e.recurrentConstraint),this.biasConstraint=ha(e.biasConstraint),this.dropout=si([1,vp([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=si([1,vp([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var r;let s;if(e=ns(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const a=this.biasInitializer,o=this.units;s=new((r=class extends Pc{apply(p,g){const v=a.apply([o]),w=(new zE).apply([o]),N=a.apply([2*o]);return zO(zO(v,w),N)}}).className="CustomInit",r)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,r){return Lt(()=>{const i=null!=r.training&&r.training;if(3!==e.length)throw new It(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let s=e[1];const a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=$c({ones:()=>qu(e),rate:this.dropout,training:i,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=$c({ones:()=>qu(s),rate:this.recurrentDropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const l=this.recurrentDropoutMask;let p,g,v,w;0<this.dropout&&this.dropout<1&&(e=_t(e,this.dropoutMask[0]));let N=gf(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=_t(s,l[0])),N=gn(N,gf(s,this.recurrentKernel.read())),this.useBias&&(N=yf(N,this.bias.read()));const[D,O,k,L]=_u(N,4,N.rank-1);p=this.recurrentActivation.apply(D),g=this.recurrentActivation.apply(O),v=gn(_t(g,a),_t(p,this.activation.apply(k))),w=this.recurrentActivation.apply(L);const $=_t(w,this.activation.apply(v));return[$,$,v]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:_f(this.activation),recurrentActivation:_f(this.recurrentActivation),useBias:this.useBias,kernelInitializer:mi(this.kernelInitializer),recurrentInitializer:mi(this.recurrentInitializer),biasInitializer:mi(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:xs(this.kernelRegularizer),recurrentRegularizer:xs(this.recurrentRegularizer),biasRegularizer:xs(this.biasRegularizer),activityRegularizer:xs(this.activityRegularizer),kernelConstraint:Eo(this.kernelConstraint),recurrentConstraint:Eo(this.recurrentConstraint),biasConstraint:Eo(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),r)}}return n.className="LSTMCell",n})();yn(Qx);let OI=(()=>{class n extends Fh{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Qx(e),super(e)}call(e,r){return Lt(()=>(null!=this.cell.dropoutMask&&(Lr(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Lr(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return n.className="LSTM",n})();yn(OI);let eb=(()=>{class n extends sy{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const r of this.cells.slice().reverse())Array.isArray(r.stateSize)?e.push(...r.stateSize):e.push(r.stateSize);return e}call(e,r){return Lt(()=>{let i=e.slice(1);const s=[];for(const l of this.cells.slice().reverse())Array.isArray(l.stateSize)?s.push(i.splice(0,l.stateSize.length)):s.push(i.splice(0,1));s.reverse();const a=[];let o;for(let l=0;l<this.cells.length;++l){const p=this.cells[l];i=s[l],o=0===l?[e[0]].concat(i):[o[0]].concat(i),o=p.call(o,r),a.push(o.slice(1))}i=[];for(const l of a.slice().reverse())i.push(...l);return[o[0]].concat(i)})}build(e){let r;qE(e)&&(e=e[0]),this.cells.forEach((i,s)=>{gd(`RNNCell_${s}`,()=>{i.build(e),r=Array.isArray(i.stateSize)?i.stateSize[0]:i.stateSize,e=[e[0],r]})}),this.built=!0}getConfig(){const e=super.getConfig(),s={cells:this.cells.map(a=>({className:a.getClassName(),config:a.getConfig()}))};return Object.assign(Object.assign({},e),s)}static fromConfig(e,r,i={}){const s=[];for(const a of r.cells)s.push(bf(a,i));return new e({cells:s})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const r of this.cells)e.push(...r.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const r of this.cells)e.push(...r.nonTrainableWeights);if(!this.trainable){const r=[];for(const i of this.cells)r.push(...i.trainableWeights);return r.concat(e)}return e}getWeights(){const e=[];for(const r of this.cells)e.push(...r.weights);return Tx(e)}setWeights(e){const r=[];for(const i of this.cells){const a=e.splice(i.weights.length);for(let o=0;o<i.weights.length;++o)r.push([i.weights[o],a[o]])}xd(r)}}return n.className="StackedRNNCells",n})();function $c(n){const{ones:t,rate:e,training:r=!1,count:i=1,dropoutFunc:s}=n,a=()=>null!=s?s(t(),e):$E(t(),e),o=()=>H0(a,t,r);return!i||i<=1?so(o().clone()):Array(i).fill(void 0).map(o).map(p=>so(p.clone()))}yn(eb);let v$=(()=>{class n extends Fh{constructor(e){if(e.unroll)throw new qr("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new qr("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new oo({ndim:5})]}call(e,r){return Lt(()=>{if(null!=this.cell.dropoutMask&&(Lr(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Lr(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),r&&r.constants)throw new It("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})})}computeOutputShape(e){let r=this.computeSingleOutputShape(e);return this.returnSequences||(r=[r[0],...r.slice(2)]),this.returnState&&(r=[r,...Array(2).fill([e[0],...r.slice(-3)])]),r}getInitialState(e){return Lt(()=>{const{stateSize:r}=this.cell,s=this.computeSingleOutputShape(e.shape),o=Wa([s[0],...s.slice(2)]);return Array.isArray(r)?Array(r.length).fill(o):[o]})}resetStates(e,r=!1){Lt(()=>{if(!this.stateful)throw new Oc("Cannot call resetStates() on an RNN Layer that is not stateful.");const i=this.inputSpec[0].shape,s=this.computeSingleOutputShape(i),a=[s[0],...s.slice(2)];if(null==i[0])throw new It("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>Wa(a)):[Wa(a)];else if(null==e)Lr(this.states_),null!=this.keptStates&&(Lr(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Wa(a)):this.states_[0]=Wa(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new It(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);r?this.keptStates.push(this.states_.slice()):Lr(this.states_);for(let l=0;l<this.states_.length;++l){const p=e[l],g=a;if(!Kt(p.shape,g))throw new It(`State ${l} is incompatible with layer ${this.name}: expected shape=${g}, received shape=${p.shape}`);this.states_[l]=p}}this.states_=this.states_.map(l=>so(l.clone()))})}computeSingleOutputShape(e){const{dataFormat:r,filters:i,kernelSize:s,padding:a,strides:o,dilationRate:l}=this.cell,p="channelsFirst"===r,v=e[p?4:3],w=Lc(e[p?3:2],s[0],a,o[0],l[0]),N=Lc(v,s[1],a,o[1],l[1]);return[...e.slice(0,2),...p?[i,w,N]:[w,N,i]]}}return n.className="ConvRNN2D",n})(),kI=(()=>{class n extends Qx{constructor(e){const{filters:r,kernelSize:i,strides:s,padding:a,dataFormat:o,dilationRate:l}=e;super(Object.assign(Object.assign({},e),{units:r})),this.filters=r,pr(this.filters,"filters"),this.kernelSize=Gm(i,2,"kernelSize"),this.kernelSize.forEach(p=>pr(p,"kernelSize")),this.strides=Gm(s||1,2,"strides"),this.strides.forEach(p=>pr(p,"strides")),this.padding=a||"valid",ac(this.padding),this.dataFormat=o||"channelsLast",Ha(this.dataFormat),this.dilationRate=Gm(l||1,2,"dilationRate"),this.dilationRate.forEach(p=>pr(p,"dilationRate"))}build(e){var r;e=ns(e);const i="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[i])throw new It(`The channel dimension of the input should be defined. Found ${e[i]}`);const o=this.kernelSize.concat([e[i],4*this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const l=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let p;if(this.unitForgetBias){const g=this.biasInitializer,v=this.filters;p=new((r=class extends Pc{apply(N,D){return FE([g.apply([v]),ul([v]),g.apply([2*v])])}}).className="CustomInit",r)}else p=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,p,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,r){return Lt(()=>{if(3!==e.length)throw new It(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const i=r.training||!1,s=e[0],a=e[1],o=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=$c({ones:()=>qu(s),rate:this.dropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const p=this.dropoutMask,g=(cn,xn,rn)=>xn&&xn[rn]?_t(xn[rn],cn):cn;let v=g(s,p,0),w=g(s,p,1),N=g(s,p,2),D=g(s,p,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=$c({ones:()=>qu(a),rate:this.recurrentDropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const O=this.recurrentDropoutMask;let k=g(a,O,0),L=g(a,O,1),$=g(a,O,2),U=g(a,O,3);const[W,ce,ve,Ee]=_u(this.kernel.read(),4,3),[ge,it,ut,Mt]=this.useBias?_u(this.bias.read(),4):[null,null,null,null];v=this.inputConv(v,W,ge,this.padding),w=this.inputConv(w,ce,it,this.padding),N=this.inputConv(N,ve,ut,this.padding),D=this.inputConv(D,Ee,Mt,this.padding);const[Ot,vt,Rt,Dt]=_u(this.recurrentKernel.read(),4,3);k=this.recurrentConv(k,Ot),L=this.recurrentConv(L,vt),$=this.recurrentConv($,Rt),U=this.recurrentConv(U,Dt);const Ht=this.recurrentActivation.apply(gn(v,k)),Bt=this.recurrentActivation.apply(gn(w,L)),Wt=gn(_t(Bt,o),_t(Ht,this.activation.apply(gn(N,$)))),ln=_t(this.recurrentActivation.apply(gn(D,U)),this.activation.apply(Wt));return[ln,ln,Wt]})}getConfig(){const i=function(n,t){var e={};for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&t.indexOf(r)<0&&(e[r]=n[r]);if(null!=n&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(r=Object.getOwnPropertySymbols(n);i<r.length;i++)t.indexOf(r[i])<0&&Object.prototype.propertyIsEnumerable.call(n,r[i])&&(e[r[i]]=n[r[i]])}return e}(super.getConfig(),["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},i),s)}inputConv(e,r,i,s){const a=Xf(e,r,this.strides,s||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return i?yf(a,i,this.dataFormat):a}recurrentConv(e,r){return Xf(e,r,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}return n.className="ConvLSTM2DCell",n})();yn(kI);let PI=(()=>{class n extends v${constructor(e){const r=new kI(e);super(Object.assign(Object.assign({},e),{cell:r}))}static fromConfig(e,r){return new e(r)}}return n.className="ConvLSTM2D",n})();yn(PI);let FI=(()=>{class n extends ai{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const r=e.shape,i=[];for(let s=0;s<this.noiseShape.length;++s)i.push(null==this.noiseShape[s]?r[s]:this.noiseShape[s]);return i}call(e,r){return Lt(()=>{this.invokeCallHook(e,r);const i=tr(e);if(0<this.rate&&this.rate<1){const s=null!=r.training&&r.training,a=this.getNoiseShape(i);return H0(()=>$E(i,this.rate,a,this.seed),()=>i,s)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},r=super.getConfig();return Object.assign(e,r),e}dispose(){return super.dispose()}}return n.className="Dropout",n})();yn(FI);let Yk=(()=>{class n extends FI{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const r=e.shape;return[r[0],1,r[2]]}}return n.className="SpatialDropout1D",n})();yn(Yk);let Zk=(()=>{class n extends ai{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=[r,e.inputDim]}this.units=e.units,pr(this.units,"units"),this.activation=Ph(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=ts(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=ts(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=ha(e.kernelConstraint),this.biasConstraint=ha(e.biasConstraint),this.kernelRegularizer=ia(e.kernelRegularizer),this.biasRegularizer=ia(e.biasRegularizer),this.activityRegularizer=ia(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const r=(e=ns(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[r,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:r}}],this.built=!0}computeOutputShape(e){const r=(e=ns(e)).slice();return r[r.length-1]=this.units,r}call(e,r){return Lt(()=>{this.invokeCallHook(e,r);const i=tr(e),s=OO(this.activation.getClassName());let a;return null!=s?a=gf(i,this.kernel.read(),s,this.bias?this.bias.read():null):(a=gf(i,this.kernel.read()),null!=this.bias&&(a=yf(a,this.bias.read())),null!=this.activation&&(a=this.activation.apply(a))),a})}getConfig(){const e={units:this.units,activation:_f(this.activation),useBias:this.useBias,kernelInitializer:mi(this.kernelInitializer),biasInitializer:mi(this.biasInitializer),kernelRegularizer:xs(this.kernelRegularizer),biasRegularizer:xs(this.biasRegularizer),activityRegularizer:xs(this.activityRegularizer),kernelConstraint:Eo(this.kernelConstraint),biasConstraint:Eo(this.biasConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Dense",n})();yn(Zk);let nb=(()=>{class n extends ai{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=ns(e);for(const r of e.slice(1))if(null==r)throw new It(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],yp(e,1)]}call(e,r){return Lt(()=>{this.invokeCallHook(e,r);let i=tr(e);if("channelsFirst"===this.dataFormat&&i.rank>1){const s=[0];for(let a=2;a<i.rank;++a)s.push(a);s.push(1),i=ui(i,s)}return function BO(n){if(n.rank<=1)throw new It(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],yp(n.shape,1)];return St(n,t)}(i)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const r=super.getConfig();return Object.assign(e,r),e}}return n.className="Flatten",n})();yn(nb);let jk=(()=>{class n extends ai{constructor(e){super(e),this.supportsMasking=!0,this.activation=Ph(e.activation)}call(e,r){return Lt(()=>{this.invokeCallHook(e,r);const i=tr(e);return this.activation.apply(i)})}getConfig(){const e={activation:_f(this.activation)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Activation",n})();yn(jk);let oy=(()=>{class n extends ai{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,r){return Lt(()=>function $O(n,t){return Lt(()=>{if(2!==n.shape.length)throw new It(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);return Ex(q0(n,1),[1,t,1])})}(e=tr(e),this.n))}getConfig(){const e={n:this.n},r=super.getConfig();return Object.assign(e,r),e}}return n.className="RepeatVector",n})();yn(oy);let Jk=(()=>{class n extends ai{constructor(e){super(e),this.targetShape=e.targetShape;for(let r=0;r<this.targetShape.length;++r)this.isUnknown(this.targetShape[r])&&(this.targetShape[r]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,r){const i="Total size of new array must be unchanged.",s=r.slice();let a=1,o=null;for(let p=0;p<s.length;++p){const g=s[p];if(this.isUnknown(g)){if(null!==o)throw new It("Can only specifiy one unknown dimension.");o=p}else a*=g}const l=yp(e);if(null!==o){if(0===a||l%a!=0)throw new It(i);s[o]=l/a}else if(l!==a)throw new It(i);return s}computeOutputShape(e){let r=!1;for(let i=0;i<e.length;++i)if(this.isUnknown(e[i])){r=!0;break}return r?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,r){return Lt(()=>{this.invokeCallHook(e,r);const i=tr(e),s=i.shape,a=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return St(i,a)})}getConfig(){const e={targetShape:this.targetShape},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Reshape",n})();yn(Jk);let LI=(()=>{class n extends ai{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const r=cl(1,e.dims.length+1);if(!Kt(e.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new oo({ndim:this.dims.length+1})]}computeOutputShape(e){const r=(e=ns(e)).slice();return this.dims.forEach((i,s)=>{r[s+1]=e[i]}),r}call(e,r){return ui(tr(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Permute",n})();yn(LI);let $I=(()=>{class n extends ai{constructor(e){super(e??{}),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={maskValue:this.maskValue};return Object.assign(r,e),r}computeMask(e,r){const i=tr(e);return om(fp(i,this.maskValue),-1)}call(e,r){return Lt(()=>{this.invokeCallHook(e,r);const i=tr(e),o=om(fp(i,this.maskValue),-1,!0);return _t(i,_n(o,i.dtype))})}}return n.className="Masking",n})();yn($I);let BI=(()=>{class n extends ai{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=null==e.inputLength?[r,null]:[r].concat(us(e.inputLength))}this.inputDim=e.inputDim,pr(this.inputDim,"inputDim"),this.outputDim=e.outputDim,pr(this.outputDim,"outputDim"),this.embeddingsInitializer=ts(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=ia(e.embeddingsRegularizer),this.activityRegularizer=ia(e.activityRegularizer),this.embeddingsConstraint=ha(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,r){return Lt(()=>this.maskZero?(e=tr(e),fp(e,di(e))):null)}computeOutputShape(e){if(e=ns(e),null==this.inputLength)return[...e,this.outputDim];const r=us(this.inputLength);if(r.length!==e.length-1)throw new It(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let i=0;for(let s=0;s<r.length;++s){const a=r[s],o=e[s+1];if(null!=a&&null!=o&&a!==o)throw new It(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==a&&(r[i]=o),i++}}return[e[0],...r,this.outputDim]}call(e,r){return Lt(()=>{this.invokeCallHook(e,r);let i=tr(e);"int32"!==i.dtype&&(i=Qf(i,"int32"));const s=VO(this.embeddings.read(),St(i,[i.size]));return St(s,ns(this.computeOutputShape(i.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:mi(this.embeddingsInitializer),embeddingsRegularizer:xs(this.embeddingsRegularizer),activityRegularizer:xs(this.activityRegularizer),embeddingsConstraint:Eo(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Embedding",n})();yn(BI);class Np extends ai{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new qr}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const r=t.slice(0,t.length-e.length);for(let i=0;i<e.length;++i){const s=t[t.length-e.length+i],a=e[i];if(null==s||null==a||s<0||a<0)r.push(null);else if(1===s)r.push(a);else if(1===a)r.push(s);else{if(s!==a)throw new It("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));r.push(s)}}return r}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[ns(t)]),t.length<2)throw new It(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const s of t)null!=s&&null!==s[0]&&e.push(s[0]);if(e=gp(e),e.length>1)throw new It(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let r=null==t[0]?null:t[0].slice(1);for(let s=1;s<t.length;++s){const a=null==t[s]?null:t[s].slice(1);r=this.computeElementwiseOpOutputShape(r,a)}const i=t.map(s=>s.length);this.reshapeRequired=-1!==t.indexOf(null)||1!==gp(i).length}call(t,e){return Lt(()=>{if(this.reshapeRequired){const r=[],i=t.map(s=>s.rank);if(-1===i.indexOf(null)){const s=vp(i);for(let a of t){const o=a.rank;for(let l=0;l<s-o;++l)a=q0(a,1);r.push(a)}return this.mergeFunction(r)}{let s=!1;for(const l of t){const p=l.rank;if(null==p){const g=l.shape,v=g[0],w=g.slice(1).concat([v]);let N=St(l,[v].concat(yp(g.slice(1))));N=ui(N,[1,0]),N=St(N,w),r.push(N),s=!0}else if(p>1){const g=cl(1,p).concat([0]);r.push(ui(l,g)),s=!0}else r.push(l)}let a=this.mergeFunction(r);const o=a.rank;if(s)if(null==o){const l=a.shape,g=l[l.length-1],v=[g].concat(l.slice(0,l.length-1));a=St(ui(St(a,[-1,g]),[1,0]),v)}else if(o>1){const l=[o-1].concat(cl(0,o-1));a=ui(a,l)}return a}}return this.mergeFunction(t)})}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let i=1;i<t.length;++i){const s=null==t[i]?null:t[i].slice(1);e=this.computeElementwiseOpOutputShape(e,s)}let r=[];for(const i of t)null!=i&&null!==i[0]&&r.push(i[0]);return r=gp(r),e=1===r.length?r.concat(e):[null].concat(e),e}computeMask(t,e){return Lt(()=>{if(null==e)return null;if(!Array.isArray(e))throw new It("`mask` should be an Array");if(!Array.isArray(t))throw new It("`inputs` should be an Array");if(e.length!==t.length)throw new It(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(i=>null==i))return null;let r=(e=e.map(i=>null==i?i:tu(i,0)))[0];for(let i=1;i<e.length-1;++i)r=Jl(r,e[i]);return r})}}let uy=(()=>{class n extends Np{constructor(e){super(e)}mergeFunction(e){return Lt(()=>{let r=e[0].clone();for(let i=1;i<e.length;++i)r=gn(r,e[i]);return r})}}return n.className="Add",n})();yn(uy);let ly=(()=>{class n extends Np{constructor(e){super(e)}mergeFunction(e){return Lt(()=>{let r=e[0].clone();for(let i=1;i<e.length;++i)r=_t(r,e[i]);return r})}}return n.className="Multiply",n})();yn(ly);let rb=(()=>{class n extends Np{constructor(e){super(e)}mergeFunction(e){return Lt(()=>{let r=e[0].clone();for(let i=1;i<e.length;++i)r=gn(r,e[i]);return _t(1/e.length,r)})}}return n.className="Average",n})();yn(rb);let ib=(()=>{class n extends Np{constructor(e){super(e)}mergeFunction(e){return Lt(()=>{let r=e[0];for(let i=1;i<e.length;++i)r=cf(r,e[i]);return r})}}return n.className="Maximum",n})();yn(ib);let cy=(()=>{class n extends Np{constructor(e){super(e)}mergeFunction(e){return Lt(()=>{let r=e[0];for(let i=1;i<e.length;++i)r=Th(r,e[i]);return r})}}return n.className="Minimum",n})();yn(cy);let sb=(()=>{class n extends Np{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new It("A `Concatenate` layer should be called on a list of at least 2 inputs");let r=!0;for(const s of e)if(null!=s){r=!1;break}if(r)return;const i=[];for(let s=0;s<e.length;++s){const a=e[s].slice();a.splice(this.axis,1);let o=!1;for(const l of i)if(Kt(l,a)){o=!0;break}o||i.push(a)}if(i.length>1)throw new It("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Lt(()=>FE(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new It("A `Concatenate` layer should be called on a list of inputs.");const r=e,i=r[0].slice(),s=this.axis<0?i.length+this.axis:this.axis;for(const a of r.slice(1)){if(null==i[s]||null==a[s]){i[s]=null;break}i[s]+=a[s]}return i}computeMask(e,r){if(null==r)return null;if(!Array.isArray(r))throw new It("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new It("`inputs` should be an array for Concatenate");if(r.length!==e.length)throw new It(`Mismatch in the length of mask (${r.length}) and the legnth of inputs (${e.length})`);return Lt(()=>{let i=!0;if(r.forEach(o=>{null==o||(i=!1)}),i)return null;const s=[];for(let o=0;o<e.length;++o)s.push(null==r[o]?_n(qu(e[o]),"bool"):r[o].rank<e[o].rank?tu(r[o],-1):r[o]);const a=Da(s,this.axis);return zg(a,-1,!1)})}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Concatenate",n})();function fy(n,t){for(;n<0;)n+=t;return n}yn(sb);let UI=(()=>{class n extends Np{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){K(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0],i=e[1];if(r.length>3||i.length>3)throw new qr("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(r,i);if(r[s[0]]!==i[s[1]])throw new It(`Dimension incompatibility: ${r[s[0]]} !== ${i[s[1]]}`)}mergeFunction(e){if(2!==e.length)throw new It(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let s,r=e[0],i=e[1];return s=Array.isArray(this.axes)?this.axes.map((a,o)=>fy(a,e[o].shape.length)):[fy(this.axes,r.shape.length),fy(this.axes,i.shape.length)],this.normalize&&(r=kx(r,s[0]),i=kx(i,s[1])),function zI(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new qr("batchDot is not implemented for tensors of 4D or higher rank yet");if(K(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),K(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),"number"==typeof e&&(e=[e,e]),"complex64"===n.dtype||"complex64"===t.dtype)throw new qr("batchDot is not implemented for complex64-type Tensors yet.");const r=n.shape.length,i=t.shape.length;null==e&&(e=[r-1,i-2]);const s=e;return Lt(()=>{let a,o;if(r>i){a=r-i;const l=[];for(let p=0;p<a;++p)l.push(1);t=St(t,t.shape.concat(l))}else if(i>r){a=i-r;const l=[];for(let p=0;p<a;++p)l.push(1);n=St(n,n.shape.concat(l))}else a=0;if(o=2===n.shape.length&&2===t.shape.length?s[0]===s[1]?er(_t(n,t),s[0]):er(_t(ui(n,[1,0]),t),s[1]):ni(n,t,s[0]!==n.shape.length-1,s[1]===t.shape.length-1),a>0){let l;l=r>i?r+i-3:r-1;const p=[];for(let g=l;g<l+a;++g)p.push(g);o=Zf(o,p)}return 1===o.shape.length&&(o=tu(o,1)),o})}(r,i,s)}interpretAxes(e,r){let i;return i=Array.isArray(this.axes)?this.axes:[fy(this.axes,e.length),fy(this.axes,r.length)],i}computeOutputShape(e){K(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0].slice(),i=e[1].slice();if(r.length>3||i.length>3)throw new qr("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(r,i);r.splice(s[0],1),i.splice(s[1],1),i.splice(0,1);const a=r.concat(i);return 1===a.length&&a.push(1),a}computeMask(e,r){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Dot",n})();yn(UI);let hy=(()=>{class n extends ai{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={stddev:this.stddev};return Object.assign(r,e),r}call(e,r){return Lt(()=>{this.invokeCallHook(e,r);const i=tr(e);return H0(()=>gn(Ix(i.shape,0,this.stddev),i),()=>i,r.training||!1)})}}return n.className="GaussianNoise",n})();yn(hy);let VI=(()=>{class n extends ai{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return Lt(()=>{this.invokeCallHook(e,r);const i=tr(e);return this.rate>0&&this.rate<1?H0(()=>{const a=Math.sqrt(this.rate/(1-this.rate));return _t(i,Ix(i.shape,1,a))},()=>i,r.training||!1):i})}}return n.className="GaussianDropout",n})();yn(VI);let py=(()=>{class n extends ai{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||tr(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return Lt(()=>{if(this.rate<1&&this.rate>0){const i=this._getNoiseShape(e);return H0(()=>{const a=tr(e),p=-1.7580993408473766;let g=Kf(Mh(i),this.rate);g=Qf(g,"float32");const v=((1-this.rate)*(1+this.rate*p**2))**-.5,w=-v*p*this.rate,N=gn(_t(a,g),_t(gn(g,-1),p));return gn(_t(N,v),w)},()=>tr(e),r.training||!1)}return e})}}return n.className="AlphaDropout",n})();function dy(n,t,e,r,i,s=.001){let a;if(2===n.rank)a=Yv(n,t,e,r,i,s);else if(3===n.rank)a=Wg(n,t,e,r,i,s);else{if(4!==n.rank)throw new qr(`batchNormalization is not implemented for array of rank ${n.rank} yet`);a=Zv(n,t,e,r,i,s)}return a}yn(py);let GI=(()=>{class n extends ai{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=ts(e.betaInitializer||"zeros"),this.gammaInitializer=ts(e.gammaInitializer||"ones"),this.movingMeanInitializer=ts(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=ts(e.movingVarianceInitializer||"ones"),this.betaConstraint=ha(e.betaConstraint),this.gammaConstraint=ha(e.gammaConstraint),this.betaRegularizer=ia(e.betaRegularizer),this.gammaRegularizer=ia(e.gammaRegularizer)}build(e){e=ns(e);const r=this.axis>=0?this.axis:this.axis+e.length,i=e[r];if(null==i)throw new It(`Axis ${r} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new oo({ndim:e.length,axes:{[r]:i}})];const s=[i];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,r){return Lt(()=>{const i=null!=r.training&&r.training,s=tr(e),a=s.shape,o=a.length,l=cl(0,o),p=this.axis>=0?this.axis:this.axis+o;l.splice(p,1);const g=ds(1,o);g[p]=a[p];const v=l.slice();v.sort();const w=!Kt(v,cl(0,o).slice(0,o-1));if(!i)return(()=>{if(w){const U=St(this.movingMean.read(),g),V=St(this.movingVariance.read(),g),W=this.center?St(this.beta.read(),g):null,ce=this.scale?St(this.gamma.read(),g):null;return dy(s,U,V,W,ce,this.epsilon)}return dy(s,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[D,O,k]=function Sd(n,t,e,r,i=.001){return Kt(r.slice().sort(),cl(0,n.rank-1))?function ab(n,t,e,r,i=.001){return Lt(()=>{const s=gm(n,r),a=s.mean,o=s.variance;return[dy(n,a,o,e,t,i),a,o]})}(n,t,e,r,i):function eP(n,t,e,r,i=.001){return Lt(()=>{const s=gm(n,r),a=s.mean,o=s.variance,l=[];for(const D of cl(0,n.rank))-1!==r.indexOf(D)?l.push(1):l.push(n.shape[D]);const p=St(a,l),g=St(o,l),v=null==t?null:St(t,l),w=null==e?null:St(e,l);return[dy(n,p,g,w,v,i),a,o]})}(n,t,e,r,i)}(s,this.gamma.read(),this.beta.read(),l,this.epsilon),L=(U,V,W)=>{Lt(()=>{const ce=1-W,ve=U.read(),Ee=_t(Hn(ve,V),ce);U.write(Hn(ve,Ee))})};return(()=>{L(this.movingMean,O,this.momentum),L(this.movingVariance,k,this.momentum)})(),D})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:mi(this.betaInitializer),gammaInitializer:mi(this.gammaInitializer),movingMeanInitializer:mi(this.movingMeanInitializer),movingVarianceInitializer:mi(this.movingVarianceInitializer),betaRegularizer:xs(this.betaRegularizer),gammaRegularizer:xs(this.gammaRegularizer),betaConstraint:Eo(this.betaConstraint),gammaConstraint:Eo(this.gammaConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="BatchNormalization",n})();yn(GI);let qI=(()=>{class n extends ai{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const r of this.axis)if(!Number.isInteger(r))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=ts(e.betaInitializer||"zeros"),this.gammaInitializer=ts(e.gammaInitializer||"ones"),this.betaRegularizer=ia(e.betaRegularizer),this.gammaRegularizer=ia(e.gammaRegularizer),this.supportsMasking=!0}build(e){const r=(e=ns(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=r);for(const a of this.axis)if(a<0||a>=r)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==gp(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const i=this.axis.map(a=>e[a]);this.gamma=this.scale?this.addWeight("gamma",i,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",i,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,r){const i=tr(e),s=i.shape,a=s.length;return Lt(()=>{let{mean:l,variance:p}=gm(i,this.axis,!0);const g=ds(1,a);for(const k of this.axis)g[k]=s[k];const v=k=>null!=k&&k.shape.length!==a?St(k,g):k;let w=this.scale?v(this.gamma.read()):null,N=this.center?v(this.beta.read()):null;const D=[],O=[];for(let k=0;k<a;++k)-1!==this.axis.indexOf(k)?(D.push(s[k]),O.push(1)):(D.push(1),O.push(s[k]));return l=Cl(l,D),p=Cl(p,D),null!=w&&(w=Cl(w,O)),null!=N&&(N=Cl(N,O)),dy(i,l,p,N,w,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:mi(this.betaInitializer),gammaInitializer:mi(this.gammaInitializer),betaRegularizer:xs(this.betaRegularizer),gammaRegularizer:xs(this.gammaRegularizer)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="LayerNormalization",n})();yn(qI);let ob=(()=>{class n extends ai{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new It(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let r,i;if("number"==typeof e.padding[0])r=[e.padding[0],e.padding[0]],i=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new It(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(r=e.padding[0],2!==e.padding[1].length)throw new It(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);i=e.padding[1]}this.padding=[r,i]}this.inputSpec=[new oo({ndim:4})]}computeOutputShape(e){let r,i;return e=ns(e),"channelsFirst"===this.dataFormat?(r=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,i=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],r,i]):(r=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,i=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],r,i,e[3]])}call(e,r){return Lt(()=>function tP(n,t,e){return Lt(()=>{if(4!==n.rank)throw new It(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new It("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==e&&(e="channelsLast"),"channelsLast"!==e&&"channelsFirst"!==e)throw new It(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===e?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],Yf(n,r)})}(tr(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ZeroPadding2D",n})();function my(n,t,e,r,i,s){return Lt(()=>{let a;Ha(i),Dm(s),ac(r),null==e&&(e=[1,1]),null==r&&(r="valid"),null==i&&(i="channelsLast"),null==s&&(s="max"),n=CI(n,i);const o="same"===r?"same":"valid";return a="max"===s?mm(n,t,e,o):Xp(n,t,e,o),"channelsFirst"===i&&(a=ui(a,[0,3,1,2])),a})}function gy(n,t,e,r,i,s){return Lt(()=>{let a;Ha(i),Dm(s),ac(r),null==e&&(e=[1,1,1]),null==r&&(r="valid"),null==i&&(i="channelsLast"),null==s&&(s="max"),n=Uk(n,i);const o="same"===r?"same":"valid";return a="max"===s?df(n,t,e,o):Xv(n,t,e,o),"channelsFirst"===i&&(a=ui(a,[0,4,1,2,3])),a})}yn(ob);class WI extends ai{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new It(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(pr(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new It(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}pr(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,ac(this.padding),this.inputSpec=[new oo({ndim:3})]}computeOutputShape(t){const e=Lc((t=ns(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return Lt(()=>{this.invokeCallHook(t,e),t=q0(tr(t),2);const r=this.poolingFunction(tr(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Zf(r,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}let HI=(()=>{class n extends WI{constructor(e){super(e)}poolingFunction(e,r,i,s,a){return Ha(a),ac(s),my(e,r,i,s,a,"max")}}return n.className="MaxPooling1D",n})();yn(HI);let ub=(()=>{class n extends WI{constructor(e){super(e)}poolingFunction(e,r,i,s,a){return Ha(a),ac(s),my(e,r,i,s,a,"avg")}}return n.className="AveragePooling1D",n})();yn(ub);class XI extends ai{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new It(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];pr(this.poolSize,"poolSize"),pr(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Ha(this.dataFormat),ac(this.padding),this.inputSpec=[new oo({ndim:4})]}computeOutputShape(t){t=ns(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],r="channelsFirst"===this.dataFormat?t[3]:t[2];return e=Lc(e,this.poolSize[0],this.padding,this.strides[0]),r=Lc(r,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,r]:[t[0],e,r,t[3]]}call(t,e){return Lt(()=>(this.invokeCallHook(t,e),this.poolingFunction(tr(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}let lb=(()=>{class n extends XI{constructor(e){super(e)}poolingFunction(e,r,i,s,a){return Ha(a),ac(s),my(e,r,i,s,a,"max")}}return n.className="MaxPooling2D",n})();yn(lb);let KI=(()=>{class n extends XI{constructor(e){super(e)}poolingFunction(e,r,i,s,a){return Ha(a),ac(s),my(e,r,i,s,a,"avg")}}return n.className="AveragePooling2D",n})();yn(KI);class YI extends ai{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new It(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];pr(this.poolSize,"poolSize"),pr(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Ha(this.dataFormat),ac(this.padding),this.inputSpec=[new oo({ndim:5})]}computeOutputShape(t){t=ns(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],r="channelsFirst"===this.dataFormat?t[3]:t[2],i="channelsFirst"===this.dataFormat?t[4]:t[3];return e=Lc(e,this.poolSize[0],this.padding,this.strides[0]),r=Lc(r,this.poolSize[1],this.padding,this.strides[1]),i=Lc(i,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,r,i]:[t[0],e,r,i,t[4]]}call(t,e){return Lt(()=>(this.invokeCallHook(t,e),this.poolingFunction(tr(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}let cb=(()=>{class n extends YI{constructor(e){super(e)}poolingFunction(e,r,i,s,a){return Ha(a),ac(s),gy(e,r,i,s,a,"max")}}return n.className="MaxPooling3D",n})();yn(cb);let ZI=(()=>{class n extends YI{constructor(e){super(e)}poolingFunction(e,r,i,s,a){return Ha(a),ac(s),gy(e,r,i,s,a,"avg")}}return n.className="AveragePooling3D",n})();yn(ZI);class jI extends ai{constructor(t){super(t),this.inputSpec=[new oo({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new qr}}let JI=(()=>{class n extends jI{constructor(e){super(e||{})}call(e,r){return Lt(()=>{const i=tr(e);return ra(i,1)})}}return n.className="GlobalAveragePooling1D",n})();yn(JI);let fb=(()=>{class n extends jI{constructor(e){super(e||{})}call(e,r){return Lt(()=>{const i=tr(e);return Il(i,1)})}}return n.className="GlobalMaxPooling1D",n})();yn(fb);class QI extends ai{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Ha(this.dataFormat),this.inputSpec=[new oo({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new qr}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}let hb=(()=>{class n extends QI{call(e,r){return Lt(()=>{const i=tr(e);return ra(i,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalAveragePooling2D",n})();yn(hb);let eC=(()=>{class n extends QI{call(e,r){return Lt(()=>{const i=tr(e);return Il(i,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalMaxPooling2D",n})();yn(eC);class tC extends ai{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,r={}){const s=bf(e.layer,r);delete e.layer;const a={layer:s};return Object.assign(a,e),new t(a)}}let Hm=(()=>{class n extends tC{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=ns(e)).length<3)throw new It(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const r=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(r),this.layer.built=!0),super.build(e)}computeOutputShape(e){const r=[(e=ns(e))[0]].concat(e.slice(2)),i=this.layer.computeOutputShape(r);return[i[0],e[1]].concat(i.slice(1))}call(e,r){return Lt(()=>Xk((o,l)=>[tr(this.layer.call(o,r)),[]],e=tr(e),[],!1,null,null,!1,!0)[1])}}return n.className="TimeDistributed",n})();yn(Hm);let nC=(()=>{class n extends tC{constructor(e){super(e);const r=e.layer.getConfig(),i={};i.className=e.layer.getClassName(),i.config=r,this.forwardLayer=bf(i),r.goBackwards=!0!==r.goBackwards;const s={};if(s.className=e.layer.getClassName(),s.config=r,this.backwardLayer=bf(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function yy(n){md(wo,"BidirectionalMergeMode",n)}(this.mergeMode),e.weights)throw new qr("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const i=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,i)),this.backwardLayer.setWeights(e.slice(i))}computeOutputShape(e){let i,s,a,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState&&(a=r.slice(1)),i=r[0],"concat"===this.mergeMode?(i[i.length-1]*=2,s=[i]):s=null==this.mergeMode?[i,i.slice()]:[i],this.returnState?null==this.mergeMode?s.concat(a).concat(a.slice()):[i].concat(a).concat(a.slice()):ll(s)}apply(e,r){let i=null==r?null:r.initialState,s=null==r?null:r.constants;null==r&&(r={});const a=Hk(e,i,s,this.numConstants);if(e=a.inputs,i=a.initialState,s=a.constants,Array.isArray(e)&&(i=e.slice(1),e=e[0]),(null==i||0===i.length)&&null==s)return super.apply(e,r);const o=[],l=[];if(null!=i){const g=i.length;if(g%2>0)throw new It("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");r.initialState=i,o.push(...i);const v=i.map(w=>new oo({shape:w.shape}));this.forwardLayer.stateSpec=v.slice(0,g/2),this.backwardLayer.stateSpec=v.slice(g/2),l.push(...v)}if(null!=s)throw new qr("Support for constants in Bidirectional layers is not implemented yet.");const p=o[0]instanceof vf;for(const g of o)if(g instanceof vf!==p)throw new It("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(p){const g=[e].concat(o),v=this.inputSpec.concat(l),w=this.inputSpec;this.inputSpec=v;const N=super.apply(g,r);return this.inputSpec=w,N}return super.apply(e,r)}call(e,r){return Lt(()=>{const i=r.initialState;let s,a,o,l;if(null==i)s=this.forwardLayer.call(e,r),a=this.backwardLayer.call(e,r);else{const p=i.slice(0,i.length/2),g=i.slice(i.length/2);s=this.forwardLayer.call(e,Object.assign(r,{initialState:p})),a=this.backwardLayer.call(e,Object.assign(r,{initialState:g}))}return this.returnState&&(Array.isArray(s)&&(o=s.slice(1).concat(a.slice(1))),s=s[0],a=a[0]),this.returnSequences&&(a=Ql(a,1)),"concat"===this.mergeMode?l=FE([s,a]):"sum"===this.mergeMode?l=gn(s,a):"ave"===this.mergeMode?l=_t(.5,gn(s,a)):"mul"===this.mergeMode?l=_t(s,a):null==this.mergeMode&&(l=[s,a]),this.returnState?null==this.mergeMode?l.concat(o):[l].concat(o):l})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){gd(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),gd(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,r){let i;if(Array.isArray(r)&&(r=r[0]),i=this.returnSequences?null==this.mergeMode?[r,r]:r:null==this.mergeMode?[null,null]:null,this.returnState){const a=this.forwardLayer.states.map(o=>null);return Array.isArray(i)?i.concat(a).concat(a):[i].concat(a).concat(a)}return i}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},r=super.getConfig();return Object.assign(e,r),e}static fromConfig(e,r){const i=bf(r.layer);if(delete r.layer,null!=r.numConstants)throw new qr("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=r;return s.layer=i,new e(s)}}return n.className="Bidirectional",n})();yn(nC);let rC=(()=>{class n extends ai{constructor(e){super(e),this.scale=e.scale,this.offset=e.offset?e.offset:0}getConfig(){const e={scale:this.scale,offset:this.offset},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return Lt(()=>("float32"!==(e=tr(e)).dtype&&(e=Qf(e,"float32")),gn(_t(e,this.scale),this.offset)))}}return n.className="Rescaling",n})();yn(rC);const{resizeBilinear:rP,cropAndResize:iC}=ec;let sC=(()=>{class n extends ai{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,r,i,s,a,o,l,p){return Lt(()=>{let g,v=!1;const k=[r/o,i/l,(s+r)/o,(a+i)/l],L=[];3===e.rank?(v=!0,g=Wu([e])):g=e;for(let ce=0;ce<g.shape[0];ce++)L.push(k);const $=al(L,[L.length,4]),U=pp(0,L.length,1,"int32"),W=iC(g,$,U,[s,a],"nearest");return Qf(v?tr(Al(W)):W,p)})}upsize(e,r,i,s){return Lt(()=>Qf(rP(e,[r,i]),s))}call(e,r){return Lt(()=>{const i=tr(e),s=i.dtype,a=i.shape,o=a[a.length-3],l=a[a.length-2];let p=0;o!==this.height&&(p=Math.floor((o-this.height)/2));let g=0;return l!==this.width&&(g=Math.floor((l-this.width)/2),0===g&&(g=1)),p>=0&&g>=0?this.centerCrop(i,p,g,this.height,this.width,o,l,s):this.upsize(e,this.height,this.width,s)})}getConfig(){const e={height:this.height,width:this.width},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){const i=(e=ns(e)).length-2;return e[e.length-3]=this.height,e[i]=this.width,e}}return n.className="CenterCrop",n})();yn(sC);let vy=(()=>{class n extends ai{constructor(e){super(e),this.numTokens=e.numTokens,this.outputMode=e.outputMode?e.outputMode:"multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){return null==(e=ns(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,r){return Lt(()=>{let i;if("int32"!==(e=tr(e)).dtype&&(e=Qf(e,"int32")),typeof r.countWeights<"u"){if("count"!==this.outputMode)throw new It(`countWeights is not used when outputMode !== count.\n              Received countWeights=${r.countWeights}`);i=tr(r.countWeights)}const s=Il(e),a=op(e),o=bu(this.numTokens,s).bufferSync().get(0),l=Kf(a,0).bufferSync().get(0);if(!o||!l)throw new It(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function iP(n,t,e,r){let i=tr(n);if("int32"!==i.dtype&&(i=Qf(i,"int32")),"int"===t)return i;const s=i.shape;if(0===i.rank&&(i=tu(i,-1)),"oneHot"===t&&1!==i.shape[i.shape.length-1]&&(i=tu(i,-1)),i.rank>2)throw new It(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${i.rank}.`);const a=["multiHot","oneHot"].includes(t);let l;if(l=Zg(i,typeof r<"u"&&"count"===t?r:[],e,a),"tfIdf"!==t)return l;if(r)return _t(l,r);throw new It("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,i)})}}return n.className="CategoryEncoding",n})();yn(vy);const aC=new Set(["bilinear","nearest"]);let oC=(()=>{class n extends ai{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!aC.has(e.interpolation))throw new It(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){return e=ns(e),[this.height,this.width,e[2]]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return Lt(()=>{const i=[this.height,this.width];if("bilinear"===this.interpolation)return ec.resizeBilinear(e,i,!this.cropToAspectRatio);if("nearest"===this.interpolation)return ec.resizeNearestNeighbor(e,i,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...aC]} are supported`)})}}return n.className="Resizing",n})();yn(oC);let uC=(()=>{class n{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}return n.className="RandomSeed",n})(),sP=(()=>{class n extends ai{constructor(e){super(e),this.randomGenerator=new uC(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},r=super.getConfig();return Object.assign(e,r),e}}return n.className="BaseRandomLayer",n})();const xy=new Set(["bilinear","nearest"]);let pb=(()=>{class n extends sP{constructor(e){super(e);const{factor:r,interpolation:i="bilinear"}=e;if(this.factor=r,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new It(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new It(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new It(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(i){if(!xy.has(i))throw new It(`Invalid interpolation parameter: ${i} is not implemented`);this.interpolation=i}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){return e=ns(e),[this.imgHeight,-1,e[2]]}call(e,r){return Lt(()=>{const i=tr(e);this.imgHeight=i.shape[i.shape.length-3];const s=i.shape[i.shape.length-2];this.widthFactor=Mh([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*s;a=Math.round(a);const o=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return ec.resizeBilinear(e,o);case"nearest":return ec.resizeNearestNeighbor(e,o);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...xy]} are supported`)}})}}return n.className="RandomWidth",n})();function lC(n){return new K0(n)}function Xm(n){return new zk(n)}function db(n){return new Lk(n)}function oP(n){return new $k(n)}function cC(n){return new Bk(n)}function I$(n){return new II(n)}function C$(n){return new EI(n)}function uP(n){return new jx(n)}function lP(n){return new TI(n)}function cP(n){return new Zx(n)}function fP(n){return new iy(n)}function hP(n){return new Nd(n)}function pP(n){return new MI(n)}function fC(n){return new RI(n)}function hC(n){return new DI(n)}function pC(n){return new Wk(n)}function dP(n){return new jk(n)}function by(n){return new Zk(n)}function wy(n){return new FI(n)}function mP(n){return new Yk(n)}function gP(n){return new nb(n)}function mb(n){return new oy(n)}function dC(n){return new Jk(n)}function gb(n){return new LI(n)}function yP(n){return new BI(n)}function vP(n){return new uy(n)}function mC(n){return new rb(n)}function yb(n){return new sb(n)}function xP(n){return new ib(n)}function bP(n){return new cy(n)}function wP(n){return new ly(n)}function gC(n){return new UI(n)}function yC(n){return new GI(n)}function _P(n){return new qI(n)}function _y(n){return new ob(n)}function vb(n){return new ub(n)}function NP(n){return vb(n)}function xb(n){return vb(n)}function c(n){return new KI(n)}function f(n){return c(n)}function d(n){return c(n)}function m(n){return new ZI(n)}function y(n){return m(n)}function b(n){return m(n)}function I(n){return new JI(n)}function C(n){return new hb(n)}function A(n){return new fb(n)}function T(n){return new eC(n)}function E(n){return new HI(n)}function S(n){return new lb(n)}function R(n){return new cb(n)}function P(n){return new Kk(n)}function F(n){return new Wm(n)}function B(n){return new OI(n)}function J(n){return new Qx(n)}function j(n){return new ay(n)}function oe(n){return new Jx(n)}function G(n){return new PI(n)}function ee(n){return new kI(n)}function ne(n){return new Fh(n)}function X(n){return new eb(n)}function be(n){return new nC(n)}function Ie(n){return new Hm(n)}yn(pb);const Ce=A,fe=T,Ve=E,qe=S;function at(n){return new hy(n)}function ht(n){return new VI(n)}function bt(n){return new py(n)}function ct(n){return new $I(n)}function Ge(n){return new rC(n)}function Ft(n){return new sC(n)}function Re(n){return new oC(n)}function Nt(n){return new vy(n)}function Ut(n){return new pb(n)}function un(n,t){return sI(n,t)}function At(n,t){return vk(n,t)}function qt(n,t){return xk(n,t)}function an(n,t){return aI(n,t)}function jt(n,t){return oI(n,t)}function dn(n,t){return yk(n,t)}function Nn(n,t){return function V3(n,t){return Lt(()=>{const e=gk(n,t),r=function z3(n,t){return Lt(()=>_n(er(Jl(zu(n,1),zu(t,0))),"float32"))}(n,t),i=gn(e,r);return _n(xo(bu(i,0),ur(e,i),0),"float32")})}(n,t)}function Cn(n,t){return rI(n,t)}function sn(n,t){return Px(n,t)}function Sr(n,t){return wd(n,t)}function dr(n,t){return wd(n,t)}function Ln(n,t){return wd(n,t)}function sr(n,t){return bd(n,t)}function st(n,t){return bd(n,t)}function wt(n,t){return bd(n,t)}function Qt(n){return new ry(n)}function Zt(n){return function m$(n){return _I(n),new ry({l1:null!=n?n.l1:null,l2:0})}(n)}function vn(n){return function g$(n){return _I(n),new ry({l2:null!=n?n.l2:null,l1:0})}(n)}class In extends iu{constructor(){super(...arguments),this.model=null}setModel(t){if(!(t instanceof wf))throw new Error("model must be a LayersModel, not some other Container");this.model=t}}function Xn(n,t){return n<t}function Rr(n,t){return n>t}class jr extends In{constructor(t){if(super(),null==t&&(t={}),t.restoreBestWeights)throw new qr("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=t.monitor||"val_loss",this.minDelta=Math.abs(t.minDelta||0),this.patience=t.patience||0,this.verbose=t.verbose||0,this.mode=t.mode||"auto",this.baseline=t.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.monitorFunc="min"===this.mode?Xn:"max"===this.mode||-1!==this.monitor.indexOf("acc")?Rr:Xn,this.monitorFunc===Xn&&(this.minDelta*=-1)}onTrainBegin(t){var e=this;return(0,Qe.Z)(function*(){e.wait=0,e.stoppedEpoch=0,e.best=null!=e.baseline?e.baseline:e.monitorFunc===Xn?1/0:-1/0})()}onEpochEnd(t,e){var r=this;return(0,Qe.Z)(function*(){yield wp(e);const i=r.getMonitorValue(e);null!=i&&(r.monitorFunc(i-r.minDelta,r.best)?(r.best=i,r.wait=0):(r.wait++,r.wait>=r.patience&&(r.stoppedEpoch=t,r.model.stopTraining=!0)))})()}onTrainEnd(t){var e=this;return(0,Qe.Z)(function*(){e.stoppedEpoch>0&&e.verbose&&console.log(`Epoch ${e.stoppedEpoch}: early stopping.`)})()}getMonitorValue(t){null==t&&(t={});const e=t[this.monitor];return null==e&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(t)}`),e}}const ms={earlyStopping:function sa(n){return new jr(n)}};Pt().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Nf,$s=(()=>{return(n=$s||($s={}))[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF",$s;var n})();!function(n){let t;var e;(e=t=n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(Nf||(Nf={}));const su={};function Lh(n,t){su[n]={tfOpName:n,category:"custom",inputs:[],attrs:[],customExecutor:t}}function Ed(n){return su[n]}function $h(n){delete su[n]}function se(n,t,e,r,i){const s=t.inputParams[n];if(s&&void 0!==s.inputIndexStart){const o=s.inputIndexStart,l=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?o+1:s.inputIndexEnd,p=o<0?t.inputNames.length+o:o;if("tensor"===s.type)return uo(t.inputNames[p],e,r,i);if("tensors"===s.type){const w=t.inputs.slice(o,l);return t.inputNames.slice(o,l).filter((D,O)=>{var k;return"NoOp"!==(null===(k=w[O])||void 0===k?void 0:k.op)}).map(D=>uo(D,e,r,i))}const g=uo(t.inputNames[p],e,r,i),v=g.dataSync();return"number"===s.type?v[0]:Za(g.shape,v)}const a=t.attrParams[n];return a&&a.value}function uo(n,t,e,r){const[i,s]=Eu(n,e);if(null!=r){const o=r.getHashTableHandleByName(i);if(null!=o)return o}const a=e.currentContextIds.find(o=>!!t[Id(i,o)]);return void 0!==a?t[Id(i,a)][s]:void 0}function bb(n,t,e){return t[Id(n,e.currentContextId)]}function Bc(n,t){const[e,r,i]=Eu(n,t);return[Id(e,t&&t.currentContextId),r,i]}function Id(n,t){return t?`${n}-${t}`:n}function Eu(n,t){if(""===n)return["",0,void 0];const e=null!=t&&null!=t.parseNodeNameCache;if(e){const s=t.parseNodeNameCache.get(n);if(null!=s)return s}const r=n.split(":");let i;if(1===r.length)i=[n,0,void 0];else{const a=3===r.length?r[1]:void 0;i=[r[0],Number(r[r.length-1]),a]}return e&&t.parseNodeNameCache.set(n,i),i}function vC(n,t,e){let r=se("pad",n,t,e);if("explicit"===r){r=se("explicitPaddings",n,t,e);const i=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)i[s][0]=r[2*s],i[s][1]=r[2*s+1];return i}return r}function Sp(n){return n.kept?n:Ic(n)}const zV=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],UV=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],VV=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],GV=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],qV=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],WV=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],HV=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],XV=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],KV=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],YV=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],ZV=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],jV=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],JV=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],QV=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],eG=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],tG=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],nG=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],rG=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],iG=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class A${static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[$e,Ne,Se,Pe,Z,Be,ue,He,_e,kt,Ct,Ke,rt,et,pt,dt,je,zt,$t].map(r=>r.json));this.opMappers=e.reduce((r,i)=>(r[i.tfOpName]=i,r),{})}transformGraph(t,e={}){const i=[],s=[],a=[],o=t.node.reduce((O,k)=>(O[k.name]=this.mapNode(k),k.op.startsWith("Placeholder")?i.push(O[k.name]):"Const"===k.op?s.push(O[k.name]):(null==k.input||0===k.input.length)&&a.push(O[k.name]),O),{});let l=[];const p=[];let g={},v={};null!=e&&(g=this.mapSignatureEntries(e.inputs),v=this.mapSignatureEntries(e.outputs));const w=Object.keys(o);w.forEach(O=>{const k=o[O];k.inputNames.forEach((L,$)=>{const[U,,V]=Bc(L),W=o[U];if(null!=W.outputs){const ce=W.outputs.indexOf(V);-1!==ce&&(k.inputNames[$]=`${U}:${ce}`)}k.inputs.push(W),W.children.push(k)})}),0===Object.keys(v).length?w.forEach(O=>{const k=o[O];0===k.children.length&&p.push(k)}):Object.keys(v).forEach(O=>{const[k]=Bc(O),L=o[k];null!=L&&(L.signatureKey=v[O],p.push(L))}),Object.keys(g).length>0?Object.keys(g).forEach(O=>{const[k]=Bc(O),L=o[k];L&&(L.signatureKey=g[O],l.push(L))}):l=i;let N={};null!=t.library&&null!=t.library.function&&(N=t.library.function.reduce((O,k)=>(O[k.signature.name]=this.mapFunction(k),O),{}));const D={nodes:o,inputs:l,outputs:p,weights:s,placeholders:i,signature:e,functions:N};return a.length>0&&(D.initNodes=a),D}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,r)=>(e[t[r].name]=r,e),{})}mapNode(t){const e=Ed(t.op)||this.opMappers[t.op]||{};null==t.attr&&(t.attr={});const r={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(i=>i.startsWith("^")?i.slice(1):i),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return null!=e.inputs&&(r.inputParams=e.inputs.reduce((i,s)=>(i[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},i),{})),null!=e.attrs&&(r.attrParams=e.attrs.reduce((i,s)=>{const a=s.type;let o;switch(s.type){case"string":o=SP(t.attr,s.tfName,s.defaultValue),void 0===o&&s.tfDeprecatedName&&(o=SP(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":o=DP(t.attr,s.tfName,s.defaultValue),void 0===o&&s.tfDeprecatedName&&(o=DP(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":o=IP(t.attr,s.tfName,s.defaultValue||0),void 0===o&&s.tfDeprecatedName&&(o=IP(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":o=RP(t.attr,s.tfName,s.defaultValue),void 0===o&&s.tfDeprecatedName&&(o=RP(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":o=EP(t.attr,s.tfName,s.defaultValue),void 0===o&&s.tfDeprecatedName&&(o=EP(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":o=kP(t.attr,s.tfName,s.defaultValue),void 0===o&&s.tfDeprecatedName&&(o=kP(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":o=MP(t.attr,s.tfName,s.defaultValue),void 0===o&&s.tfDeprecatedName&&(o=MP(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":o=OP(t.attr,s.tfName,s.defaultValue),void 0===o&&s.tfDeprecatedName&&(o=OP(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":o=AP(t.attr,s.tfName,s.defaultValue),void 0===o&&s.tfDeprecatedName&&(o=AP(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":o=TP(t.attr,s.tfName,s.defaultValue),void 0===o&&s.tfDeprecatedName&&(o=TP(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":o=M$(t.attr,s.tfName,s.defaultValue),void 0===o&&s.tfDeprecatedName&&(o=M$(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${t.op}`)}return i[s.name]={value:o,type:a},i},{})),r}mapFunction(t){const e=t.nodeDef,i=[];let s={};null!=e&&(s=e.reduce((v,w)=>(v[w.name]=this.mapNode(w),"Const"===w.op&&i.push(v[w.name]),v),{}));const a=[],o=[];t.signature.inputArg.forEach(v=>{const[w]=Bc(v.name),N={name:w,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:CP(v.type),type:"dtype"}},children:[]};N.signatureKey=v.name,a.push(N),s[w]=N}),Object.keys(s).forEach(v=>{const w=s[v];w.inputNames.forEach((N,D)=>{const[O,,k]=Bc(N),L=s[O];if(null!=L.outputs){const $=L.outputs.indexOf(k);-1!==$&&(w.inputNames[D]=`${O}:${$}`)}w.inputs.push(L),L.children.push(w)})});const p=t.ret;t.signature.outputArg.forEach(v=>{const[w,N]=Bc(p[v.name]),D=s[w];null!=D&&(D.defaultOutput=N,o.push(D))});const g=this.mapArgsToSignature(t);return{nodes:s,inputs:a,outputs:o,weights:i,placeholders:[],signature:g}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r),e),{}),outputs:t.signature.outputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r,t.ret),e),{})}}mapArgToTensorInfo(t,e){let r=t.name;return null!=e&&(r=e[r]),{name:r,dtype:t.type}}}function T$(n,t){const e=Array.isArray(n)?String.fromCharCode.apply(null,n):function sG(n){const t=Pt().global;if(typeof t.atob<"u")return t.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(n);return t?e:e.toLowerCase()}function SP(n,t,e,r=!1){const i=n[t];return null!=i?T$(i.s,r):e}function EP(n,t,e){const r=n[t];return r?r.b:e}function IP(n,t,e){const r=n[t]||{},i=null!=r.i?r.i:null!=r.f?r.f:e;return"number"==typeof i?i:parseInt(i,10)}function CP(n){switch("string"==typeof n&&(n=$s[n]),n){case $s.DT_FLOAT:case $s.DT_HALF:return"float32";case $s.DT_INT32:case $s.DT_INT64:case $s.DT_INT8:case $s.DT_UINT8:return"int32";case $s.DT_BOOL:return"bool";case $s.DT_DOUBLE:return"float32";case $s.DT_STRING:return"string";default:return null}}function M$(n,t,e){const r=n[t];return r&&r.func?r.func.name:e}function AP(n,t,e){const r=n[t];return r&&r.type?CP(r.type):e}function TP(n,t,e){const r=n[t];return r&&r.list&&r.list.type?r.list.type.map(i=>CP(i)):e}function R$(n){if(!n.unknownRank)return null!=n.dim?n.dim.map(t=>"number"==typeof t.size?t.size:parseInt(t.size,10)):[]}function MP(n,t,e){const r=n[t];return r&&r.shape?R$(r.shape):e}function RP(n,t,e){const r=n[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(i=>"number"==typeof i?i:parseInt(i,10)):e}function DP(n,t,e,r=!1){const i=n[t];return i&&i.list&&i.list.s?i.list.s.map(s=>T$(s,r)):e}function OP(n,t,e){const r=n[t];return r&&r.list&&r.list.shape?r.list.shape.map(i=>R$(i)):e}function kP(n,t,e){const r=n[t];return r&&r.list&&r.list.b?r.list.b:e}class aG{constructor(t,e,r){this.node=t,this.tensorMap=e,this.context=r,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(i=>this.getInput(i)),null!=t.rawAttrs&&(this.attrs=Object.keys(t.rawAttrs).reduce((i,s)=>(i[s]=this.getAttr(s),i),{}))}getInput(t){return uo(t,this.tensorMap,this.context)}getAttr(t,e){const r=this.node.rawAttrs[t];if(null!=r.tensor)return uo(t,this.tensorMap,this.context);if(null!=r.i||null!=r.f)return IP(this.node.rawAttrs,t,e);if(null!=r.s)return SP(this.node.rawAttrs,t,e);if(null!=r.b)return EP(this.node.rawAttrs,t,e);if(null!=r.shape)return MP(this.node.rawAttrs,t,e);if(null!=r.type)return AP(this.node.rawAttrs,t,e);if(null!=r.list){if(null!=r.list.i||null!=r.list.f)return RP(this.node.rawAttrs,t,e);if(null!=r.list.s)return DP(this.node.rawAttrs,t,e);if(null!=r.list.shape)return OP(this.node.rawAttrs,t,e);if(null!=r.list.b)return kP(this.node.rawAttrs,t,e);if(null!=r.list.type)return TP(this.node.rawAttrs,t,e)}return e}}const oG=(n,t,e,r=tn)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(se("a",n,t,e),se("b",n,t,e))];case"AddN":return[r.addN(se("tensors",n,t,e))];case"FloorMod":case"Mod":return[r.mod(se("a",n,t,e),se("b",n,t,e))];case"Mul":return[r.mul(se("a",n,t,e),se("b",n,t,e))];case"RealDiv":case"Div":return[r.div(se("a",n,t,e),se("b",n,t,e))];case"DivNoNan":return[r.divNoNan(se("a",n,t,e),se("b",n,t,e))];case"FloorDiv":return[r.floorDiv(se("a",n,t,e),se("b",n,t,e))];case"Sub":return[r.sub(se("a",n,t,e),se("b",n,t,e))];case"Minimum":return[r.minimum(se("a",n,t,e),se("b",n,t,e))];case"Maximum":return[r.maximum(se("a",n,t,e),se("b",n,t,e))];case"Pow":return[r.pow(se("a",n,t,e),se("b",n,t,e))];case"SquaredDifference":return[r.squaredDifference(se("a",n,t,e),se("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},uG=(n,t,e,r=tn)=>{switch(n.op){case"Abs":case"ComplexAbs":return[r.abs(se("x",n,t,e))];case"Acos":return[r.acos(se("x",n,t,e))];case"Acosh":return[r.acosh(se("x",n,t,e))];case"Asin":return[r.asin(se("x",n,t,e))];case"Asinh":return[r.asinh(se("x",n,t,e))];case"Atan":return[r.atan(se("x",n,t,e))];case"Atan2":return[r.atan2(se("x",n,t,e),se("y",n,t,e))];case"Atanh":return[r.atanh(se("x",n,t,e))];case"Ceil":return[r.ceil(se("x",n,t,e))];case"Complex":return[r.complex(se("real",n,t,e),se("imag",n,t,e))];case"Cos":return[r.cos(se("x",n,t,e))];case"Cosh":return[r.cosh(se("x",n,t,e))];case"Elu":return[r.elu(se("x",n,t,e))];case"Erf":return[r.erf(se("x",n,t,e))];case"Exp":return[r.exp(se("x",n,t,e))];case"Expm1":return[r.expm1(se("x",n,t,e))];case"Floor":return[r.floor(se("x",n,t,e))];case"Log":return[r.log(se("x",n,t,e))];case"Log1p":return[r.log1p(se("x",n,t,e))];case"Imag":return[r.imag(se("x",n,t,e))];case"Neg":return[r.neg(se("x",n,t,e))];case"Reciprocal":return[r.reciprocal(se("x",n,t,e))];case"Real":return[r.real(se("x",n,t,e))];case"Relu":return[r.relu(se("x",n,t,e))];case"Round":return[r.round(se("x",n,t,e))];case"Selu":return[r.selu(se("x",n,t,e))];case"Sigmoid":return[r.sigmoid(se("x",n,t,e))];case"Sin":return[r.sin(se("x",n,t,e))];case"Sign":return[r.sign(se("x",n,t,e))];case"Sinh":return[r.sinh(se("x",n,t,e))];case"Softplus":return[r.softplus(se("x",n,t,e))];case"Sqrt":return[r.sqrt(se("x",n,t,e))];case"Square":return[r.square(se("x",n,t,e))];case"Tanh":return[r.tanh(se("x",n,t,e))];case"Tan":return[r.tan(se("x",n,t,e))];case"ClipByValue":return[r.clipByValue(se("x",n,t,e),se("clipValueMin",n,t,e),se("clipValueMax",n,t,e))];case"Relu6":return[r.relu6(se("x",n,t,e))];case"Rsqrt":return[r.rsqrt(uo(n.inputNames[0],t,e))];case"Prod":return[r.prod(se("x",n,t,e),se("axes",n,t,e))];case"LeakyRelu":return[r.leakyRelu(se("x",n,t,e),se("alpha",n,t,e))];case"Prelu":return[r.prelu(se("x",n,t,e),se("alpha",n,t,e))];case"IsNan":return[r.isNaN(uo(n.inputNames[0],t,e))];case"IsInf":return[r.isInf(uo(n.inputNames[0],t,e))];case"IsFinite":return[r.isFinite(uo(n.inputNames[0],t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function Sf(n,t,e=""){if("number"!=typeof n&&"number"!=typeof t){K(n.length===t.length,()=>e+` Shapes ${n} and ${t} must match`);for(let r=0;r<n.length;r++){const i=n[r],s=t[r];K(i<0||s<0||i===s,()=>e+` Shapes ${n} and ${t} must match`)}}}function D$(n){return!("number"==typeof n||n.some(t=>t<0))}function wb(n,t,e){let r=PP(n,e);const i=!D$(r);if(i&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(i&&t.forEach(s=>{r=PP(s.shape,r)}),!D$(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function PP(n,t){if("number"==typeof n)return t;if("number"==typeof t)return n;if(n.length!==t.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${t}`);const e=[];for(let r=0;r<n.length;++r){const i=n[r],s=t[r];if(i>=0&&s>=0&&i!==s)throw new Error(`Incompatible shape during merge: ${n} vs. ${t}`);e[r]=i>=0?i:s}return e}class lG{constructor(t,e,r,i,s,a,o){this.name=t,this.dtype=e,this.maxSize=r,this.elementShape=i,this.identicalElementShapes=s,this.dynamicSize=a,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=mr(0),so(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(null==t||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=e.shape),Sf(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);r.tensor=e,so(e),r.written=!0,this.tensors[t]=r}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((r,i)=>this.write(r,e[i]))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let i=0;i<this.size();i++)t.push(i)}if(0===t.length)return al([],[0].concat(this.elementShape));const r=this.readMany(t);return Sf(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),Wu(r,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(0===this.size())return al([],[0].concat(this.elementShape));const e=[];for(let i=0;i<this.size();i++)e.push(i);const r=this.readMany(e);return Sf(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),Da(r,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const r=Math.max(...t);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(t,Al(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let r=0;const i=t.map(l=>(r+=l,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===r?0:e.size/r,a=[];Lt(()=>{e=St(e,[1,r,s]);for(let l=0;l<t.length;++l)a[l]=St(li(e,[0,0===l?0:i[l-1],0],[1,t[l],s]),this.elementShape);return a});const o=[];for(let l=0;l<t.length;l++)o[l]=l;this.writeMany(o,a)}}class Km{get id(){return this.idTensor.id}constructor(t,e,r,i=-1){this.tensors=t,this.elementShape=e,this.elementDtype=r,t?.forEach(s=>{if(r!==s.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${s.dtype}`);Sf(e,s.shape,"TensorList shape mismatch: "),so(s)}),this.idTensor=mr(0),this.maxNumElements=i,so(this.idTensor)}copy(){return new Km([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(null==t||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,r=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(-1!==r&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);Sf(t,this.elementShape,"TensorList shape mismatch: ");const i=wb(this.elementShape,this.tensors,t);return Lt(()=>{const s=this.tensors.map(a=>St(a,i));return Wu(s,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const r=wb(this.elementShape,this.tensors,t),i=this.tensors.pop();return i.kept=!1,Sf(i.shape,t,"TensorList shape mismatch: "),St(i,r)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Sf(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");so(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const e=new Km([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let r=0;r<Math.min(this.tensors.length,t);++r)e.tensors[r]=this.tensors[r];return e}getItem(t,e,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[t])throw new Error(`element at index ${t} is null.`);Sf(this.tensors[t].shape,e,"TensorList shape mismatch: ");const i=wb(this.elementShape,this.tensors,e);return St(this.tensors[t],i)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||-1!==this.maxNumElements&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Sf(this.elementShape,e.shape,"TensorList shape mismatch: "),so(e),null!=this.tensors[t]&&(this.tensors[t].kept=!1),this.tensors[t]=e}gather(t,e,r){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);Sf(this.elementShape,r,"TensorList shape mismatch: "),t=t.slice(0,this.size());const i=wb(this.elementShape,this.tensors,r);return 0===t.length?al([],[0].concat(i)):Lt(()=>{const s=t.map(a=>St(this.tensors[a],i));return Wu(s,0)})}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Sf(this.elementShape,e,"TensorList shape mismatch: ");const r=wb(this.elementShape,this.tensors,e);return 0===this.size()?al([],[0].concat(r)):Lt(()=>{const i=this.tensors.map(s=>St(s,r));return Da(i,0)})}}const dG=function(){var n=(0,Qe.Z)(function*(t,e,r){switch(t.op){case"If":case"StatelessIf":{const i=se("thenBranch",t,e,r),s=se("elseBranch",t,e,r),a=se("cond",t,e,r),o=se("args",t,e,r);return(yield a.data())[0]?r.functionMap[i].executeFunctionAsync(o,r.tensorArrayMap,r.tensorListMap):r.functionMap[s].executeFunctionAsync(o,r.tensorArrayMap,r.tensorListMap)}case"While":case"StatelessWhile":{const i=se("body",t,e,r),s=se("cond",t,e,r),a=se("args",t,e,r),o=yield r.functionMap[s].executeFunctionAsync(a,r.tensorArrayMap,r.tensorListMap),l=a.map(v=>v.id);let p=yield o[0].data();o.forEach(v=>{!v.kept&&-1===l.indexOf(v.id)&&v.dispose()});let g=a;for(;p[0];){const v=g;g=yield r.functionMap[i].executeFunctionAsync(g,r.tensorArrayMap,r.tensorListMap);const w=g.map(D=>D.id);v.forEach(D=>{!D.kept&&-1===l.indexOf(D.id)&&-1===w.indexOf(D.id)&&D.dispose()});const N=yield r.functionMap[s].executeFunctionAsync(g,r.tensorArrayMap,r.tensorListMap);p=yield N[0].data(),N.forEach(D=>{!D.kept&&-1===l.indexOf(D.id)&&-1===w.indexOf(D.id)&&D.dispose()})}return g}case"LoopCond":return[Sp(se("pred",t,e,r))];case"Switch":{const i=se("pred",t,e,r);let s=se("data",t,e,r);return s.kept||(s=Sp(s)),(yield i.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const i=t.inputNames.find(s=>void 0!==uo(s,e,r));return i?[Sp(uo(i,e,r))]:void 0}case"Enter":{const i=se("frameName",t,e,r),s=se("tensor",t,e,r);return r.enterFrame(i),[Sp(s)]}case"Exit":{const i=se("tensor",t,e,r);return r.exitFrame(),[Sp(i)]}case"NextIteration":{const i=se("tensor",t,e,r);return r.nextIteration(),[Sp(i)]}case"TensorArrayV3":{const i=se("size",t,e,r),s=se("dtype",t,e,r),a=se("elementShape",t,e,r),o=se("dynamicSize",t,e,r),l=se("clearAfterRead",t,e,r),p=se("identicalElementShapes",t,e,r),g=se("name",t,e,r),v=new lG(g,s,i,a,p,o,l);return r.addTensorArray(v),[v.idTensor,mr(1)]}case"TensorArrayWriteV3":{const i=se("tensorArrayId",t,e,r),s=se("index",t,e,r),a=se("tensor",t,e,r),o=r.getTensorArray(i.id);return o.write(s,a),[o.idTensor]}case"TensorArrayReadV3":{const i=se("tensorArrayId",t,e,r),s=se("index",t,e,r);return[r.getTensorArray(i.id).read(s)]}case"TensorArrayGatherV3":{const i=se("tensorArrayId",t,e,r),s=se("indices",t,e,r),a=se("dtype",t,e,r);return[r.getTensorArray(i.id).gather(s,a)]}case"TensorArrayScatterV3":{const i=se("tensorArrayId",t,e,r),s=se("indices",t,e,r),a=se("tensor",t,e,r),o=r.getTensorArray(i.id);return o.scatter(s,a),[o.idTensor]}case"TensorArrayConcatV3":{const i=se("tensorArrayId",t,e,r),s=r.getTensorArray(i.id),a=se("dtype",t,e,r);return[s.concat(a)]}case"TensorArraySplitV3":{const i=se("tensorArrayId",t,e,r),s=se("tensor",t,e,r),a=se("lengths",t,e,r),o=r.getTensorArray(i.id);return o.split(a,s),[o.idTensor]}case"TensorArraySizeV3":{const i=se("tensorArrayId",t,e,r);return[mr(r.getTensorArray(i.id).size(),"int32")]}case"TensorArrayCloseV3":{const i=se("tensorArrayId",t,e,r),s=r.getTensorArray(i.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const i=se("tensorListId",t,e,r),s=se("index",t,e,r),a=se("tensor",t,e,r),o=r.getTensorList(i.id);return o.setItem(s,a),[o.idTensor]}case"TensorListGetItem":{const i=se("tensorListId",t,e,r),s=se("index",t,e,r),a=se("elementShape",t,e,r),o=se("elementDType",t,e,r);return[r.getTensorList(i.id).getItem(s,a,o)]}case"TensorListScatterV2":case"TensorListScatter":{const i=se("indices",t,e,r),l=function hG(n,t,e,r){if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);const i=Math.max(...t);if(null!=r&&-1!==r&&i>=r)throw new Error(`Max index must be < array size (${i}  vs. ${r})`);const s=new Km([],e,n.dtype,r),a=Al(n,0);return t.forEach((o,l)=>{s.setItem(o,a[l])}),s}(se("tensor",t,e,r),i,se("elementShape",t,e,r),se("numElements",t,e,r));return r.addTensorList(l),[l.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const i=se("elementShape",t,e,r),s=se("elementDType",t,e,r);let a;a="TensorListReserve"===t.op?"numElements":"maxNumElements";const o=se(a,t,e,r),p=function fG(n,t,e,r){return new Km([],n,t,r)}(i,s,0,"TensorListReserve"===t.op?-1:o);return r.addTensorList(p),[p.idTensor]}case"TensorListGather":{const i=se("tensorListId",t,e,r),s=se("indices",t,e,r),a=se("elementShape",t,e,r),o=se("elementDType",t,e,r);return[r.getTensorList(i.id).gather(s,o,a)]}case"TensorListStack":{const i=se("tensorListId",t,e,r),s=se("elementShape",t,e,r),a=se("elementDType",t,e,r),o=se("numElements",t,e,r);return[r.getTensorList(i.id).stack(s,a,o)]}case"TensorListFromTensor":{const o=function cG(n,t,e){const r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==e)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${e}`);Sf(n.shape.slice(1),t,"TensorList shape mismatch: ");const s=Al(n);return new Km(s,t,r)}(se("tensor",t,e,r),se("elementShape",t,e,r),se("elementDType",t,e,r));return r.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const i=se("tensorListId",t,e,r),s=r.getTensorList(i.id),a=se("dtype",t,e,r),o=se("elementShape",t,e,r);return[s.concat(a,o)]}case"TensorListPushBack":{const i=se("tensorListId",t,e,r),s=se("tensor",t,e,r),a=r.getTensorList(i.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{const i=se("tensorListId",t,e,r),s=se("elementShape",t,e,r),a=se("elementDType",t,e,r);return[r.getTensorList(i.id).popBack(s,a)]}case"TensorListSplit":{const i=se("tensor",t,e,r),s=se("elementShape",t,e,r),o=function pG(n,t,e){let r=0;const i=t.map(g=>(r+=g,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${n.shape}`);const a=PP(n.shape.slice(1),e),o=0===r?0:n.size/r,l=Lt(()=>{const g=[];n=St(n,[1,r,o]);for(let v=0;v<t.length;++v)g[v]=St(li(n,[0,0===v?0:i[v-1],0],[1,t[v],o]),a);return n.dispose(),g}),p=new Km([],e,n.dtype,t.length);for(let g=0;g<l.length;g++)p.setItem(g,l[g]);return p}(i,se("lengths",t,e,r),s);return r.addTensorList(o),[o.idTensor]}case"TensorListLength":{const i=se("tensorListId",t,e,r);return[mr(r.getTensorList(i.id).size(),"int32")]}case"TensorListResize":{const i=se("tensorListId",t,e,r),s=se("size",t,e,r),o=r.getTensorList(i.id).resize(s);return r.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,i){return n.apply(this,arguments)}}();function O$(n,t,e){const[r,i]=se("fusedOps",n,t,e),s="biasadd"===r,a=!s,o="prelu"===i,l="fusedbatchnorm"===r,p=se("numArgs",n,t,e);if(s){if(o&&2!==p)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&1!==p)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const g=se("strides",n,t,e),v=vC(n,t,e),w=se("dataFormat",n,t,e).toUpperCase(),N=se("dilations",n,t,e);let[D,O]=se("args",n,t,e);return a&&(O=D,D=void 0),{stride:g,pad:v,dataFormat:w,dilations:N,biasArg:D,preluArg:O,activationFunc:i,leakyreluAlpha:se("leakyreluAlpha",n,t,e)}}const mG=(n,t,e,r=tn)=>{switch(n.op){case"Conv1D":{const i=se("stride",n,t,e),s=se("pad",n,t,e),a=se("dataFormat",n,t,e).toUpperCase(),o=se("dilation",n,t,e);return[r.conv1d(se("x",n,t,e),se("filter",n,t,e),i,s,a,o)]}case"Conv2D":{const i=se("strides",n,t,e),s=vC(n,t,e),a=se("dataFormat",n,t,e).toUpperCase(),o=se("dilations",n,t,e);return[r.conv2d(se("x",n,t,e),se("filter",n,t,e),[i[1],i[2]],s,a,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:i,pad:s,dataFormat:a,dilations:o,biasArg:l,preluArg:p,activationFunc:g,leakyreluAlpha:v}=O$(n,t,e);return[r.fused.conv2d({x:se("x",n,t,e),filter:se("filter",n,t,e),strides:[i[1],i[2]],pad:s,dataFormat:a,dilations:[o[1],o[2]],bias:l,activation:g,preluActivationWeights:p,leakyreluAlpha:v})]}case"FusedDepthwiseConv2dNative":{const{stride:i,pad:s,dataFormat:a,dilations:o,biasArg:l,preluArg:p,activationFunc:g,leakyreluAlpha:v}=O$(n,t,e);return[r.fused.depthwiseConv2d({x:se("x",n,t,e),filter:se("filter",n,t,e),strides:[i[1],i[2]],pad:s,dataFormat:a,dilations:[o[1],o[2]],bias:l,activation:g,preluActivationWeights:p,leakyreluAlpha:v})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const i=se("outputShape",n,t,e),s=se("strides",n,t,e),a=vC(n,t,e);return[r.conv2dTranspose(se("x",n,t,e),se("filter",n,t,e),i,[s[1],s[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const i=se("strides",n,t,e),s=vC(n,t,e),a=se("dilations",n,t,e),o=se("dataFormat",n,t,e).toUpperCase();return[r.depthwiseConv2d(se("input",n,t,e),se("filter",n,t,e),[i[1],i[2]],s,o,[a[1],a[2]])]}case"Conv3D":{const i=se("strides",n,t,e),s=se("pad",n,t,e),a=se("dataFormat",n,t,e).toUpperCase(),o=se("dilations",n,t,e);return[r.conv3d(se("x",n,t,e),se("filter",n,t,e),[i[1],i[2],i[3]],s,a,[o[1],o[2],o[3]])]}case"AvgPool":{const i=se("strides",n,t,e),s=se("pad",n,t,e),a=se("kernelSize",n,t,e);return[r.avgPool(se("x",n,t,e),[a[1],a[2]],[i[1],i[2]],s)]}case"MaxPool":{const i=se("strides",n,t,e),s=se("pad",n,t,e),a=se("kernelSize",n,t,e);return[r.maxPool(se("x",n,t,e),[a[1],a[2]],[i[1],i[2]],s)]}case"MaxPoolWithArgmax":{const i=se("strides",n,t,e),s=se("pad",n,t,e),a=se("kernelSize",n,t,e),o=se("includeBatchInIndex",n,t,e),{result:l,indexes:p}=r.maxPoolWithArgmax(se("x",n,t,e),[a[1],a[2]],[i[1],i[2]],s,o);return[l,p]}case"AvgPool3D":{const i=se("strides",n,t,e),s=se("pad",n,t,e),a=se("kernelSize",n,t,e);return[r.avgPool3d(se("x",n,t,e),[a[1],a[2],a[3]],[i[1],i[2],i[3]],s)]}case"MaxPool3D":{const i=se("strides",n,t,e),s=se("pad",n,t,e),a=se("kernelSize",n,t,e);return[r.maxPool3d(se("x",n,t,e),[a[1],a[2],a[3]],[i[1],i[2],i[3]],s)]}case"Dilation2D":{const i=se("strides",n,t,e),s=se("pad",n,t,e),a=se("dilations",n,t,e),o=i[1],l=i[2],p=a[1],g=a[2];return[r.dilation2d(se("x",n,t,e),se("filter",n,t,e),[o,l],s,[p,g],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},gG=(n,t,e,r=tn)=>{switch(n.op){case"Fill":{const i=se("shape",n,t,e),s=se("dtype",n,t,e),a=se("value",n,t,e);return[r.fill(i,a,s)]}case"LinSpace":{const i=se("start",n,t,e),s=se("stop",n,t,e),a=se("num",n,t,e);return[r.linspace(i,s,a)]}case"Multinomial":{const i=se("logits",n,t,e),s=se("numSamples",n,t,e),a=se("seed",n,t,e);return[r.multinomial(i,s,a)]}case"OneHot":{const i=se("indices",n,t,e),s=se("depth",n,t,e),a=se("onValue",n,t,e),o=se("offValue",n,t,e),l=se("dtype",n,t,e);return[r.oneHot(i,s,a,o,l)]}case"Ones":return[r.ones(se("shape",n,t,e),se("dtype",n,t,e))];case"OnesLike":return[r.onesLike(se("x",n,t,e))];case"RandomStandardNormal":return[r.randomStandardNormal(se("shape",n,t,e),se("dtype",n,t,e),se("seed",n,t,e))];case"RandomUniform":return[r.randomUniform(se("shape",n,t,e),se("minval",n,t,e),se("maxval",n,t,e),se("dtype",n,t,e))];case"Range":{const i=se("start",n,t,e),s=se("stop",n,t,e),a=se("step",n,t,e);return[r.range(i,s,a,se("dtype",n,t,e))]}case"TruncatedNormal":{const i=se("shape",n,t,e),s=se("mean",n,t,e),a=se("stdDev",n,t,e),o=se("seed",n,t,e);return[r.truncatedNormal(i,s,a,se("dtype",n,t,e),o)]}case"Zeros":return[r.zeros(se("shape",n,t,e),se("dtype",n,t,e))];case"ZerosLike":return[r.zerosLike(se("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function FP(n,t,e){return{boxes:se("boxes",n,t,e),scores:se("scores",n,t,e),maxOutputSize:se("maxOutputSize",n,t,e),iouThreshold:se("iouThreshold",n,t,e),scoreThreshold:se("scoreThreshold",n,t,e),softNmsSigma:se("softNmsSigma",n,t,e)}}const yG=function(){var n=(0,Qe.Z)(function*(t,e,r,i,s=tn){switch(t.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:o,maxOutputSize:l,iouThreshold:p,scoreThreshold:g,softNmsSigma:v}=FP(t,e,r),w=yield s.image.nonMaxSuppressionWithScoreAsync(a,o,l,p,g,v);return[w.selectedIndices,w.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:o,maxOutputSize:l,iouThreshold:p,scoreThreshold:g}=FP(t,e,r),v=se("padToMaxOutputSize",t,e,r),w=yield s.image.nonMaxSuppressionPaddedAsync(a,o,l,p,g,v);return[w.selectedIndices,w.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:o,maxOutputSize:l,iouThreshold:p,scoreThreshold:g}=FP(t,e,r);return[yield s.image.nonMaxSuppressionAsync(a,o,l,p,g)]}case"Where":{const a=s.cast(se("condition",t,e,r),"bool"),o=[yield s.whereAsync(a)];return a.dispose(),o}case"ListDiff":return s.setdiff1dAsync(se("x",t,e,r),se("y",t,e,r));default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,i,s){return n.apply(this,arguments)}}(),vG=(n,t,e,r=tn)=>{switch(n.op){case"LowerBound":{const i=se("sortedSequence",n,t,e),s=se("values",n,t,e);return[r.lowerBound(i,s)]}case"TopKV2":{const i=se("x",n,t,e),s=se("k",n,t,e),a=se("sorted",n,t,e),o=r.topk(i,s,a);return[o.values,o.indices]}case"UpperBound":{const i=se("sortedSequence",n,t,e),s=se("values",n,t,e);return[r.upperBound(i,s)]}case"Unique":{const i=se("x",n,t,e),s=r.unique(i);return[s.values,s.indices]}case"UniqueV2":{const i=se("x",n,t,e),s=se("axis",n,t,e),a=r.unique(i,s);return[a.values,a.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},xG=(n,t,e,r=tn)=>{switch(n.op){case"Const":return t[n.name];case"PlaceholderWithDefault":const i=se("default",n,t,e);return[uo(n.name,t,e)||i];case"Placeholder":return[uo(n.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[Sp(se("x",n,t,e))];case"IdentityN":return se("x",n,t,e).map(g=>Sp(g));case"Shape":return[r.tensor1d(se("x",n,t,e).shape,"int32")];case"ShapeN":return se("x",n,t,e).map(g=>r.tensor1d(g.shape));case"Size":return[r.scalar(se("x",n,t,e).size,"int32")];case"Rank":return[r.scalar(se("x",n,t,e).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const a=se("x",n,t,e),o=se("data",n,t,e),l=se("message",n,t,e),p=se("summarize",n,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let g=0;g<o.length;g++)console.log(Array.prototype.slice.call(o[g].dataSync()).slice(0,p));return[a];default:throw TypeError(`Node type ${n.op} is not implemented`)}};class bG{get id(){return this.handle.id}constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=mr(0),this.tensorMap=new Map,so(this.handle)}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return mr(this.size(),"int32")}import(t,e){var r=this;return(0,Qe.Z)(function*(){r.checkKeyAndValueTensor(t,e);const i=yield t.data();return r.tensorMap.forEach(s=>s.dispose()),r.tensorMap.clear(),Lt(()=>{const s=Al(e),a=i.length,o=s.length;K(a===o,()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${o} elements.`);for(let l=0;l<a;l++){const p=i[l],g=s[l];so(g),r.tensorMap.set(p,g)}return r.handle})})()}find(t,e){var r=this;return(0,Qe.Z)(function*(){r.checkKeyAndValueTensor(t,e);const i=yield t.data();return Lt(()=>{const s=[];for(let a=0;a<i.length;a++){const l=r.findWithDefault(i[a],e);s.push(l)}return Wu(s)})})()}findWithDefault(t,e){return this.tensorMap.get(t)??e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}const wG=function(){var n=(0,Qe.Z)(function*(t,e,r,i){switch(t.op){case"HashTable":case"HashTableV2":{const s=i.getHashTableHandleByName(t.name);if(null!=s)return[s];{const a=se("keyDType",t,e,r),o=se("valueDType",t,e,r),l=new bG(a,o);return i.addHashTable(t.name,l),[l.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=se("tableHandle",t,e,r,i),a=se("keys",t,e,r),o=se("values",t,e,r);return[yield i.getHashTableById(s.id).import(a,o)]}case"LookupTableFind":case"LookupTableFindV2":{const s=se("tableHandle",t,e,r,i),a=se("keys",t,e,r),o=se("defaultValue",t,e,r);return[yield i.getHashTableById(s.id).find(a,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=se("tableHandle",t,e,r,i);return[i.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,i,s){return n.apply(this,arguments)}}(),_G=(n,t,e,r=tn)=>{switch(n.op){case"ResizeBilinear":{const i=se("images",n,t,e),s=se("size",n,t,e),a=se("alignCorners",n,t,e),o=se("halfPixelCenters",n,t,e);return[r.image.resizeBilinear(i,[s[0],s[1]],a,o)]}case"ResizeNearestNeighbor":{const i=se("images",n,t,e),s=se("size",n,t,e),a=se("alignCorners",n,t,e),o=se("halfPixelCenters",n,t,e);return[r.image.resizeNearestNeighbor(i,[s[0],s[1]],a,o)]}case"CropAndResize":{const i=se("image",n,t,e),s=se("boxes",n,t,e),a=se("boxInd",n,t,e),o=se("cropSize",n,t,e),l=se("method",n,t,e),p=se("extrapolationValue",n,t,e);return[r.image.cropAndResize(i,s,a,o,l,p)]}case"ImageProjectiveTransformV3":{const i=se("images",n,t,e),s=se("transforms",n,t,e),a=se("outputShape",n,t,e),o=se("fillValue",n,t,e),l=se("interpolation",n,t,e),p=se("fillMode",n,t,e);return[r.image.transform(i,s,l.toLowerCase(),p.toLowerCase(),o,a)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},NG=(n,t,e,r=tn)=>{switch(n.op){case"Equal":return[r.equal(se("a",n,t,e),se("b",n,t,e))];case"NotEqual":return[r.notEqual(se("a",n,t,e),se("b",n,t,e))];case"Greater":return[r.greater(se("a",n,t,e),se("b",n,t,e))];case"GreaterEqual":return[r.greaterEqual(se("a",n,t,e),se("b",n,t,e))];case"Less":return[r.less(se("a",n,t,e),se("b",n,t,e))];case"LessEqual":return[r.lessEqual(se("a",n,t,e),se("b",n,t,e))];case"LogicalAnd":return[r.logicalAnd(se("a",n,t,e),se("b",n,t,e))];case"LogicalNot":return[r.logicalNot(se("a",n,t,e))];case"LogicalOr":return[r.logicalOr(se("a",n,t,e),se("b",n,t,e))];case"Select":case"SelectV2":return[r.where(se("condition",n,t,e),se("a",n,t,e),se("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},SG=(n,t,e,r=tn)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(se("a",n,t,e),se("b",n,t,e),se("transposeA",n,t,e),se("transposeB",n,t,e))];case"Einsum":return[r.einsum(se("equation",n,t,e),...se("tensors",n,t,e))];case"Transpose":return[r.transpose(se("x",n,t,e),se("perm",n,t,e))];case"_FusedMatMul":const[i,s]=se("fusedOps",n,t,e),a="biasadd"===i,o="prelu"===s,l=se("numArgs",n,t,e),p=se("leakyreluAlpha",n,t,e);if(a){if(o&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[g,v]=se("args",n,t,e);return[r.fused.matMul({a:se("a",n,t,e),b:se("b",n,t,e),transposeA:se("transposeA",n,t,e),transposeB:se("transposeB",n,t,e),bias:g,activation:s,preluActivationWeights:v,leakyreluAlpha:p})];case"MatrixBandPart":return[r.linalg.bandPart(se("a",n,t,e),se("numLower",n,t,e),se("numUpper",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},EG=(n,t,e,r=tn)=>{switch(n.op){case"EuclideanNorm":return[r.euclideanNorm(se("x",n,t,e),se("axis",n,t,e),se("keepDims",n,t,e))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(se("x",n,t,e),se("mean",n,t,e),se("variance",n,t,e),se("offset",n,t,e),se("scale",n,t,e),se("epsilon",n,t,e))];case"LRN":return[r.localResponseNormalization(se("x",n,t,e),se("radius",n,t,e),se("bias",n,t,e),se("alpha",n,t,e),se("beta",n,t,e))];case"Softmax":return[r.softmax(se("x",n,t,e))];case"LogSoftmax":return[r.logSoftmax(se("x",n,t,e))];case"SparseToDense":return[r.sparseToDense(se("sparseIndices",n,t,e),se("outputShape",n,t,e),se("sparseValues",n,t,e),se("defaultValue",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},IG=(n,t,e,r=tn)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:i,outputDenseValues:s}=r.raggedGather(se("paramsNestedSplits",n,t,e),se("paramsDenseValues",n,t,e),se("indices",n,t,e),se("outputRaggedRank",n,t,e));return i.concat(s)}case"RaggedRange":{const{rtNestedSplits:i,rtDenseValues:s}=r.raggedRange(se("starts",n,t,e),se("limits",n,t,e),se("splits",n,t,e));return[i,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(se("shape",n,t,e),se("values",n,t,e),se("defaultValue",n,t,e),se("rowPartitionTensors",n,t,e),se("rowPartitionTypes",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},CG=(n,t,e,r=tn)=>{switch(n.op){case"Max":{const o=se("axis",n,t,e),l=se("keepDims",n,t,e);return[r.max(se("x",n,t,e),o,l)]}case"Mean":{const o=se("axis",n,t,e),l=se("keepDims",n,t,e);return[r.mean(se("x",n,t,e),o,l)]}case"Min":{const o=se("axis",n,t,e),l=se("keepDims",n,t,e);return[r.min(se("x",n,t,e),o,l)]}case"Sum":{const o=se("axis",n,t,e),l=se("keepDims",n,t,e);return[r.sum(se("x",n,t,e),o,l)]}case"All":{const o=se("axis",n,t,e),l=se("keepDims",n,t,e);return[r.all(se("x",n,t,e),o,l)]}case"Any":{const o=se("axis",n,t,e),l=se("keepDims",n,t,e);return[r.any(se("x",n,t,e),o,l)]}case"ArgMax":{const o=se("axis",n,t,e);return[r.argMax(se("x",n,t,e),o)]}case"ArgMin":{const o=se("axis",n,t,e);return[r.argMin(se("x",n,t,e),o)]}case"Prod":{const o=se("axis",n,t,e),l=se("keepDims",n,t,e);return[r.prod(se("x",n,t,e),o,l)]}case"Cumprod":{const o=se("axis",n,t,e),l=se("exclusive",n,t,e),p=se("reverse",n,t,e);return[r.cumprod(se("x",n,t,e),o,l,p)]}case"Cumsum":{const o=se("axis",n,t,e),l=se("exclusive",n,t,e),p=se("reverse",n,t,e);return[r.cumsum(se("x",n,t,e),o,l,p)]}case"Bincount":const i=se("x",n,t,e),s=se("weights",n,t,e),a=se("size",n,t,e);return[r.bincount(i,s,a)];case"DenseBincount":{const o=se("x",n,t,e),l=se("weights",n,t,e),p=se("size",n,t,e),g=se("binaryOutput",n,t,e);return[r.denseBincount(o,l,p,g)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},AG=(n,t,e,r=tn)=>{switch(n.op){case"ConcatV2":case"Concat":{const i=se("n",n,t,e),s=se("axis",n,t,e);let a=se("tensors",n,t,e);return a=a.slice(0,i),[r.concat(a,s)]}case"Gather":{const i=se("x",n,t,e),s=se("indices",n,t,e);return[r.gather(i,r.cast(s,"int32"),0)]}case"GatherV2":{const i=se("axis",n,t,e),s=se("batchDims",n,t,e),a=se("x",n,t,e),o=se("indices",n,t,e);return[r.gather(a,r.cast(o,"int32"),i,s)]}case"Reverse":{const i=se("dims",n,t,e),s=[];for(let o=0;o<i.length;o++)i[o]&&s.push(o);const a=se("x",n,t,e);return[r.reverse(a,s)]}case"ReverseV2":{const i=se("axis",n,t,e),s=se("x",n,t,e);return[r.reverse(s,i)]}case"Slice":{const i=se("begin",n,t,e),s=se("size",n,t,e);return[r.slice(se("x",n,t,e),i,s)]}case"StridedSlice":{const i=se("begin",n,t,e),s=se("end",n,t,e),a=se("strides",n,t,e),o=se("beginMask",n,t,e),l=se("endMask",n,t,e),p=se("ellipsisMask",n,t,e),g=se("newAxisMask",n,t,e),v=se("shrinkAxisMask",n,t,e),w=se("x",n,t,e);return[r.stridedSlice(w,i,s,a,o,l,p,g,v)]}case"Pack":return Lt(()=>{const i=se("axis",n,t,e),s=se("tensors",n,t,e),a=s[0].shape,o=r.squeeze(s[0]).shape,l=s.map(p=>{const g=Kt(p.shape,a);if(!g&&!Kt(r.squeeze(p).shape,o))throw new Error("the input tensors shape does not match");return g?p:r.reshape(p,a)});return[r.stack(l,i)]});case"Unpack":{const i=se("axis",n,t,e),s=se("tensor",n,t,e);return r.unstack(s,i)}case"Tile":{const i=se("reps",n,t,e);return[r.tile(se("x",n,t,e),i)]}case"Split":case"SplitV":{const i=se("axis",n,t,e),s=se("numOrSizeSplits",n,t,e),a=se("x",n,t,e);return r.split(a,s,i)}case"ScatterNd":{const i=se("indices",n,t,e),s=se("values",n,t,e),a=se("shape",n,t,e);return[r.scatterND(i,s,a)]}case"GatherNd":{const i=se("x",n,t,e),s=se("indices",n,t,e);return[r.gatherND(i,s)]}case"SparseToDense":{const i=se("sparseIndices",n,t,e),s=se("outputShape",n,t,e),a=se("sparseValues",n,t,e),o=se("defaultValue",n,t,e);return[r.sparseToDense(i,a,s,a.dtype===o.dtype?o:r.cast(o,a.dtype))]}case"TensorScatterUpdate":{const i=se("indices",n,t,e),s=se("values",n,t,e),a=se("tensor",n,t,e);return[r.tensorScatterUpdate(a,i,s)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},TG=(n,t,e,r=tn)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:i,outputValues:s,emptyRowIndicator:a,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(se("indices",n,t,e),se("values",n,t,e),se("denseShape",n,t,e),se("defaultValue",n,t,e));return[i,s,a,o]}case"SparseReshape":{const{outputIndices:i,outputShape:s}=r.sparse.sparseReshape(se("inputIndices",n,t,e),se("inputShape",n,t,e),se("newShape",n,t,e));return[i,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(se("data",n,t,e),se("indices",n,t,e),se("segmentIds",n,t,e))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(se("data",n,t,e),se("indices",n,t,e),se("segmentIds",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},MG=(n,t,e,r=tn)=>{switch(n.op){case"FFT":return[r.fft(se("x",n,t,e))];case"IFFT":return[r.ifft(se("x",n,t,e))];case"RFFT":return[r.rfft(se("x",n,t,e))];case"IRFFT":return[r.irfft(se("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},RG=(n,t,e,r=tn)=>{switch(n.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(se("input",n,t,e),se("pattern",n,t,e),se("rewrite",n,t,e),se("replaceGlobal",n,t,e))];case"StringNGrams":{const{nGrams:i,nGramsSplits:s}=r.string.stringNGrams(se("data",n,t,e),se("dataSplits",n,t,e),se("separator",n,t,e),se("nGramWidths",n,t,e),se("leftPad",n,t,e),se("rightPad",n,t,e),se("padWidth",n,t,e),se("preserveShortSequences",n,t,e));return[i,s]}case"StringSplit":{const{indices:i,values:s,shape:a}=r.string.stringSplit(se("input",n,t,e),se("delimiter",n,t,e),se("skipEmpty",n,t,e));return[i,s,a]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(se("input",n,t,e),se("numBuckets",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},DG=(n,t,e,r=tn)=>{switch(n.op){case"Cast":return[r.cast(se("x",n,t,e),se("dtype",n,t,e))];case"ExpandDims":{const i=se("axis",n,t,e);return[r.expandDims(se("x",n,t,e),i)]}case"Squeeze":{const i=se("axis",n,t,e);return[r.squeeze(se("x",n,t,e),i)]}case"Reshape":return[r.reshape(se("x",n,t,e),se("shape",n,t,e))];case"MirrorPad":return[r.mirrorPad(se("x",n,t,e),se("padding",n,t,e),se("mode",n,t,e))];case"PadV2":case"Pad":return[r.pad(se("x",n,t,e),se("padding",n,t,e),se("constantValue",n,t,e))];case"SpaceToBatchND":{const i=se("blockShape",n,t,e),s=se("paddings",n,t,e);return[r.spaceToBatchND(se("x",n,t,e),i,s)]}case"BatchToSpaceND":{const i=se("blockShape",n,t,e),s=se("crops",n,t,e);return[r.batchToSpaceND(se("x",n,t,e),i,s)]}case"DepthToSpace":{const i=se("blockSize",n,t,e),s=se("dataFormat",n,t,e).toUpperCase();return[r.depthToSpace(se("x",n,t,e),i,s)]}case"BroadcastTo":return[r.broadcastTo(se("x",n,t,e),se("shape",n,t,e))];case"BroadcastArgs":return[r.broadcastArgs(se("s0",n,t,e),se("s1",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function k$(n,t,e,r,i=Lt){const s=((a,o,l)=>{switch(a.category){case"arithmetic":return i(()=>oG(a,o,l));case"basic_math":return i(()=>uG(a,o,l));case"control":return dG(a,o,l);case"convolution":return i(()=>mG(a,o,l));case"creation":return i(()=>gG(a,o,l));case"dynamic":return yG(a,o,l);case"evaluation":return i(()=>vG(a,o,l));case"image":return i(()=>_G(a,o,l));case"graph":return i(()=>xG(a,o,l));case"logical":return i(()=>NG(a,o,l));case"matrices":return i(()=>SG(a,o,l));case"normalization":return i(()=>EG(a,o,l));case"ragged":return i(()=>IG(a,o,l));case"reduction":return i(()=>CG(a,o,l));case"slice_join":return i(()=>AG(a,o,l));case"sparse":return i(()=>TG(a,o,l));case"spectral":return i(()=>MG(a,o,l));case"string":return i(()=>RG(a,o,l));case"transformation":return i(()=>DG(a,o,l));case"hash_table":return wG(a,o,l,r);case"custom":const p=Ed(a.op);if(p&&p.customExecutor)return p.customExecutor(new aG(a,o,l));throw TypeError(`Custom op ${a.op} is not registered.`);default:throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,t,e);return Or(s)?s.then(a=>[].concat(a)):[].concat(s)}class P${constructor(t={},e={},r={},i={},s){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=r,this.functionMap=i,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const r=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(r))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}function F$(n,t,e,r){const i=new Set,s=[];let a=null,o=null;const l=new Set,p=new Set(Object.keys(n).map(w=>Eu(w)[0]));r=r||[];const g=new Set(r.map(w=>Eu(w.name)[0])),v=[...t];for(;v.length>0;){const w=v.pop();if((Ym(w)||zG(w)||UG(w))&&null==a&&(a=w,o=a.children.map(N=>N.name).filter(N=>i.has(N))),i.add(w.name),null==e[w.name]&&!p.has(w.name)&&!g.has(w.name)){if(0===w.inputs.length){s.push(w.name);continue}w.inputs.forEach(N=>{l.has(N.name)||(l.add(N.name),v.push(N))})}}return{inputs:n,outputs:t,usedNodes:i,missingInputs:s,dynamicNode:a,syncInputs:o}}class xC extends Error{constructor(t){super(`NodesExecutionOrderError: ${t}`)}}const LG=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),$G=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),BG=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Ym(n){return LG.has(n.op)}function zG(n){return $G.has(n.op)}function UG(n){return BG.has(n.op)}class bC{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map(r=>t[r].map(i=>i.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach(r=>{this._functionExecutorMap[r]=new bC(t.functions[r],this)})}getCompilationKey(t,e){const r=t.map(s=>s.name).sort(),i=e.map(s=>s.name).sort();return r.join(this.SEPARATOR)+"--"+i.join(this.SEPARATOR)}compile(t,e){const r=F$(t,e,this.weightMap,this._initNodes),{missingInputs:i,dynamicNode:s,syncInputs:a}=r;if(null!=s)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(i.length>0){const p=e.map(v=>v.name),g=Object.keys(t);throw new Error(`Cannot compute the outputs [${p}] from the provided inputs [${g}]. Missing the following inputs: [${i}]`)}const o=function OG(n,t){const{usedNodes:e,inputs:r}=t,a=k=>e.has("string"==typeof k?k:k.name);function o(k){return[...new Map(k.map(L=>[L.name,L])).values()]}const l=o([...Object.keys(r).map(k=>Eu(k)[0]).map(k=>n.nodes[k]),...n.weights,...n.initNodes||[]]).filter(a),p=o([...l,...Object.values(n.nodes)]).filter(a),g=new Map(p.map(k=>[k.name,k])),v={};for(const k of p){v[k.name]=v[k.name]||0;for(const L of k.children)a(L)||(v[L.name]=Number.POSITIVE_INFINITY),v[L.name]=(v[L.name]||0)+1}const w=Object.entries(v).filter(([,k])=>0===k).map(([k])=>k),N=[...w];for(;w.length>0;){const k=w.pop(),L=g.get(k);for(const $ of L.children.filter(a))0==--v[$.name]&&(N.push($.name),w.push($.name))}const O=function kG(n,t){const e=new Map(n.map(a=>[a.name,a])),r=t.map(a=>a.name),i=new Set(r);for(;r.length>0;){const a=r.pop(),o=e.get(a);for(const l of o.children)!e.has(l.name)||i.has(l.name)||(i.add(l.name),r.push(l.name))}return n.filter(a=>i.has(a.name))}(N.map(k=>g.get(k)),l);return function PG(n,t){const e=new Map(n.map((o,l)=>[o.name,l])),r=new Set(t.map(o=>o.name)),i=o=>r.has("string"==typeof o?o:o.name),s=new Set(n.map(o=>o.name)),a=o=>s.has("string"==typeof o?o:o.name);for(const o of n){for(const l of o.children.filter(a)){if(!e.has(l.name))throw new xC(`Child ${l.name} of node ${o.name} is unreachable.`);if(e.get(o.name)>e.get(l.name))throw new xC(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!i(o))for(const l of o.inputs){if(!e.has(l.name))throw new xC(`Input ${l.name} of node ${o.name} is unreachable.`);if(e.get(l.name)>e.get(o.name))throw new xC(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}(O,l),O}(this.graph,r),l=function FG(n){const t=new Map(n.map((o,l)=>[o.name,l])),e=Number.MAX_SAFE_INTEGER,r=n.map((o,l)=>Ym(o)?e:l),i=o=>r[t.get(o.name)]??-1,s=n.map((o,l)=>o.children.map(i).reduce((p,g)=>Math.max(p,g),r[l])),a=new Map;for(let o=0;o<n.length;++o){const l=s[o];if(l===e)continue;const p=n[o],g=n[l];a.has(g.name)||a.set(g.name,[]),a.get(g.name).push(p)}return a}(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(t){if(null==t)return null;const e=t.clone();return so(e),e}cloneTensorList(t){return t?t.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([e,r])=>[e,this.cloneTensorList(r)]))}execute(t,e){this.disposeIntermediateTensors(),t=this.mapInputs(t);const r=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const i=r.map(w=>this.graph.nodes[Eu(w)[0]]),s=e.map(w=>Eu(w)[0]),a=new Set(s);let o=s.map(w=>this.graph.nodes[w]);0===o.length&&(o=this._outputs);const l=this.getCompilationKey(i,o);let p=this.compiledMap.get(l);null==p&&(p=this.compile(t,o),this.compiledMap.set(l,p));try{this.keepIntermediateTensors=Pt().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(w){this.keepIntermediateTensors=!1,console.warn(w.message)}const g={},v={};return Lt(()=>{const w=new P$(this.weightMap,g,v,this.functionExecutorMap,this.parseNodeNameCache),N=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(L=>{const[$,U]=Eu(L,w),V=[];V[U]=t[L],N[$]=V,this.keepIntermediateTensors&&(this.clonedTensorsMap[$]=this.cloneTensorList(V))});const D=this.getFrozenTensorIds(N),{orderedNodes:O,nodeLiveUntilMap:k}=p;for(const L of O){if(N[L.name])continue;const $=k$(L,N,w,this._resourceManager);if(Or($))throw new Error(`The execution of the op '${L.op}' returned a promise. Please use model.executeAsync() instead.`);N[L.name]=$,this.keepIntermediateTensors&&(this.clonedTensorsMap[L.name]=this.cloneTensorList($)),this.checkTensorForDisposalWithNodeLiveUntilInfo(L,N,w,D,a,k.get(L.name))}return null==this.parent&&w.dispose(D),e.map(L=>uo(L,N,w))})}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map(r=>t[r]).map(r=>r.map(i=>i.id)));return new Set(e)}checkTensorForDisposal(t,e,r,i,s,a,o){if(!Ym(e)&&!a.has(t)){for(const l of r[t])null!=l&&(o[l.id]=(o[l.id]||0)+e.children.length);for(const l of e.inputs){if(Ym(l))continue;const p=bb(l.name,r,i);if(null!=p)for(const g of p){if(!g||g.kept||s.has(g.id))continue;const v=o[g.id];1===v?(g.dispose(),delete o[g.id]):null!=v&&o[g.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,e,r,i,s,a){function o(l){return Ym(l)||s.has(l.name)}if(!Ym(t)&&null!=a)for(const l of a){if(o(l))continue;const p=bb(l.name,e,r);for(const g of p)!g||g.kept||i.has(g.id)||g.dispose()}}executeAsync(t,e){var r=this;return(0,Qe.Z)(function*(){return r._executeAsync(t,e)})()}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(const e of t)e&&!e.isDisposed&&e.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}_executeAsync(t,e,r=!1,i={},s={}){var a=this;return(0,Qe.Z)(function*(){a.disposeIntermediateTensors(),r||(t=a.mapInputs(t),a.checkInputs(t),a.checkInputShapeAndType(t),e=a.mapOutputs(e),a.checkOutputs(e));try{a.keepIntermediateTensors=Pt().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(N){a.keepIntermediateTensors=!1,console.warn(N.message)}const o=new P$(a.weightMap,i,s,a.functionExecutorMap,a.parseNodeNameCache);a.keepIntermediateTensors&&(a.clonedTensorsMap=a.cloneTensorMap(a.weightMap));const l=yield a.executeWithControlFlow(t,o,e,r),p=e.map(N=>uo(N,l,o)),g=p.map(N=>N.id),v=Object.keys(t).map(N=>t[N].id),w=new Set([...g,...v,...a.weightIds]);return Object.values(l).forEach(N=>{N.forEach(D=>{D&&!D.isDisposed&&!w.has(D.id)&&D.dispose()})}),null==a.parent&&o.dispose(w),p})()}executeFunctionAsync(t,e,r){var i=this;return(0,Qe.Z)(function*(){const s=t.reduce((a,o,l)=>(a[i.inputs[l].name]=o,a),{});return i._executeAsync(s,i.outputNodes,!0,e,r)})()}executeWithControlFlow(t,e,r,i){var s=this;return(0,Qe.Z)(function*(){const a=Object.keys(t),o=a.map(W=>s.graph.nodes[Eu(W)[0]]),l=r.map(W=>Eu(W)[0]),p=new Set(l);let g=l.map(W=>s.graph.nodes[W]);0===g.length&&(g=s._outputs);const{usedNodes:v,missingInputs:w,dynamicNode:N,syncInputs:D}=F$(t,g,s.weightMap,s._initNodes),O=[...o,...s.graph.weights,...s._initNodes||[]].map(W=>({node:W,contexts:e.currentContext})),k=Object.assign({},s.weightMap);Object.keys(t).forEach(W=>{const[ce,ve]=Eu(W),Ee=[];Ee[ve]=t[W],k[ce]=Ee});const L={},$=s.getFrozenTensorIds(k),U={};for(;O.length>0;){const W=s.processStack(o,O,e,k,U,$,p,L,v);yield Promise.all(W)}null==N&&!i&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const V=g.filter(W=>!Ym(W)&&!uo(W.name,k,e)).map(W=>W.name);if(V.length>0){let W="";throw null!=N&&(W=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${D}]`),new Error(`Cannot compute the outputs [${V}] from the provided inputs [${a}]. Consider providing the following inputs: [${w}]. ${W}`)}return k})()}processStack(t,e,r,i,s,a,o,l,p){const g=[];for(;e.length>0;){const v=e.pop();r.currentContext=v.contexts;let w="";if("Enter"===v.node.op&&se("isConstant",v.node,i,r)&&([w]=Bc(v.node.name,r)),null==i[v.node.name]){const N=k$(v.node,i,r,this._resourceManager);w||([w]=Bc(v.node.name,r));const D=r.currentContext;Or(N)?g.push(N.then(O=>(i[w]=O,this.keepIntermediateTensors&&(this.clonedTensorsMap[w]=this.cloneTensorList(O)),r.currentContext=D,this.checkTensorForDisposal(w,v.node,i,r,a,o,l),this.processChildNodes(v.node,e,r,i,s,p),O))):(i[w]=N,this.keepIntermediateTensors&&(this.clonedTensorsMap[w]=this.cloneTensorList(N)),this.checkTensorForDisposal(w,v.node,i,r,a,o,l),this.processChildNodes(v.node,e,r,i,s,p))}else this.processChildNodes(v.node,e,r,i,s,p)}return g}processChildNodes(t,e,r,i,s,a){t.children.forEach(o=>{const[l]=Bc(o.name,r);s[l]||!a.has(o.name)||("Merge"===o.op?o.inputNames.some(p=>!!uo(p,i,r))&&(s[l]=!0,e.push({contexts:r.currentContext,node:o})):o.inputNames.every(p=>!!uo(p,i,r))&&(s[l]=!0,e.push({contexts:r.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{const r=t[e],[i]=Eu(e),s=this.graph.nodes[i];if(s.attrParams.shape&&s.attrParams.shape.value){const a=s.attrParams.shape.value;K(a.length===r.shape.length&&r.shape.every((l,p)=>-1===a[p]||a[p]===l),()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${a}], but was [${r.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&K(r.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(t){var e,r;const i={};for(const s in t){const a=null===(r=null===(e=this._signature)||void 0===e?void 0:e.inputs)||void 0===r?void 0:r[s];null!=a?i[a.name]=t[s]:i[s]=t[s]}return i}checkInputs(t){const e=Object.keys(t).filter(r=>{const[i]=Eu(r);return null==this.graph.nodes[i]});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>{var r,i;const s=null===(i=null===(r=this._signature)||void 0===r?void 0:r.outputs)||void 0===i?void 0:i[e];return null!=s?s.name:e},{})}checkOutputs(t){t.forEach(e=>{const[r]=Eu(e);if(!this.graph.nodes[r])throw new Error(`The output '${e}' is not found in the graph`)})}}class VG{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}const GG="?tfjs-format=file",qG="model.json";class LP{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,e={},r=ye){this.modelUrl=t,this.loadOptions=e,this.version="n/a",this.io=r,null==e&&(this.loadOptions={}),this.resourceManager=new VG}findIOHandler(){const t=this.modelUrl;if(null!=t.load)this.handler=t;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const e=this.io.getLoadHandlers(t,this.loadOptions);if(0===e.length)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return Or(t)?t.then(e=>this.loadSync(e)):this.loadSync(t)}loadSync(t){this.artifacts=t;const e=this.artifacts.modelTopology;let r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const s=this.artifacts.userDefinedMetadata;null!=s.signature&&(r=s.signature),null!=s.structuredOutputKeys&&(this.structuredOutputKeys=s.structuredOutputKeys)}this.signature=r,this.version=`${e.versions.producer}.${e.versions.minConsumer}`;const i=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new bC(A$.Instance.transformGraph(e,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(i),this.executor.resourceManager=this.resourceManager,null!=t.modelInitializer&&null!=t.modelInitializer.node){const s=A$.Instance.transformGraph(t.modelInitializer);this.initializer=new bC(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}save(t,e){var r=this;return(0,Qe.Z)(function*(){if("string"==typeof t){const i=r.io.getSaveHandlers(t);if(0===i.length)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(i.length>1)throw new Error(`Found more than one (${i.length}) save handlers for URL '${t}'`);t=i[0]}if(null==t.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(r.artifacts)})()}addStructuredOutputNames(t){if(this.structuredOutputKeys){const r={};return(t instanceof Xi?[t]:t).forEach((i,s)=>r[this.structuredOutputKeys[s]]=i),r}return t}predict(t,e){const r=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(r)}predictAsync(t,e){var r=this;return(0,Qe.Z)(function*(){const i=yield r.executeAsync(t,r.outputNodes);return r.addStructuredOutputNames(i)})()}normalizeInputs(t){var e;if(!(t instanceof Xi||Array.isArray(t))){const s=null===(e=this.signature)||void 0===e?void 0:e.inputs;if(null!=s)for(const a in s){const o=s[a];null!=o.resourceId&&(t[a]=this.resourceIdToCapturedInput[o.resourceId])}return t}t=Array.isArray(t)?t:[t];const r=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${t.length} input tensors provided.`);let i=0;return this.inputNodes.reduce((s,a)=>{var o,l,p;const g=null===(p=null===(l=null===(o=this.signature)||void 0===o?void 0:o.inputs)||void 0===l?void 0:l[a])||void 0===p?void 0:p.resourceId;return s[a]=null!=g?this.resourceIdToCapturedInput[g]:t[i++],s},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return null==this.initializer?[]:this.initializer.execute({},null==this.initializerSignature?[]:Object.keys(this.initializerSignature.outputs))}executeInitializerGraphAsync(){var t=this;return(0,Qe.Z)(function*(){return null==t.initializer?[]:t.initializer.executeAsync({},null==t.initializerSignature?[]:Object.keys(t.initializerSignature.outputs))})()}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const e=this.initializerSignature.outputs,r=Object.keys(e);for(let i=0;i<r.length;i++)this.resourceIdToCapturedInput[e[r[i]].resourceId]=t[i]}}execute(t,e){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const r=this.executor.execute(t,e);return r.length>1?r:r[0]}executeAsync(t,e){var r=this;return(0,Qe.Z)(function*(){null==r.resourceIdToCapturedInput&&r.setResourceIdToCapturedInput(yield r.executeInitializerGraphAsync()),t=r.normalizeInputs(t),e=r.normalizeOutputs(e);const i=yield r.executor.executeAsync(t,e);return i.length>1?i:i[0]})()}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,r)=>(e[r]=[t[r]],e),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Lr(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}function WG(n){return $P.apply(this,arguments)}function $P(){return($P=(0,Qe.Z)(function*(n,t={},e=ye){if(null==n)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof n&&(n=function XG(n){return n.endsWith("/")||(n+="/"),`${n}${qG}${GG}`}(n));const r=new LP(n,t,e);return yield r.load(),r})).apply(this,arguments)}function HG(n){if(null==n)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(n instanceof Array){const[r,i]=n;if(!r)throw new Error("modelJSON must be the first element of the array");if(!(i&&i instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");t=qf(Hr(r,Sg(r.weightsManifest),i))}else if("load"in n)t=n;else{if(!("modelTopology"in n&&"weightSpecs"in n&&"weightData"in n))throw new Error("Unknown model format");t=qf(n)}const e=new LP(t);return e.load(),e}const L$="4.4.0";function wC(n,t,e=new Map,r=new Set){if(null==n)return null;if("function"==typeof Blob&&n instanceof Blob)return n.slice();if(r.has(n))throw new Error("Circular references are not supported.");if(e.has(n))return e.get(n);const i=t(n);if(i.recurse&&null!==i.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(i.recurse){if(Ny(n)){const s=Array.isArray(n)?[]:{};r.add(n);for(const a in n){const l=wC(n[a],t,e,r);s[a]=l}return r.delete(n),n.__proto__&&(s.__proto__=n.__proto__),s}throw new Error(`Can't recurse into non-iterable type: ${n}`)}return e.set(n,i.value),i.value}function YG(n,t=B$){return $$(n,t)}function $$(n,t,e=new Set){const r=n[0];if(e.has(r))throw new Error("Circular references are not supported.");const i=t(n);if(i.recurse&&null!==i.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(i.recurse){if(Ny(r)){const s=Array.isArray(r)?[]:{};e.add(r);for(const a in r){const l=$$(n.map(p=>p[a]),t,e);s[a]=l}return e.delete(r),s}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return i.value}function B$(n){return null===n?null:Ny(n[0])?{value:null,recurse:!0}:{value:n,recurse:!1}}function z$(n,t){return BP.apply(this,arguments)}function BP(){return(BP=(0,Qe.Z)(function*(n,t){const e=new Map;wC(n,t,e);for(const i of Array.from(e.keys())){const s=e.get(i);if(Or(s)){const a=yield s;e.set(i,a)}}return wC(n,t,e)})).apply(this,arguments)}function Ny(n){let t=!1;if(Pt().get("IS_BROWSER"))t=n instanceof TextDecoder;else{const{StringDecoder:e}=nn(8963);t=n instanceof e}return null!=n&&!ArrayBuffer.isView(n)&&(Array.isArray(n)||"object"==typeof n&&!(n instanceof Xi)&&!(n instanceof Promise)&&!t)}function QG(n){return n instanceof Xi?{value:n.clone(),recurse:!1}:Ny(n)?{value:null,recurse:!0}:{value:n,recurse:!1}}class U${constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.wrap(this.begin+t),r=this.get(e);return this.set(e,this.pop()),r}}let eq=(()=>{class n extends U${constructor(){super(n.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,r=new Array(e),i=this.length();for(let s=0;s<i;s++)r[s]=this.get(this.wrap(this.begin+s));this.data=r,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=i}}return n.INITIAL_CAPACITY=32,n})();function V$(n){return new nq(n)}function _b(n){return new rq(n)}class au{toArray(){var t=this;return(0,Qe.Z)(function*(){const e=[];let r=yield t.next();for(;!r.done;)e.push(r.value),r=yield t.next();return e})()}toArrayForTest(){var t=this;return(0,Qe.Z)(function*(){const e=t.prefetch(100),r=[];let i=yield e.next();for(;!i.done;)r.push(i.value),i=yield e.next();return r})()}resolveFully(){var t=this;return(0,Qe.Z)(function*(){let e=yield t.next();for(;!e.done;)e=yield t.next()})()}resolveWhile(t){var e=this;return(0,Qe.Z)(function*(){let r=yield e.next(),i=t(r.value);for(;!r.done&&i;)r=yield e.next(),i=t(r.value)})()}handleErrors(t){return new cq(this,t)}filter(t){return new uq(this,t)}map(t){return new lq(this,t)}mapAsync(t){return new q$(this,t)}serialMapAsync(t){return new q$(this,t).serial()}flatmap(t){return new fq(this,t)}forEachAsync(t){var e=this;return(0,Qe.Z)(function*(){return e.map(t).resolveFully()})()}serialForEach(t){var e=this;return(0,Qe.Z)(function*(){return e.serialMapAsync(t).resolveWhile(r=>!0===r)})()}rowMajorBatch(t,e=!0){return new oq(this,t,e)}columnMajorBatch(t,e=!0,r=B$){return this.rowMajorBatch(t,e).map(s=>YG(s,r))}concatenate(t,e){return new W$(V$([this,t]),e)}take(t){return t<0||null==t?this:new aq(this,t)}skip(t){return t<0||null==t?this:new sq(this,t)}prefetch(t){return new H$(this,t)}shuffle(t,e){return new pq(this,t,e)}serial(){return new iq(this)}}class nq extends au{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}next(){var t=this;return(0,Qe.Z)(function*(){if(t.trav>=t.items.length)return{value:null,done:!0};const e=t.items[t.trav];return t.trav++,{value:(n=e,function KG(n,t){return wC(n,t)}(n,QG)),done:!1};var n})()}}class rq extends au{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}next(){var t=this;return(0,Qe.Z)(function*(){try{return t.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}})()}}class iq extends au{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}next(){var t=this;return(0,Qe.Z)(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return(0,Qe.Z)(function*(){return t.upstream.next()})()}}class sq extends au{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}next(){var t=this;return(0,Qe.Z)(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return(0,Qe.Z)(function*(){for(;t.count++<t.maxCount;){const e=yield t.upstream.next();if(e.done)return e;Lr(e.value)}return t.upstream.next()})()}}class aq extends au{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}next(){var t=this;return(0,Qe.Z)(function*(){return t.count++>=t.maxCount?{value:null,done:!0}:t.upstream.next()})()}}class oq extends au{constructor(t,e,r=!0){super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=r,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}next(){var t=this;return(0,Qe.Z)(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return(0,Qe.Z)(function*(){const e=[];for(;e.length<t.batchSize;){const r=yield t.upstream.next();if(r.done)return t.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(r.value)}return{value:e,done:!1}})()}}class uq extends au{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}next(){var t=this;return(0,Qe.Z)(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return(0,Qe.Z)(function*(){for(;;){const e=yield t.upstream.next();if(e.done||t.predicate(e.value))return e;Lr(e.value)}})()}}class lq extends au{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Map`}next(){var t=this;return(0,Qe.Z)(function*(){const e=yield t.upstream.next();if(e.done)return{value:null,done:!0};const r=zf(e.value),i=t.transform(e.value),s=zf(i);for(const a of r)wg(a,s)||a.dispose();return{value:i,done:!1}})()}}class cq extends au{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}next(){var t=this;return(0,Qe.Z)(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return(0,Qe.Z)(function*(){for(;;)try{return yield t.upstream.next()}catch(e){if(!t.handler(e))return{value:null,done:!0}}})()}}class q$ extends au{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> AsyncMap`}next(){var t=this;return(0,Qe.Z)(function*(){const e=yield t.upstream.next();if(e.done)return{value:null,done:!0};const r=zf(e.value),i=yield t.transform(e.value),s=zf(i);for(const a of r)wg(a,s)||a.dispose();return{value:i,done:!1}})()}}class zP extends au{constructor(){super(),this.outputQueue=new eq,this.lastRead=Promise.resolve({value:null,done:!1})}next(){var t=this;return(0,Qe.Z)(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}serialNext(){var t=this;return(0,Qe.Z)(function*(){for(;0===t.outputQueue.length();)if(!(yield t.pump()))return{value:null,done:!0};return{value:t.outputQueue.shift(),done:!1}})()}}class fq extends zP{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Flatmap`}pump(){var t=this;return(0,Qe.Z)(function*(){const e=yield t.upstream.next();if(e.done)return!1;const r=zf(e.value),i=t.transform(e.value),s=zf(i);t.outputQueue.pushAll(i);for(const a of r)wg(a,s)||a.dispose();return!0})()}}class W$ extends au{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}next(){var t=this;return(0,Qe.Z)(function*(){return t.lastRead=t.readFromChain(t.lastRead),t.lastRead})()}readFromChain(t){var e=this;return(0,Qe.Z)(function*(){if(yield t,null==e.iterator){const i=yield e.moreIterators.next();if(i.done)return{value:null,done:!0};e.iterator=i.value,null!=e.baseErrorHandler&&(e.iterator=e.iterator.handleErrors(e.baseErrorHandler))}const r=yield e.iterator.next();return r.done?(e.iterator=null,e.readFromChain(t)):r})()}}var Ep=(()=>{return(n=Ep||(Ep={}))[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST",Ep;var n})();class hq extends au{constructor(t,e=Ep.FAIL){super(),this.iterators=t,this.mismatchMode=e,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}nextState(t){var e=this;return(0,Qe.Z)(function*(){yield t;let r=0,i=0;const a=yield z$(e.iterators,function s(o){return o instanceof au?{value:o.next().then(p=>(r++,p.done&&i++,p.value)),recurse:!1}:{value:null,recurse:!0}});if(r===i)return{value:null,done:!0};if(i>0)switch(e.mismatchMode){case Ep.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${e.count}.`);case Ep.SHORTEST:return{value:null,done:!0}}return e.count++,{value:a,done:!1}})()}next(){var t=this;return(0,Qe.Z)(function*(){return t.currentPromise=t.nextState(t.currentPromise),t.currentPromise})()}}class H$ extends au{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new U$(e)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class pq extends H${constructor(t,e,r){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=rd.alea(r||Fs().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}next(){var t=this;return(0,Qe.Z)(function*(){return t.lastRead=t.lastRead.then(()=>t.serialNext()),t.lastRead})()}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}serialNext(){var t=this;return(0,Qe.Z)(function*(){for(t.upstreamExhausted||t.refill();!t.buffer.isEmpty();){const e=t.chooseIndex(),r=yield t.buffer.shuffleExcise(e);if(!r.done)return t.refill(),r;t.upstreamExhausted=!0}return{value:null,done:!0}})()}}let Nb=(()=>{class n{constructor(){this.size=null}batch(e,r=!0){const i=this;let s;return K(e>0,()=>`batchSize needs to be positive, but it is\n      ${e}`),s=this.size===1/0||null==this.size?this.size:r?Math.ceil(this.size/e):Math.floor(this.size/e),lc((0,Qe.Z)(function*(){return(yield i.iterator()).columnMajorBatch(e,r,gq)}),s)}concatenate(e){const r=this;let i;return i=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,lc((0,Qe.Z)(function*(){return(yield r.iterator()).concatenate(yield e.iterator())}),i)}filter(e){const r=this;let i;return i=this.size===1/0?1/0:null,lc((0,Qe.Z)(function*(){return(yield r.iterator()).filter(s=>Lt(()=>e(s)))}),i)}forEachAsync(e){var r=this;return(0,Qe.Z)(function*(){return(yield r.iterator()).forEachAsync(e)})()}map(e){const r=this;return lc((0,Qe.Z)(function*(){return(yield r.iterator()).map(i=>Lt(()=>e(i)))}),this.size)}mapAsync(e){const r=this;return lc((0,Qe.Z)(function*(){return(yield r.iterator()).mapAsync(e)}),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const r=this;return lc((0,Qe.Z)(function*(){return(yield r.iterator()).prefetch(e)}),this.size)}repeat(e){const r=this;let i;return i=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,lc((0,Qe.Z)(function*(){return function G$(n,t){return new W$(n,t)}(_b((0,Qe.Z)(function*(){return{value:yield r.iterator(),done:!1}})).take(e))}),i)}skip(e){const r=this;let i;return i=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,lc((0,Qe.Z)(function*(){return(yield r.iterator()).skip(e)}),i)}shuffle(e,r,i=!0){if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const s=this,a=rd.alea(r||Fs().toString());return lc((0,Qe.Z)(function*(){let o=a.int32();return i&&(o+=a.int32()),(yield s.iterator()).shuffle(e,o.toString())}),this.size)}take(e){const r=this;let i;return i=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,lc((0,Qe.Z)(function*(){return(yield r.iterator()).take(e)}),i)}toArray(){var e=this;return(0,Qe.Z)(function*(){if(e.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(yield e.iterator()).toArray()})()}toArrayForTest(){var e=this;return(0,Qe.Z)(function*(){if(e.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(yield e.iterator()).toArrayForTest()})()}}return n.MAX_BUFFER_SIZE=1e4,n})();function lc(n,t=null){return new class extends Nb{constructor(){super(...arguments),this.size=t}iterator(){return(0,Qe.Z)(function*(){return n()})()}}}function dq(n){return lc((0,Qe.Z)(function*(){return V$(n)}),n.length)}function mq(n){if(!Ny(n))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(n))for(let e=0;e<n.length;e++)t=null==t?n[e].size:Math.min(t,n[e].size);else if(n instanceof Object)for(const e in n)t=null==t?n[e].size:Math.min(t,n[e].size);return lc((0,Qe.Z)(function*(){return function tq(n,t=Ep.FAIL){return new hq(n,t)}(yield z$(n,r=>{if(r instanceof Nb)return{value:r.iterator(),recurse:!1};if(Ny(r))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")}),Ep.SHORTEST)}),t)}function gq(n){return null===n?null:function ZG(n){return null==n||function jG(n){return null===n||"object"!=typeof n&&"function"!=typeof n}(n)||Array.isArray(n)||"object"==typeof n&&n instanceof Xi||yo(n)}(n[0])?{value:yq(n),recurse:!1}:{value:null,recurse:!0}}function yq(n){if(0===n.length)throw new Error("Can't make a batch of zero elements.");return n[0]instanceof Xi?Wu(n):al(n)}class X$ extends Nb{constructor(t){super(),this.input=t}iterator(){var t=this;return(0,Qe.Z)(function*(){return(yield t.input.iterator()).decodeUTF8().split("\n").map(s=>(s.endsWith("\r")&&(s=s.slice(0,-1)),s))})()}}const Sb=Symbol("out"),K$=Symbol("field"),NC=Symbol("quote"),UP=Symbol("quoteafterquote"),Y$=Symbol("quoteinquote");class Z$ extends Nb{columnNames(){var t=this;return(0,Qe.Z)(function*(){return t.columnNamesValidated||(yield t.setColumnNames()),t.configuredColumnsOnly?Object.keys(t.columnConfigs):t.fullColumnNames})()}setColumnNames(){var t=this;return(0,Qe.Z)(function*(){const e=yield t.maybeReadHeaderLine();if(!t.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");t.fullColumnNames&&e&&K(e.length===t.fullColumnNames.length,()=>"The length of provided columnNames ("+t.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),t.fullColumnNames||(t.fullColumnNames=e);const r=t.fullColumnNames.reduce((s,a)=>(s[a]=s[a]+1||1,s),{}),i=Object.keys(r).filter(s=>r[s]>1);if(K(0===i.length,()=>"Duplicate column names found: "+i.toString()),t.columnConfigs)for(const s of Object.keys(t.columnConfigs))if(-1===t.fullColumnNames.indexOf(s))throw new Error('The key "'+s+'" provided in columnConfigs does not match any of the column names ('+t.fullColumnNames.toString()+").");t.columnNamesValidated=!0})()}maybeReadHeaderLine(){var t=this;return(0,Qe.Z)(function*(){if(t.hasHeader){const r=yield(yield t.base.iterator()).next();if(r.done)throw new Error("No data was found for CSV parsing.");return t.parseRow(r.value,!1)}return null})()}constructor(t,e){super(),this.input=t,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new X$(t),e||(e={}),this.hasHeader=!1!==e.hasHeader,this.fullColumnNames=e.columnNames,this.columnConfigs=e.columnConfigs,this.configuredColumnsOnly=e.configuredColumnsOnly,e.delimWhitespace?(K(null==e.delimiter,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=e.delimiter?e.delimiter:","}iterator(){var t=this;return(0,Qe.Z)(function*(){t.columnNamesValidated||(yield t.setColumnNames());let e=yield t.base.iterator();return t.hasHeader&&(e=e.skip(1)),e.map(r=>t.makeDataElement(r))})()}makeDataElement(t){const e=this.parseRow(t),r={},i={};for(let s=0;s<this.fullColumnNames.length;s++){const a=this.fullColumnNames[s],o=this.columnConfigs?this.columnConfigs[a]:null;if(!this.configuredColumnsOnly||o){const l=e[s];let p=null;if(""===l)if(o&&void 0!==o.default)p=o.default;else{if(o&&(o.required||o.isLabel))throw new Error(`Required column ${a} is empty in this line: ${t}`);p=void 0}else{const g=Number(l);if(isNaN(g))p=o&&"bool"===o.dtype?this.getBoolean(l):l;else if(o&&o.dtype)switch(o.dtype){case"float32":default:p=g;break;case"int32":p=Math.floor(g);break;case"bool":p=this.getBoolean(l)}else p=g}o&&o.isLabel?i[a]=p:r[a]=p}}return 0===Object.keys(i).length?r:{xs:r,ys:i}}getBoolean(t){return"1"===t||"true"===t.toLowerCase()?1:0}parseRow(t,e=!0){const r=[];let i=0;const s=t.length;let a=Sb;for(let o=0;o<s;o++)switch(a){case Sb:switch(t.charAt(o)){case'"':i=o+1,a=NC;break;case this.delimiter:if(i=o+1," "===this.delimiter&&this.delimWhitespace)break;r.push(""),a=Sb;break;default:a=K$,i=o}break;case K$:t.charAt(o)===this.delimiter&&(r.push(t.substring(i,o)),a=Sb,i=o+1);break;case NC:'"'===t.charAt(o)&&(a=UP);break;case UP:switch(t.charAt(o)){case this.delimiter:r.push(t.substring(i,o-1)),a=Sb,i=o+1;break;case'"':a=NC;break;default:a=Y$}break;case Y$:'"'===t.charAt(o)&&(a=NC)}if(r.push(a===UP?t.substring(i,s-1):t.substring(i)),e&&r.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${r}`);return r}}class VP extends au{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;const e=Math.log2(this.fftSize);if(this.fftSize<0||e<4||e>14||!Number.isInteger(e))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=!1!==t.includeSpectrogram,this.includeWaveform=!0===t.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static create(t={}){return(0,Qe.Z)(function*(){if(!Pt().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");const e=new VP(t);return yield e.start(),e})()}start(){var t=this;return(0,Qe.Z)(function*(){try{t.stream=yield navigator.mediaDevices.getUserMedia({audio:null==t.audioTrackConstraints||t.audioTrackConstraints,video:!1})}catch(i){throw new Error(`Error thrown while initializing video stream: ${i.message}`)}if(!t.stream)throw new Error("Could not obtain audio from microphone.");const e=window.AudioContext||window.webkitAudioContext;if(t.audioContext=new e,t.sampleRateHz){if(t.audioContext.sampleRate!==t.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${t.sampleRateHz}; Actual: ${t.audioContext.sampleRate}`)}else t.sampleRateHz=t.audioContext.sampleRate;const r=t.audioContext.createMediaStreamSource(t.stream);t.analyser=t.audioContext.createAnalyser(),t.analyser.fftSize=2*t.fftSize,t.analyser.smoothingTimeConstant=t.smoothingTimeConstant,r.connect(t.analyser),t.freqData=new Float32Array(t.fftSize),t.timeData=new Float32Array(t.fftSize)})()}next(){var t=this;return(0,Qe.Z)(function*(){if(t.isClosed)return{value:null,done:!0};let e,r;const i=yield t.getAudioData();if(t.includeSpectrogram){const s=t.flattenQueue(i.freqDataQueue);e=t.getTensorFromAudioDataArray(s,[t.numFrames,t.columnTruncateLength,1])}if(t.includeWaveform){const s=t.flattenQueue(i.timeDataQueue);r=t.getTensorFromAudioDataArray(s,[t.numFrames*t.fftSize,1])}return{value:{spectrogram:e,waveform:r},done:!1}})()}capture(){var t=this;return(0,Qe.Z)(function*(){return(yield t.next()).value})()}getAudioData(){var t=this;return(0,Qe.Z)(function*(){const e=[],r=[];let i=0;return new Promise(s=>{const a=setInterval(()=>{t.includeSpectrogram&&(t.analyser.getFloatFrequencyData(t.freqData),t.freqData[0]===-1/0&&s({freqDataQueue:e,timeDataQueue:r}),e.push(t.freqData.slice(0,t.columnTruncateLength))),t.includeWaveform&&(t.analyser.getFloatTimeDomainData(t.timeData),r.push(t.timeData.slice())),++i===t.numFrames&&(clearInterval(a),s({freqDataQueue:e,timeDataQueue:r}))},t.fftSize/t.sampleRateHz*1e3)})})()}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){const e=t[0].length,r=new Float32Array(t.length*e);return t.forEach((i,s)=>r.set(i,s*e)),r}getTensorFromAudioDataArray(t,e){const r=new Float32Array(ft(e));return r.set(t,r.length-t.length),al(r,e)}}class GP extends au{constructor(t,e){if(super(),this.webcamVideoElement=t,this.webcamConfig=e,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=bo([0],"int32"),this.webcamConfig.centerCrop){const r=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,i=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,s=(1-r)/2,a=(1-i)/2;this.cropBox=jf([a,s,i+a,s+r],[1,4])}else this.cropBox=jf([0,0,1,1],[1,4])}summary(){return"webcam"}static create(t,e={}){return(0,Qe.Z)(function*(){if(!Pt().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!e.resizeWidth||!e.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=e.resizeWidth,t.height=e.resizeHeight}const r=new GP(t,e);return yield r.start(),r})()}start(){var t=this;return(0,Qe.Z)(function*(){t.webcamConfig.facingMode&&K("user"===t.webcamConfig.facingMode||"environment"===t.webcamConfig.facingMode,()=>`Invalid webcam facing mode: ${t.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{t.stream=yield navigator.mediaDevices.getUserMedia({video:{deviceId:t.webcamConfig.deviceId,facingMode:t.webcamConfig.facingMode?t.webcamConfig.facingMode:"user",width:t.webcamVideoElement.width,height:t.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!t.stream)throw new Error("Could not obtain video from webcam.");try{t.webcamVideoElement.srcObject=t.stream}catch(e){console.log(e),t.webcamVideoElement.src=window.URL.createObjectURL(t.stream)}return t.webcamVideoElement.play(),t.isClosed=!1,new Promise(e=>{t.webcamVideoElement.onloadedmetadata=()=>{e()}})})()}next(){var t=this;return(0,Qe.Z)(function*(){if(t.isClosed)return{value:null,done:!0};let e;try{e=l_(t.webcamVideoElement)}catch(r){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(r)}`)}if(!t.resize)return{value:e,done:!1};try{return{value:t.cropAndResizeFrame(e),done:!1}}catch(r){throw new Error(`Error thrown cropping the video: ${r.message}`)}finally{e.dispose()}})()}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(t){return Lt(()=>{const e=tu(_n(t,"float32"),0);let r;return r=ec.cropAndResize(e,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear"),St(r,r.shape.slice(1))})}capture(){var t=this;return(0,Qe.Z)(function*(){return(yield t.next()).value})()}stop(){this.stream.getTracks().forEach(e=>e.stop());try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}class j${}class J$ extends au{split(t){return new vq(this,t)}}class vq extends J${constructor(t,e){super(),this.upstream=t,this.impl=new xq(t,e)}summary(){return this.impl.summary()}next(){var t=this;return(0,Qe.Z)(function*(){return t.impl.next()})()}}class xq extends zP{constructor(t,e){super(),this.upstream=t,this.separator=e,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}pump(){var t=this;return(0,Qe.Z)(function*(){const e=yield t.upstream.next();if(e.done)return""!==t.carryover&&(t.outputQueue.push(t.carryover),t.carryover="",!0);const r=e.value.split(t.separator);r[0]=t.carryover+r[0];for(const i of r.slice(0,-1))t.outputQueue.push(i);return t.carryover=r[r.length-1],!0})()}}class bq extends au{decodeUTF8(){return new wq(this)}}class wq extends J${constructor(t){super(),this.upstream=t,this.impl=new _q(t)}summary(){return this.impl.summary()}next(){var t=this;return(0,Qe.Z)(function*(){return t.impl.next()})()}}class _q extends zP{constructor(t){if(super(),this.upstream=t,Pt().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:e}=nn(1601);this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}pump(){var t=this;return(0,Qe.Z)(function*(){const e=yield t.upstream.next();let r,i;return!e.done&&(r=e.value,i=Pt().get("IS_BROWSER")?t.decoder.decode(r,{stream:!0}):t.decoder.write(Buffer.from(r.buffer)),t.outputQueue.push(i),!0)})()}}class Q$ extends bq{constructor(t,e={}){super(),this.file=t,this.options=e,K(t instanceof Uint8Array||!!Pt().get("IS_BROWSER")&&(t instanceof File||t instanceof Blob),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=e.offset||0,this.chunkSize=e.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}next(){var t=this;return(0,Qe.Z)(function*(){return t.offset>=(t.file instanceof Uint8Array?t.file.byteLength:t.file.size)?{value:null,done:!0}:{value:yield new Promise((r,i)=>{const s=t.offset+t.chunkSize;if(t.file instanceof Uint8Array)r(new Uint8Array(t.file.slice(t.offset,s)));else{const a=new FileReader;a.onload=l=>{let p=a.result;if(p instanceof ArrayBuffer&&(p=new Uint8Array(p)),!(p instanceof Uint8Array))return i(new TypeError("FileReader returned unknown type."));r(p)},a.onabort=l=>i(new Error("Aborted")),a.onerror=l=>i(new Error(l.type));const o=t.file.slice(t.offset,s);a.readAsArrayBuffer(o)}t.offset=s}),done:!1}})()}}function qP(){return(qP=(0,Qe.Z)(function*(n,t={},e){let r,i;"string"==typeof n?r=n:(r=n.url,i=Sq(n));const s=yield(e||Ud)(r,i);if(s.ok){const a=new Uint8Array(yield s.arrayBuffer());return new Q$(a,t)}throw new Error(s.statusText)})).apply(this,arguments)}const Sq=n=>({method:n.method,headers:n.headers,body:n.body,mode:n.mode,credentials:n.credentials,cache:n.cache,redirect:n.redirect,referrer:n.referrer,integrity:n.integrity});function eB(n){return"string"==typeof n&&"file://"===n.slice(0,7)}class tB extends j${constructor(t,e={}){super(),this.input=t,this.options=e}iterator(){var t=this;return(0,Qe.Z)(function*(){if(eB(t.input)&&Pt().get("IS_NODE")){const e=nn(7792);t.input=e.readFileSync(t.input.slice(7))}return new Q$(t.input,t.options)})()}}class nB extends j${constructor(t,e={}){super(),this.url=t,this.fileOptions=e}iterator(){var t=this;return(0,Qe.Z)(function*(){return eB(t.url)?new tB(t.url,t.fileOptions).iterator():function Nq(n){return qP.apply(this,arguments)}(t.url,t.fileOptions)})()}}function Eq(n,t={}){return new Z$(new nB(n),t)}function Iq(n){const t=_b(n);return lc((0,Qe.Z)(function*(){return t}))}function Cq(n){return lc((0,Qe.Z)(function*(){const t=yield n();return _b(()=>t.next())}))}function Aq(n,t){return WP.apply(this,arguments)}function WP(){return(WP=(0,Qe.Z)(function*(n,t){return GP.create(n,t)})).apply(this,arguments)}function Tq(n){return HP.apply(this,arguments)}function HP(){return(HP=(0,Qe.Z)(function*(n){return VP.create(n)})).apply(this,arguments)}const rB="4.4.0";function lr(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&K("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}const Mq=_0;let iB=(()=>{class n extends Yn{nextDataId(){return n.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new ri(this,Zl())}write(e,r,i){this.firstUse&&(this.firstUse=!1,Pt().get("IS_NODE")&&eu("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const s={id:this.nextDataId()};return this.data.set(s,{values:e,dtype:i,refCount:1}),s}makeTensorInfo(e,r,i){let s;if("string"===r&&null!=i&&i.length>0&&da(i[0])){const a=i.map(o=>sf(o));s=this.write(a,e,r)}else s=this.write(i,e,r);return{dataId:s,shape:e,dtype:r}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,r,i,s,a){this.data.set(e,{values:r,dtype:s,refCount:a})}numDataIds(){return this.data.numDataIds()}read(e){var r=this;return(0,Qe.Z)(function*(){return r.readSync(e)})()}readSync(e){const{dtype:r,complexTensorInfos:i}=this.data.get(e);return"complex64"===r?Dc(this.readSync(i.real.dataId),this.readSync(i.imag.dataId)):Zu(this.data.get(e).values,r)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const i=r.map(s=>Va(s));return zr(e.shape,e.dtype,i)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return zr(e.shape,e.dtype,r)}makeOutput(e,r,i){return Zl().makeTensorFromTensorInfo(this.makeTensorInfo(r,i,e),this)}disposeData(e,r=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!r&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:i}=this.data.get(e);null!=i&&(this.disposeData(i.real.dataId,!0),this.disposeData(i.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return(0,Qe.Z)(function*(){const r=Fs();return e(),{kernelMs:Fs()-r}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){lr([e],"where");const r=this.readSync(e.dataId);return Mq(e.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return n.nextDataId=0,n})();function sB(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}const Rq={kernelName:ga,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend;lr(t,"abs");let r=new Float32Array(ft(t.shape));return r=sB(e.data.get(t.dataId).values),e.makeOutput(r,t.shape,t.dtype)}};function Io(n){return(t,e,r,i,s)=>{const a=$r(t,e),o=a.length,l=zn(a),g=hi(s,ft(a)),v=t.length,w=e.length,N=zn(t),D=zn(e),O=np(t,a),k=np(e,a);if(O.length+k.length===0)for(let L=0;L<g.length;++L)g[L]=n(r[L%r.length],i[L%i.length]);else for(let L=0;L<g.length;++L){const $=Ia(L,o,l),U=$.slice(-v);O.forEach(ve=>U[ve]=0);const V=Yi(U,v,N),W=$.slice(-w);k.forEach(ve=>W[ve]=0);const ce=Yi(W,w,D);g[L]=n(r[V],i[ce])}return[g,a]}}function cc(n){const{inputs:t,backend:e}=n,{real:r,imag:i}=t,s=e.data.get(r.dataId).values,a=e.data.get(i.dataId).values,o=e.makeTensorInfo(r.shape,"complex64");return e.data.get(o.dataId).complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",s),imag:e.makeTensorInfo(i.shape,"float32",a)},o}const Dq={kernelName:Pl,backendName:"cpu",kernelFunc:cc};function SC(n,t,e="float32"){if("complex64"===e)return cc({inputs:{real:SC(n,t,"float32"),imag:SC(n,t,"float32")},backend:n});const r=Ki(ft(t),e);return n.makeTensorInfo(t,e,r)}function Bh(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const Oq={kernelName:va,backendName:"cpu",kernelFunc:Bh};function Zm(n){const{inputs:t,backend:e}=n,{input:r}=t,i=e.data.get(r.dataId).complexTensorInfos.real,s=e.data.get(i.dataId).values;return e.makeTensorInfo(i.shape,i.dtype,s)}const kq={kernelName:xc,backendName:"cpu",kernelFunc:Zm};function aB(n,t,e,r){if("int32"===r)return[t,"int32",Int32Array.from(n)];if("bool"===r){const i=io([0],e),[s,a]=Io((o,l)=>o!==l?1:0)(t,[],n,i,"bool");return[a,"bool",s]}throw new Error(`Error in Cast: failed to cast ${e} to ${r}`)}function Cd(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===i.dtype)return Bh({inputs:{x:i},backend:e});const g=SC(e,i.shape,i.dtype),v=Cd({inputs:{x:i},backend:e,attrs:{dtype:"float32"}}),w=cc({inputs:{real:v,imag:g},backend:e});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(v),w}if("complex64"===i.dtype){const g=Zm({inputs:{input:i},backend:e}),v=Cd({inputs:{x:g},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(g),v}if(!co(i.dtype,s)){const g=Bh({inputs:{x:i},backend:e});return{dataId:g.dataId,shape:g.shape,dtype:s}}const a=e.data.get(i.dataId).values,[o,l,p]=aB(a,i.shape,i.dtype,s);return e.makeTensorInfo(o,l,p)}const Pq={kernelName:rr,backendName:"cpu",kernelFunc:Cd};function ou(n,t,e,r){return null==e?({inputs:i,backend:s})=>{const{a,b:o}=i,l=s;lr([a,o],n);const p=l.data.get(a.dataId).values,g=l.data.get(o.dataId).values,v="string"===a.dtype?mf(p):p,w="string"===a.dtype?mf(g):g,N=r||a.dtype,[D,O]=t(a.shape,o.shape,v,w,N);return l.makeTensorInfo(O,N,D)}:({inputs:i,backend:s})=>{const{a,b:o}=i,l=s;if("complex64"===a.dtype||"complex64"===o.dtype){const p=Cd({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(p.dataId),w=g.complexTensorInfos.imag,N=l.data.get(g.complexTensorInfos.real.dataId).values,D=l.data.get(w.dataId).values,O=Cd({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),k=l.data.get(O.dataId),$=k.complexTensorInfos.imag,U=l.data.get(k.complexTensorInfos.real.dataId).values,V=l.data.get($.dataId).values,[W,ce,ve]=e(a.shape,o.shape,N,D,U,V),Ee=l.makeTensorInfo(ve,"float32",W),ge=l.makeTensorInfo(ve,"float32",ce),it=cc({inputs:{real:Ee,imag:ge},backend:l});return l.disposeIntermediateTensorInfo(p),l.disposeIntermediateTensorInfo(O),l.disposeIntermediateTensorInfo(Ee),l.disposeIntermediateTensorInfo(ge),it}{const p=l.data.get(a.dataId).values,g=l.data.get(o.dataId).values,v=r||a.dtype,[w,N]=t(a.shape,o.shape,p,g,v);return l.makeTensorInfo(N,v,w)}}}function XP(n){return(t,e,r,i,s,a)=>{const o=$r(t,e),l=ft(o),p=o.length,g=zn(o),v=hi("float32",l),w=hi("float32",l),N=np(t,o),D=np(e,o),O=Dc(r,i),k=Dc(s,a),L=t.length,$=zn(t),U=e.length,V=zn(e);if(N.length+D.length===0)for(let W=0;W<v.length;W++){const ce=W%O.length,ve=W%k.length,Ee=n(O[2*ce],O[2*ce+1],k[2*ve],k[2*ve+1]);v[W]=Ee.real,w[W]=Ee.imag}else for(let W=0;W<v.length;W++){const ce=Ia(W,p,g),ve=ce.slice(-L);N.forEach(Mt=>ve[Mt]=0);const Ee=Yi(ve,L,$),ge=ce.slice(-U);D.forEach(Mt=>ge[Mt]=0);const it=Yi(ge,U,V),ut=n(O[2*Ee],O[2*Ee+1],k[2*it],k[2*it+1]);v[W]=ut.real,w[W]=ut.imag}return[v,w,o]}}const oB=Io((n,t)=>n+t),Fq=XP((n,t,e,r)=>({real:n+e,imag:t+r})),Sy=ou(Ju,oB,Fq),Lq={kernelName:Ju,backendName:"cpu",kernelFunc:Sy};function KP(n,t,e,r,i){const s=ft(r),a=Ki(i,e);for(let o=0;o<n.length;o++){const l=n[o];if(l<0)throw new Error("Input x must be non-negative!");l>=i||(a[l]+=s>0?t[o]:1)}return a}function uB(n,t,e,r=!1){const i=n.shape[0],s=n.shape[1],a=zr([i,e],t.dtype);for(let o=0;o<i;o++)for(let l=0;l<s;l++){const p=n.get(o,l);if(p<0)throw new Error("Input x must be non-negative!");p>=e||a.set(r?1:t.size>0?a.get(o,p)+t.get(o,l):a.get(o,p)+1,o,p)}return a}function zh(n){return(t,e,r)=>{const i=Dr(e,t.length);for(let s=0;s<t.length;++s)i[s]=n(t[s],r);return i}}function Os(n,t,e){return Ad(n,zh(t),e)}function Ad(n,t,e){return({inputs:r,attrs:i,backend:s})=>{const{x:a}=r;lr(a,n);const o=s,l=o.data.get(a.dataId).values;let p;if("string"===a.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");p=mf(l)}else p=l;const g=e||a.dtype,v=t(p,g,i);return o.makeTensorInfo(a.shape,g,v)}}const lB=zh(n=>Math.ceil(n)),$q=Ad(As,lB),Bq={kernelName:As,backendName:"cpu",kernelFunc:$q};function cB(n,t,e,r){const i=Dr(e,ft(t));if(r&&"string"!==e){let s=0;n.forEach(a=>{const o=ft(a.shape);i.set(a.vals,s),s+=o})}else{let s=0;n.forEach(a=>{const o="string"===e?mf(a.vals):a.vals;let l=0;for(let p=0;p<a.shape[0];++p){const g=p*t[1]+s;for(let v=0;v<a.shape[1];++v)i[g+v]=o[l++]}s+=a.shape[1]})}return i}const fB=Io((n,t)=>n===t?1:0),hB=ou(Hh,fB,null,"bool"),zq={kernelName:Hh,backendName:"cpu",kernelFunc:hB},pB=zh(n=>Math.exp(n)),dB=Ad(yl,pB,"float32"),Uq={kernelName:yl,backendName:"cpu",kernelFunc:dB},mB=zh(n=>Math.expm1(n)),Vq=Ad(Df,mB),Gq={kernelName:Df,backendName:"cpu",kernelFunc:Vq},gB=zh(n=>Math.floor(n)),qq=Ad(el,gB),Wq={kernelName:el,backendName:"cpu",kernelFunc:qq},yB=Io((n,t)=>Math.floor(n/t)),Hq=ou(Do,yB,null,"int32"),Xq={kernelName:Do,backendName:"cpu",kernelFunc:Hq};function vB(n,t,e,r,i,s,a,o,l){const p=zr([r,s],e);for(let g=0;g<r;g++){const v=[];let w=0;for(let N=0;N<i;N++){const D=n[g*i+N];w+=D*a[N],v.push(D)}if(w<0||w>=l/s)throw new Error(`Invalid indices: ${v} does not index into ${o}`);for(let N=0;N<s;N++)p.values[g*s+N]=t.get(...t.indexToLoc(w*s+N))}return p}function xB(n,t,e){const r=zr(e,n.dtype);for(let i=0;i<r.size;++i){const a=r.indexToLoc(i).slice(),p=t.locToIndex([a[0],a[2]]);a[2]=t.values[p];const g=n.locToIndex(a);0<=g&&g<n.values.length&&(r.values[i]=n.values[g])}return r}const bB=Io((n,t)=>n>t?1:0),Kq=ou(fh,bB,null,"bool"),Yq={kernelName:fh,backendName:"cpu",kernelFunc:Kq},wB=Io((n,t)=>n>=t?1:0),Zq=ou($l,wB,null,"bool"),jq={kernelName:$l,backendName:"cpu",kernelFunc:Zq},_B=Io((n,t)=>n<t?1:0),Jq=ou(pu,_B,null,"bool"),Qq={kernelName:pu,backendName:"cpu",kernelFunc:Jq},NB=Io((n,t)=>n<=t?1:0),e9=ou(as,NB,null,"bool"),t9={kernelName:as,backendName:"cpu",kernelFunc:e9};function SB(n,t,e){const r=(t-n)/(e-1),i=Ki(e,"float32");i[0]=n;for(let s=1;s<i.length;s++)i[s]=i[s-1]+r;return i}const EB=zh(n=>Math.log(n)),n9=Ad(Ta,EB),r9={kernelName:Ta,backendName:"cpu",kernelFunc:n9};function IB(n,t,e,r){const i=hi(r,ft(e));for(let s=0;s<i.length;++s){const a=s*t;let o=n[a];for(let l=0;l<t;++l){const p=n[a+l];(Number.isNaN(p)||p>o)&&(o=p)}i[s]=o}return i}const CB=Io((n,t)=>Math.max(n,t)),i9=ou(Ko,CB),s9={kernelName:Ko,backendName:"cpu",kernelFunc:i9},AB=Io((n,t)=>Math.min(n,t)),a9=ou(Yo,AB),o9={kernelName:Yo,backendName:"cpu",kernelFunc:a9},YP=Io((n,t)=>n*t),u9=XP((n,t,e,r)=>({real:n*e-t*r,imag:n*r+t*e})),EC=ou(du,YP,u9),l9={kernelName:du,backendName:"cpu",kernelFunc:EC};function TB(n,t,e){const r=ji(-1,e);return YP([],t,r,n,e)}const f9={kernelName:mu,backendName:"cpu",kernelFunc:function c9(n){const{inputs:t,backend:e}=n,{x:r}=t;lr(r,"neg");const i=e.data.get(r.dataId).values,[s,a]=TB(i,r.shape,r.dtype);return e.makeTensorInfo(a,r.dtype,s)}},MB=Io((n,t)=>n!==t?1:0),h9=ou(qs,MB,null,"bool"),p9={kernelName:qs,backendName:"cpu",kernelFunc:h9};function ZP(n,t,e,r,i){const s=t.length,a=ft(t),o=zn(t),l=zn(i),p=hi(e,ft(i));for(let g=0;g<a;++g){const v=Ia(g,s,o),w=new Array(v.length);for(let D=0;D<w.length;D++)w[D]=v[r[D]];p[Yi(w,s,l)]=n[g]}return p}function Tl(n){const{inputs:t,attrs:e,backend:r}=n,{x:i}=t,{perm:s}=e;lr(i,"transpose");const o=new Array(i.shape.length);for(let v=0;v<o.length;v++)o[v]=i.shape[s[v]];const p=ZP(r.data.get(i.dataId).values,i.shape,i.dtype,s,o);return{dataId:r.write(p,o,i.dtype),shape:o,dtype:i.dtype}}const d9={kernelName:Wl,backendName:"cpu",kernelFunc:Tl};function RB(n,t,e,r){const[i,s]=ao(n,r),a=$u(t,"int32"),o=Ki(ft(i),a),l=ft(s);for(let p=0;p<o.length;++p){const g=p*l;let v=1;for(let w=0;w<l;++w)v*=e[g+w];o[p]=v}return{outVals:o,outShape:i,outDtype:a}}const g9={kernelName:ph,backendName:"cpu",kernelFunc:function m9(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:s,keepDims:a}=r;lr(i,"prod");const o=i.shape.length,l=ar(s,i.shape),p=na(l,o);let g=l,v=i;const w=[];null!=p&&(v=Tl({inputs:{x:i},backend:e,attrs:{perm:p}}),w.push(v),g=ka(g.length,o));const N=e.data.get(v.dataId).values,{outVals:D,outShape:O,outDtype:k}=RB(v.shape,v.dtype,N,g);let L=O;return a&&(L=Oa(O,l)),w.forEach($=>e.disposeIntermediateTensorInfo($)),e.makeTensorInfo(L,k,D)}};function DB(n,t){const e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let r=t;r<n.length;r++)e[t-1]*=n[r];return e}function OB(n,t,e,r,i,s,a,o){if(0===n.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function y9(n,t,e){n.forEach((r,i)=>{if(r<0||r>=e){const s=Ia(i,t.length,zn(t)).join(",");throw new Error(`indices[${s}] = ${r} is not in [0, ${e})`)}})}(s,a,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const p=r[0],{outSplits:g,valueSlices:v,numValues:w}=function x9(n,t,e,r){const i=[];let s=0;const o=new Array(t.length-1+e.length).fill(null).map(()=>[0]);!function v9(n,t){for(let e=0;e<n.length;++e){const r=n[e],i=e===n.length-1?t:n[e+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>i)throw new Error("Ragged splits must not point past values");for(let s=1;s<r.length;++s)if(r[s-1]>r[s])throw new Error("Ragged splits must be sorted in ascending order")}}(e,r);let l=1;for(let p=0;p<t.length-1;++p){l*=t[p];const g=t[p+1];for(let v=1;v<l+1;++v)o[p].push(v*g)}for(let p=0;p<n.length;++p){let g=n[p],v=n[p]+1;for(let w=0;w<e.length;++w){const N=e[w],D=w+t.length-1;if(D>=0){const O=o[D],k=O[O.length-1]-N[g];for(let L=g;L<v;++L)o[D].push(N[L+1]+k)}g=N[g],v=N[v]}v!==g&&(i.push([g,v]),s+=v-g)}return{outSplits:o,valueSlices:i,numValues:s}}(s,a,n,p),N=function b9(n){const t=[];for(let e=0;e<n.length;++e){const i=Dr("int32",n[e].length);t.push(i),n[e].forEach((s,a)=>i[a]=s)}return t}(g),D=function _9(n,t,e,r,i){const s=t.slice();s[0]=i;const a=Dr(e,ft(s)),o=n.length;return function w9(n,t,e,r,i,s){const a=DB(t,2)[1],o=DB(s,2)[1];let l=0;for(const p of e)for(let g=p[0];g<p[1];++g){for(let v=0;v<r;++v)i[l*o+v]=n[g*a+v];++l}}(n,t,r,0===o?0:o/t[0],a,s),[a,s]}(e,r,i,v,w);return[N,D[0],D[1]]}const kB=2147483647;function PB(n,t,e,r,i,s,a){if(t.length>1)throw new Error("starts must be a scalar or vector");if(i.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");const o=0===t.length,l=0===i.length,p=0===a.length,g=[];o||g.push(t[0]),l||g.push(i[0]),p||g.push(a[0]);for(let k=1;k<g.length;++k)if(g[k]!==g[k-1])throw new Error("starts, limits, and deltas must have the same shape");const v=0===g.length?1:g[0],w=Dr("int32",v+1);w[0]=0;for(let k=0;k<v;++k){const L=o?n[0]:n[k],$=l?r[0]:r[k],U=p?s[0]:s[k];if(0===U)throw new Error("Requires delta != 0");let V;if(U>0&&$<L||U<0&&$>L)V=0;else if(V=Math.ceil(Math.abs(($-L)/U)),V>kB)throw new Error(`Requires ((limit - start) / delta) <= ${kB}`);w[k+1]=w[k]+V}const D=Dr(e,w[v]);let O=0;for(let k=0;k<v;++k){const L=w[k+1]-w[k];let $=o?n[0]:n[k];const U=p?s[0]:s[k];for(let V=0;V<L;++V)D[O++]=$,$+=U}return[w,D]}var Ef=nc;class IC{constructor(t,e,r,i,s,a,o,l,p,g){this.shape=t,this.shapeShape=e,this.values=r,this.valuesShape=i,this.valuesDType=s,this.defaultValue=a,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=p,this.rowPartitionTypes=ES(g),this.raggedRank=Z1(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Ef.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Ef.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Ef.VALUE_ROWIDS:return IC.getMaxWidthValueRowID(e);case Ef.ROW_SPLITS:return IC.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${Ef[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(0===e||1===e)return 0;let r=0;for(let i=0;i<e-1;++i){const s=t[i+1]-t[i];s>r&&(r=s)}return r}static getMaxWidthValueRowID(t){const e=t.length;if(0===e)return 0;let r=0,i=t[0],s=0;for(let a=1;a<e;++a){const o=t[a];o!==i&&(i=o,s=Math.max(a-r,s),r=a)}return Math.max(e-r,s)}tensorShapeFromTensor(t,e,r=!0){if(0===e.length){if(-1===t[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return LB(t,r)}calculateOutputSize(t){const e=this.valuesShape;IS(this.defaultValueShape,e);const i=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=SS(this.raggedRank,i,e);a[0]<0&&(a[0]=t);for(let o=1;o<=this.raggedRank;++o)a[o]<0&&(a[o]=this.getMaxWidth(o));return a}calculateFirstParentOutputIndex(t,e,r){const i=Math.min(t,r),s=[];let a=0;for(let o=0;o<i;++o,a+=e)s.push(a);for(let o=i;o<t;++o)s.push(-1);return K(s.length===t,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(t,e,r,i){const s=t.length,a=[];for(let o=0;o<s-1;++o){const l=t[o+1]-t[o];let p=Math.min(i,l),g=e[o];-1===g&&(p=0);for(let v=0;v<p;++v)a.push(g),g+=r;for(let v=0;v<l-p;++v)a.push(-1)}if(s>0&&a.length!==t[s-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(t,e,r,i){const s=t.length,a=[];if(0===s)return[];let o=0,l=t[0];if(l>=e.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${e.length}`);let p=e[l];a.push(p);for(let g=1;g<s;++g){const v=t[g];if(v===l)p>=0&&(++o,o<i?p+=r:p=-1);else{if(o=0,l=v,v>=e.length)throw new Error(`Got nextValueRowId=${v} which is not less than ${e.length}`);p=e[v]}a.push(p)}if(a.length!==t.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(t,e,r,i){const s=this.getRowPartitionTensor(t),a=this.getRowPartitionTypeByDimension(t);switch(a){case Ef.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,e,r,i);case Ef.ROW_SPLITS:if(s.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(s,e,r,i);default:throw new Error(`Unsupported partition type: ${Ef[a]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case Ef.FIRST_DIM_SIZE:return t[0];case Ef.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Ef.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Ef[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),r=this.calculateOutputSize(e),i=new Array(this.raggedRank+1);i[i.length-1]=1;for(let l=i.length-2;l>=0;--l)i[l]=i[l+1]*r[l+1];const s=LB(r,!1),a=Dr(this.valuesDType,ft(s));if(i[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(e,i[0],r[0]);for(let p=1;p<=this.raggedRank;++p)l=this.calculateOutputIndex(p-1,l,i[p],r[p]);this.setOutput(this.raggedRank,l,a,s)}return[s,a]}setOutput(t,e,r,i){if(0===r.length)return;const s=this.values,a=r;let o=i.slice();o=o.slice(t+1);const l=ft(o),p=e.length;let g=this.defaultValue;if(g.length!==l&&1!==g.length){const D=this.defaultValueShape;Lt(()=>{const O=St(g,D);g=sp(O,o).dataSync()})}let v=0,w=0,N=0;for(let D=0;D<=p;++D){let O=D<p?e[D]:-1;if(O!==N){if(w<N){const k=s.subarray(v*l);FB(a.subarray(w*l),k,(N-w)*l)}if(D>=p&&(O=Math.floor(r.length/l)),O>N)if(1===this.defaultValue.length)a.subarray(N*l,O*l).fill(this.defaultValue[0]),N=O;else for(;O>N;)FB(a.slice(N*l),g,l),++N;O<0?(v=D+1,w=N):(v=D,w=N,N=w+1)}else++N}}}function FB(n,t,e){for(let r=0;r<e;r++)n[r]=t[r]}function LB(n,t){const e=[];for(let r of n){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}e.push(r)}return e}function $B(n,t,e,r,i,s,a,o,l,p){return new IC(n,t,e,r,i,s,a,o,l,p).compute()}function BB(n,t,e,r){if(n===t||n<t&&e<0||t<n&&e>1)return Ki(0,r);const l=Ki(Math.abs(Math.ceil((t-n)/e)),r);t<n&&1===e&&(e=-1),l[0]=n;for(let p=1;p<l.length;p++)l[p]=l[p-1]+e;return l}const zB=zh(n=>1/Math.sqrt(n)),N9=Ad(dh,zB),S9={kernelName:dh,backendName:"cpu",kernelFunc:N9};function jm(n,t,e,r,i,s,a,o,l,p){const g=[r/i,i],v=n.values,w=t.values;if(0===r)return zr(e,t.dtype);const N=l instanceof Ga?l:zr(g,t.dtype);"string"==typeof l||"number"==typeof l?N.values.fill(l):"boolean"==typeof l&&N.values.fill(+l);for(let D=0;D<s;D++){const O=[];let k=0;for(let L=0;L<a;L++){const $=v[D*a+L];O.push($),k+=$*o[L]}if(k<0||k>=r/i)throw new Error(`Invalid indices: ${O} does not index into ${e}`);for(let L=0;L<i;L++)p?N.values[k*i+L]+=w[D*i+L]:N.values[k*i+L]=0===t.rank?w[0]:w[D*i+L]}return N}const E9=zh(n=>1/(1+Math.exp(-n))),UB=Os(wa,n=>1/(1+Math.exp(-n))),I9={kernelName:wa,backendName:"cpu",kernelFunc:UB};function VB(n,t,e,r,i){const s=Mv(r,t,e),a=ft(e),o=zn(r);if(s){const v=Rv(t,o);return"string"===i?n.slice(v,v+a):n.subarray(v,v+a)}const p=zr(r,i,"string"===i?mf(n):n),g=zr(e,i);for(let v=0;v<g.size;++v){const w=g.indexToLoc(v),N=w.map((D,O)=>D+t[O]);g.set(p.get(...N),...w)}return"string"===i?qS(g.values):g.values}function Jm(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{begin:s,size:a}=r;lr(i,"slice");const[o,l]=Bg(i,s,a);$g(i,o,l);const g=VB(e.data.get(i.dataId).values,o,l,i.shape,i.dtype);return e.makeTensorInfo(l,i.dtype,g)}const C9={kernelName:po,backendName:"cpu",kernelFunc:Jm};function GB(n,t,e,r,i,s,a){const o=t[0],l=s[0],p=new Array(l),g=new Array(o),v=t[1];if(0===l){if(0!==o)throw new Error(fx(o));return[Dr(e,0),[0,v],Dr(i,0),p,g]}let w=!0,N=0;const D=new Array(l).fill(0);for(let k=0;k<o;++k){const L=n[k*v];if(L<0)throw new Error(PS(k,L));if(L>=l)throw new Error(FS(k,L,l));++D[L],w=w&&L>=N,N=L}let O=!0;for(let k=0;k<l;++k){const L=0===D[k];p[k]=L,O=O&&!L,D[k]=Math.max(D[k],1),k>0&&(D[k]+=D[k-1])}if(O&&w){const k=n,L=r;for(let $=0;$<o;++$)g[$]=$;return[k,[o,v],L,p,g]}{const k=D[l-1],L=Dr(e,k*v),$=Dr(i,k),U=new Array(l).fill(0);for(let V=0;V<o;++V){const W=n[V*v],ve=(0===W?0:D[W-1])+U[W];U[W]++;for(let Ee=0;Ee<v;++Ee)L[ve*v+Ee]=n[V*v+Ee];$[ve]=r[V],g[V]=ve}for(let V=0;V<l;++V)if(0===U[V]){const ce=0===V?0:D[V-1];L[ce*v+0]=V;for(let ve=1;ve<v;++ve)L[ce*v+ve]=0;$[ce]=a}return[L,[k,v],$,p,g]}}function qB(n,t,e,r,i){const s=ft(r),a=t[0],o=i.length,l=[];let p=1,g=-1;for(let k=0;k<o;++k){const L=i[k];if(-1===L){if(-1!==g)throw new Error(LS(g,k));g=k,l.push(1)}else{if(L<0)throw new Error($S(k,L));p*=L,l.push(L)}}if(-1!==g){if(p<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const k=Math.trunc(s/p);if(p*k!==s)throw new Error(hx(r,l));l[g]=k}if(ft(l)!==s)throw new Error(zS(r,l));const w=r.length,N=[];if(w>0){N[w-1]=1;for(let k=w-2;k>=0;--k)N[k]=N[k+1]*r[k+1]}const D=[];if(o>0){D[o-1]=1;for(let k=o-2;k>=0;--k)D[k]=D[k+1]*l[k+1]}const O=Dr(e,a*o);for(let k=0;k<a;++k){let L=0;for(let $=0;$<w;++$)L+=n[k*w+$]*N[$];for(let $=0;$<o;++$)O[k*o+$]=Math.trunc(L/D[$]),L%=D[$]}return[O,[a,o],l]}function jP(n,t,e,r,i,s=!1,a=0){const o=r.length,l=[t[0],n.length/t[0]],p=l[1],v=o>0?i[o-1]+1:0;if(v<0)throw new Error("segment ids must be >= 0");const w=t.slice();w[0]=v;const D=Dr(e,w.reduce((U,V)=>U*V,1));if(0===o)return v>0&&D.fill(a),[D,w];if(v<=0)throw new Error("segment ids must be >= 0");let O=0,k=1,L=0,$=i[O];for(;;){let U=0;if(k<o){if(U=i[k],$===U){++k;continue}if($>=U)throw new Error("segment ids are not increasing")}if($<0||$>=v)throw new Error(US($,v));$>L&&D.fill(a,L*p,$*p);for(let V=O;V<k;++V){const W=r[V];if(W<0||W>=l[0])throw new Error(VS(V,r[V],l[0]));for(let ce=0;ce<p;ce++)D[$*p+ce]+=n[W*p+ce]}if(s)for(let V=0;V<p;V++)D[$*p+V]/=k-O;if(O=k,++k,L=$+1,$=U,k>o)break}return L<v&&D.fill(a,L*p,v*p),[D,w]}const A9=zh(n=>Math.sqrt(n)),T9=Os(Rs,n=>Math.sqrt(n)),M9={kernelName:Rs,backendName:"cpu",kernelFunc:T9},WB=Io((n,t)=>{const e=n-t;return e*e}),R9=ou(Lo,WB),D9={kernelName:Lo,backendName:"cpu",kernelFunc:R9},HB=zh((n,t)=>{const{pattern:e,replaceGlobal:r,rewrite:i}=t;return n.replace(new RegExp(e,r?"g":""),i)}),O9=Ad(Qn,HB),k9={kernelName:Qn,backendName:"cpu",kernelFunc:O9};function XB(n,t,e,r){const i=zr(n,t.dtype);for(let s=0;s<i.size;s++){const a=i.indexToLoc(s),o=new Array(a.length);for(let l=0;l<o.length;l++)o[l]=a[l]*e[l]+r[l];i.set(t.get(...o),...a)}return i}class P9{constructor(t,e,r,i,s,a){this.separator=sf(t),this.nGramWidths=e,this.leftPad=sf(r),this.rightPad=sf(i),this.padWidth=s,this.preserveShort=a}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const r=this.getPadWidth(e);return Math.max(0,t+2*r-e+1)}createNGrams(t,e,r,i,s,a){for(let o=0;o<s;++o){const l=this.getPadWidth(a),p=Math.max(0,l-o),g=Math.max(0,l-(s-(o+1))),v=a-(p+g),w=e+(p>0?0:o-l);let N=0;N+=p*this.leftPad.length;for(let $=0;$<v;++$)N+=t[w+$].length;N+=g*this.rightPad.length,N+=(p+g+v-1)*this.separator.length,r[i+o]=new Uint8Array(N);const O=r[i+o];let k=0;const L=$=>$.forEach(U=>O[k++]=U);for(let $=0;$<p;++$)L(this.leftPad),L(this.separator);for(let $=0;$<v-1;++$)L(t[w+$]),L(this.separator);if(v>0){L(t[w+v-1]);for(let $=0;$<g;++$)L(this.separator),L(this.rightPad)}else{for(let $=0;$<g-1;++$)L(this.rightPad),L(this.separator);L(this.rightPad)}}}compute(t,e){const r=t.length,i=e.length;if(i>0){let l=e[0];if(0!==l)throw new Error(`First split value must be 0, got ${l}`);for(let p=1;p<i;++p){let g=e[p]>=l;if(g=g&&e[p]<=r,!g)throw new Error(`Invalid split value ${e[p]}, must be in [${l}, ${r}]`);l=e[p]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const s=i-1,a=Dr("int32",i);if(0===r||0===i){const l=new Array(r);for(let p=0;p<=s;++p)a[p]=0;return[l,a]}a[0]=0;for(let l=1;l<=s;++l){const p=e[l]-e[l-1];let g=0;this.nGramWidths.forEach(v=>{g+=this.getNumNGrams(p,v)}),this.preserveShort&&p>0&&0===g&&(g=1),a[l]=a[l-1]+g}const o=new Array(a[s]);for(let l=0;l<s;++l){const p=e[l];let g=a[l];if(this.nGramWidths.forEach(v=>{const N=this.getNumNGrams(e[l+1]-e[l],v);this.createNGrams(t,p,o,g,N,v),g+=N}),this.preserveShort&&g===a[l]){const v=e[l+1]-e[l];if(0===v)continue;this.createNGrams(t,p,o,g,1,v+2*this.padWidth)}}return[o,a]}}function KB(n,t,e,r,i,s,a,o){return new P9(e,r,i,s,a,o).compute(n,t)}function F9(n,t,e,r){if(!n.length)return;if(0===t.length){for(let s=0;s<n.length;++s)r.push(n.subarray(s,s+1));return}if(1===t.length){const s=t[0];let a=n.indexOf(s);for(;-1!==a;){const o=n.subarray(0,a);(!e||0!==o.length)&&r.push(o),a=(n=n.subarray(a+1)).indexOf(s)}return void((!e||0!==n.length)&&r.push(n))}let i=0;for(let s=0;s<n.length+1;s++)if(s===n.length||-1!==t.indexOf(n[s])){const a=n.subarray(i,s);(!e||0!==a.length)&&r.push(a),i=s+1}}function YB(n,t,e){const r=n.length,i=[];let s=0,a=0;const o=new Array(r);for(let w=0;w<r;++w){const N=i.length;F9(n[w],t,e,i);const D=i.length-N;o[w]=D,s+=D,a=Math.max(a,D)}const l=Dr("int32",2*s),p=new Array(s),g=[r,a];let v=0;for(let w=0;w<r;++w)for(let N=0;N<o[w];++N)l[2*v]=w,l[2*v+1]=N,p[v]=i[v],++v;return[l,p,g]}function ZB(n,t){const e=Dr("int32",n.length);for(let r=0;r<n.length;++r)e[r]=fi(n[r]).modulo(t).getLowBitsUnsigned();return e}const jB=Io((n,t)=>n-t),L9=XP((n,t,e,r)=>({real:n-e,imag:t-r})),JP=ou(il,jB,L9),$9={kernelName:il,backendName:"cpu",kernelFunc:JP};function JB(n,t){const e=new Array(n.rank);for(let i=0;i<e.length;i++)e[i]=n.shape[i]*t[i];const r=zr(e,n.dtype);for(let i=0;i<r.values.length;++i){const s=r.indexToLoc(i),a=new Array(n.rank);for(let l=0;l<a.length;l++)a[l]=s[l]%n.shape[l];const o=n.locToIndex(a);r.values[i]=n.values[o]}return r}const Eb=(n,t)=>{const e=t.value-n.value;return 0===e?n.index-t.index:e};function QB(n,t,e=0,r=n.length-1){for(;r>e;){if(r-e>600){const o=r-e+1,l=t-e+1,p=Math.log(o),g=.5*Math.exp(2*p/3),v=.5*Math.sqrt(p*g*(o-g)/o)*Math.sign(l-o/2);QB(n,t,Math.max(e,Math.floor(t-l*g/o+v)),Math.min(r,Math.floor(t+(o-l)*g/o+v)))}const i=n[t];let s=e,a=r;for(nt(n,e,t),Eb(n[r],i)>0&&nt(n,e,r);s<a;){for(nt(n,s,a),s++,a--;Eb(n[s],i)<0;)s+=1;for(;Eb(n[a],i)>0;)a-=1}0===Eb(n[e],i)?nt(n,e,a):(a+=1,nt(n,a,r)),a<=t&&(e=a+1),t<=a&&(r=a-1)}}function e4(n,t,e,r,i){const s=t[t.length-1],[a,o]=[n.length/s,s],l=hi(e,a*r),p=hi("int32",a*r);for(let v=0;v<a;v++){const w=v*o,N=n.subarray(w,w+o);let D=new Array(N.length);N.forEach(($,U)=>D[U]={value:$,index:U}),r<D.length&&(QB(D,r),D=D.slice(0,r)),i&&D.sort(Eb);const O=v*r,k=l.subarray(O,O+r),L=p.subarray(O,O+r);for(let $=0;$<r;$++)k[$]=D[$].value,L[$]=D[$].index}const g=t.slice();return g[g.length-1]=r,[zr(g,e,l),zr(g,"int32",p)]}function t4(n,t,e,r){const i=ar(t,e)[0],s=[1,e[0],1];for(let D=0;D<i;D++)s[0]*=e[D];s[1]=e[i];for(let D=i+1;D<e.length;D++)s[2]*=e[D];const a=new Map,o=new Int32Array(e[i]),l=new Ga(s,r,n),p=[],g=1===s[0]&&1===s[2];for(let D=0;D<e[i];D++){let O;if(g)O=n[D].toString();else{const L=[];for(let $=0;$<s[0];$++)for(let U=0;U<s[2];U++)L.push(l.get($,D,U));O=L.join(",")}const k=a.get(O);if(null!=k)o[D]=k;else{const L=a.size;a.set(O,L),o[D]=L,p.push(D)}}const v=s.slice();v[1]=a.size;const w=new Ga(v,r);p.forEach((D,O)=>{for(let k=0;k<s[0];k++)for(let L=0;L<s[2];L++)w.set(l.get(k,D,L),k,O,L)});const N=e.slice();return N[i]=v[1],{outputValues:w.values,outputShape:N,indices:o}}const n4="4.4.0";Mg("cpu",()=>new iB,1);const r4=Os(hs,n=>n>=0?n:Math.exp(n)-1),B9={kernelName:hs,backendName:"cpu",kernelFunc:r4};function i4(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{alpha:s}=r;lr([i],"leakyRelu");const a=ft(i.shape),o=e.data.get(i.dataId).values,l=hi("float32",a);for(let p=0;p<o.length;p++)l[p]=o[p]<0?s*o[p]:o[p];return e.makeTensorInfo(i.shape,"float32",l)}const z9={kernelName:Yr,backendName:"cpu",kernelFunc:i4},U9=Io((n,t)=>n<0?t*n:n);function s4(n){const{inputs:t,backend:e}=n,{x:r,alpha:i}=t;lr([r,i],"prelu");const s=e.data.get(r.dataId).values,a=e.data.get(i.dataId).values,[o,l]=U9(r.shape,i.shape,s,a,"float32");return e.makeTensorInfo(l,"float32",o)}const V9={kernelName:Ul,backendName:"cpu",kernelFunc:s4},a4=Os(Po,n=>Math.max(0,n)),G9={kernelName:Po,backendName:"cpu",kernelFunc:a4},o4=Os(Ss,n=>Math.min(Math.max(0,n),6)),q9={kernelName:Ss,backendName:"cpu",kernelFunc:o4};function CC(n,t,e,r,i){if("linear"===e)return Bh({inputs:{x:t},backend:n});if("relu"===e)return a4({inputs:{x:t},backend:n});if("elu"===e)return r4({inputs:{x:t},backend:n});if("relu6"===e)return o4({inputs:{x:t},backend:n});if("prelu"===e)return s4({inputs:{x:t,alpha:r},backend:n});if("leakyrelu"===e)return i4({inputs:{x:t},backend:n,attrs:{alpha:i}});if("sigmoid"===e)return UB({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function aa(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{shape:s}=r,a=ft(i.shape),o=ls(s,a),l=ft(o);K(a===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${i.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),e.incRef(i.dataId);const p=e.data.get(i.dataId);if(null!=p.complexTensorInfos){const v=p.complexTensorInfos.imag;p.complexTensorInfos.real.shape=o,v.shape=o}return{dataId:i.dataId,shape:o,dtype:i.dtype}}const W9={kernelName:tl,backendName:"cpu",kernelFunc:aa};function u4(n){const{inputs:t,backend:e,attrs:r}=n,{a:i,b:s}=t,{transposeA:a,transposeB:o}=r;lr([i,s],"matMul");const l=i.shape.length,p=s.shape.length,g=a?i.shape[l-2]:i.shape[l-1],v=o?s.shape[p-1]:s.shape[p-2],w=a?i.shape[l-1]:i.shape[l-2],N=o?s.shape[p-2]:s.shape[p-1],D=i.shape.slice(0,-2),O=s.shape.slice(0,-2),k=ft(D),L=ft(O),U=$r(i.shape.slice(0,-2),s.shape.slice(0,-2)).concat([w,N]);K(g===v,()=>`Error in matMul: inner shapes (${g}) and (${v}) of Tensors with shapes ${i.shape} and ${s.shape} and transposeA=${a} and transposeB=${o} must match.`);const W=o?[L,N,v]:[L,v,N],ce=aa({inputs:{x:i},backend:e,attrs:{shape:a?[k,g,w]:[k,w,g]}}),ve=aa({inputs:{x:s},backend:e,attrs:{shape:W}}),Ee=a?ce.shape[1]:ce.shape[2],ge=a?ce.shape[2]:ce.shape[1],it=o?ve.shape[1]:ve.shape[2],ut=Math.max(k,L),Mt=e.data.get(ce.dataId).values,Ot=e.data.get(ve.dataId).values,vt=zn(ce.shape),Rt=zn(ve.shape),[Dt,Ht,Bt]=a?[vt[0],1,vt[1]]:[vt[0],vt[1],1],[Wt,ln,cn]=o?[1,Rt[1],Rt[0]]:[Rt[1],1,Rt[0]],xn=ge*it,rn=zr([ut,ge,it],ce.dtype),bn=rn.values,mn=e.blockSize;for(let Mn=0;Mn<ut;Mn++){const nr=Mn%k,wr=Mn%L;for(let yr=0;yr<ge;yr+=mn){const Wr=Math.min(yr+mn,ge);for(let Xr=0;Xr<it;Xr+=mn){const ws=Math.min(Xr+mn,it);for(let zs=0;zs<Ee;zs+=mn){const Sa=Math.min(zs+mn,Ee);for(let Us=yr;Us<Wr;Us++)for(let Vs=Xr;Vs<ws;Vs++){let $a=0;for(let Ea=zs;Ea<Sa;Ea++)$a+=Mt[nr*Dt+Us*Ht+Ea*Bt]*Ot[Ea*Wt+Vs*ln+wr*cn];bn[Mn*xn+(Us*it+Vs)]+=$a}}}}}return e.disposeIntermediateTensorInfo(ce),e.disposeIntermediateTensorInfo(ve),e.makeTensorInfo(U,rn.dtype,rn.values)}const H9={kernelName:fs,backendName:"cpu",kernelFunc:u4},K9={kernelName:Qo,backendName:"cpu",kernelFunc:function X9(n){const{inputs:t,backend:e,attrs:r}=n,{a:i,b:s,bias:a,preluActivationWeights:o}=t,{transposeA:l,transposeB:p,activation:g,leakyreluAlpha:v}=r;let w,N,D;const O=[];w=u4({inputs:{a:i,b:s},attrs:{transposeA:l,transposeB:p},backend:e}),a&&(N=Sy({inputs:{a:w,b:a},backend:e}),O.push(w),w=N),g&&(D=CC(e,w,g,o,v),O.push(w),w=D);for(const L of O)e.disposeIntermediateTensorInfo(L);return w}},Y9=Os(To,n=>Math.acos(n)),Z9={kernelName:To,backendName:"cpu",kernelFunc:Y9},j9=Os(ml,n=>Math.acosh(n)),J9={kernelName:ml,backendName:"cpu",kernelFunc:j9},e8={kernelName:kl,backendName:"cpu",kernelFunc:function Q9(n){const{inputs:t,backend:e}=n,r=t;lr(t,"addN");const i=r.map(o=>e.data.get(o.dataId).values),s=zr(r[0].shape,r[0].dtype),a=s.values;for(let o=0;o<r.length;o++){const l=i[o];for(let p=0;p<a.length;p++)a[p]+=l[p]}return e.makeTensorInfo(s.shape,s.dtype,s.values)}},n8={kernelName:Vr,backendName:"cpu",kernelFunc:function t8(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:s,keepDims:a}=r;lr(i,"all");const o=ar(s,i.shape);let l=o;const p=na(l,i.shape.length);let g=i;null!=p&&(g=Tl({inputs:{x:i},backend:e,attrs:{perm:p}}),l=ka(l.length,i.shape.length)),Vo("all",l,g.shape.length);const[v,w]=ao(g.shape,l),N=ft(w),D=Ki(ft(v),g.dtype),O=e.data.get(g.dataId).values;for(let L=0;L<D.length;++L){const $=L*N;let U=O[$];for(let V=0;V<N;++V)U=U&&O[$+V];D[L]=U}null!=p&&e.disposeIntermediateTensorInfo(g);const k=e.makeTensorInfo(v,g.dtype,D);if(a){const $=aa({inputs:{x:k},backend:e,attrs:{shape:Oa(v,o)}});return e.disposeIntermediateTensorInfo(k),$}return k}},i8={kernelName:Ks,backendName:"cpu",kernelFunc:function r8(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:s,keepDims:a}=r;lr(i,"any");const o=ar(s,i.shape);let l=o;const p=na(l,i.shape.length);let g=i;null!=p&&(g=Tl({inputs:{x:i},backend:e,attrs:{perm:p}}),l=ka(l.length,i.shape.length)),Vo("any",l,g.shape.length);const[v,w]=ao(g.shape,l),N=ft(w),D=Ki(ft(v),g.dtype),O=e.data.get(g.dataId).values;for(let L=0;L<D.length;++L){const $=L*N;let U=O[$];for(let V=0;V<N;++V)U=U||O[$+V];D[L]=U}null!=p&&e.disposeIntermediateTensorInfo(g);const k=e.makeTensorInfo(v,g.dtype,D);if(a){const $=aa({inputs:{x:k},backend:e,attrs:{shape:Oa(v,o)}});return e.disposeIntermediateTensorInfo(k),$}return k}},a8={kernelName:Ho,backendName:"cpu",kernelFunc:function s8(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:s}=r;lr(i,"argMax");let a=ar(s,i.shape);const o=na(a,i.shape.length);let l=i;const p=[];null!=o&&(l=Tl({inputs:{x:i},backend:e,attrs:{perm:o}}),p.push(l),a=ka(a.length,l.shape.length)),a=[a[0]],Vo("argMax",a,l.shape.length);const[g,v]=ao(l.shape,a),N=Ki(ft(g),"int32"),D=ft(v),O=e.data.get(l.dataId).values;for(let k=0;k<N.length;++k){const L=k*D;let $=O[L],U=0;for(let V=0;V<D;++V){const W=O[L+V];W>$&&($=W,U=V)}N[k]=U}return p.forEach(k=>e.disposeIntermediateTensorInfo(k)),e.makeTensorInfo(g,"int32",N)}},u8={kernelName:Af,backendName:"cpu",kernelFunc:function o8(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:s}=r;lr(i,"argMin");let a=ar(s,i.shape);const o=na(a,i.shape.length);let l=i;const p=[];null!=o&&(l=Tl({inputs:{x:i},backend:e,attrs:{perm:o}}),p.push(l),a=ka(a.length,l.shape.length)),a=[a[0]],Vo("argMin",a,l.shape.length);const[g,v]=ao(l.shape,a),N=Ki(ft(g),"int32"),D=ft(v),O=e.data.get(l.dataId).values;for(let k=0;k<N.length;++k){const L=k*D;let $=O[L],U=0;for(let V=0;V<D;++V){const W=O[L+V];W<$&&($=W,U=V)}N[k]=U}return p.forEach(k=>e.disposeIntermediateTensorInfo(k)),e.makeTensorInfo(g,"int32",N)}},l8=Os(Tf,n=>Math.asin(n)),c8={kernelName:Tf,backendName:"cpu",kernelFunc:l8},f8=Os(Gr,n=>Math.asinh(n)),h8={kernelName:Gr,backendName:"cpu",kernelFunc:f8},p8=Os(ja,n=>Math.atan(n)),d8={kernelName:ja,backendName:"cpu",kernelFunc:p8},m8=Io((n,t)=>Math.atan2(n,t)),g8=ou(Yc,m8),y8={kernelName:Yc,backendName:"cpu",kernelFunc:g8},v8=Os(jn,n=>Math.atanh(n)),x8={kernelName:jn,backendName:"cpu",kernelFunc:v8};function QP(n,t,e,r,i,s){const a=i.strideHeight,o=i.strideWidth,l=i.dilationHeight,p=i.dilationWidth,g=i.effectiveFilterHeight,v=i.effectiveFilterWidth,w=i.padInfo.top,N=i.padInfo.left,D="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,O=zr(i.outShape,e),k=O.values,L=i.outShape[1]*i.outShape[2]*i.outShape[3],$=i.outShape[2]*i.outShape[3],U=i.outShape[3];for(let V=0;V<i.batchSize;++V){const W=V*L,ce=V*r[0];for(let ve=0;ve<i.inChannels;++ve)for(let Ee=0;Ee<i.outHeight;++Ee){const ge=Ee*a-w,it=Math.max(0,ge),ut=Math.min(i.inHeight,g+ge),Mt=W+Ee*$;for(let Ot=0;Ot<i.outWidth;++Ot){const vt=Ot*o-N,Rt=Math.max(0,vt),Dt=Math.min(i.inWidth,v+vt);let Ht=D,Bt=0,Wt=0;for(let cn=it;cn<ut;cn+=l){const xn=ce+cn*r[1];for(let rn=Rt;rn<Dt;rn+=p){const mn=n[xn+rn*r[2]+ve];"max"===s&&mn>Ht?Ht=mn:"avg"===s&&(Bt+=mn,Wt++)}if(isNaN(Ht))break}k[Mt+Ot*U+ve]="avg"===s?Bt/Wt:Ht}}}return O}function l4(n,t,e,r,i=!1,s=!1){const a=zr(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,p=r.dilationHeight,g=r.dilationWidth,v=r.effectiveFilterHeight,w=r.effectiveFilterWidth,N=r.padInfo.top,D=r.padInfo.left,O=zr(t,e,n);for(let k=0;k<r.batchSize;++k)for(let L=0;L<r.inChannels;++L)for(let $=0;$<r.outHeight;++$){const U=$*o-N;let V=U;for(;V<0;)V+=p;const W=Math.min(r.inHeight,v+U);for(let ce=0;ce<r.outWidth;++ce){const ve=ce*l-D;let Ee=ve;for(;Ee<0;)Ee+=g;const ge=Math.min(r.inWidth,w+ve);let it=Number.NEGATIVE_INFINITY,ut=-1;for(let Mt=V;Mt<W;Mt+=p){const Ot=Mt-U;for(let vt=Ee;vt<ge;vt+=g){const Rt=vt-ve,Dt=O.get(k,Mt,vt,L);Dt>it&&(it=Dt,ut=i?s?((k*r.inHeight+Mt)*r.inWidth+vt)*r.inChannels+L:(Mt*r.inWidth+vt)*r.inChannels+L:Ot*w+Rt)}}a.set(ut,k,$,ce,L)}}return a}function c4(n,t,e,r,i,s){const a=i.strideDepth,o=i.strideHeight,l=i.strideWidth,p=i.dilationDepth,g=i.dilationHeight,v=i.dilationWidth,w=i.effectiveFilterDepth,N=i.effectiveFilterHeight,D=i.effectiveFilterWidth,O=i.padInfo.front,k=i.padInfo.top,L=i.padInfo.left,$="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,U=zr(i.outShape,e),V=U.values,W=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],ce=i.outShape[2]*i.outShape[3]*i.outShape[4],ve=i.outShape[3]*i.outShape[4],Ee=i.outShape[4];for(let ge=0;ge<i.batchSize;++ge){const it=ge*W,ut=ge*r[0];for(let Mt=0;Mt<i.inChannels;++Mt)for(let Ot=0;Ot<i.outDepth;++Ot){const vt=Ot*a-O;let Rt=vt;for(;Rt<0;)Rt+=p;const Dt=Math.min(i.inDepth,w+vt),Ht=it+Ot*ce;for(let Bt=0;Bt<i.outHeight;++Bt){const Wt=Bt*o-k;let ln=Wt;for(;ln<0;)ln+=g;const cn=Math.min(i.inHeight,N+Wt),xn=Ht+Bt*ve;for(let rn=0;rn<i.outWidth;++rn){const bn=rn*l-L;let mn=bn;for(;mn<0;)mn+=v;const Mn=Math.min(i.inWidth,D+bn),nr=xn+rn*Ee;let wr=$,yr=0,Wr=0;for(let ws=Rt;ws<Dt;ws+=p){const zs=ut+ws*r[1];for(let Sa=ln;Sa<cn;Sa+=g){const Us=zs+Sa*r[2];for(let Vs=mn;Vs<Mn;Vs+=v){const Ea=n[Us+Vs*r[3]+Mt];if("max"===s&&Ea>wr?wr=Ea:"avg"===s&&(yr+=Ea,Wr++),isNaN(wr))break}if(isNaN(wr))break}if(isNaN(wr))break}V[nr+Mt]="avg"===s?yr/Math.max(Wr,1):wr}}}}return U}const _8={kernelName:Mr,backendName:"cpu",kernelFunc:function w8(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t;lr(i,"avgPool");const{filterSize:s,strides:a,pad:o,dimRoundingMode:l}=r;K(Uo(a,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`);const g=jl(i.shape,s,a,1,o,l);let v;if(1===g.filterWidth&&1===g.filterHeight&&Kt(g.inShape,g.outShape))v=Bh({inputs:{x:i},backend:e});else{const w=e.data.get(i.dataId).values,N=zn(i.shape),D=QP(w,0,i.dtype,N,g,"avg");v=e.makeTensorInfo(g.outShape,i.dtype,D.values)}return v}},S8={kernelName:hn,backendName:"cpu",kernelFunc:function N8(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{filterSize:s,strides:a,pad:o,dimRoundingMode:l,dataFormat:p}=r;lr(i,"avgPool3d");const g=pf(i.shape,s,a,1,o,l,p),w=c4(e.data.get(i.dataId).values,0,i.dtype,zn(i.shape),g,"avg");return e.makeTensorInfo(w.shape,"float32",w.values)}},I8={kernelName:Ys,backendName:"cpu",kernelFunc:function E8(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,input:s}=t,{filterSize:a,strides:o,pad:l,dimRoundingMode:p}=r;lr([i,s],"avgPool3DGrad");const g=pf(s.shape,a,o,1,l,p),v=g.strideDepth,w=g.strideHeight,N=g.strideWidth,D=g.filterDepth,O=g.filterHeight,k=g.filterWidth,L=g.dilationDepth,$=g.dilationHeight,U=g.dilationWidth,V=g.effectiveFilterDepth,W=g.effectiveFilterHeight,ce=g.effectiveFilterWidth,ve=V-1-g.padInfo.front,Ee=ce-1-g.padInfo.left,ge=W-1-g.padInfo.top,it=zr(s.shape,"float32"),ut=1/(D*O*k),Mt=e.bufferSync(i);for(let Ot=0;Ot<g.batchSize;++Ot)for(let vt=0;vt<g.inChannels;++vt)for(let Rt=0;Rt<g.inDepth;++Rt)for(let Dt=0;Dt<g.inHeight;++Dt)for(let Ht=0;Ht<g.inWidth;++Ht){const Bt=Rt-ve,Wt=Dt-ge,ln=Ht-Ee;let cn=0;for(let xn=0;xn<V;xn+=L){const rn=(Bt+xn)/v;if(!(rn<0||rn>=g.outDepth||Math.floor(rn)!==rn))for(let bn=0;bn<W;bn+=$){const mn=(Wt+bn)/w;if(!(mn<0||mn>=g.outHeight||Math.floor(mn)!==mn))for(let Mn=0;Mn<ce;Mn+=U){const nr=(ln+Mn)/N;nr<0||nr>=g.outWidth||Math.floor(nr)!==nr||(cn+=Mt.get(Ot,rn,mn,nr,vt))}}}it.set(cn*ut,Ot,Rt,Dt,Ht,vt)}return e.makeTensorInfo(it.shape,it.dtype,it.values)}},A8={kernelName:Mf,backendName:"cpu",kernelFunc:function C8(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,input:s}=t,a=s;lr([i,s],"avgPoolGrad");const{filterSize:o,strides:l,pad:p}=r,g=jl(a.shape,o,l,1,p),v=g.strideHeight,w=g.strideWidth,N=g.filterHeight,D=g.filterWidth,O=g.dilationHeight,k=g.dilationWidth,L=g.effectiveFilterHeight,$=g.effectiveFilterWidth,U=$-1-g.padInfo.left,V=L-1-g.padInfo.top,W=zr(a.shape,"float32"),ce=1/(N*D),ve=e.data.get(i.dataId).values,Ee=zr(i.shape,"float32",ve);for(let ge=0;ge<g.batchSize;++ge)for(let it=0;it<g.inChannels;++it)for(let ut=0;ut<g.inHeight;++ut)for(let Mt=0;Mt<g.inWidth;++Mt){const Ot=ut-V,vt=Mt-U;let Rt=0;for(let Dt=0;Dt<L;Dt+=O){const Ht=(Ot+Dt)/v;if(!(Ht<0||Ht>=g.outHeight||Math.floor(Ht)!==Ht))for(let Bt=0;Bt<$;Bt+=k){const Wt=(vt+Bt)/w;Wt<0||Wt>=g.outWidth||Math.floor(Wt)!==Wt||(Rt+=Ee.get(ge,Ht,Wt,it))}}W.set(Rt*ce,ge,ut,Mt,it)}return e.makeTensorInfo(W.shape,W.dtype,W.values)}},M8={kernelName:yc,backendName:"cpu",kernelFunc:function T8(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,scale:s,offset:a,mean:o,variance:l}=t;K(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),K(null==a||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),K(null==s||o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),lr([i,o,l,s,a],"batchNorm");let{varianceEpsilon:p}=r;null==p&&(p=.001);const g=e.data.get(i.dataId).values,v=e.data.get(o.dataId).values,w=e.data.get(l.dataId).values,N=s?e.data.get(s.dataId).values:new Float32Array([1]),D=a?e.data.get(a.dataId).values:new Float32Array([0]),O=new Float32Array(g.length),k=D.length,L=N.length,$=w.length,U=v.length;let V=0,W=0,ce=0,ve=0;for(let Ee=0;Ee<g.length;++Ee)O[Ee]=D[V++]+(g[Ee]-v[W++])*N[ce++]/Math.sqrt(w[ve++]+p),V>=k&&(V=0),W>=U&&(W=0),ce>=L&&(ce=0),ve>=$&&(ve=0);return e.makeTensorInfo(i.shape,i.dtype,O)}},D8={kernelName:Ja,backendName:"cpu",kernelFunc:function R8(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{blockShape:s,crops:a}=r;lr([i],"batchToSpaceND");const o=s.reduce((L,$)=>L*$),l=Cm(i.shape,s,o),p=pd(l.length,s.length),g=Am(i.shape,s,o),v=Q1(a,s.length),w=D0(g,a,s.length),N=aa({inputs:{x:i},backend:e,attrs:{shape:l}}),D=Tl({inputs:{x:N},backend:e,attrs:{perm:p}}),O=aa({inputs:{x:D},backend:e,attrs:{shape:g}}),k=Jm({inputs:{x:O},backend:e,attrs:{begin:v,size:w}});return e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(D),e.disposeIntermediateTensorInfo(O),k}},k8={kernelName:mc,backendName:"cpu",kernelFunc:function O8(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,weights:s}=t,{size:a}=r,p=KP(e.data.get(i.dataId).values,e.data.get(s.dataId).values,s.dtype,s.shape,a);return e.makeTensorInfo([a],s.dtype,p)}},F8={kernelName:en,backendName:"cpu",kernelFunc:function P8(n){const{inputs:t,backend:e}=n,{s0:r,s1:i}=t,s=e.data.get(r.dataId).values,a=e.data.get(i.dataId).values,o=$r(Array.from(s),Array.from(a));return e.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},L8=Os(Qa,(n,t)=>n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n),$8={kernelName:Qa,backendName:"cpu",kernelFunc:L8},B8={kernelName:Zi,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend,r=new Float32Array(ft(t.shape)),i=e.data.get(t.dataId),a=i.complexTensorInfos.imag,o=e.data.get(i.complexTensorInfos.real.dataId).values,l=e.data.get(a.dataId).values;for(let p=0;p<o.length;p++)r[p]=Math.hypot(o[p],l[p]);return e.makeOutput(r,t.shape,"float32")}};function Ey(n){const{inputs:t,backend:e}=n,{input:r}=t,i=e.data.get(r.dataId).complexTensorInfos.imag,s=e.data.get(i.dataId).values;return e.makeTensorInfo(i.shape,i.dtype,s)}const z8={kernelName:vl,backendName:"cpu",kernelFunc:Ey};function Iy(n){const{inputs:t,backend:e,attrs:r}=n,{axis:i}=r,s=ar(i,t[0].shape)[0];Y1(t.map(O=>O.shape),s);let o=tc(t.map(O=>O.shape),s);if(0===ft(o))return e.makeTensorInfo(o,t[0].dtype,[]);const l=t.filter(O=>ft(O.shape)>0);if(1===l.length)return Bh({inputs:{x:l[0]},backend:e});if("complex64"===l[0].dtype){const O=l.map(V=>Zm({inputs:{input:V},backend:e})),k=l.map(V=>Ey({inputs:{input:V},backend:e})),L=Iy({inputs:O,backend:e,attrs:{axis:s}}),$=Iy({inputs:k,backend:e,attrs:{axis:s}}),U=cc({inputs:{real:L,imag:$},backend:e});return O.forEach(V=>e.disposeIntermediateTensorInfo(V)),k.forEach(V=>e.disposeIntermediateTensorInfo(V)),e.disposeIntermediateTensorInfo(L),e.disposeIntermediateTensorInfo($),U}const p=l.map(O=>{const L=[-1,ft(O.shape.slice(s))];return aa({inputs:{x:O},backend:e,attrs:{shape:L}})}),g=p.map(O=>({vals:e.data.get(O.dataId).values,shape:O.shape}));o=tc(p.map(O=>O.shape),1);const w=cB(g,o,t[0].dtype,1===p[0].shape[0]),N=tc(l.map(O=>O.shape),s),D=e.makeTensorInfo(N,t[0].dtype,w);return p.forEach(O=>e.disposeIntermediateTensorInfo(O)),D}const U8={kernelName:ci,backendName:"cpu",kernelFunc:Iy};function f4(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,filter:s}=t,{strides:a,pad:o,dataFormat:l,dilations:p,dimRoundingMode:g}=r;lr([i,s],"conv2d");const v=Hf(l),w=vo(i.shape,s.shape,a,p,o,g,!1,v),N=w.filterHeight,D=w.filterWidth,O=w.dilationHeight,k=w.dilationWidth,L=w.padInfo.left,$=w.padInfo.top,U="channelsLast"===w.dataFormat,V=new Ga(w.outShape,i.dtype),W=zn(i.shape),ce=zn(s.shape),ve=W[0],Ee=U?W[1]:W[2],ge=U?W[2]:1,it=U?1:W[1],ut=V.strides[0],Mt=U?V.strides[1]:V.strides[2],Ot=U?V.strides[2]:1,vt=U?1:V.strides[1],Rt=e.data.get(i.dataId).values,Dt=e.data.get(s.dataId).values,Ht=V.values;for(let Bt=0;Bt<w.batchSize;++Bt){const Wt=Bt*ve,ln=Bt*ut;for(let cn=0;cn<w.outHeight;++cn){const xn=ln+cn*Mt,rn=cn*w.strideHeight-$;for(let bn=0;bn<N;++bn){const mn=rn+bn*O;if(mn<0||mn>=w.inHeight)continue;const Mn=bn*ce[0],nr=Wt+mn*Ee;for(let wr=0;wr<w.outWidth;++wr){const yr=xn+wr*Ot,Wr=wr*w.strideWidth-L;for(let Xr=0;Xr<D;++Xr){const ws=Wr+Xr*k;if(ws<0||ws>=w.inWidth)continue;const Sa=nr+ws*ge;let Us=Mn+Xr*ce[1];for(let Vs=0;Vs<w.inChannels;++Vs){const $a=Rt[Sa+Vs*it];for(let Ea=0;Ea<w.outChannels;++Ea)Ht[yr+Ea*vt]+=$a*Dt[Us+Ea];Us+=w.outChannels}}}}}}return e.makeTensorInfo(V.shape,V.dtype,Ht)}const V8={kernelName:kr,backendName:"cpu",kernelFunc:f4},q8={kernelName:ys,backendName:"cpu",kernelFunc:function G8(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,dy:s}=t,{strides:a,pad:o,dataFormat:l,dimRoundingMode:p,filterShape:g}=r;lr([i,s],"conv2dBackpropFilter");const v=Hf(l),w=vo(i.shape,g,a,1,o,p,!1,v),{strideHeight:N,strideWidth:D,filterHeight:O,filterWidth:k}=w,L="channelsLast"===w.dataFormat,$=new Ga(w.filterShape,"float32"),U=w.padInfo.left,V=w.padInfo.top,W=e.data.get(i.dataId).values,ce=e.data.get(s.dataId).values,ve=new Ga(i.shape,i.dtype,W),Ee=new Ga(s.shape,s.dtype,ce);for(let ge=0;ge<O;++ge){const it=Math.max(0,Math.ceil((V-ge)/N)),ut=Math.min(w.outHeight,(w.inHeight+V-ge)/N);for(let Mt=0;Mt<k;++Mt){const Ot=Math.max(0,Math.ceil((U-Mt)/D)),vt=Math.min(w.outWidth,(w.inWidth+U-Mt)/D);for(let Rt=0;Rt<w.inChannels;++Rt)for(let Dt=0;Dt<w.outChannels;++Dt){let Ht=0;for(let Bt=0;Bt<w.batchSize;++Bt)for(let Wt=it;Wt<ut;++Wt){const ln=ge+Wt*N-V;for(let cn=Ot;cn<vt;++cn){const xn=Mt+cn*D-U;Ht+=L?ve.get(Bt,ln,xn,Rt)*Ee.get(Bt,Wt,cn,Dt):ve.get(Bt,Rt,ln,xn)*Ee.get(Bt,Dt,Wt,cn)}}$.set(Ht,ge,Mt,Rt,Dt)}}}return e.makeTensorInfo($.shape,$.dtype,$.values)}},H8={kernelName:uh,backendName:"cpu",kernelFunc:function W8(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,filter:s}=t,{inputShape:a,strides:o,pad:l,dataFormat:p,dimRoundingMode:g}=r;lr([i,s],"conv2dBackpropInput");const v=zn(s.shape),w=zn(i.shape);let N=Hf(p);const D=vo(a,s.shape,o,1,l,g,!1,N),O=new Ga(D.inShape,"float32"),k=O.values,L=e.data.get(i.dataId).values,$=e.data.get(s.dataId).values,[U,V,W]=v,{batchSize:ce,filterHeight:ve,filterWidth:Ee,inChannels:ge,inHeight:it,inWidth:ut,outChannels:Mt,outHeight:Ot,outWidth:vt,strideHeight:Rt,strideWidth:Dt}=D;N=D.dataFormat;const Ht=ve-1-D.padInfo.top,Bt=Ee-1-D.padInfo.left,Wt="channelsLast"===N,ln=O.strides[0],cn=Wt?O.strides[1]:O.strides[2],xn=Wt?O.strides[2]:1,rn=Wt?1:O.strides[1],bn=w[0],mn=Wt?w[1]:w[2],Mn=Wt?w[2]:1,nr=Wt?1:w[1];for(let wr=0;wr<ce;++wr)for(let yr=0;yr<ge;++yr)for(let Wr=0;Wr<it;++Wr){const Xr=Wr-Ht,ws=Math.max(0,Math.ceil(Xr/Rt)),zs=Math.min(Ot,(ve+Xr)/Rt);for(let Sa=0;Sa<ut;++Sa){const Us=Sa-Bt,Vs=Math.max(0,Math.ceil(Us/Dt)),$a=Math.min(vt,(Ee+Us)/Dt);let Ea=0;for(let Au=ws;Au<zs;++Au){const Pd=Au*Rt-Xr;for(let Wc=Vs;Wc<$a;++Wc){const ah=bn*wr+mn*Au+Mn*Wc,Dp=U*(ve-1-Pd)+V*(Ee-1-(Wc*Dt-Us))+W*yr;for(let Fd=0;Fd<Mt;++Fd)Ea+=L[ah+nr*Fd]*$[Dp+Fd]}}k[ln*wr+cn*Wr+xn*Sa+rn*yr]=Ea}}return e.makeTensorInfo(O.shape,O.dtype,O.values)}},K8={kernelName:lh,backendName:"cpu",kernelFunc:function X8(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,filter:s}=t,{strides:a,pad:o,dilations:l}=r;lr([i,s],"conv3d");const p=_h(i.shape,s.shape,a,l,o),{filterDepth:g,filterHeight:v,filterWidth:w,dilationDepth:N,dilationHeight:D,dilationWidth:O,padInfo:k}=p,L=k.front,$=k.left,U=k.top,V=new Ga(p.outShape,i.dtype),W=e.data.get(i.dataId).values,ce=e.data.get(s.dataId).values,ve=V.values,Ee=zn(i.shape),ge=zn(s.shape);for(let it=0;it<p.batchSize;++it){const ut=it*Ee[0],Mt=it*V.strides[0];for(let Ot=0;Ot<p.outDepth;++Ot){const vt=Mt+Ot*V.strides[1],Rt=Ot*p.strideDepth-L;for(let Dt=0;Dt<g;++Dt){const Ht=Rt+Dt*N;if(Ht<0||Ht>=p.inDepth)continue;const Bt=Dt*ge[0],Wt=ut+Ht*Ee[1];for(let ln=0;ln<p.outHeight;++ln){const cn=vt+ln*V.strides[2],xn=ln*p.strideHeight-U;for(let rn=0;rn<v;++rn){const bn=xn+rn*D;if(bn<0||bn>=p.inHeight)continue;const mn=Bt+rn*ge[1],Mn=Wt+bn*Ee[2];for(let nr=0;nr<p.outWidth;++nr){const wr=cn+nr*p.outChannels,yr=nr*p.strideWidth-$;for(let Wr=0;Wr<w;++Wr){const Xr=yr+Wr*O;if(Xr<0||Xr>=p.inWidth)continue;const zs=Mn+Xr*p.inChannels;let Sa=mn+Wr*ge[2];for(let Us=0;Us<p.inChannels;++Us){const Vs=W[zs+Us];for(let $a=0;$a<p.outChannels;++$a)ve[wr+$a]+=Vs*ce[Sa+$a];Sa+=p.outChannels}}}}}}}}return e.makeTensorInfo(V.shape,V.dtype,V.values)}},Z8={kernelName:Ca,backendName:"cpu",kernelFunc:function Y8(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,dy:s}=t,{strides:a,pad:o,filterShape:l}=r;lr([i,s],"conv3dBackpropFilterV2");const p=zn(i.shape),g=zn(s.shape),v=_h(i.shape,l,a,1,o),w=v.strideDepth,N=v.strideHeight,D=v.strideWidth,O=v.filterDepth,k=v.filterHeight,L=v.filterWidth,$=new Ga(v.filterShape,"float32"),U=$.values,[V,W,ce,ve]=$.strides,Ee=e.data.get(s.dataId).values,[ge,it,ut,Mt]=g,Ot=e.data.get(i.dataId).values,[vt,Rt,Dt,Ht]=p,Bt=v.padInfo.front,Wt=v.padInfo.left,ln=v.padInfo.top;for(let cn=0;cn<O;++cn){const xn=Math.max(0,Math.ceil((Bt-cn)/w)),rn=Math.min(v.outDepth,(v.inDepth+Bt-cn)/w),bn=cn*V;for(let mn=0;mn<k;++mn){const Mn=Math.max(0,Math.ceil((ln-mn)/N)),nr=Math.min(v.outHeight,(v.inHeight+ln-mn)/N),wr=mn*W+bn;for(let yr=0;yr<L;++yr){const Wr=Math.max(0,Math.ceil((Wt-yr)/D)),Xr=Math.min(v.outWidth,(v.inWidth+Wt-yr)/D),ws=yr*ce+wr;for(let zs=0;zs<v.inChannels;++zs){const Sa=zs*ve+ws;for(let Us=0;Us<v.outChannels;++Us){let Vs=0;for(let $a=0;$a<v.batchSize;++$a){const Ea=$a*vt,Rp=$a*ge;for(let Au=xn;Au<rn;++Au){const Wc=(cn+Au*w-Bt)*Rt+Ea,cg=Au*it+Rp;for(let ah=Mn;ah<nr;++ah){const Fd=(mn+ah*N-ln)*Dt+Wc,Ld=ah*ut+cg;for(let $d=Wr;$d<Xr;++$d)Vs+=Ot[(yr+$d*D-Wt)*Ht+Fd+zs]*Ee[$d*Mt+Ld+Us]}}}U[Sa+Us]=Vs}}}}}return e.makeTensorInfo($.shape,$.dtype,$.values)}},J8={kernelName:hu,backendName:"cpu",kernelFunc:function j8(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,filter:s}=t,{pad:a,strides:o,inputShape:l}=r;lr([i],"conv3dBackpropInputV2");const p=zn(i.shape),g=zn(s.shape),v=_h(l,s.shape,o,1,a),w=new Ga(v.inShape,"float32"),N=w.values,[D,O,k,L]=w.strides,$=e.data.get(i.dataId).values,[U,V,W,ce]=p,ve=e.data.get(s.dataId).values,[Ee,ge,it,ut]=g,{batchSize:Mt,filterDepth:Ot,filterHeight:vt,filterWidth:Rt,inChannels:Dt,inDepth:Ht,inHeight:Bt,inWidth:Wt,outChannels:ln,outDepth:cn,outHeight:xn,outWidth:rn,strideDepth:bn,strideHeight:mn,strideWidth:Mn}=v,nr=Ot-1-v.padInfo.front,wr=vt-1-v.padInfo.top,yr=Rt-1-v.padInfo.left;for(let Wr=0;Wr<Mt;++Wr)for(let Xr=0;Xr<Dt;++Xr)for(let ws=0;ws<Ht;++ws){const zs=ws-nr,Sa=Math.max(0,Math.ceil(zs/bn)),Us=Math.min(cn,(Ot+zs)/bn);for(let Vs=0;Vs<Bt;++Vs){const $a=Vs-wr,Ea=Math.max(0,Math.ceil($a/mn)),Rp=Math.min(xn,(vt+$a)/mn);for(let Au=0;Au<Wt;++Au){const Pd=Au-yr,Wc=Math.max(0,Math.ceil(Pd/Mn)),cg=Math.min(rn,(Rt+Pd)/Mn);let ah=0;for(let Dp=Sa;Dp<Us;++Dp){const Fd=Dp*bn-zs;for(let Ld=Ea;Ld<Rp;++Ld){const $d=Ld*mn-$a;for(let uw=Wc;uw<cg;++uw){const zL=U*Wr+V*Dp+W*Ld+ce*uw,Jue=Ee*(Ot-1-Fd)+ge*(vt-1-$d)+it*(Rt-1-(uw*Mn-Pd))+ut*Xr;for(let P2=0;P2<ln;++P2)ah+=$[zL+P2]*ve[Jue+P2]}}}N[D*Wr+O*ws+k*Vs+L*Au+Xr]=ah}}}return e.makeTensorInfo(w.shape,w.dtype,w.values)}},Q8=Os(eo,n=>Math.cos(n)),eW={kernelName:eo,backendName:"cpu",kernelFunc:Q8},tW=Os(Jr,n=>Math.cosh(n)),nW={kernelName:Jr,backendName:"cpu",kernelFunc:tW},iW={kernelName:gl,backendName:"cpu",kernelFunc:function rW(n){const{inputs:t,backend:e,attrs:r}=n,{image:i,boxes:s,boxInd:a}=t,{cropSize:o,method:l,extrapolationValue:p}=r,[g,v,w,N]=i.shape,D=s.shape[0],[O,k]=o,L=zr([D,O,k,N],"float32"),$=e.data.get(s.dataId).values,U=e.data.get(a.dataId).values,V=e.data.get(i.dataId).values,W=zn(i.shape),ce=zn(L.shape);for(let ve=0;ve<D;ve++){const Ee=4*ve,ge=$[Ee],it=$[Ee+1],ut=$[Ee+2],Mt=$[Ee+3],Ot=U[ve];if(Ot>=g)continue;const vt=O>1?(ut-ge)*(v-1)/(O-1):0,Rt=k>1?(Mt-it)*(w-1)/(k-1):0;for(let Dt=0;Dt<O;Dt++){const Ht=O>1?ge*(v-1)+Dt*vt:.5*(ge+ut)*(v-1);if(Ht<0||Ht>v-1)for(let Bt=0;Bt<k;Bt++)for(let Wt=0;Wt<N;Wt++)L.values[Wt+Bt*ce[2]+Dt*ce[1]+ve*ce[0]]=p;else if("bilinear"===l){const Bt=Math.floor(Ht),Wt=Math.ceil(Ht),ln=Ht-Bt;for(let cn=0;cn<k;cn++){const xn=k>1?it*(w-1)+cn*Rt:.5*(it+Mt)*(w-1);if(xn<0||xn>w-1){for(let Mn=0;Mn<N;Mn++)L.values[Mn+cn*ce[2]+Dt*ce[1]+ve*ce[0]]=p;continue}const rn=Math.floor(xn),bn=Math.ceil(xn),mn=xn-rn;for(let Mn=0;Mn<N;Mn++){let nr=Mn+rn*W[2]+Bt*W[1]+Ot*W[0];const wr=V[nr];nr=Mn+bn*W[2]+Bt*W[1]+Ot*W[0];const yr=V[nr];nr=Mn+rn*W[2]+Wt*W[1]+Ot*W[0];const Wr=V[nr];nr=Mn+bn*W[2]+Wt*W[1]+Ot*W[0];const Xr=V[nr],ws=wr+(yr-wr)*mn;nr=Mn+cn*ce[2]+Dt*ce[1]+ve*ce[0],L.values[nr]=ws+(Wr+(Xr-Wr)*mn-ws)*ln}}}else for(let Bt=0;Bt<k;++Bt){const Wt=k>1?it*(w-1)+Bt*Rt:.5*(it+Mt)*(w-1);if(Wt<0||Wt>w-1){for(let xn=0;xn<N;xn++)L.values[xn+Bt*ce[2]+Dt*ce[1]+ve*ce[0]]=p;continue}const ln=Math.round(Wt),cn=Math.round(Ht);for(let xn=0;xn<N;xn++)L.values[xn+Bt*ce[2]+Dt*ce[1]+ve*ce[0]]=V[xn+ln*W[2]+cn*W[1]+Ot*W[0]]}}}return e.makeTensorInfo(L.shape,L.dtype,L.values)}},aW={kernelName:Zc,backendName:"cpu",kernelFunc:function sW(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:s,exclusive:a,reverse:o}=r;lr(i,"cumprod");const l=na([s],i.shape.length);let p=i;null!=l&&(p=Tl({inputs:{x:i},backend:e,attrs:{perm:l}}));const g=ka(1,i.shape.length)[0];if(g!==p.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${p.shape.length-1} but got axis=${g}`);const v=$u(p.dtype,"int32"),w=Ur(ft(p.shape),v),N=e.data.get(p.dataId).values,D=p.shape[p.shape.length-1],O=o?(L,$)=>L+D-$-1:(L,$)=>L+$;for(let L=0;L<N.length;L+=D)for(let $=0;$<D;$++){const U=O(L,$);if(0===$)w[U]=a?1:N[U];else{const V=O(L,$-1);w[U]=a?N[V]*w[V]:N[U]*w[V]}}const k=e.makeTensorInfo(p.shape,v,w);if(null!=l){const $=Tl({inputs:{x:k},backend:e,attrs:{perm:Ch(l)}});return e.disposeIntermediateTensorInfo(k),e.disposeIntermediateTensorInfo(p),$}return k}},uW={kernelName:Zs,backendName:"cpu",kernelFunc:function oW(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:s,exclusive:a,reverse:o}=r;lr(i,"cumsum");const l=na([s],i.shape.length);let p=i;null!=l&&(p=Tl({inputs:{x:i},backend:e,attrs:{perm:l}}));const g=ka(1,i.shape.length)[0];if(g!==p.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${p.shape.length-1} but got axis=${g}`);const v=$u(p.dtype,"int32"),w=Ki(ft(p.shape),v),N=e.data.get(p.dataId).values,D=p.shape[p.shape.length-1],O=o?(L,$)=>L+D-$-1:(L,$)=>L+$;for(let L=0;L<N.length;L+=D)for(let $=0;$<D;$++){const U=O(L,$);if(0===$)w[U]=a?0:N[U];else{const V=O(L,$-1);w[U]=a?N[V]+w[V]:N[U]+w[V]}}const k=e.makeTensorInfo(p.shape,v,w);if(null!=l){const $=Tl({inputs:{x:k},backend:e,attrs:{perm:Ch(l)}});return e.disposeIntermediateTensorInfo(k),e.disposeIntermediateTensorInfo(p),$}return k}},cW={kernelName:Qu,backendName:"cpu",kernelFunc:function lW(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,weights:s}=t,{size:a,binaryOutput:o}=r;if(1===i.shape.length){const g=KP(e.data.get(i.dataId).values,e.data.get(s.dataId).values,s.dtype,s.shape,a);return e.makeTensorInfo([a],s.dtype,g)}if(2===i.shape.length){const g=uB(e.bufferSync(i),e.bufferSync(s),a,o);return e.makeTensorInfo(g.shape,s.dtype,g.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}},hW={kernelName:Qi,backendName:"cpu",kernelFunc:function fW(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{blockSize:s,dataFormat:a}=r;K("NHWC"===a,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`);const o=i.shape[0],l=i.shape[1],p=i.shape[2],g=i.shape[3],v=l*s,w=p*s,N=g/(s*s),D=e.data.get(i.dataId).values,O=new Float32Array(o*v*w*N);let k=0;for(let L=0;L<o;++L)for(let $=0;$<v;++$){const U=Math.floor($/s),V=$%s;for(let W=0;W<w;++W){const ce=Math.floor(W/s),Ee=(V*s+W%s)*N;for(let ge=0;ge<N;++ge)O[k++]=D[ge+Ee+g*(ce+p*(U+l*L))]}}return e.makeTensorInfo([o,v,w,N],i.dtype,O)}};function h4(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,filter:s}=t,{strides:a,pad:o,dilations:l,dimRoundingMode:p}=r;lr([i,s],"depthwiseConv2DNative");const g=zn(i.shape),v=zn(s.shape);let w=l;null==w&&(w=[1,1]),K(Uo(a,w),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${w}'`);const N=vo(i.shape,s.shape,a,w,o,p,!0),{filterHeight:D,filterWidth:O,dilationHeight:k,dilationWidth:L,padInfo:$}=N,U=$.left,V=$.top,W=N.outChannels/N.inChannels,ce=new Ga(N.outShape,i.dtype),ve=e.data.get(i.dataId).values,Ee=e.data.get(s.dataId).values,ge=ce.values;for(let it=0;it<N.batchSize;++it){const ut=it*g[0],Mt=it*ce.strides[0];for(let Ot=0;Ot<N.outHeight;++Ot){const vt=Mt+Ot*ce.strides[1],Rt=Ot*N.strideHeight-V;for(let Dt=0;Dt<D;++Dt){const Ht=Rt+Dt*k;if(Ht<0||Ht>=N.inHeight)continue;const Bt=Dt*v[0],Wt=ut+Ht*g[1];for(let ln=0;ln<N.outWidth;++ln){const cn=vt+ln*ce.strides[2],xn=ln*N.strideWidth-U;for(let rn=0;rn<O;++rn){const bn=xn+rn*L;if(bn<0||bn>=N.inWidth)continue;const Mn=Wt+bn*N.inChannels;let nr=cn,wr=Bt+rn*v[1];for(let yr=0;yr<N.inChannels;++yr){const Wr=ve[Mn+yr];for(let Xr=0;Xr<W;++Xr)ge[nr+Xr]+=Wr*Ee[wr+Xr];nr+=W,wr+=W}}}}}}return e.makeTensorInfo(ce.shape,ce.dtype,ce.values)}const pW={kernelName:la,backendName:"cpu",kernelFunc:h4},mW={kernelName:Fl,backendName:"cpu",kernelFunc:function dW(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,dy:s}=t,{strides:a,dilations:o,pad:l,dimRoundingMode:p,filterShape:g}=r;lr([i,s],"depthwiseConv2dNativeBackpropFilter");const v=vo(i.shape,g,a,o,l,p,!0),{strideHeight:w,strideWidth:N,filterHeight:D,filterWidth:O}=v,k=new Ga(v.filterShape,"float32"),L=v.padInfo.left,$=v.padInfo.top,U=v.outChannels/v.inChannels,V=e.data.get(i.dataId).values,W=new Ga(i.shape,i.dtype,V),ce=e.data.get(s.dataId).values,ve=new Ga(s.shape,s.dtype,ce);for(let Ee=0;Ee<D;++Ee){const ge=Math.max(0,Math.ceil(($-Ee)/w)),it=Math.min(v.outHeight,(v.inHeight+$-Ee)/w);for(let ut=0;ut<O;++ut){const Mt=Math.max(0,Math.ceil((L-ut)/N)),Ot=Math.min(v.outWidth,(v.inWidth+L-ut)/N);for(let vt=0;vt<v.outChannels;++vt){const Rt=Math.trunc(vt/U),Dt=vt%U;let Ht=0;for(let Bt=0;Bt<v.batchSize;++Bt)for(let Wt=ge;Wt<it;++Wt){const ln=Ee+Wt*w-$;for(let cn=Mt;cn<Ot;++cn)Ht+=W.get(Bt,ln,ut+cn*N-L,Rt)*ve.get(Bt,Wt,cn,vt)}k.set(Ht,Ee,ut,Rt,Dt)}}}return e.makeTensorInfo(k.shape,k.dtype,k.values)}},yW={kernelName:Mo,backendName:"cpu",kernelFunc:function gW(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,filter:s}=t,{strides:a,dilations:o,pad:l,dimRoundingMode:p,inputShape:g}=r;lr([i,s],"depthwiseConv2DNativeBackpropInput");const v=zn(i.shape),w=zn(s.shape),N=vo(g,s.shape,a,o,l,p,!0),D=new Ga(N.inShape,"float32"),O=D.values,[k,L,$]=D.strides,U=e.data.get(i.dataId).values,[V,W,ce]=v,ve=e.data.get(s.dataId).values,[Ee,ge,it]=w,{batchSize:ut,filterHeight:Mt,filterWidth:Ot,inChannels:vt,inHeight:Rt,inWidth:Dt,outChannels:Ht,outHeight:Bt,outWidth:Wt,strideHeight:ln,strideWidth:cn}=N,xn=Mt-1-N.padInfo.top,rn=Ot-1-N.padInfo.left,bn=Ht/vt;for(let mn=0;mn<ut;++mn)for(let Mn=0;Mn<vt;++Mn)for(let nr=0;nr<Rt;++nr){const wr=nr-xn,yr=Math.max(0,Math.ceil(wr/ln)),Wr=Math.min(Bt,(Mt+wr)/ln);for(let Xr=0;Xr<Dt;++Xr){const ws=Xr-rn,zs=Math.max(0,Math.ceil(ws/cn)),Sa=Math.min(Wt,(Ot+ws)/cn);let Us=0;for(let Vs=yr;Vs<Wr;++Vs){const $a=Vs*ln-wr;for(let Ea=zs;Ea<Sa;++Ea){const Au=V*mn+W*Vs+ce*Ea,Pd=Ee*(Mt-1-$a)+ge*(Ot-1-(Ea*cn-ws))+it*Mn;for(let Wc=0;Wc<bn;++Wc)Us+=U[Au+(Mn*bn+Wc)]*ve[Pd+Wc]}}O[k*mn+L*nr+$*Xr+Mn]=Us}}return e.makeTensorInfo(D.shape,D.dtype,D.values)}},xW={kernelName:Tu,backendName:"cpu",kernelFunc:function vW(n){const{inputs:t,backend:e}=n,{x:r}=t,i=ft(r.shape),s=e.data.get(r.dataId).values,a=zr([i,i],r.dtype),o=a.values;for(let p=0;p<s.length;p++)o[p*i+p]=s[p];const l=[...r.shape,...r.shape];return e.makeTensorInfo(l,a.dtype,a.values)}},bW={kernelName:Mu,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:i}=n,{strides:s,pad:a,dilations:o}=e,l=t,p=l.data.get(r.dataId).values,g=r.shape.length,v=l.data.get(i.dataId).values,w=i.shape.length,{batchSize:N,inHeight:D,inWidth:O,inChannels:k,outHeight:L,outWidth:$,padInfo:U,strideHeight:V,strideWidth:W,filterHeight:ce,filterWidth:ve,dilationHeight:Ee,dilationWidth:ge,outShape:it}=lm(r.shape,i.shape,s,a,"NHWC",o),ut=ft(it),Mt=it.length,Ot=Dr(r.dtype,ut);for(let Rt=0;Rt<N;++Rt)for(let Dt=0;Dt<L;++Dt){const Ht=Dt*V-U.top;for(let Bt=0;Bt<$;++Bt){const Wt=Bt*W-U.left;for(let ln=0;ln<k;++ln){let cn=Number.MIN_SAFE_INTEGER;for(let rn=0;rn<ce;++rn){const bn=Ht+rn*Ee;if(bn>=0&&bn<D)for(let mn=0;mn<ve;++mn){const Mn=Wt+mn*ge;if(Mn>=0&&Mn<O){const nr=Yi([Rt,bn,Mn,ln],g,zn(r.shape)),wr=Yi([rn,mn,ln],w,zn(i.shape)),yr=p[nr]+v[wr];yr>cn&&(cn=yr)}}}Ot[Yi([Rt,Dt,Bt,ln],Mt,zn(it))]=cn}}}return{dataId:l.write(io(Ot,r.dtype),it,r.dtype),shape:it,dtype:r.dtype}}},wW={kernelName:Ts,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:i,dy:s}=n,{strides:a,pad:o,dilations:l}=e,p=t,g=Za(r.shape,p.data.get(r.dataId).values),v=Za(i.shape,p.data.get(i.dataId).values),{batchSize:w,inHeight:N,inWidth:D,inChannels:O,outHeight:k,outWidth:L,padInfo:$,strideHeight:U,strideWidth:V,filterHeight:W,filterWidth:ce,dilationHeight:ve,dilationWidth:Ee,outShape:ge}=lm(r.shape,i.shape,a,o,"NHWC",l);K(s.rank===ge.length,()=>`Error in ${Ts}, dy must have the same rank as output ${ge.length}, but got ${s.rank}`);const it=Za(ge,p.data.get(s.dataId).values),ut=oa(i.shape,i.dtype);for(let Ot=0;Ot<w;++Ot)for(let vt=0;vt<k;++vt){const Rt=vt*U-$.top;for(let Dt=0;Dt<L;++Dt){const Ht=Dt*V-$.left;for(let Bt=0;Bt<O;++Bt){let Wt=Number.MIN_SAFE_INTEGER,ln=0,cn=0;for(let xn=0;xn<W;++xn){const rn=Rt+xn*ve;if(rn>=0&&rn<N)for(let bn=0;bn<ce;++bn){const mn=Ht+bn*Ee;if(mn>=0&&mn<D){const Mn=g[Ot][rn][mn][Bt]+v[xn][bn][Bt];Mn>Wt&&(Wt=Mn,ln=xn,cn=bn)}}}ut[ln][cn][Bt]+=it[Ot][vt][Dt][Bt]}}}return{dataId:p.write(io(ut,r.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},_W={kernelName:Ll,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:i,dy:s}=n,{strides:a,pad:o,dilations:l}=e,p=t,g=Za(r.shape,p.data.get(r.dataId).values),v=Za(i.shape,p.data.get(i.dataId).values),{batchSize:w,inHeight:N,inWidth:D,inChannels:O,outHeight:k,outWidth:L,padInfo:$,strideHeight:U,strideWidth:V,filterHeight:W,filterWidth:ce,dilationHeight:ve,dilationWidth:Ee,outShape:ge}=lm(r.shape,i.shape,a,o,"NHWC",l);K(s.rank===ge.length,()=>`Error in ${Ll}, dy must have the same rank as output ${ge.length}, but got ${s.rank}`);const it=Za(ge,p.data.get(s.dataId).values),ut=oa(r.shape,r.dtype);for(let Ot=0;Ot<w;++Ot)for(let vt=0;vt<k;++vt){const Rt=vt*U-$.top;for(let Dt=0;Dt<L;++Dt){const Ht=Dt*V-$.left;for(let Bt=0;Bt<O;++Bt){let Wt=Number.MIN_SAFE_INTEGER,ln=Rt<0?0:Rt,cn=Ht<0?0:Ht;for(let xn=0;xn<W;++xn){const rn=Rt+xn*ve;if(rn>=0&&rn<N)for(let bn=0;bn<ce;++bn){const mn=Ht+bn*Ee;if(mn>=0&&mn<D){const Mn=g[Ot][rn][mn][Bt]+v[xn][bn][Bt];Mn>Wt&&(Wt=Mn,ln=rn,cn=mn)}}}ut[Ot][ln][cn][Bt]+=it[Ot][vt][Dt][Bt]}}}return{dataId:p.write(io(ut,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function Ib(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:s,keepDims:a}=r;let o;lr(i,"sum"),o="bool"===i.dtype?Cd({inputs:{x:i},backend:e,attrs:{dtype:"int32"}}):Bh({inputs:{x:i},backend:e});const l=o.shape.length,p=ar(s,o.shape),g=na(p,l);let v=p,w=o;null!=g&&(w=Tl({inputs:{x:o},backend:e,attrs:{perm:g}}),v=ka(v.length,l)),Vo("sum",v,w.shape.length);const[N,D]=ao(w.shape,v);let k=SC(e,N,$u(w.dtype,"int32"));const L=ft(D),$=e.data.get(k.dataId).values,U=e.data.get(w.dataId).values;for(let V=0;V<$.length;++V){const W=V*L;let ce=0;for(let ve=0;ve<L;++ve)ce+=U[W+ve];$[V]=ce}if(a){const W=k;k=aa({inputs:{x:k},backend:e,attrs:{shape:Oa(k.shape,p)}}),e.disposeIntermediateTensorInfo(W)}return e.disposeIntermediateTensorInfo(o),null!=g&&e.disposeIntermediateTensorInfo(w),k}const NW={kernelName:ot,backendName:"cpu",kernelFunc:Ib},EW={kernelName:Ro,backendName:"cpu",kernelFunc:function SW(n){const{inputs:t,backend:e,attrs:r}=n,{equation:i}=r,s=t,{allDims:a,summedDims:o,idDims:l}=ox(i,s.length);ux(a.length,l,s);const{path:p,steps:g}=lx(o,l),v=g.length;let w=null,N=a.length;const D=[];for(let O=0;O<v;++O){for(const k of g[O]){const{permutationIndices:L,expandDims:$}=F0(N,l[k]);let U;L0(L)?U=s[k]:(U=Tl({inputs:{x:s[k]},backend:e,attrs:{perm:L}}),D.push(U));const V=U.shape.slice();for(let W=0;W<$.length;++W)V.splice($[W],0,1);Kt(U.shape,V)||(U=aa({inputs:{x:U},backend:e,attrs:{shape:V}}),D.push(U)),null===w?w=U:(w=EC({inputs:{a:U,b:w},backend:e}),D.push(w))}O<v-1&&(p[O]>=0&&(w=Ib({inputs:{x:w},backend:e,attrs:{axis:p[O]-(a.length-N),keepDims:!1}}),D.push(w)),N--)}for(const O of D)O!==w&&e.disposeIntermediateTensorInfo(O);return w}},CW={kernelName:Gs,backendName:"cpu",kernelFunc:function IW(n){const{inputs:t,backend:e}=n,{dy:r,y:i}=t;lr([r,i],"eluGrad");const s=new Float32Array(ft(i.shape)),a=e.data.get(i.dataId).values,o=e.data.get(r.dataId).values;for(let l=0;l<a.length;++l){const p=a[l];s[l]=p>=0?o[l]:o[l]*(p+1)}return e.makeTensorInfo(i.shape,"float32",s)}},AW=P0,TW=ex,MW=tx,RW=nx,DW=rx,OW=ix,kW=Os(gc,n=>{const t=Math.sign(n),e=Math.abs(n),r=1/(1+AW*e);return t*(1-((((OW*r+DW)*r+RW)*r+MW)*r+TW)*r*Math.exp(-e*e))}),PW={kernelName:gc,backendName:"cpu",kernelFunc:kW};function AC(n){const{inputs:t,backend:e,attrs:r}=n,{input:i}=t,{dim:s}=r,a=i.shape.length,o=i.shape.slice();let l=s;return s<0&&(K(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+s+1),o.splice(l,0,1),aa({inputs:{x:i},backend:e,attrs:{shape:o}})}const FW={kernelName:ch,backendName:"cpu",kernelFunc:AC},LW=Io((n,t)=>n/t),eF=ou(Rf,LW),tF={kernelName:Rf,backendName:"cpu",kernelFunc:eF};function p4(n,t,e){const r=n.shape,i=r[0],s=r[1],a=e.data.get(n.dataId),o=a.complexTensorInfos.real,l=a.complexTensorInfos.imag,p=[i,s],g=ft(p),v=hi("float32",g),w=hi("float32",g);for(let k=0;k<i;k++){const L=Jm({inputs:{x:o},backend:e,attrs:{begin:[k,0],size:[1,s]}}),$=Jm({inputs:{x:l},backend:e,attrs:{begin:[k,0],size:[1,s]}}),U=cc({inputs:{real:L,imag:$},backend:e}),{real:V,imag:W}=$W(U,t,e),ce=Dc(V,W);for(let ve=0;ve<s;ve++){const Ee=sx(ce,ve);v[k*s+ve]=Ee.real,w[k*s+ve]=Ee.imag}e.disposeIntermediateTensorInfo(L),e.disposeIntermediateTensorInfo($),e.disposeIntermediateTensorInfo(U)}const N=e.makeTensorInfo(p,"float32",v),D=e.makeTensorInfo(p,"float32",w),O=cc({inputs:{real:N,imag:D},backend:e});return e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(D),O}function $W(n,t,e){const r=ft(n.shape),i=e.data.get(n.dataId),s=e.data.get(i.complexTensorInfos.real.dataId).values,a=e.data.get(i.complexTensorInfos.imag.dataId).values;if(function BW(n){return 0==(n&n-1)}(r)){const o=nF(s,a,r,t,e),l=[n.shape[0],n.shape[1]];if(t){const p=e.makeTensorInfo(l,"float32",o.real),g=e.makeTensorInfo(l,"float32",o.imag),v=e.makeTensorInfo([],"float32",ji(r,"float32")),w=Bh({inputs:{x:v},backend:e}),N=tF.kernelFunc({inputs:{a:p,b:v},backend:e}),D=tF.kernelFunc({inputs:{a:g,b:w},backend:e}),O=e.data.get(N.dataId).values,k=e.data.get(D.dataId).values;return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(D),{real:O,imag:k}}return o}{const l=function zW(n,t,e){const r=new Float32Array(2*t);for(let i=0;i<t;i++){let s=0,a=0;for(let o=0;o<t;o++){const l=DS(i*o,t,e),p=sx(n,o);s+=p.real*l.real-p.imag*l.imag,a+=p.real*l.imag+p.imag*l.real}e&&(s/=t,a/=t),MS(r,s,a,i)}return r}(Dc(s,a),r,t);return CS(l)}}function nF(n,t,e,r,i){if(1===e)return{real:n,imag:t};const s=Dc(n,t),a=e/2,o=AS(s),l=o.real,p=o.imag,g=[l.length],v=i.makeTensorInfo(g,"float32",l),w=i.makeTensorInfo(g,"float32",p),N=cc({inputs:{real:v,imag:w},backend:i}),D=TS(s),O=D.real,k=D.imag,L=[O.length],$=i.makeTensorInfo(L,"float32",O),U=i.makeTensorInfo(L,"float32",k),V=cc({inputs:{real:$,imag:U},backend:i}),W=nF(l,p,a,r,i),ce=W.real,ve=W.imag,Ee=[ce.length],ge=i.makeTensorInfo(Ee,"float32",ce),it=i.makeTensorInfo(Ee,"float32",ve),ut=cc({inputs:{real:ge,imag:it},backend:i}),Mt=nF(O,k,a,r,i),Ot=Mt.real,vt=Mt.imag,Rt=[Ot.length],Dt=i.makeTensorInfo(Rt,"float32",Ot),Ht=i.makeTensorInfo(Rt,"float32",vt),Bt=cc({inputs:{real:Dt,imag:Ht},backend:i}),Wt=RS(e,r),ln=[Wt.real.length],cn=i.makeTensorInfo(ln,"float32",Wt.real),xn=i.makeTensorInfo(ln,"float32",Wt.imag),rn=cc({inputs:{real:cn,imag:xn},backend:i}),bn=EC({inputs:{a:rn,b:Bt},backend:i}),mn=Sy({inputs:{a:ut,b:bn},backend:i}),Mn=JP({inputs:{a:ut,b:bn},backend:i}),nr=Zm({inputs:{input:mn},backend:i}),wr=Zm({inputs:{input:Mn},backend:i}),yr=Ey({inputs:{input:mn},backend:i}),Wr=Ey({inputs:{input:Mn},backend:i}),Xr=Iy({inputs:[nr,wr],backend:i,attrs:{axis:0}}),ws=Iy({inputs:[yr,Wr],backend:i,attrs:{axis:0}}),zs=i.data.get(Xr.dataId).values,Sa=i.data.get(ws.dataId).values;return i.disposeIntermediateTensorInfo(v),i.disposeIntermediateTensorInfo(w),i.disposeIntermediateTensorInfo(N),i.disposeIntermediateTensorInfo($),i.disposeIntermediateTensorInfo(U),i.disposeIntermediateTensorInfo(V),i.disposeIntermediateTensorInfo(ge),i.disposeIntermediateTensorInfo(it),i.disposeIntermediateTensorInfo(ut),i.disposeIntermediateTensorInfo(Dt),i.disposeIntermediateTensorInfo(Ht),i.disposeIntermediateTensorInfo(Bt),i.disposeIntermediateTensorInfo(cn),i.disposeIntermediateTensorInfo(xn),i.disposeIntermediateTensorInfo(rn),i.disposeIntermediateTensorInfo(bn),i.disposeIntermediateTensorInfo(mn),i.disposeIntermediateTensorInfo(Mn),i.disposeIntermediateTensorInfo(nr),i.disposeIntermediateTensorInfo(yr),i.disposeIntermediateTensorInfo(wr),i.disposeIntermediateTensorInfo(Wr),i.disposeIntermediateTensorInfo(Xr),i.disposeIntermediateTensorInfo(ws),{real:zs,imag:Sa}}const VW={kernelName:Aa,backendName:"cpu",kernelFunc:function UW(n){const{inputs:t,backend:e}=n,{input:r}=t,i=ft(r.shape),s=r.shape[r.shape.length-1],o=aa({inputs:{x:r},backend:e,attrs:{shape:[i/s,s]}}),l=p4(o,!1,e),p=aa({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),p}};function rF(n){const{backend:t,attrs:e}=n,{shape:r,value:i,dtype:s}=e,a=s||Hc(i),o=Dr(a,ft(r));return function qW(n,t,e){n.fill(t)}(o,i),t.makeTensorInfo(r,a,o)}const GW={kernelName:Ru,backendName:"cpu",kernelFunc:rF},WW={kernelName:ya,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{image:r}=n,i=e,s=hi(r.dtype,ft(r.shape)),[a,o,l,p]=r.shape,g=i.data.get(r.dataId).values;for(let w=0;w<a;w++){const N=w*l*o*p;for(let D=0;D<o;D++){const O=D*(l*p);for(let k=0;k<l;k++){const L=k*p;for(let $=0;$<p;$++){const U=Math.round(l-k-1),V=N+O+L+$;let W=g[V];U>=0&&U<l&&(W=g[N+O+U*p+$]),s[V]=W}}}}return{dataId:i.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},XW={kernelName:Xl,backendName:"cpu",kernelFunc:function HW(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,filter:s,bias:a,preluActivationWeights:o}=t,{strides:l,pad:p,dataFormat:g,dilations:v,dimRoundingMode:w,activation:N,leakyreluAlpha:D}=r;let O=f4({inputs:{x:i,filter:s},backend:e,attrs:{strides:l,pad:p,dataFormat:g,dilations:v,dimRoundingMode:w}});if(a){const k=O;if("NCHW"===g&&1===a.shape.length&&1!==a.shape[0]){const L=aa({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});O=Sy({inputs:{a:O,b:L},backend:e}),e.disposeIntermediateTensorInfo(L)}else O=Sy({inputs:{a:O,b:a},backend:e});e.disposeIntermediateTensorInfo(k)}if(N){const k=O;if("NCHW"===g&&"prelu"===N&&1===o.shape.length&&1!==o.shape[0]){const L=aa({inputs:{x:o},backend:e,attrs:{shape:[o.shape[0],1,1]}});O=CC(e,O,N,L,D),e.disposeIntermediateTensorInfo(L)}else O=CC(e,O,N,o,D);e.disposeIntermediateTensorInfo(k)}return O}},YW={kernelName:Nl,backendName:"cpu",kernelFunc:function KW(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,filter:s,bias:a,preluActivationWeights:o}=t,{strides:l,pad:p,dataFormat:g,dilations:v,dimRoundingMode:w,activation:N,leakyreluAlpha:D}=r;let O=h4({inputs:{x:i,filter:s},backend:e,attrs:{strides:l,pad:p,dataFormat:g,dilations:v,dimRoundingMode:w}});if(a){const k=O;O=Sy({inputs:{a:O,b:a},backend:e}),e.disposeIntermediateTensorInfo(k)}if(N){const k=O;O=CC(e,O,N,o,D),e.disposeIntermediateTensorInfo(k)}return O}},jW={kernelName:Wn,backendName:"cpu",kernelFunc:function ZW(n){const{inputs:t,backend:e}=n,{params:r,indices:i}=t,s=ft(r.shape),a=i.shape,o=a[a.length-1],[l,p,g,v]=sm(r,i);if(0===p)return e.makeTensorInfo(l,r.dtype,[]);const D=vB(e.data.get(i.dataId).values,e.bufferSync(r),r.dtype,p,o,g,v,r.shape,s);return e.makeTensorInfo(l,r.dtype,D.values)}},QW={kernelName:ss,backendName:"cpu",kernelFunc:function JW(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,indices:s}=t,{axis:a,batchDims:o}=r;lr([i,s],"gatherV2");const l=ar(a,i.shape)[0],p=e.data.get(s.dataId).values,g=i.shape[l];for(let V=0;V<p.length;++V){const W=p[V];K(W<=g-1&&W>=0,()=>`GatherV2: the index value ${W} is not in [0, ${g-1}]`)}let v=o;null==o&&(v=0);const w=ft(s.shape),N=gx(i,s,l,v),D=aa({inputs:{x:i},backend:e,attrs:{shape:[N.batchSize,N.outerSize,N.dimSize,N.sliceSize]}}),O=aa({inputs:{x:s},backend:e,attrs:{shape:[N.batchSize,w/N.batchSize]}}),k=[N.batchSize,N.outerSize,w/N.batchSize,N.sliceSize],L=e.bufferSync(O),U=xB(e.bufferSync(D),L,k);return e.disposeIntermediateTensorInfo(D),e.disposeIntermediateTensorInfo(O),e.makeTensorInfo(N.outputShape,U.dtype,U.values)}},t7={kernelName:Xo,backendName:"cpu",kernelFunc:function e7(n){const{inputs:t,backend:e}=n,{input:r}=t,i=ft(r.shape),s=r.shape[r.shape.length-1],o=aa({inputs:{x:r},backend:e,attrs:{shape:[i/s,s]}}),l=p4(o,!0,e),p=aa({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),p}},n7=Os(Bl,n=>Number.isFinite(n)?1:0,"bool"),r7={kernelName:Bl,backendName:"cpu",kernelFunc:n7},i7=Os(jc,n=>Math.abs(n)===1/0?1:0,"bool"),s7={kernelName:jc,backendName:"cpu",kernelFunc:i7},a7=Os(Of,n=>Number.isNaN(n)?1:0,"bool"),o7={kernelName:Of,backendName:"cpu",kernelFunc:a7},l7={kernelName:Jc,backendName:"cpu",kernelFunc:function u7(n){const{backend:t,attrs:e}=n,{start:r,stop:i,num:s}=e,a=SB(r,i,s);return t.makeTensorInfo([a.length],"float32",a)}},c7=Os(kf,n=>Math.log1p(n)),f7={kernelName:kf,backendName:"cpu",kernelFunc:c7},h7=Io((n,t)=>n&&t),p7=ou(Fr,h7,null,"bool"),d7={kernelName:Fr,backendName:"cpu",kernelFunc:p7},m7=Os(xl,n=>n?0:1,"bool"),g7={kernelName:xl,backendName:"cpu",kernelFunc:m7},y7=Io((n,t)=>n||t),v7=ou(Hi,y7,null,"bool"),x7={kernelName:Hi,backendName:"cpu",kernelFunc:v7},w7={kernelName:vc,backendName:"cpu",kernelFunc:function b7(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{depthRadius:s,bias:a,alpha:o,beta:l}=r;lr(i,"LRN");const p=i.shape[3],g=p-1,v=e.data.get(i.dataId).values,w=ft(i.shape),N=new Float32Array(w);function D(O){const k=O%p;let L=O-k+Math.max(0,k-s);const $=O-k+Math.min(k+s,g);let U=0;for(;L<=$;L++){const V=v[L];U+=V*V}return U}for(let O=0;O<w;O++){const k=D(O),L=v[O]*Math.pow(a+o*k,-l);N[O]=L}return e.makeTensorInfo(i.shape,i.dtype,N)}},N7={kernelName:Qr,backendName:"cpu",kernelFunc:function _7(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,y:s,dy:a}=t,{depthRadius:o,bias:l,alpha:p,beta:g}=r;lr(a,"LRNGrad");const v=ft(a.shape),w=a.shape[3],N=e.data.get(a.dataId).values,D=e.data.get(i.dataId).values,O=e.data.get(s.dataId).values,k=new Float32Array(v),L=v;for(let $=0;$<L;$++){const U=$%w,V=$-U+Math.max(0,U-o),W=$-U+Math.min(w,U+o+1);let ce=0;for(let ve=V;ve<W;ve++)ce+=Math.pow(D[ve],2);ce=p*ce+l;for(let ve=V;ve<W;ve++){let Ee=-2*p*g*D[ve]*O[$]/ce;$===ve&&(Ee+=Math.pow(ce,-g)),Ee*=N[$],k[ve]+=Ee}}return e.makeTensorInfo(a.shape,i.dtype,k)}};function d4(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{reductionIndices:s,keepDims:a}=r,o=e;let l=i.shape;const p=l.length,g=ar(s,l);let v=g;const w=na(v,p);let N=o.data.get(i.dataId).values;if(null!=w){const V=new Array(p);for(let W=0;W<V.length;W++)V[W]=l[w[W]];N=ZP(N,l,i.dtype,w,V),v=ka(v.length,p),l=V}lr(i,"max"),Vo("max",v,p);const[D,O]=ao(l,v),L=IB(N,ft(O),D,i.dtype),$=o.write(L,D,i.dtype);let U=D;return a&&(U=Oa(D,g)),{dataId:$,shape:U,dtype:i.dtype}}const S7={kernelName:Ps,backendName:"cpu",kernelFunc:d4},I7={kernelName:no,backendName:"cpu",kernelFunc:function E7(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t;lr(i,"maxPool");const{filterSize:s,strides:a,pad:o,dimRoundingMode:l}=r;K(Uo(a,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`);const g=jl(i.shape,s,a,1,o,l);let v;if(1===g.filterWidth&&1===g.filterHeight&&Kt(g.inShape,g.outShape))v=Bh({inputs:{x:i},backend:e});else{const w=e.data.get(i.dataId).values,N=zn(i.shape),D=QP(w,0,i.dtype,N,g,"max");v=e.makeTensorInfo(g.outShape,i.dtype,D.values)}return v}},A7={kernelName:_r,backendName:"cpu",kernelFunc:function C7(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{filterSize:s,strides:a,pad:o,dimRoundingMode:l,dataFormat:p}=r;lr(i,"maxPool3d");const g=pf(i.shape,s,a,1,o,l,p),w=c4(e.data.get(i.dataId).values,0,i.dtype,zn(i.shape),g,"max");return e.makeTensorInfo(w.shape,"float32",w.values)}},M7={kernelName:Cr,backendName:"cpu",kernelFunc:function T7(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,input:s}=t,{filterSize:a,strides:o,pad:l,dimRoundingMode:p}=r;lr([i,s],"maxPool3DGrad");const g=pf(s.shape,a,o,1,l,p),w=function b8(n,t){const e=zr(t.outShape,"int32"),r=t.strideDepth,i=t.strideHeight,s=t.strideWidth,a=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,p=t.effectiveFilterDepth,g=t.effectiveFilterHeight,v=t.effectiveFilterWidth,w=t.padInfo.front,N=t.padInfo.top,D=t.padInfo.left;for(let O=0;O<t.batchSize;++O)for(let k=0;k<t.inChannels;++k)for(let L=0;L<t.outDepth;++L){const $=L*r-w;let U=$;for(;U<0;)U+=a;const V=Math.min(t.inDepth,p+$);for(let W=0;W<t.outHeight;++W){const ce=W*i-N;let ve=ce;for(;ve<0;)ve+=o;const Ee=Math.min(t.inHeight,g+ce);for(let ge=0;ge<t.outWidth;++ge){const it=ge*s-D;let ut=it;for(;ut<0;)ut+=l;const Mt=Math.min(t.inWidth,v+it);let Ot=Number.NEGATIVE_INFINITY,vt=-1;for(let Rt=U;Rt<V;Rt+=a){const Dt=Rt-$;for(let Ht=ve;Ht<Ee;Ht+=o){const Bt=Ht-ce;for(let Wt=ut;Wt<Mt;Wt+=l){const ln=Wt-it,cn=n.get(O,Rt,Ht,Wt,k);cn>=Ot&&(Ot=cn,vt=Dt*g*v+Bt*g+ln)}}}e.set(vt,O,L,W,ge,k)}}}return e}(e.bufferSync(s),g),N=g.strideDepth,D=g.strideHeight,O=g.strideWidth,k=g.dilationDepth,L=g.dilationHeight,$=g.dilationWidth,U=g.effectiveFilterDepth,V=g.effectiveFilterHeight,W=g.effectiveFilterWidth,ce=U-1-g.padInfo.front,ve=W-1-g.padInfo.left,Ee=V-1-g.padInfo.top,ge=zr(s.shape,"float32"),it=e.bufferSync(i);for(let ut=0;ut<g.batchSize;++ut)for(let Mt=0;Mt<g.inChannels;++Mt)for(let Ot=0;Ot<g.inDepth;++Ot)for(let vt=0;vt<g.inHeight;++vt)for(let Rt=0;Rt<g.inWidth;++Rt){const Dt=Ot-ce,Ht=vt-Ee,Bt=Rt-ve;let Wt=0;for(let ln=0;ln<U;ln+=k){const cn=(Dt+ln)/N;if(!(cn<0||cn>=g.outDepth||Math.floor(cn)!==cn))for(let xn=0;xn<V;xn+=L){const rn=(Ht+xn)/D;if(!(rn<0||rn>=g.outHeight||Math.floor(rn)!==rn))for(let bn=0;bn<W;bn+=$){const mn=(Bt+bn)/O;if(mn<0||mn>=g.outWidth||Math.floor(mn)!==mn)continue;const wr=U*V*W-1-w.get(ut,cn,rn,mn,Mt)===ln*V*W+xn*W+bn?1:0;0!==wr&&(Wt+=it.get(ut,cn,rn,mn,Mt)*wr)}}}ge.set(Wt,ut,Ot,vt,Rt,Mt)}return e.makeTensorInfo(ge.shape,ge.dtype,ge.values)}},D7={kernelName:os,backendName:"cpu",kernelFunc:function R7(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,input:s,output:a}=t,o=s;lr([s,a],"maxPoolGrad");const{filterSize:l,strides:p,pad:g,dimRoundingMode:v}=r,w=jl(o.shape,l,p,1,g,v),N=e.data.get(o.dataId).values,D=zr(w.outShape,o.dtype,l4(N,o.shape,o.dtype,w).values),O=w.strideHeight,k=w.strideWidth,L=w.dilationHeight,$=w.dilationWidth,U=w.effectiveFilterHeight,V=w.effectiveFilterWidth,W=V-1-w.padInfo.left,ce=U-1-w.padInfo.top,ve=zr(o.shape,"float32"),Ee=e.data.get(i.dataId).values,ge=zr(i.shape,"float32",Ee);for(let it=0;it<w.batchSize;++it)for(let ut=0;ut<w.inChannels;++ut)for(let Mt=0;Mt<w.inHeight;++Mt)for(let Ot=0;Ot<w.inWidth;++Ot){const vt=Mt-ce,Rt=Ot-W;let Dt=0;for(let Ht=0;Ht<U;Ht+=L){const Bt=(vt+Ht)/O;if(!(Bt<0||Bt>=w.outHeight||Math.floor(Bt)!==Bt))for(let Wt=0;Wt<V;Wt+=$){const ln=(Rt+Wt)/k;if(ln<0||ln>=w.outWidth||Math.floor(ln)!==ln)continue;const rn=U*V-1-D.get(it,Bt,ln,ut)===Ht*V+Wt?1:0;0!==rn&&(Dt+=ge.get(it,Bt,ln,ut)*rn)}}ve.set(Dt,it,Mt,Ot,ut)}return e.makeTensorInfo(ve.shape,ve.dtype,ve.values)}},k7={kernelName:Qc,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:i,strides:s,pad:a,includeBatchInIndex:o}=t,l=e;lr(r,"MaxPoolWithArgmax");const p=l.data.get(r.dataId).values,g=jl(r.shape,i,s,[1,1],a),[v,w]=function O7(n,t,e,r,i){const a=QP(n,0,e,zn(t),i,"max"),o=l4(n,t,e,i,!0,r);return[a.values,o.values]}(p,r.shape,r.dtype,o,g),N=l.write(v,g.outShape,r.dtype),D=l.write(w,g.outShape,r.dtype);return[{dataId:N,shape:g.outShape,dtype:r.dtype},{dataId:D,shape:g.outShape,dtype:"int32"}]}},F7={kernelName:Oo,backendName:"cpu",kernelFunc:function P7(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:s,keepDims:a}=r,o=ar(s,i.shape),g=ft(ao(i.shape,o)[1]),v=[],w=e.makeTensorInfo([],"float32",new Float32Array([g]));v.push(w);const N=Cd({inputs:{x:i},backend:e,attrs:{dtype:"float32"}});v.push(N);const D=eF({inputs:{a:N,b:w},backend:e});v.push(D);const O=Ib({inputs:{x:D},backend:e,attrs:{axis:s,keepDims:a}});return v.forEach(k=>e.disposeIntermediateTensorInfo(k)),O}},$7={kernelName:js,backendName:"cpu",kernelFunc:function L7(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:s,keepDims:a}=r;lr(i,"min");const o=ar(s,i.shape);let l=o;const p=na(l,i.shape.length);let g=i;null!=p&&(g=Tl({inputs:{x:i},backend:e,attrs:{perm:p}}),l=ka(l.length,i.shape.length)),Vo("min",l,g.shape.length);const[v,w]=ao(g.shape,l),N=ft(w),D=Ki(ft(v),g.dtype),O=e.data.get(g.dataId).values;for(let L=0;L<D.length;++L){const $=L*N;let U=O[$];for(let V=0;V<N;++V){const W=O[$+V];(Number.isNaN(W)||W<U)&&(U=W)}D[L]=U}null!=p&&e.disposeIntermediateTensorInfo(g);const k=e.makeTensorInfo(v,g.dtype,D);if(a){const $=aa({inputs:{x:k},backend:e,attrs:{shape:Oa(v,o)}});return e.disposeIntermediateTensorInfo(k),$}return k}},z7={kernelName:Js,backendName:"cpu",kernelFunc:function B7(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{paddings:s,mode:a}=r;lr(i,"mirrorPad");const o=s.map((U,V)=>U[0]+i.shape[V]+U[1]),l=s.map(U=>U[0]),p=s.map((U,V)=>U[0]+i.shape[V]),g="reflect"===a?0:1,v=e.data.get(i.dataId).values,w=i.shape.length,N=zn(i.shape),D=ft(o),O=o.length,k=zn(o),L=hi(i.dtype,D);for(let U=0;U<D;U++){let V=Ia(U,O,k);for(let ce=0;ce<O;ce++)V[ce]<l[ce]?V[ce]=2*l[ce]-V[ce]-g:V[ce]>=p[ce]&&(V[ce]=2*(p[ce]-1)-V[ce]+g);V=V.map((ce,ve)=>ce-l[ve]);const W=Yi(V,w,N);L[U]=v[W]}return{dataId:e.write(L,o,i.dtype),shape:o,dtype:i.dtype}}},U7=Io((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t}),V7=ou(fo,U7),G7={kernelName:fo,backendName:"cpu",kernelFunc:V7};function m4(n){const{inputs:t,backend:e,attrs:r}=n,{logits:i}=t,{dim:s}=r,a=i.shape.length;let o=s;if(-1===o&&(o=a-1),o!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${o}`);const l=ar([o],i.shape),p=d4({inputs:{x:i},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),g=Oa(p.shape,l),v=aa({inputs:{x:p},backend:e,attrs:{shape:g}}),w=JP({inputs:{a:i,b:v},backend:e}),N=dB({inputs:{x:w},backend:e}),D=Ib({inputs:{x:N},backend:e,attrs:{axis:l,keepDims:!1}}),O=aa({inputs:{x:D},backend:e,attrs:{shape:g}}),k=eF({inputs:{a:N,b:O},backend:e});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(D),e.disposeIntermediateTensorInfo(O),k}const q7={kernelName:za,backendName:"cpu",kernelFunc:m4},H7={kernelName:Zo,backendName:"cpu",kernelFunc:function W7(n){const{inputs:t,backend:e,attrs:r}=n,{logits:i}=t,{numSamples:s,seed:a,normalized:o}=r;lr(i,"multinomial");const l=o?i:m4({inputs:{logits:i},backend:e,attrs:{dim:-1}}),p=l.shape[0],g=l.shape[1],v=e.data.get(l.dataId).values,w=[p,s],N=Ki(ft(w),"int32");for(let D=0;D<p;++D){const O=D*g,k=new Float32Array(g-1);k[0]=v[O];for(let U=1;U<k.length;++U)k[U]=k[U-1]+v[O+U];const L=rd.alea(a.toString()),$=D*s;for(let U=0;U<s;++U){const V=L();N[$+U]=k.length;for(let W=0;W<k.length;W++)if(V<k[W]){N[$+U]=W;break}}}return o||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(w,"int32",N)}},X7=A0,Y7={kernelName:Kh,backendName:"cpu",kernelFunc:function K7(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:i,scores:s}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=r;lr(i,"NonMaxSuppression");const p=e.data.get(i.dataId).values,g=e.data.get(s.dataId).values,{selectedIndices:v}=X7(p,g,a,o,l);return e.makeTensorInfo([v.length],"int32",new Int32Array(v))}},Z7=Em,J7={kernelName:Pf,backendName:"cpu",kernelFunc:function j7(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:i,scores:s}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:p}=r;lr(i,"NonMaxSuppressionPadded");const g=e.data.get(i.dataId).values,v=e.data.get(s.dataId).values,{selectedIndices:w,validOutputs:N}=Z7(g,v,a,o,l,p);return[e.makeTensorInfo([w.length],"int32",new Int32Array(w)),e.makeTensorInfo([],"int32",new Int32Array([N]))]}},Q7=T0,tH={kernelName:xa,backendName:"cpu",kernelFunc:function eH(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:i,scores:s}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:p}=r;lr(i,"NonMaxSuppressionWithScore");const g=e.data.get(i.dataId).values,v=e.data.get(s.dataId).values,w=a,N=o,D=l,O=p,{selectedIndices:k,selectedScores:L}=Q7(g,v,w,N,D,O);return[e.makeTensorInfo([k.length],"int32",new Int32Array(k)),e.makeTensorInfo([L.length],"float32",new Float32Array(L))]}},rH={kernelName:ko,backendName:"cpu",kernelFunc:function nH(n){const{inputs:t,backend:e,attrs:r}=n,{indices:i}=t,{dtype:s,depth:a,onValue:o,offValue:l}=r;lr(i,"oneHot");const p=ft(i.shape),g=new Float32Array(p*a);g.fill(l);const v=e.data.get(i.dataId).values;for(let w=0;w<p;++w)v[w]>=0&&v[w]<a&&(g[w*a+v[w]]=o);return e.makeTensorInfo([...i.shape,a],s,g)}};function TC(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const i=Zm({inputs:{input:r},backend:e}),s=TC({inputs:{x:i},backend:e}),a=Ey({inputs:{input:r},backend:e}),o=TC({inputs:{x:a},backend:e}),l=cc({inputs:{real:s,imag:o},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(o),l}return rF({backend:e,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const iH={kernelName:mh,backendName:"cpu",kernelFunc:TC},sH={kernelName:Du,backendName:"cpu",kernelFunc:function g4(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const i=Zm({inputs:{input:r},backend:e}),s=g4({inputs:{x:i},backend:e}),a=Ey({inputs:{input:r},backend:e}),o=TC({inputs:{x:a},backend:e}),l=cc({inputs:{real:s,imag:o},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(o),l}return rF({backend:e,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function y4(n){const{inputs:t,backend:e,attrs:r}=n,{axis:i}=r;if(1===t.length)return AC({inputs:{input:t[0]},backend:e,attrs:{dim:i}});const s=t[0].shape,a=t[0].dtype;t.forEach(g=>{xt(s,g.shape,"All tensors passed to stack must have matching shapes"),K(a===g.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],p=Iy({inputs:t.map(g=>{const v=AC({inputs:{input:g},backend:e,attrs:{dim:i}});return o.push(v),v}),backend:e,attrs:{axis:i}});return o.forEach(g=>e.disposeIntermediateTensorInfo(g)),p}const aH={kernelName:hh,backendName:"cpu",kernelFunc:y4},v4={kernelName:ba,backendName:"cpu",kernelFunc:function oH(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{paddings:s,constantValue:a}=r;lr(i,"pad");const o=s.map(($,U)=>$[0]+i.shape[U]+$[1]),l=s.map($=>$[0]),p=e.data.get(i.dataId).values,g=ft(i.shape),v=i.shape.length,w=zn(i.shape),N=ft(o),D=o.length,O=zn(o),k=hi(i.dtype,N);0!==a&&k.fill(a);for(let $=0;$<g;$++)k[Yi(Ia($,v,w).map((ce,ve)=>ce+l[ve]),D,O)]=p[$];return{dataId:e.write(k,o,i.dtype),shape:o,dtype:i.dtype}}},uH=Io((n,t)=>Math.pow(n,t)),lH=ou(zl,uH),cH={kernelName:zl,backendName:"cpu",kernelFunc:lH},hH={kernelName:Yh,backendName:"cpu",kernelFunc:function fH(n){const{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:i,paramsDenseValues:s,indices:a}=t,l=i.map(L=>e.data.get(L.dataId).values),p=i.map(L=>L.shape),g=e.data.get(s.dataId).values,v=e.data.get(a.dataId).values,[w,N,D]=OB(l,p,g,s.shape,s.dtype,v,a.shape),O=w.map(L=>e.makeTensorInfo([L.length],"int32",L)),k=e.makeTensorInfo(D,s.dtype,N);return O.concat([k])}},dH={kernelName:Vl,backendName:"cpu",kernelFunc:function pH(n){const{inputs:t,backend:e}=n,{starts:r,limits:i,deltas:s}=t,a=e.data.get(r.dataId).values,o=e.data.get(i.dataId).values,l=e.data.get(s.dataId).values,[p,g]=PB(a,r.shape,r.dtype,o,i.shape,l,s.shape);return[e.makeTensorInfo([p.length],"int32",p),e.makeTensorInfo([g.length],r.dtype,g)]}},gH={kernelName:jo,backendName:"cpu",kernelFunc:function mH(n){const{inputs:t,backend:e,attrs:r}=n,{shape:i,values:s,defaultValue:a,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,p=e.data.get(i.dataId).values,g=e.data.get(s.dataId).values,v=e.data.get(a.dataId).values,w=o.map(k=>e.data.get(k.dataId).values),N=o.map(k=>k.shape),[D,O]=$B(p,i.shape,g,s.shape,s.dtype,v,a.shape,w,N,l);return e.makeTensorInfo(D,s.dtype,O)}},vH={kernelName:Qs,backendName:"cpu",kernelFunc:function yH(n){const{backend:t,attrs:e}=n,{start:r,stop:i,dtype:s,step:a}=e,o=BB(r,i,a,s);return t.makeTensorInfo([o.length],s,o)}},xH=Os(ea,n=>1/n),bH={kernelName:ea,backendName:"cpu",kernelFunc:xH},_H={kernelName:ir,backendName:"cpu",kernelFunc:function wH(n){const{inputs:t,backend:e,attrs:r}=n,{images:i}=t,{alignCorners:s,halfPixelCenters:a,size:o}=r;lr(i,"resizeBilinear");const l=zn(i.shape),[p,g]=o,[v,w,N,D]=i.shape,O=e.data.get(i.dataId).values,k=new Float32Array(ft([v,p,g,D])),L=[s&&p>1?w-1:w,s&&g>1?N-1:N],$=[s&&p>1?p-1:p,s&&g>1?g-1:g];let U=0;const V=L[0]/$[0],W=L[1]/$[1];for(let ce=0;ce<v;ce++)for(let ve=0;ve<p;ve++){let Ee;Ee=a?V*(ve+.5)-.5:V*ve;const ge=Math.max(0,Math.floor(Ee)),it=Ee-ge,ut=Math.min(w-1,Math.ceil(Ee)),Mt=ce*l[0]+ge*l[1],Ot=ce*l[0]+ut*l[1];for(let vt=0;vt<g;vt++){let Rt;Rt=a?W*(vt+.5)-.5:W*vt;const Dt=Math.max(0,Math.floor(Rt)),Ht=Rt-Dt,Bt=Math.min(N-1,Math.ceil(Rt)),Wt=Mt+Dt*l[2],ln=Ot+Dt*l[2],cn=Mt+Bt*l[2],xn=Ot+Bt*l[2];for(let rn=0;rn<D;rn++){const bn=O[Wt+rn],mn=O[ln+rn],wr=bn+(O[cn+rn]-bn)*Ht;k[U++]=wr+(mn+(O[xn+rn]-mn)*Ht-wr)*it}}}return e.makeTensorInfo([v,p,g,D],"float32",k)}},SH={kernelName:Ou,backendName:"cpu",kernelFunc:function NH(n){const{inputs:t,backend:e,attrs:r}=n,{images:i,dy:s}=t,{alignCorners:a}=r;lr([s,i],"resizeBilinearGrad");const o=zn(i.shape),[l,p,g,v]=i.shape,[,w,N]=s.shape,D=new Float32Array(l*p*g*v),O=[a&&w>1?p-1:p,a&&N>1?g-1:g],k=[a&&w>1?w-1:w,a&&N>1?N-1:N],L=O[0]/k[0],$=O[1]/k[1],U=e.data.get(s.dataId).values;let V=0;for(let W=0;W<l;W++){const ce=W*o[0];for(let ve=0;ve<w;ve++){const Ee=ve*L,ge=Math.floor(Ee),it=Math.min(Math.ceil(Ee),p-1),ut=ce+ge*o[1],Mt=ce+it*o[1],Ot=Ee-ge,vt=1-Ot;for(let Rt=0;Rt<N;Rt++){const Dt=Rt*$,Ht=Math.floor(Dt),Bt=Math.min(Math.ceil(Dt),g-1),Wt=Dt-Ht,ln=1-Wt,cn=ut+Ht*o[2],xn=ut+Bt*o[2],rn=Mt+Ht*o[2],bn=Mt+Bt*o[2],mn=vt*ln,Mn=vt*Wt,nr=Ot*ln,wr=Ot*Wt;for(let yr=0;yr<v;yr++){const Wr=U[V++];D[cn+yr]+=Wr*mn,D[xn+yr]+=Wr*Mn,D[rn+yr]+=Wr*nr,D[bn+yr]+=Wr*wr}}}}return e.makeTensorInfo([l,g,p,v],"float32",D)}},IH={kernelName:ef,backendName:"cpu",kernelFunc:function EH(n){const{inputs:t,backend:e,attrs:r}=n,{images:i}=t,{alignCorners:s,halfPixelCenters:a,size:o}=r;lr(i,"resizeNearestNeighbor");const l=zn(i.shape),[p,g]=o,[v,w,N,D]=i.shape,O=e.data.get(i.dataId).values,k=new Float32Array(v*p*g*D),L=[s&&p>1?w-1:w,s&&g>1?N-1:N],$=[s&&p>1?p-1:p,s&&g>1?g-1:g],U=L[0]/$[0],V=L[1]/$[1];let W=0;for(let ce=0;ce<v;ce++){const ve=ce*l[0];for(let Ee=0;Ee<p;Ee++){const ge=a?U*(Ee+.5):U*Ee;let it=Math.min(w-1,s?Math.round(ge):Math.floor(ge));a&&(it=Math.max(0,it));const ut=ve+it*l[1];for(let Mt=0;Mt<g;Mt++){const Ot=a?V*(Mt+.5):V*Mt;let vt=Math.min(N-1,s?Math.round(Ot):Math.floor(Ot));a&&(vt=Math.max(0,vt));const Rt=ut+vt*l[2];for(let Dt=0;Dt<D;Dt++)k[W++]=O[Rt+Dt]}}}return e.makeTensorInfo([v,p,g,D],i.dtype,k)}},AH={kernelName:es,backendName:"cpu",kernelFunc:function CH(n){const{inputs:t,backend:e,attrs:r}=n,{images:i,dy:s}=t,{alignCorners:a}=r;lr([s,i],"resizeNearestNeighborGrad");const o=zn(i.shape),l=zn(s.shape),[p,g,v,w]=i.shape,[,N,D]=s.shape,O=new Float32Array(p*g*v*w),k=e.data.get(s.dataId).values,L=[a&&N>1?g-1:g,a&&D>1?v-1:v],$=[a&&N>1?N-1:N,a&&D>1?D-1:D],U=L[0]/$[0],V=L[1]/$[1],W=1/U,ce=1/V,ve=2*Math.ceil(W)+2,Ee=2*Math.ceil(ce)+2;for(let ge=0;ge<p;ge++){const it=ge*o[0];for(let ut=0;ut<g;ut++){const Mt=it+ut*o[1],Ot=Math.floor(ut*W),vt=Math.floor(Ot-ve/2);for(let Rt=0;Rt<v;Rt++){const Dt=Mt+Rt*o[2],Ht=Math.floor(Rt*ce),Bt=Math.floor(Ht-Ee/2);for(let Wt=0;Wt<w;Wt++){let ln=0;for(let cn=0;cn<ve;cn++){const xn=cn+vt;if(xn<0||xn>=N)continue;const rn=it+xn*l[1],bn=xn*U;if(ut===Math.min(g-1,a?Math.round(bn):Math.floor(bn)))for(let Mn=0;Mn<Ee;Mn++){const nr=Mn+Bt;if(nr<0||nr>=D)continue;const wr=rn+nr*l[2],yr=nr*V;Rt===Math.min(v-1,a?Math.round(yr):Math.floor(yr))&&(ln+=k[wr+Wt])}}O[Dt+Wt]=ln}}}}return e.makeTensorInfo(i.shape,i.dtype,O)}},MH={kernelName:ho,backendName:"cpu",kernelFunc:function TH(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{dims:s}=r;lr(i,"reverse");const a=i.shape.length,o=ar(s,i.shape);if(0===a)return Bh({inputs:{x:i},backend:e});const l=new Ga(i.shape,i.dtype),p=e.bufferSync(i);for(let g=0;g<l.size;g++){const v=l.indexToLoc(g),w=v.slice();o.forEach(N=>w[N]=i.shape[N]-1-w[N]),l.set(p.get(...w),...v)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}},RH={kernelName:Op,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:i,fillValue:s,center:a}=t,o=e,l=hi(r.dtype,ft(r.shape)),[p,g,v,w]=r.shape,[N,D]=J1(a,g,v),k=Math.sin(i),L=Math.cos(i),$=o.data.get(r.dataId).values;for(let V=0;V<p;V++){const W=V*v*g*w;for(let ce=0;ce<g;ce++){const ve=ce*(v*w);for(let Ee=0;Ee<v;Ee++){const ge=Ee*w;for(let it=0;it<w;it++){const ut=[p,ce,Ee,it],Mt=ut[2],Ot=ut[1];let vt=(Mt-N)*L-(Ot-D)*k,Rt=(Mt-N)*k+(Ot-D)*L;vt=Math.round(vt+N),Rt=Math.round(Rt+D);let Dt=s;"number"!=typeof s&&(Dt=3===it?255:s[it]),vt>=0&&vt<v&&Rt>=0&&Rt<g&&(Dt=$[W+Rt*(v*w)+vt*w+it]),l[W+ve+ge+it]=Dt}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},DH=Os(Ms,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2==0?t:t+1}),OH={kernelName:Ms,backendName:"cpu",kernelFunc:DH},PH={kernelName:ku,backendName:"cpu",kernelFunc:function kH(n){const{inputs:t,backend:e,attrs:r}=n,{indices:i,updates:s}=t,{shape:a}=r,{sliceRank:o,numUpdates:l,sliceSize:p,strides:g,outputSize:v}=Wf(0,i,a),O=jm(e.bufferSync(i),e.bufferSync(s),a,v,p,l,o,g,0,!0);return e.makeTensorInfo(a,O.dtype,O.values)}};function FH(n,t){let e=0,r=n.length,i=0;for(;e<r;)i=Math.floor((e+r)/2),n[i]<t?e=i+1:r=i;return r}function LH(n,t){let e=0,r=n.length,i=0;for(;e<r;)i=Math.floor((e+r)/2),n[i]<=t?e=i+1:r=i;return r}const zH={kernelName:ca,backendName:"cpu",kernelFunc:function BH(n){const{inputs:t,backend:e,attrs:r}=n,{sortedSequence:i,values:s}=t,{side:a}=r,p=function $H(n,t,e,r,i,s){const a=Dr("int32",e*i);for(let o=0;o<e;++o){const l=n.slice(o*r,(o+1)*r),p=o*i;for(let g=0;g<i;++g)a[p+g]="left"===s?FH(l,t[g+p]):LH(l,t[g+p])}return a}(e.data.get(i.dataId).values,e.data.get(s.dataId).values,i.shape[0],i.shape[1],s.shape[1],a);return e.makeTensorInfo(s.shape,"int32",p)}},VH={kernelName:ta,backendName:"cpu",kernelFunc:function UH(n){const{inputs:t,backend:e}=n,{condition:r,t:i,e:s}=t;lr([r,i,s],"select");const a=r.shape.length,o=e.data.get(r.dataId).values,l=e.data.get(i.dataId).values,p=e.data.get(s.dataId).values,g=$u(i.dtype,s.dtype),v=Ki(ft(i.shape),g);let w=0;const N=0===a||a>1||1===i.shape.length?1:ft(i.shape.slice(1));for(let D=0;D<o.length;D++)for(let O=0;O<N;O++)v[w++]=1===o[D]?l[D]:p[D];return e.makeTensorInfo(i.shape,g,v)}},GH=O0,qH=k0,WH=Os(Pr,n=>n>=0?qH*n:GH*(Math.exp(n)-1)),HH={kernelName:Pr,backendName:"cpu",kernelFunc:WH},XH=Os(Fu,n=>n<0?-1:n>0?1:0),KH={kernelName:Fu,backendName:"cpu",kernelFunc:XH},YH=Os(wc,n=>Math.sin(n)),ZH={kernelName:wc,backendName:"cpu",kernelFunc:YH},jH=Os(Pu,n=>Math.sinh(n)),JH={kernelName:Pu,backendName:"cpu",kernelFunc:jH},x4=Math.log(1.1920928955078125e-7)+2,QH=Os(Ff,n=>{const t=n>-x4,e=n<x4,r=Math.exp(n);let i;return i=e?r:t?n:Math.log(1+r),i}),eX={kernelName:Ff,backendName:"cpu",kernelFunc:QH},nX={kernelName:Fo,backendName:"cpu",kernelFunc:function tX(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{blockShape:s,paddings:a}=r;lr([i],"spaceToBatchND");const o=ft(s),l=[[0,0]];l.push(...a);for(let ce=1+s.length;ce<i.shape.length;++ce)l.push([0,0]);const p=v4.kernelFunc({inputs:{x:i},backend:e,attrs:{paddings:l,constantValue:0}}),g=Cm(p.shape,s,o,!1),v=pd(g.length,s.length,!1),w=Am(p.shape,s,o,!1),O=aa({inputs:{x:p},backend:e,attrs:{shape:g}}),$=Tl({inputs:{x:O},backend:e,attrs:{perm:v}}),W=aa({inputs:{x:$},backend:e,attrs:{shape:w}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(O),e.disposeIntermediateTensorInfo($),W}},iX={kernelName:wl,backendName:"cpu",kernelFunc:function rX(n){const{inputs:t,backend:e}=n,{indices:r,values:i,denseShape:s,defaultValue:a}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==i.shape.length)throw new Error(`Values must be a vector, saw:\n        ${i.shape}`);if(0!==a.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${a.shape}`);const o=e.data.get(r.dataId).values,l=e.data.get(i.dataId).values,p=e.data.get(s.dataId).values,g=e.data.get(a.dataId).values[0],[v,w,N,D,O]=GB(o,r.shape,r.dtype,l,i.dtype,p,g);return[e.makeTensorInfo(w,r.dtype,v),e.makeTensorInfo([w[0]],i.dtype,N),e.makeTensorInfo([D.length],"bool",new Uint8Array(D.map(k=>Number(k)))),e.makeTensorInfo([O.length],r.dtype,new Int32Array(O))]}},aX={kernelName:Gl,backendName:"cpu",kernelFunc:function sX(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:i,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==i.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${i.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const a=Array.from(e.data.get(i.dataId).values),o=e.data.get(r.dataId).values,l=Array.from(e.data.get(s.dataId).values),[p,g,v]=qB(o,r.shape,r.dtype,a,l);return[e.makeTensorInfo(g,r.dtype,p),e.makeTensorInfo([v.length],s.dtype,new Int32Array(v))]}},uX={kernelName:Jo,backendName:"cpu",kernelFunc:function oX(n){const{inputs:t,backend:e}=n,{data:r,indices:i,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${i.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);if(i.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const a=e.data.get(r.dataId).values,o=e.data.get(i.dataId).values,l=e.data.get(s.dataId).values,[p,g]=jP(a,r.shape,r.dtype,o,l,!0);return e.makeTensorInfo(g,r.dtype,p)}},cX={kernelName:ql,backendName:"cpu",kernelFunc:function lX(n){const{inputs:t,backend:e}=n,{data:r,indices:i,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${i.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);if(i.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const a=e.data.get(r.dataId).values,o=e.data.get(i.dataId).values,l=e.data.get(s.dataId).values,[p,g]=jP(a,r.shape,r.dtype,o,l);return e.makeTensorInfo(g,r.dtype,p)}},hX={kernelName:Ma,backendName:"cpu",kernelFunc:function fX(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:i,sparseValues:s,defaultValue:a}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:p,sliceSize:g,strides:v,outputSize:w}=Wf(0,i,o),N=!1,D=e.bufferSync(i);let O;switch(s.dtype){case"bool":O=jm(D,e.bufferSync(s),o,w,g,p,l,v,Boolean(e.data.get(a.dataId).values[0]),N);break;case"float32":case"int32":O=jm(D,e.bufferSync(s),o,w,g,p,l,v,e.data.get(a.dataId).values[0],N);break;case"string":O=jm(D,e.bufferSync(s),o,w,g,p,l,v,Va(e.data.get(a.dataId).values[0]),N);break;default:throw new Error(`Unsupported type ${s.dtype}`)}return e.makeTensorInfo(o,O.dtype,O.values)}},dX={kernelName:Ws,backendName:"cpu",kernelFunc:function pX(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{numOrSizeSplits:s,axis:a}=r,o=ar(a,i.shape)[0],l=cx(i,s,o),p=new Array(i.shape.length).fill(0),g=i.shape.slice();return l.map(v=>{const w=[...g];w[o]=v;const N=Jm({inputs:{x:i},backend:e,attrs:{begin:p,size:w}});return p[o]+=v,N})}},mX={kernelName:Zr,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,r=t;lr(e,"square");const i=r.data.get(e.dataId).values,s=new Float32Array(i.length);for(let o=0;o<i.length;++o){const l=i[o];s[o]=l*l}return{dataId:r.write(s,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},gX=Os(Hl,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),yX={kernelName:Hl,backendName:"cpu",kernelFunc:gX},xX={kernelName:nl,backendName:"cpu",kernelFunc:function vX(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{begin:s,end:a,strides:o,beginMask:l,endMask:p,ellipsisMask:g,newAxisMask:v,shrinkAxisMask:w}=r;lr(i,"stridedSlice");const{finalShapeSparse:N,finalShape:D,isIdentity:O,sliceDim0:k,isSimpleSlice:L,begin:$,end:U,strides:V}=Dv(i.shape,s,a,o,l,p,g,v,w);let W;if(O)W=aa({inputs:{x:i},backend:e,attrs:{shape:D}});else if(k||L){K(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const ce=Av($,U,V),ve=Jm({inputs:{x:i},backend:e,attrs:{begin:$,size:ce}});W=aa({inputs:{x:ve},backend:e,attrs:{shape:D}}),e.disposeIntermediateTensorInfo(ve)}else{const ve=XB(N,e.bufferSync(i),V,$);W=e.makeTensorInfo(D,ve.dtype,ve.values)}return W}},wX={kernelName:_a,backendName:"cpu",kernelFunc:function bX(n){const{inputs:t,backend:e,attrs:r}=n,{separator:i,nGramWidths:s,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:p}=r,{data:g,dataSplits:v}=t,w=e.data.get(g.dataId).values,N=e.data.get(v.dataId).values,[D,O]=KB(w,N,i,s,a,o,l,p);return[e.makeTensorInfo([D.length],"string",D),e.makeTensorInfo(v.shape,"int32",O)]}},NX={kernelName:rl,backendName:"cpu",kernelFunc:function _X(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:i}=r,{input:s,delimiter:a}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==a.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=e.data.get(s.dataId).values,l=e.data.get(a.dataId).values[0],[p,g,v]=YB(o,l,i),w=g.length;return[e.makeTensorInfo([w,2],"int32",p),e.makeTensorInfo([w],"string",g),e.makeTensorInfo([2],"int32",new Int32Array(v))]}},EX={kernelName:Lf,backendName:"cpu",kernelFunc:function SX(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:i}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const o=ZB(e.data.get(s.dataId).values,i);return e.makeTensorInfo(s.shape,"int32",o)}},IX=Os(gu,n=>Math.tan(n)),CX={kernelName:gu,backendName:"cpu",kernelFunc:IX},AX=Os(vs,n=>Math.tanh(n));function b4(n,t,e){switch(e){case"reflect":return function $X(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const r=2*t;e<r&&(e=r*Math.trunc(-e/r)+e),e=e<-t?e+r:-e-1}else if(e>t-1)if(t<=1)e=0;else{const r=2*t;e-=r*Math.trunc(e/r),e>=t&&(e=r-e-1)}return Oe(0,e,t-1)}(n,t);case"wrap":return function BX(n,t){let e=n;return e<0?t<=1?e=0:e+=t*(Math.trunc(-e/(t-1))+1):e>t-1&&(t<=1?e=0:e-=t*Math.trunc(e/(t-1))),Oe(0,e,t-1)}(n,t);case"nearest":return function UX(n,t){return Oe(0,n,t-1)}(n,t);default:return function zX(n,t){return n}(n)}}function Cb(n,t,e,r,i,s,a,o,l,p,g){return 0<=o&&o<t&&0<=l&&l<e?n[a*r+o*i+l*s+p]:g}function VX(n,t,e,r,i,s,a,o,l,p,g){return Cb(n,t,e,r,i,s,a,Math.round(o),Math.round(l),p,g)}function GX(n,t,e,r,i,s,a,o,l,p,g){const v=Math.floor(o),w=Math.floor(l),N=v+1,D=w+1;return(N-o)*((D-l)*Cb(n,t,e,r,i,s,a,v,w,p,g)+(l-w)*Cb(n,t,e,r,i,s,a,v,D,p,g))+(o-v)*((D-l)*Cb(n,t,e,r,i,s,a,N,w,p,g)+(l-w)*Cb(n,t,e,r,i,s,a,N,D,p,g))}const ZX=[K9,Rq,Z9,J9,Lq,e8,n8,i8,a8,u8,c8,h8,d8,y8,x8,_8,S8,I8,A8,H9,M8,D8,k8,F8,Pq,Bq,$8,Dq,B8,U8,V8,q8,H8,K8,Z8,J8,eW,nW,iW,aW,uW,cW,hW,pW,mW,yW,xW,bW,wW,_W,EW,B9,CW,zq,PW,Uq,FW,Gq,VW,GW,WW,Wq,Xq,XW,YW,jW,QW,Yq,jq,Oq,t7,z8,r7,s7,o7,z9,Qq,t9,l7,r9,f7,d7,g7,x7,w7,N7,S7,s9,I7,A7,M7,D7,k7,F7,$7,o9,z7,G7,H7,l9,f9,Y7,J7,tH,p9,rH,sH,aH,v4,cH,V9,g9,hH,dH,gH,vH,kq,tF,bH,G9,q9,W9,_H,SH,IH,AH,MH,RH,OH,S9,PH,zH,VH,HH,I9,KH,ZH,JH,C9,q7,eX,nX,iX,aX,uX,cX,hX,dX,M9,mX,D9,k9,yX,xX,wX,NX,EX,$9,NW,CX,{kernelName:vs,backendName:"cpu",kernelFunc:AX},{kernelName:bc,backendName:"cpu",kernelFunc:function MX(n){const{inputs:t,backend:e}=n,{tensor:r,indices:i,updates:s}=t,{sliceRank:a,numUpdates:o,sliceSize:l,strides:p,outputSize:g}=Wf(0,i,r.shape),w=e.bufferSync(i),N=e.bufferSync(s),D=e.bufferSync(r),O=jm(w,N,r.shape,g,l,o,a,p,D,!1);return e.makeTensorInfo(r.shape,O.dtype,O.values)}},{kernelName:ps,backendName:"cpu",kernelFunc:function DX(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{reps:s}=r;lr(i,"tile");const a=JB(e.bufferSync(i),s);return e.makeTensorInfo(a.shape,a.dtype,a.values)}},{kernelName:_l,backendName:"cpu",kernelFunc:function kX(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{k:s,sorted:a}=r;lr(i,"topk");const o=e.data.get(i.dataId).values,[l,p]=e4(o,i.shape,i.dtype,s,a);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(p.shape,p.dtype,p.values)]}},{kernelName:Ua,backendName:"cpu",kernelFunc:function FX(n){const{inputs:t,attrs:e,backend:r}=n,{image:i,transforms:s}=t,{interpolation:a,fillMode:o,fillValue:l,outputShape:p}=e,[g,v,w,N]=i.shape,[D,O]=p??[v,w],k=[g,D,O,N],L=zn(i.shape),$=L[0],U=L[1],V=L[2],W=zn(k),ce=W[0],ve=W[1],Ee=W[2],ge=hi(i.dtype,ft(k));ge.fill(l);const it=r.data.get(i.dataId).values,ut=r.data.get(s.dataId).values;for(let Ot=0;Ot<g;++Ot){const vt=1===s.shape[0]?ut:ut.subarray(8*Ot,8*Ot+8);for(let Rt=0;Rt<D;++Rt)for(let Dt=0;Dt<O;++Dt)for(let Ht=0;Ht<N;++Ht){let Bt;const Wt=vt[6]*Dt+vt[7]*Rt+1;if(0===Wt)continue;const cn=(vt[3]*Dt+vt[4]*Rt+vt[5])/Wt,xn=b4((vt[0]*Dt+vt[1]*Rt+vt[2])/Wt,w,o),rn=b4(cn,v,o);switch(a){case"nearest":Bt=VX(it,v,w,$,U,V,Ot,rn,xn,Ht,l);break;case"bilinear":Bt=GX(it,v,w,$,U,V,Ot,rn,xn,Ht,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}ge[Ot*ce+Rt*ve+Dt*Ee+Ht]=Bt}return r.makeTensorInfo(k,i.dtype,ge)}return{dataId:r.write(ge,k,i.dtype),shape:i.shape,dtype:i.dtype}}},d9,{kernelName:tf,backendName:"cpu",kernelFunc:function qX(n){const{inputs:t,attrs:e,backend:r}=n,{axis:i}=e,{x:s}=t;lr(s,"unique");const a=r.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:p}=t4(a,i,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([p.length],"int32",p)]}},{kernelName:Hs,backendName:"cpu",kernelFunc:function HX(n){const{inputs:t,backend:e,attrs:r}=n,{value:i}=t;let{axis:s}=r;s<0&&(s+=i.shape.length);const a=i.shape.length,o=i.shape[s],l=new Array(a-1);let p=0;for(let N=0;N<a;N++)N!==s&&(l[p++]=i.shape[N]);const g=new Array(a).fill(0),v=i.shape.slice();v[s]=1;const w=new Array(o);for(let N=0;N<w.length;N++){g[s]=N;const D=Jm({inputs:{x:i},backend:e,attrs:{begin:g,size:v}});w[N]=aa({inputs:{x:D},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(D)}return w}},{kernelName:nf,backendName:"cpu",kernelFunc:function KX(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,segmentIds:s}=t,{numSegments:a}=r;lr(i,"unsortedSegmentSum");const p=[],g=[],v=i.shape.length-s.shape.length;let w=s;for(let D=0;D<v;++D){const O=AC({inputs:{input:w},backend:e,attrs:{dim:D+1}});w=O,g.push(O)}for(let D=0;D<a;++D){const O=ji(D,"int32"),k=e.makeTensorInfo([],"int32",O),L=hB({inputs:{a:k,b:w},backend:e}),$=Cd({inputs:{x:L},backend:e,attrs:{dtype:"float32"}}),U=EC({inputs:{a:$,b:i},backend:e}),V=Ib({inputs:{x:U},backend:e,attrs:{axis:0,keepDims:!1}});p.push(V),g.push(k),g.push(L),g.push($),g.push(U),g.push(V)}const N=y4({inputs:p,backend:e,attrs:{axis:0}});return g.forEach(D=>e.disposeIntermediateTensorInfo(D)),N}},iH];for(const n of ZX)sl(n);const Td={},MC={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function w4(n,t){Td[n]=t}function ih(n,t){if(!(n in Td)||null!=t){const r=function JX(n,t){if(1!==n&&2!==n)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=t??function jX(n){if(!Pt().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&2===n)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(n);return e.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Td[n]},!1),Pt().getBool("SOFTWARE_WEBGL_ENABLED")&&(MC.failIfMajorPerformanceCaveat=!1),1===n?e.getContext("webgl",MC)||e.getContext("experimental-webgl",MC):e.getContext("webgl2",MC)}(n,t);if(null===r)return console.log("Could not get context for WebGL version",n),null;Td[n]=r}const e=Td[n];return null==e||e.isContextLost()?(delete Td[n],ih(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Td[n])}var Cy=(()=>{return(n=Cy||(Cy={}))[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH",Cy;var n})(),fc=(()=>{return(n=fc||(fc={}))[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD",fc;var n})(),uu=(()=>{return(n=uu||(uu={}))[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",uu;var n})();function Ab(n,t){return[t,n]}function RC(n){const t=ft(n);return br(Math.ceil(t/4))}function Ay(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function iF(n,t){const e=n;let r,i,s,a,o,l,p,g,v,w;return 2===Pt().getNumber("WEBGL_VERSION")?(r=e.R32F,i=e.R16F,s=e.RGBA16F,a=e.RGBA32F,o=e.RED,p=4,g=1,v=e.HALF_FLOAT,w=e.FLOAT,l=e.RGBA8):(r=n.RGBA,i=n.RGBA,s=n.RGBA,a=e.RGBA,o=n.RGBA,p=4,g=4,v=null!=t?t.HALF_FLOAT_OES:null,w=n.FLOAT,l=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:a,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:p,defaultNumChannels:g,textureTypeHalfFloat:v,textureTypeFloat:w}}function On(n,t){const e=t();return Pt().getBool("DEBUG")&&function tK(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+N4(n,t))}(n),e}const nK=5.96e-8,rK=65504;function _4(n){return!!(Pt().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===n||nK<Math.abs(n)&&Math.abs(n)<rK)}function N4(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Tb(n,t){return Ip(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function S4(n,t){const e=Ip(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(On(n,()=>n.shaderSource(e,t)),On(n,()=>n.compileShader(e)),!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function E4(n,t){const e=Ip(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(On(n,()=>n.shaderSource(e,t)),On(n,()=>n.compileShader(e)),Pt().get("ENGINE_COMPILE_ONLY"))return e;if(!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw sF(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}const iK=/ERROR: [0-9]+:([0-9]+):/g;function sF(n,t){const e=iK.exec(t);if(null==e)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(n);const r=+e[1],i=n.split("\n"),s=i.length.toString().length+2,a=i.map((v,w)=>qi((w+1).toString(),s)+v);let o=0;for(let v=0;v<a.length;v++)o=Math.max(a[v].length,o);const l=a.slice(0,r-1),p=a.slice(r-1,r),g=a.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${qi(p[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(g.join("\n"))}function I4(n){return Ip(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function C4(n,t){if(On(n,()=>n.linkProgram(t)),!Pt().get("ENGINE_COMPILE_ONLY")&&!1===n.getProgramParameter(t,n.LINK_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function DC(n,t){if(On(n,()=>n.validateProgram(t)),!1===n.getProgramParameter(t,n.VALIDATE_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function A4(n,t){const e=Ip(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return On(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),On(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function T4(n,t){const e=Ip(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return On(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),On(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function sK(){return 2===Pt().getNumber("WEBGL_VERSION")?1:4}function M4(n){return Ip(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function R4(n,t){const e=Pt().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0)throw new Error(`Requested texture size [${n}x${t}] is invalid.`);if(n>e||t>e)throw new Error(`Requested texture size [${n}x${t}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)}function D4(n){return Ip(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function aF(n,t,e,r,i,s,a){const o=n.getAttribLocation(t,e);return-1!==o&&(On(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),On(n,()=>n.vertexAttribPointer(o,i,n.FLOAT,!1,s,a)),On(n,()=>n.enableVertexAttribArray(o)),!0)}function O4(n,t,e){$4(n,e),On(n,()=>n.activeTexture(n.TEXTURE0+e)),On(n,()=>n.bindTexture(n.TEXTURE_2D,t))}function aK(n,t){$4(n,t),On(n,()=>n.activeTexture(n.TEXTURE0+t)),On(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function k4(n,t,e){return Ip(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}function P4(n,t,e){return n.getUniformLocation(t,e)}function F4(n,t,e,r){On(n,()=>O4(n,t,r)),On(n,()=>n.uniform1i(e,r))}function oK(n){On(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),On(n,()=>n.viewport(0,0,n.canvas.width,n.canvas.height)),On(n,()=>n.scissor(0,0,n.canvas.width,n.canvas.height))}function OC(n,t,e){On(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),On(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function oF(n,t){On(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),On(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Mb(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+L4(n,t))}function L4(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Ip(n,t,e){const r=On(n,()=>t());if(null==r)throw new Error(e);return r}function $4(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+n.TEXTURE0;if(r<n.TEXTURE0||r>e)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${e}].`)}function Qm(n,t=2){return ft(n.slice(0,n.length-t))}function eg(n){if(0===n.length)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Rb(n){let t=[1,1,1];return 0===n.length||1===n.length&&1===n[0]||(t=[Qm(n),...eg(n)]),t}function B4(n,t=!1){let e=Pt().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=Pt().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&Pt().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=e/2),t&&(e*=2,r*=2,1===(n=n.map((o,l)=>l>=n.length-2?De(n[l]):n[l])).length&&(n=[2,n[0]])),2!==n.length&&(n=Kr(n).newShape);let i=ft(n),s=null;n.length<=1&&i<=e?s=[1,i]:2===n.length&&n[0]<=e&&n[1]<=e?s=n:3===n.length&&n[0]*n[1]<=e&&n[2]<=e?s=[n[0]*n[1],n[2]]:3===n.length&&n[0]<=e&&n[1]*n[2]<=e?s=[n[0],n[1]*n[2]]:4===n.length&&n[0]*n[1]*n[2]<=e&&n[3]<=e?s=[n[0]*n[1]*n[2],n[3]]:4===n.length&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(s=[n[0],n[1]*n[2]*n[3]]);const a=null!=s&&Math.max(...s)>r&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(null==s||a)if(t){const o=Qm(n);let l=2,p=2;n.length&&([l,p]=eg(n)),i=o*(l/2)*(p/2),s=br(i).map(g=>2*g)}else s=br(i);return s}function kC(n){return n%2==0}function Db(n,t){if(Kt(n=n.slice(-2),t=t.slice(-2))||!n.length||!t.length||0===n[0]||0===n[1]||0===t[0]||0===t[1])return!0;if(n.length!==t.length){const e=n[n.length-1],r=t[t.length-1];if(e===r||kC(e)&&kC(r)&&(1===n[0]||1===t[0]))return!0}return n[1]===t[1]&&kC(n[0])&&kC(t[0])}let PC,FC;function z4(n){if(null==PC){const t=ih(n);PC=t.getParameter(t.MAX_TEXTURE_SIZE)}return PC}function uK(){PC=null}function lK(){FC=null}function U4(n){if(null==FC){const t=ih(n);FC=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,FC)}function V4(n){if(0===n)return 0;let t;const e=ih(n);return t=zc(e,"EXT_disjoint_timer_query_webgl2")&&2===n?2:zc(e,"EXT_disjoint_timer_query")?1:0,t}function zc(n,t){return null!=n.getExtension(t)}function uF(n){try{if(null!=ih(n))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function G4(n){if(0===n)return!1;const t=ih(n);if(1===n){if(!zc(t,"OES_texture_float"))return!1}else if(!zc(t,"EXT_color_buffer_float"))return!1;return lF(t)}function q4(n){if(0===n)return!1;const t=ih(n);if(1!==n){if(zc(t,"EXT_color_buffer_float"))return lF(t);const r="EXT_color_buffer_half_float";if(zc(t,r)){const i=t.getExtension(r);return function cK(n,t){const e=iF(n,t),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r);n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(a),o}(t,i)}return!1}return!(!zc(t,"OES_texture_float")||!zc(t,"WEBGL_color_buffer_float"))&&lF(t)}function lF(n){const t=iF(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const s=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,s),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(s),a}function W4(n){return 2===n&&null!=ih(n).fenceSync}function Ty(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&K("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const hr=Pt();function fl(){let n,t,e,r,i,s,a,o,l,p;return 2===Pt().getNumber("WEBGL_VERSION")?(n="#version 300 es",t="in",e="out",r="in",i="texture",s="outputColor",a="out vec4 outputColor;",o=Pt().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",p="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(n="",t="attribute",e="varying",r="varying",i="texture2D",s="gl_FragColor",a="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",p="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:n,attribute:t,varyingVs:e,varyingFs:r,texture2D:i,output:s,defineOutput:a,defineSpecialNaN:o,defineSpecialInf:l,defineRound:p}}function tg(n,t,e="index"){const r=zn(t);return r.map((i,s)=>`int ${n[s]} = ${e} / ${i}; ${s===r.length-1?`int ${n[s+1]} = ${e} - ${n[s]} * ${i}`:`index -= ${n[s]} * ${i}`};`).join("")}function LC(n,t,e="index"){const r=zn(t);return r.map((i,s)=>`int ${n[s]} = ${e} / outShapeStrides[${s}]; ${s===r.length-1?`int ${n[s+1]} = ${e} - ${n[s]} * outShapeStrides[${s}]`:`index -= ${n[s]} * outShapeStrides[${s}]`};`).join("")}function cF(n){const t=zn(n).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}hr.registerFlag("HAS_WEBGL",()=>hr.getNumber("WEBGL_VERSION")>0),hr.registerFlag("WEBGL_VERSION",()=>uF(2)?2:uF(1)?1:0),hr.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),hr.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===hr.get("WEBGL_VERSION")),hr.registerFlag("WEBGL_CPU_FORWARD",()=>!0),hr.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),hr.registerFlag("WEBGL_PACK",()=>hr.getBool("HAS_WEBGL")),hr.registerFlag("WEBGL_PACK_NORMALIZATION",()=>hr.getBool("WEBGL_PACK")),hr.registerFlag("WEBGL_PACK_CLIP",()=>hr.getBool("WEBGL_PACK")),hr.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>hr.getBool("WEBGL_PACK")),hr.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>hr.getBool("WEBGL_PACK")),hr.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>hr.getBool("WEBGL_PACK")),hr.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>hr.getBool("WEBGL_PACK")),hr.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>hr.getBool("WEBGL_PACK")),hr.registerFlag("WEBGL_PACK_REDUCE",()=>hr.getBool("WEBGL_PACK")),hr.registerFlag("WEBGL_LAZILY_UNPACK",()=>hr.getBool("WEBGL_PACK")),hr.registerFlag("WEBGL_CONV_IM2COL",()=>hr.getBool("WEBGL_PACK")),hr.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>z4(hr.getNumber("WEBGL_VERSION"))),hr.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>U4(hr.getNumber("WEBGL_VERSION"))),hr.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=hr.getNumber("WEBGL_VERSION");return 0===n?0:V4(n)}),hr.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>hr.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Pp()),hr.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>G4(hr.getNumber("WEBGL_VERSION"))),hr.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!hr.getBool("WEBGL_FORCE_F16_TEXTURES")&&hr.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),hr.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>q4(hr.getNumber("WEBGL_VERSION"))),hr.registerFlag("WEBGL_FENCE_API_ENABLED",()=>W4(hr.getNumber("WEBGL_VERSION"))),hr.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>hr.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),hr.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)}),hr.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Pp()?1:-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)}),hr.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),hr.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),hr.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),hr.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),hr.registerFlag("WEBGL_EXP_CONV",()=>!1),hr.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>hr.getBool("IS_TEST")),hr.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),hr.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),hr.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),hr.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const H4="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:X4}=ae;function pK(n,t,e){const r=[];if(n.forEach(N=>{const D=ft(N.shapeInfo.logicalShape);if(N.shapeInfo.isUniform?r.push(`uniform float ${N.name}${D>1?`[${D}]`:""};`):(r.push(`uniform sampler2D ${N.name};`),r.push(`uniform int offset${N.name};`)),e.enableShapeUniforms){const{uniformShape:O}=hF(e.packedInputs,N.shapeInfo.logicalShape,N.shapeInfo.texShape);switch(O.length){case 1:r.push(`uniform int ${N.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${N.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${N.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${N.name}Shape;`)}r.push(`uniform ivec2 ${N.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(N=>{r.push(`uniform ${N.type} ${N.name}${N.arrayIndex?`[${N.arrayIndex}]`:""};`)});const i=r.join("\n"),s=n.map(N=>function dK(n,t,e=!1,r){let i="";i+=e?K4(n,r):My(n,r);return n.shapeInfo.logicalShape.length<=t.logicalShape.length&&(i+=e?function XK(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),i="get"+r+"AtOutCoords",s=n.shapeInfo.logicalShape.length,a=t.logicalShape.length,o=X4(n.shapeInfo.logicalShape,t.logicalShape),l=Bs(a),p=a-s;let g;const v=["x","y","z","w","u","v"];g=0===s?"":a<2&&o.length>=1?"coords = 0;":o.map($=>`coords.${v[$+p]} = 0;`).join("\n");let w="";w=a<2&&s>0?"coords":n.shapeInfo.logicalShape.map(($,U)=>`coords.${v[U+p]}`).join(", ");let N="return outputValue;";const O=1===ft(n.shapeInfo.logicalShape),L=1===ft(t.logicalShape);if(1!==s||O||L){if(O&&!L)N=1===a?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const $=s-2,U=s-1;o.indexOf($)>-1&&o.indexOf(U)>-1?N="return vec4(outputValue.x);":o.indexOf($)>-1?N="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(U)>-1&&(N="return vec4(outputValue.xx, outputValue.zz);")}}else N="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${i}() {\n      ${l} coords = getOutputCoords();\n      ${g}\n      vec4 outputValue = get${r}(${w});\n      ${N}\n    }\n  `}(n,t):function KK(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),i="get"+r+"AtOutCoords",o=n.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!n.shapeInfo.isUniform&&o===l&&null==n.shapeInfo.flatOffset&&Kt(n.shapeInfo.texShape,t.texShape))return`\n      float ${i}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const p=Bs(l),g=X4(n.shapeInfo.logicalShape,t.logicalShape),v=l-o;let w;const N=["x","y","z","w","u","v"];w=0===o?"":l<2&&g.length>=1?"coords = 0;":g.map(O=>`coords.${N[O+v]} = 0;`).join("\n");let D="";return D=l<2&&o>0?"coords":n.shapeInfo.logicalShape.map((O,k)=>`coords.${N[k+v]}`).join(", "),`\n    float ${i}() {\n      ${p} coords = getOutputCoords();\n      ${w}\n      return get${r}(${D});\n    }\n  `}(n,t)),i}(N,t,e.packedInputs,e.enableShapeUniforms)).join("\n"),a=t.texShape,o=fl(),l=function yK(n){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${n.texture2D}(textureSampler, uv).r;\n    }\n  `}(o);let p,g,v=function bK(n){return`${n.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${n.varyingFs} vec2 resultUV;\n    ${n.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${n.defineSpecialNaN}\n    ${n.defineSpecialInf}\n    ${n.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${wK}\n    ${_K}\n    ${NK}\n  `}(o);return t.isPacked?(p=function mK(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function EK(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,e);case 2:return function OK(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Kt(n,t))return e?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const i=Math.ceil(n[1]/2);return e?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function CK(n,t,e){if(e)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],i=Math.ceil(n[2]/2),s=i*Math.ceil(n[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(n,t,e);default:return function TK(n,t,e){if(e)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],i=Math.ceil(n[n.length-1]/2),s=i*Math.ceil(n[n.length-2]/2);let a=s,o="",l="b, r, c";for(let p=2;p<n.length-1;p++)a*=n[n.length-p-1],o=`\n      int b${p} = index / ${a};\n      index -= b${p} * ${a};\n    `+o,l=`b${p}, `+l;return`\n    ivec${n.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec${n.length}(${l});\n    }\n  `}(n,t,e)}}(t.logicalShape,a,e.enableShapeUniforms),g=function xK(n){return`\n    void setOutput(vec4 val) {\n      ${n.output} = val;\n    }\n  `}(o)):(p=function gK(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function IK(n,t,e){return 1===t[0]?e?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?e?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,e);case 2:return function kK(n,t,e){return Kt(n,t)?e?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===n[1]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===n[0]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:e?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${n[1]};\n      int c = index - r * ${n[1]};\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function AK(n,t,e){if(e)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${LC(["r","c","d"],n)}\n    return ivec3(r, c, d);\n  }\n`;const r=tg(["r","c","d"],n);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(n,t,e);case 4:return function MK(n,t,e){if(e)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${LC(["r","c","d","d2"],n)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=tg(["r","c","d","d2"],n);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(n,t,e);case 5:return function RK(n,t){const e=tg(["r","c","d","d2","d3"],n);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(n,t);case 6:return function DK(n,t){const e=tg(["r","c","d","d2","d3","d4"],n);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}(t.logicalShape,a,e.enableShapeUniforms),g=function vK(n){return`\n    void setOutput(float val) {\n      ${n.output} = vec4(val, 0, 0, 0);\n    }\n  `}(o)),e.packedInputs&&(v+=SK),[v,l,g,i,p,s,e.userCode].join("\n")}function My(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return function FK(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${e};}`;const[i,s]=n.shapeInfo.texShape;if(1===i&&1===s)return`\n      float ${r}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const a=ng(e);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `;const[o,l]=n.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 1:return function $K(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${Ry(n)}\n      }\n    `;const i=n.shapeInfo.texShape,s=i[0],a=i[1];if(1===a&&1===s)return`\n      float ${r}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const o=ng(e);return 1===a?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===s?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${a}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${a}, index + ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 2:return function zK(n,t){const e=n.shapeInfo.logicalShape,r=n.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n.shapeInfo.texShape;if(null!=s&&Kt(e,s))return t?`\n      float ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${s[0]}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const{newShape:a,keptDims:o}=Kr(e);if(a.length<e.length){const N=["row","col"];return`\n      ${My(Dy(n,a),t)}\n      float ${i}(int row, int col) {\n        return ${i}(${Oy(N,o)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${i}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${Ry(n)}\n      }\n    `;const p=s[0],g=s[1],v=ng(r);return 1===g?t?`\n      float ${i}(int row, int col) {\n        float index = dot(vec3(row, col, ${v}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${v}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${p}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===p?t?`\n      float ${i}(int row, int col) {\n        float index = dot(vec3(row, col, ${v}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${v}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${g}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${i}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${v};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${i}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${v};\n    vec2 uv = uvFromFlat(${p}, ${g}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(n,t);case 3:return function VK(n,t){const e=n.shapeInfo.logicalShape,r=n.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e[1]*e[2],a=e[2],{newShape:o,keptDims:l}=Kr(e);if(o.length<e.length){const k=["row","col","depth"];return`\n        ${My(Dy(n,o),t)}\n        float ${i}(int row, int col, int depth) {\n          return ${i}(${Oy(k,l)});\n        }\n      `}if(n.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${a}, 1)));\n        ${Ry(n)}\n      }\n    `;const g=n.shapeInfo.texShape,v=g[0],w=g[1],N=n.shapeInfo.flatOffset;if(w===s&&null==N)return t?`\n      float ${i}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${i}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${a}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${w}.0, ${v}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(w===a&&null==N)return t?`\n      float ${i}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${w}.0, ${v}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const D=ng(r);return t?`\n    float ${i}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${D};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${i}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${a} + depth + ${D};\n        vec2 uv = uvFromFlat(${v}, ${w}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(n,t);case 4:return function qK(n,t){const e=n.shapeInfo.logicalShape,r=n.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e[3],a=e[2]*s,o=e[1]*a,{newShape:l,keptDims:p}=Kr(e);if(l.length<e.length){const U=["row","col","depth","depth2"];return`\n      ${My(Dy(n,l),t)}\n      float ${i}(int row, int col, int depth, int depth2) {\n        return ${i}(${Oy(U,p)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${a}, ${s}, 1)));\n        ${Ry(n)}\n      }\n    `;const g=n.shapeInfo.flatOffset,v=n.shapeInfo.texShape,w=v[0],N=v[1],D=`int stride2 = ${r}Shape[3];`,O=`int stride1 = ${r}Shape[2] * stride2;`,k=`int stride0 = ${r}Shape[1] * stride1;`;if(N===o&&null==g)return t?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        ${D}\n        ${O}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${a}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${N}.0, ${w}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(N===s&&null==g)return t?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${N}.0, ${w}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const L=ng(r);return t?`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${D}\n      ${O}\n      ${k}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${L});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${a} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${w}, ${N}, index + ${L});\n      return sampleTexture(${r}, uv);\n    }\n  `}(n,t);case 5:return function WK(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),i=t[4],s=t[3]*i,a=t[2]*s,o=t[1]*a,{newShape:l,keptDims:p}=Kr(t);if(l.length<t.length){const k=["row","col","depth","depth2","depth3"];return`\n      ${My(Dy(n,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Oy(k,p)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${a}, ${s}, ${i})) +\n          depth3;\n        ${Ry(n)}\n      }\n    `;const g=n.shapeInfo.flatOffset,v=n.shapeInfo.texShape,w=v[0],N=v[1];if(N===o&&null==g)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${a}, ${s}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${N}.0, ${w}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(N===i&&null==g)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${N}.0, ${w}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${a} + depth * ${s} +\n          depth2 * ${i} + depth3 + ${ng(e)};\n      vec2 uv = uvFromFlat(${w}, ${N}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);case 6:return function HK(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:i,keptDims:s}=Kr(t);if(i.length<t.length){const L=["row","col","depth","depth2","depth3","depth4"];return`\n      ${My(Dy(n,i))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Oy(L,s)});\n      }\n    `}const a=t[5],o=t[4]*a,l=t[3]*o,p=t[2]*l,g=t[1]*p;if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${g}, ${p}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${a}, 1)));\n        ${Ry(n)}\n      }\n    `;const v=n.shapeInfo.flatOffset,w=n.shapeInfo.texShape,N=w[0],D=w[1];if(D===g&&null==v)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${p}, ${l}, ${o}, ${a})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${D}.0, ${N}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(D===a&&null==v)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${D}.0, ${N}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${g} + col * ${p} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${a} + depth4 + ${ng(e)};\n      vec2 uv = uvFromFlat(${N}, ${D}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function K4(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return function PK(n){const t=n.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${fl().texture2D}(${t}, halfCR);\n    }\n  `}(n);case 1:return function LK(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),i=n.shapeInfo.texShape,s=fl();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${e}, uv);\n    }\n  `;const a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${a[0]}, ${a[1]}, index);\n      return ${s.texture2D}(${e}, uv);\n    }\n  `}(n,t);case 2:return function BK(n,t){const e=n.shapeInfo.logicalShape,r=n.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n.shapeInfo.texShape,a=s[0],o=s[1],l=fl();if(null!=s&&Kt(e,s))return t?`\n      vec4 ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${a}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${i}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const p=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${i}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${p[0]}, ${p[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(n,t);case 3:return function UK(n,t){const e=n.shapeInfo.logicalShape,r=n.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n.shapeInfo.texShape,a=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===e[0]){const N=[1,2],O=["b","row","col"];return`\n        ${K4(Dy(n,e.slice(1)),t)}\n        vec4 ${i}(int b, int row, int col) {\n          return ${i}(${Oy(O,N)});\n        }\n      `}const o=fl();if(t)return`\n    vec4 ${i}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;const l=a[0],p=a[1],g=Math.ceil(e[2]/2);return`\n    vec4 ${i}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${p}, ${g*Math.ceil(e[1]/2)}, ${g}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(n,t);default:return function GK(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),i=fl();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${e}, uv);\n    }\n  `;const s=n.shapeInfo.logicalShape,a=s.length,o=n.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],p=l[0],g=l[1],v=Math.ceil(s[a-1]/2);let w=v*Math.ceil(s[a-2]/2),N="int b, int row, int col",D=`b * ${w} + (row / 2) * ${v} + (col / 2)`;for(let O=2;O<a-1;O++)N=`int b${O}, `+N,w*=s[a-O-1],D=`b${O} * ${w} + `+D;return`\n    vec4 ${r}(${N}) {\n      int index = ${D};\n      int texR = index / ${g};\n      int texC = index - texR * ${g};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${g}, ${p});\n      return ${i.texture2D}(${e}, uv);\n    }\n  `}(n,t)}}const wK="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",_K="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",NK="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SK="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function ng(n){return`offset${n}`}function Ry(n){const t=n.name,e=ft(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function Bs(n){if(n<=1)return"int";if(2===n)return"ivec2";if(3===n)return"ivec3";if(4===n)return"ivec4";if(5===n)return"ivec5";if(6===n)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function hF(n,t,e){const{newShape:r,keptDims:i}=Kr(t),s=t.length,a=n&&3===s&&1===t[0],o=a?t.slice(1):r,l=!n&&s>1&&!Kt(t,e)&&r.length<s||a;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:i}}function Dy(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function Oy(n,t){return t.map(e=>n[e]).join(", ")}function Z4(n,t,e){const r=[],i=[];let s,a,o,l=null,p=null;p=n.getUniformLocation(e,"NAN",!1),1===Pt().getNumber("WEBGL_VERSION")&&(l=n.getUniformLocation(e,"INFINITY",!1));const g=!1;for(const v of t.variableNames){const w={name:v,uniform:n.getUniformLocation(e,v,g),offset:n.getUniformLocation(e,`offset${v}`,g)};t.enableShapeUniforms&&(w.shape=n.getUniformLocation(e,`${v}Shape`,g),w.texShape=n.getUniformLocation(e,`${v}TexShape`,g)),r.push(w)}if(t.enableShapeUniforms&&(s=n.getUniformLocation(e,"outShape",g),o=n.getUniformLocation(e,"outShapeStrides",g),a=n.getUniformLocation(e,"outTexShape",g)),t.customUniforms)for(const v of t.customUniforms)i.push(n.getUniformLocation(e,v.name,g));return{variablesLocations:r,customUniformLocations:i,infLoc:l,nanLoc:p,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:a}}function j4(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,r)=>{const i=e.logicalShape,s=t[r],a=s.shape;if(!Kt(i,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${a} must match`);if(e.isUniform&&s.isUniform)return;const o=e.texShape,l=s.isUniform?null:s.texData.texShape;if(!Kt(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function Xu(n){return Pt().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class JK{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Cy.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=fl();this.outputShape=t,this.enableShapeUniforms=Xu(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?LC(["r","c","d"],t):tg(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}class QK{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Cy.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=fl();this.outputShape=t,this.enableShapeUniforms=Xu(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?LC(["r","c","d"],t):tg(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}class eY{constructor(t){this.variableNames=["A"],this.outTexUsage=fc.DOWNLOAD;const e=fl();this.outputShape=t,this.userCode=`\n      ${H4}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class tY{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=fc.DOWNLOAD;const e=fl();this.outputShape=t,this.userCode=`\n      ${H4}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}const nY={R:0,G:1,B:2,A:3};class J4{constructor(t,e=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=fl();this.outputShape=t,this.enableShapeUniforms=Xu(this.outputShape.length);let s="result";e&&(s="floor(result * 255. + 0.5)");let a="";for(let o=0;o<r.length;o++)a+=`\n          if(offset == ${o}) {\n            result = values[${nY[r[o]]}];\n          }`;this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":cF(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${r.length});\n\n        flatIndex = idiv(flatIndex, ${r.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${i.texture2D}(A, uv);\n          ${a}\n        }\n        ${i.output} = vec4(${s}, 0., 0., 0.);\n      }\n    `}}class rY{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=fl();this.outputShape=t,this.enableShapeUniforms=Xu(this.outputShape.length);let i="",s="result";e&&(s="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let o=0;o<=1;o++){const l=2*a+o;i+=`\n          localCoords = coords;\n          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {\n          localCoords[2] += ${o};\n          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {\n            localCoords[1] += ${a};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${r.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${l}] = values[0];\n            } else if (offset == 1) {\n              result[${l}] = values[1];\n            } else if (offset == 2) {\n              result[${l}] = values[2];\n            } else {\n              result[${l}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":cF(t)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${i}\n\n          ${r.output} = ${s};\n        }\n    `}}function Q4(n){const t=fl();return S4(n,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function ez(n){return A4(n,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function tz(n){return T4(n,new Uint16Array([0,1,2,2,1,3]))}function Ob(n,t,e,r,i,s){R4(t,e);const a=M4(n),o=n.TEXTURE_2D;return On(n,()=>n.bindTexture(o,a)),On(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),On(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),On(n,()=>n.texParameteri(o,n.TEXTURE_MIN_FILTER,n.NEAREST)),On(n,()=>n.texParameteri(o,n.TEXTURE_MAG_FILTER,n.NEAREST)),1===Pt().getNumber("WEBGL_VERSION")?On(n,()=>n.texImage2D(o,0,r,t,e,0,i,s,null)):On(n,()=>n.texStorage2D(o,1,r,t,e)),On(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:a,texShape:[e,t]}}function pF(n){return n.internalFormatFloat}function nz(n,t,e,r){const[i,s]=Ab(t,e);return Ob(n,i,s,pF(r),r.textureFormatFloat,n.FLOAT)}function dF(n){return n.internalFormatHalfFloat}function rz(n,t,e,r){const[i,s]=Ab(t,e);return Ob(n,i,s,dF(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function mF(n){return n.downloadTextureFormat}function iz(n,t,e,r){const[i,s]=Ab(t,e);return Ob(n,i,s,mF(r),n.RGBA,n.UNSIGNED_BYTE)}function gF(n){return n.internalFormatPackedFloat}function sz(n,t,e,r){const[i,s]=Ay(t,e);return Ob(n,i,s,gF(r),n.RGBA,n.FLOAT)}function yF(n){return n.internalFormatPackedHalfFloat}function az(n,t,e,r){const[i,s]=Ay(t,e);return Ob(n,i,s,yF(r),n.RGBA,r.textureTypeHalfFloat)}function oz(n,t,e){return On(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),aF(n,t,"clipSpacePos",e,3,20,0)&&aF(n,t,"uv",e,2,20,12)}function uz(n,t,e,r,i,s){let a,o,l;On(n,()=>n.bindTexture(n.TEXTURE_2D,t)),i instanceof Uint8Array?(a=new Uint8Array(e*r*4),o=n.UNSIGNED_BYTE,l=n.RGBA):(a=new Float32Array(e*r*4),o=n.FLOAT,l=s.internalFormatPackedFloat),a.set(i),2===Pt().getNumber("WEBGL_VERSION")?On(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,r,n.RGBA,o,a)):On(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,e,r,0,n.RGBA,o,a)),On(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function lz(n,t,e){On(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?2===Pt().getNumber("WEBGL_VERSION")?On(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):On(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):2===Pt().getNumber("WEBGL_VERSION")?On(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):On(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),On(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function cz(n,t,e,r){const i=n.createBuffer();On(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,i));const o=16*t*e;return On(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,o,n.STREAM_READ)),On(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),On(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),i}function fz(n,t,e){const r=n,i=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,i),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),i}function hz(n,t,e,r){const[i,s]=Ab(t,e),o=new Uint8Array(function QX(n,t){return n*t}(t*e,4));return On(n,()=>n.readPixels(0,0,i,s,r.downloadTextureFormat,n.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function pz(n,t,e,r,i,s,a,o){const l=n,p=new Float32Array(function eK(n,t){const[e,r]=Ay(n,t);return e*r*4}(s,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,p),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),p}function dz(n,t,e){const r=new Float32Array(t*e*4);return On(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,r)),r}class BC{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=Pt().getNumber("WEBGL_VERSION");if(null!=t?(this.gl=t,w4(e,t)):this.gl=ih(e),t=this.gl,2===Pt().getNumber("WEBGL_VERSION")){const s=t;this.createVertexArray=()=>On(s,()=>s.createVertexArray()),this.bindVertexArray=a=>On(s,()=>s.bindVertexArray(a)),this.deleteVertexArray=a=>On(s,()=>s.deleteVertexArray(a)),this.getVertexArray=()=>On(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(null!=t){const s=t.getExtension("OES_vertex_array_object");if(null==s)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>On(t,()=>s.createVertexArrayOES()),this.bindVertexArray=a=>On(t,()=>s.bindVertexArrayOES(a)),this.deleteVertexArray=a=>On(t,()=>s.deleteVertexArrayOES(a)),this.getVertexArray=()=>On(t,()=>t.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const i="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Pt().getNumber("WEBGL_VERSION")){const a="OES_texture_half_float";if(this.textureFloatExtension=Tb(this.gl,"OES_texture_float"),zc(this.gl,a))this.textureHalfFloatExtension=Tb(this.gl,a);else if(Pt().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),zc(this.gl,i))this.colorBufferHalfFloatExtension=Tb(this.gl,i);else if(Pt().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",zc(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!zc(this.gl,i))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(i)}this.vertexBuffer=ez(this.gl),this.indexBuffer=tz(this.gl),this.framebuffer=D4(this.gl),this.textureConfig=iF(this.gl,this.textureHalfFloatExtension)}get debug(){return Pt().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;On(t,()=>t.finish()),On(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),On(t,()=>t.deleteFramebuffer(this.framebuffer)),On(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),On(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),On(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),nz(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),rz(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),iz(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),lz(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,r,i){this.throwIfDisposed(),uz(this.gl,t,e,r,i,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),az(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),sz(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(oF(this.gl,this.framebuffer),this.outputTexture=null),On(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,r){return this.downloadMatrixDriver(t,()=>hz(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,r,i,s,a){return pz(this.gl,t,0,0,0,s,a)}downloadFloat32MatrixFromBuffer(t,e){return fz(this.gl,t,e)}createBufferFromTexture(t,e,r){this.bindTextureToFrameBuffer(t);const i=cz(this.gl,e,r);return this.unbindTextureToFrameBuffer(),i}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,r;if(Pt().getBool("WEBGL_FENCE_API_ENABLED")){const i=t,s=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),r=()=>{const a=i.clientWaitSync(s,0,0);return a===i.ALREADY_SIGNALED||a===i.CONDITION_SATISFIED},e=s}else Pt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,Pt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(t,e,r){return this.downloadMatrixDriver(t,()=>dz(this.gl,e,r))}createProgram(t){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=Q4(e));const r=I4(e);let i;return On(e,()=>e.attachShader(r,this.vertexShader)),On(e,()=>e.attachShader(r,t)),C4(e,r),i=Object.assign(r,{vao:this.createVertexArray()}),this.bindVertexArray(i.vao),On(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),console.assert(oz(e,i,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&DC(e,i),this.setProgram(i),i}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&(On(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&(this.bindVertexArray(this.program.vao),this.debug&&DC(this.gl,this.program)),On(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,r=!0){return this.throwIfDisposed(),r?k4(this.gl,t,e):P4(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),On(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),F4(this.gl,t,e,r)}setOutputMatrixTexture(t,e,r){this.setOutputMatrixTextureDriver(t,r,e)}setOutputPackedMatrixTexture(t,e,r){this.throwIfDisposed();const[i,s]=Ay(e,r);this.setOutputMatrixTextureDriver(t,i,s)}setOutputMatrixWriteRegion(t,e,r,i){this.setOutputMatrixWriteRegionDriver(r,t,i,e)}setOutputPackedMatrixWriteRegion(t,e,r,i){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&DC(this.gl,this.program),Mb(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}On(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),On(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=Tb(this.gl,2===Pt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Pt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const r=this.gl,i=this.getQueryTimerExtensionWebGL2(),s=r.createQuery();return r.beginQuery(i.TIME_ELAPSED_EXT,s),s}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===Pt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,r=this.getQueryTimerExtensionWebGL2();return void e.endQuery(r.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(t){var e=this;return(0,Qe.Z)(function*(){return yield ks(()=>e.disposed||e.isQueryAvailable(t,Pt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(t,Pt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(t,e){if(0===e)return null;if(2===e){const r=this.gl;return r.getQueryParameter(t,r.QUERY_RESULT)/1e6}{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const r=this.gl,i=this.getQueryTimerExtensionWebGL2(),s=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(i.GPU_DISJOINT_EXT)),s&&!this.disjoint}{const r=this.getQueryTimerExtensionWebGL1(),i=r.getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function iY(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in Pt().platform&&(r=Pt().platform.setTimeoutCustom.bind(Pt().platform)),ks(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,r)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),OC(this.gl,t,this.framebuffer),this.debug&&Mb(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(OC(this.gl,this.outputTexture,this.framebuffer),this.debug&&Mb(this.gl)):oF(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(t,e,r){this.throwIfDisposed();const i=this.gl;OC(i,t,this.framebuffer),this.debug&&Mb(i),this.outputTexture=t,On(i,()=>i.viewport(0,0,e,r)),On(i,()=>i.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(t,e,r,i){this.throwIfDisposed(),On(this.gl,()=>this.gl.scissor(t,e,r,i))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:sY,bincountImpl:mz,bincountReduceImpl:aY,castImpl:oY,ceilImpl:uY,concatImpl:lY,equalImpl:cY,expImpl:fY,expm1Impl:hY,floorImpl:pY,gatherNdImpl:dY,gatherV2Impl:mY,greaterImpl:gY,greaterEqualImpl:yY,lessImpl:vY,lessEqualImpl:xY,linSpaceImpl:bY,logImpl:wY,maxImpl:_Y,maximumImpl:NY,minimumImpl:SY,multiplyImpl:EY,negImpl:IY,notEqualImpl:CY,prodImpl:AY,raggedGatherImpl:TY,raggedRangeImpl:MY,raggedTensorToTensorImpl:RY,rangeImpl:DY,rsqrtImpl:OY,scatterImpl:kY,sigmoidImpl:PY,simpleAbsImpl:gz,sliceImpl:FY,sparseFillEmptyRowsImpl:LY,sparseReshapeImpl:$Y,sparseSegmentReductionImpl:yz,sqrtImpl:BY,staticRegexReplaceImpl:zY,stridedSliceImpl:UY,stringNGramsImpl:VY,stringSplitImpl:GY,stringToHashBucketFastImpl:qY,subImpl:WY,tileImpl:HY,topKImpl:XY,transposeImpl:vF,uniqueImpl:KY}=Rn;function vz(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function hl(n,t){return 1===t?[n]:vz(n,t)}class ZY{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=Xu(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=hl("rc",this.rank),r=Bs(this.rank),i=this.getOutOfBoundsCondition(e),s=this.getSetup(e),a=this.getOutput(e);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${i}) {\n            setOutput(vec4(0));\n          } else {\n            ${s}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}getSourceCoordsArr(t){const e=[];for(let r=0;r<=1;r++)for(let i=0;i<=1;i++){let s=`${0===r?"r":"rp1"}, ${0===i?"c":"cp1"}`;for(let a=2;a<this.rank;a++)s=`${t[t.length-1-a]},`+s;e.push(s)}return e}getOutOfBoundsCondition(t){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let r=this.rank-2;r<this.rank;r++)e+=`${t[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(e+="||");return e}getSetup(t){if(1===this.rank)return"";const e=t.slice(-2);return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(t){const e=this.getSourceCoordsArr(t);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}class xz{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=Xu(this.outputShape.length);let r="";for(let i=0;i<4;i++){let s="thisRC = rc;";i%2==1&&(s+="thisRC.z += 1;"),i>1&&(s+="thisRC.y += 1;"),r+=`\n        ${s}\n        ${i>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${i}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${i>0?"}":""}\n      `}this.userCode=`\n      ${function jY(n,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?function hK(n,t,e="index"){const i=function fK(n,t){const e=n.length,r=n.map(s=>`${t}[${s}]`),i=new Array(e-1);i[e-2]=r[e-1];for(let s=e-3;s>=0;--s)i[s]=`(${i[s+1]} * ${r[s+1]})`;return i}(n.map((s,a)=>a),t);return i.map((s,a)=>`int ${n[a]} = ${e} / ${i[a]}; ${a===i.length-1?`int ${n[a+1]} = ${e} - ${n[a]} * ${i[a]}`:`index -= ${n[a]} * ${i[a]}`};`).join("")}(["r","c","d"],"inputShape"):tg(["r","c","d"],n)}\n      return ivec3(r, c, d);\n    }\n  `}(e,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":cF(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};\n\n        ${r}\n\n        setOutput(result);\n      }\n    `}}class JY{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,r){const i=wz(e,r),s=_z(t,i,r);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const a=bz(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const l=this.freeTextures[s].pop();return this.usedTextures[s].push(l),l}let o;return i===uu.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):i===uu.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):i===uu.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):i===uu.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):i===uu.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[s].push(o),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),o}releaseTexture(t,e,r,i){if(null==this.freeTextures)return;const s=wz(r,i),a=_z(e,s,i);a in this.freeTextures||(this.freeTextures[a]=[]);const o=bz(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,i),l=Pt().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==l&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=o):(this.freeTextures[a].push(t),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const p=this.usedTextures[a],g=p&&p.indexOf(t);if(null==g||g<0)throw new Error("Cannot release a texture that was never provided by this texture manager");p[g]=p[p.length-1],p.pop(),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function bz(n,t,e,r,i){const s=function eZ(n,t){switch(n){case uu.PACKED_2X2_FLOAT32:return gF(t);case uu.PACKED_2X2_FLOAT16:return yF(t);case uu.UNPACKED_FLOAT32:return pF(t);case uu.UNPACKED_FLOAT16:return dF(t);case uu.PACKED_4X1_UNSIGNED_BYTE:return mF(t);default:throw new Error(`Unknown physical texture type ${n}`)}}(t,r);let a;if(i){const[l,p]=Ay(n[0],n[1]);a=l*p}else{const[l,p]=Ab(n[0],n[1]);a=l*p}const o=function QY(n,t){if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(e,s);return a*o}function wz(n,t){if(n===fc.UPLOAD)return uu.PACKED_2X2_FLOAT32;if(n===fc.RENDER||null==n)return function tZ(n){return Pt().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?uu.PACKED_2X2_FLOAT32:uu.UNPACKED_FLOAT32:n?uu.PACKED_2X2_FLOAT16:uu.UNPACKED_FLOAT16}(t);if(n===fc.DOWNLOAD||n===fc.PIXELS)return uu.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function _z(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class Uh{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=Xu(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const Uc="if (isnan(x)) return x;",nZ="return x;",Nz="return abs(x);",rZ="return (x >= 0.0) ? x : (exp(x) - 1.0);",iZ=Uc+"\n  return (x < 0.0) ? 0.0 : x;\n",sZ=Uc+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",Md="return x;",aZ="return 1.0 / (1.0 + exp(-1.0 * x));",oZ="return x;",uZ="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",lZ="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cZ="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",fZ="return 1.0 / (1.0 + exp(-1.0 * x));";class Rd{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=Xu(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class hZ{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=Xu(this.outputShape.length);const e=t.length,r=hl("rc",e),i=Bs(e),s=function YY(n,t){if(1===n)return"rc";let e="";for(let r=0;r<n;r++)e+=t[r],r<n-1&&(e+=",");return e}(e,r),a=r.slice(-2),o=e<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`\n      void main() {\n        ${i} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${o}));\n      }\n    `}}const pZ=_0,zC={},yZ=Pt().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let Sz=(()=>{class n extends Yn{nextDataId(){return n.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Pt().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(null!=e){if(e instanceof BC)r=e;else{const i=ih(Pt().getNumber("WEBGL_VERSION"),e);r=new BC(i)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const i=ih(Pt().getNumber("WEBGL_VERSION"));r=new BC(i),this.binaryCache=function gZ(n){return n in zC||(zC[n]={}),zC[n]}(Pt().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new JY(this.gpgpu),this.numMBBeforeWarning=function xZ(){return null==Pt().global.screen?1024:Pt().global.screen.height*Pt().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new ri(this,Zl())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,r,i,s,a,o){const l=this.makeTensorInfo(r,i),p=this.texData.get(l.dataId);p.isPacked=!1,p.texture={texture:e,texShape:[s,a]},p.texShape=[s,a];const g=Rb(r),v=new J4(g,!1,o),w=this.runWebGLProgram(v,[l],i,[[s,a]]);return w.shape=r,p.texture=null,this.disposeIntermediateTensorInfo(l),w.dataId}write(e,r,i){if((Pt().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Pt().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===i&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:r,dtype:i,values:e,usage:fc.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,r,i,s,a){if(Pt().getBool("DEBUG")&&this.checkNumericalProblems(r),"complex64"===s)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:i,dtype:s,values:r,usage:fc.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const r=this.texData.get(e),{values:i,dtype:s,complexTensorInfos:a,slice:o,shape:l,isPacked:p}=r;if(null!=o){let N;N=p?new Rd(l,Md):new Uh(l,Md);const D=this.runWebGLProgram(N,[{dataId:e,shape:l,dtype:s}],s),O=this.readSync(D.dataId);return this.disposeIntermediateTensorInfo(D),O}if(null!=i)return this.convertAndCacheOnCPU(e);if("string"===s)return i;const g=null!=this.activeTimers;let v,w;return g&&(v=Fs()),w="complex64"===s?Dc(this.readSync(a.real.dataId),this.readSync(a.imag.dataId)):this.getValuesFromTexture(e),g&&(this.downloadWaitMs+=Fs()-v),this.convertAndCacheOnCPU(e,w)}read(e){var r=this;return(0,Qe.Z)(function*(){if(r.pendingRead.has(e)){const k=r.pendingRead.get(e);return new Promise(L=>k.push(L))}const i=r.texData.get(e),{values:s,shape:a,slice:o,dtype:l,complexTensorInfos:p,isPacked:g}=i;if(null!=o){let k;k=g?new Rd(a,Md):new Uh(a,Md);const L=r.runWebGLProgram(k,[{dataId:e,shape:a,dtype:l}],l),$=r.read(L.dataId);return r.disposeIntermediateTensorInfo(L),$}if(null!=s)return r.convertAndCacheOnCPU(e);if(Pt().getBool("DEBUG")&&!Pt().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Pt().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let w,N,v=null;if("complex64"!==l&&Pt().get("WEBGL_BUFFER_SUPPORTED")){w=r.decode(e);const k=r.texData.get(w.dataId);v=r.gpgpu.createBufferFromTexture(k.texture.texture,...RC(a))}if(r.pendingRead.set(e,[]),"complex64"!==l&&(yield r.gpgpu.createAndWaitForFence()),"complex64"===l){const k=yield Promise.all([r.read(p.real.dataId),r.read(p.imag.dataId)]);N=Dc(k[0],k[1])}else if(null==v)N=r.getValuesFromTexture(e);else{const k=ft(a);N=r.gpgpu.downloadFloat32MatrixFromBuffer(v,k)}if(null!=w&&r.disposeIntermediateTensorInfo(w),null!=v){const k=r.gpgpu.gl;On(k,()=>k.deleteBuffer(v))}const D=r.convertAndCacheOnCPU(e,N),O=r.pendingRead.get(e);return r.pendingRead.delete(e),O.forEach(k=>k(D)),r.pendingDisposal.has(e)&&(r.pendingDisposal.delete(e),r.disposeData(e)&&Zl().removeDataId(e,r),r.pendingDeletes--),D})()}readToGPU(e,r={}){const i=this.texData.get(e),{values:s,shape:a,slice:o,dtype:l,isPacked:p,texture:g}=i;if("complex64"===l)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=o){let D;D=p?new Rd(a,Md):new Uh(a,Md);const O=this.runWebGLProgram(D,[{dataId:e,shape:a,dtype:l}],l),k=this.readToGPU(O,r);return this.disposeIntermediateTensorInfo(O),k}if(null==g)throw null!=s?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const v=this.decode(e,r.customTexShape),w=Zl().makeTensorFromTensorInfo(v),N=this.texData.get(v.dataId);return Object.assign({tensorRef:w},N.texture)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const i=r.map(s=>Va(s));return zr(e.shape,e.dtype,i)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return zr(e.shape,e.dtype,r)}checkNumericalProblems(e){if(null!=e)for(let r=0;r<e.length;r++){const i=e[r];if(!_4(i))throw Pt().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${i} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${i} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:r,dtype:i,isPacked:s}=this.texData.get(e),a=ft(r);if(Pt().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const N=this.decode(e),D=this.texData.get(N.dataId),O=this.gpgpu.downloadMatrixFromPackedTexture(D.texture.texture,...RC(r)).subarray(0,a);return this.disposeIntermediateTensorInfo(N),O}const o=Pt().getBool("WEBGL_PACK")&&!0===s,l=o?Rb(r):r,p=o?new tY(l):new eY(l),g=this.runWebGLProgram(p,[{shape:l,dtype:i,dataId:e}],"float32"),v=this.texData.get(g.dataId),w=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(v.texture.texture,v.texShape[0],v.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(g),w}timerAvailable(){return Pt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var r=this;const i=this.activeTimers,s=[];let a=!1;null==this.programTimersStack?(this.programTimersStack=s,a=!0):this.activeTimers.push(s),this.activeTimers=s,e();const o=af(this.activeTimers.map(g=>g.query)).filter(g=>null!=g),l=af(this.activeTimers.map(g=>g.name)).filter(g=>null!=g);this.activeTimers=i,a&&(this.programTimersStack=null);const p={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(0,Qe.Z)(function*(){if(Pt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const g=yield Promise.all(o);p.kernelMs=Te(g),p.getExtraProfileInfo=()=>g.map((v,w)=>({name:l[w],ms:v})).map(v=>`${v.name}: ${v.ms}`).join(", ")}else p.kernelMs={error:"WebGL query timers are not supported in this environment."};return r.uploadWaitMs=0,r.downloadWaitMs=0,p})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Pt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Fs(),endMs:null}}endTimer(e){return Pt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Fs(),e)}getQueryTime(e){var r=this;return(0,Qe.Z)(function*(){return Pt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?r.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,r=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(r?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!r&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:i}=this.texData.get(e);return null!=i&&(this.disposeData(i.real.dataId,r),this.disposeData(i.imag.dataId,r)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:r,dtype:i,texShape:s,usage:a,isPacked:o,slice:l}=this.texData.get(e),p=l&&l.origDataId||e,g=this.dataRefCount.get(p);g>1?this.dataRefCount.set(p,g-1):(this.dataRefCount.delete(p),null!=r&&(this.numBytesInGPU-=this.computeBytes(s,i),this.textureManager.releaseTexture(r,s,a,o)));const v=this.texData.get(e);v.texture=null,v.texShape=null,v.isPacked=!1,v.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,r=yZ){return Pt().getBool("WEBGL_CPU_FORWARD")&&e.every(i=>null==this.texData.get(i.dataId).texture&&ft(i.shape)<r)}getGPGPUContext(){return this.gpgpu}where(e){eu("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const r=e.dataSync();return pZ(e.shape,r)}packedUnaryOp(e,r,i){const s=new Rd(e.shape,r),a=this.compileAndRun(s,[e],i);return Zl().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const s=gz(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if(Pt().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Nz,e.dtype);const r=new Uh(e.shape,Nz),i=this.compileAndRun(r,[e]);return Zl().makeTensorFromTensorInfo(i)}makeTensorInfo(e,r,i){let s;if("string"===r&&null!=i&&i.length>0&&da(i[0])){const a=i.map(o=>sf(o));s=this.write(a,e,r)}else s=this.write(i,e,r);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:r}}makeOutput(e,r,i){return Zl().makeTensorFromTensorInfo(this.makeTensorInfo(e,r,i),this)}unpackTensor(e){const r=new hZ(e.shape);return this.runWebGLProgram(r,[e],e.dtype)}packTensor(e){const r=new ZY(e.shape);return this.runWebGLProgram(r,[e],e.dtype,null,!0)}packedReshape(e,r){const i=[Qm(e.shape),...eg(e.shape)],s={dtype:e.dtype,shape:i,dataId:e.dataId},a=[Qm(r),...eg(r)],o=new xz(a,i),g=this.runWebGLProgram(o,[s],e.dtype,[i],!0);return{dataId:g.dataId,shape:r,dtype:g.dtype}}decode(e,r){const i=this.texData.get(e),{isPacked:s,shape:a,dtype:o}=i;null!=r&&K(ft(a)<=r[0]*r[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");const l=Rb(a);let p;p=s?new QK(l):new JK(l);const v=[r??RC(l)];return{dtype:o,shape:a,dataId:this.runWebGLProgram(p,[{shape:l,dtype:o,dataId:e}],o,v,!0,r).dataId}}runWebGLProgram(e,r,i,s,a=!1,o){const l=this.makeTensorInfo(e.outputShape,i),p=this.texData.get(l.dataId);if(e.packedOutput&&(p.isPacked=!0),e.outPackingScheme===Cy.DENSE){const $=o??RC(e.outputShape);p.texShape=$.map(U=>2*U)}if(null!=e.outTexUsage&&(p.usage=e.outTexUsage),0===ft(l.shape))return p.values=hi(l.dtype,0),l;const g=[],v=r.map($=>{if("complex64"===$.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let U=this.texData.get($.dataId);if(null==U.texture){if(!e.packedInputs&&ft($.shape)<=Pt().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:$.shape,texData:null,isUniform:!0,uniformValues:U.values};e.packedInputs&&(U.isPacked=!0,U.shape=$.shape)}if(this.uploadToGPU($.dataId),!!U.isPacked!=!!e.packedInputs)$=U.isPacked?this.unpackTensor($):this.packTensor($),g.push($),U=this.texData.get($.dataId);else if(U.isPacked&&!Db(U.shape,$.shape)){const V=$,W=$.shape;$.shape=U.shape,$=this.packedReshape($,W),g.push($),U=this.texData.get($.dataId),V.shape=W}return{shape:$.shape,texData:U,isUniform:!1}});this.uploadToGPU(l.dataId);const w={shape:l.shape,texData:p,isUniform:!1},N=function jK(n,t,e){let r="";t.concat(e).forEach(a=>{const o=null!=a.texData&&null!=a.texData.slice&&a.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!a.isUniform){const l=a.texData.texShape,{useSqueezeShape:p,uniformShape:g,keptDims:v}=hF(n.packedInputs,a.shape,l);let w="",N="",D="";if(1===g.length&&n.packedInputs){const W=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];w=`${W[0]>1}_${W[1]>1}`}else if(2!==g.length||n.packedInputs){if(g.length>2&&!n.packedInputs){const W=zn(g);D=`${W[0]===l[1]}_${W[W.length-1]===l[1]}`}}else N=`${g[0]>1}_${g[1]>1}`;const O=a.shape.length,k=2===g.length&&Kt(a.shape,l),L=1===ft(a.shape),$=np(a.shape,e.shape),U=!n.packedInputs&&O===e.shape.length&&Kt(l,e.texData.texShape);r+=`${O}_${U}_${p?v:""}_${g.length}_${L}_${$}_${k}_${w}_${N}_${D}_${n.packedInputs||g.length>2?"":`${l[0]>1}_${l[1]>1}`}_${o}`}else r+=`${a.shape}_${a.isUniform?"uniform":a.texData.texShape}_${o}`});let s=n.constructor.name;return s+="_"+r+"_"+n.userCode+`${Pt().getNumber("WEBGL_VERSION")}`,s}(e,v,w),D=this.getAndSaveBinary(N,()=>function YK(n,t,e,r){const i=e.map((g,v)=>{const w={logicalShape:g.shape,texShape:g.isUniform?null:g.texData.texShape,isUniform:g.isUniform,isPacked:!g.isUniform&&g.texData.isPacked,flatOffset:null};return null!=g.texData&&null!=g.texData.slice&&g.texData.slice.flatOffset>0&&(w.flatOffset=g.texData.slice.flatOffset),{name:t.variableNames[v],shapeInfo:w}}),s=i.map(g=>g.shapeInfo),a={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=pK(i,a,t),l=E4(n.gl,o),p=n.createProgram(l);return Pt().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:p,inShapeInfos:s,outShapeInfo:a,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:p,inShapeInfos:s,outShapeInfo:a},Z4(n,t,p))}(this.gpgpu,e,v,w)),O=null!=this.activeTimers;let k;O&&(k=this.startTimer()),Pt().get("ENGINE_COMPILE_ONLY")||function ZK(n,t,e,r,i){t.program.enableShapeUniforms||(j4(t.inShapeInfos,e),j4([t.outShapeInfo],[r]));const s=r.texData.texture,a=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(s.texture,a[0],a[1]):n.setOutputMatrixTexture(s.texture,a[0],a[1]),n.setProgram(t.webGLProgram),1===Pt().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&n.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&n.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<e.length;++l){const p=e[l],{uniform:g,offset:v,shape:w,texShape:N}=t.variablesLocations[l];if(w){const{uniformShape:D}=hF(t.program.packedInputs,p.shape,p.texData.texShape);switch(D.length){case 1:n.gl.uniform1iv(w,new Int32Array(D));break;case 2:n.gl.uniform2iv(w,new Int32Array(D));break;case 3:n.gl.uniform3iv(w,new Int32Array(D));break;case 4:n.gl.uniform4iv(w,new Int32Array(D))}}if(N&&n.gl.uniform2i(N,p.texData.texShape[0],p.texData.texShape[1]),null!=g){if(p.isUniform){if(ft(p.shape)<2)n.gl.uniform1f(g,p.uniformValues[0]);else{let D=p.uniformValues;D instanceof Float32Array||(D=new Float32Array(D)),n.gl.uniform1fv(g,D)}continue}null!=p.texData.slice&&null!=v&&n.gl.uniform1i(v,p.texData.slice.flatOffset),n.setInputMatrixTexture(p.texData.texture.texture,g,l)}}const o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:n.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(o,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const l=zn(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l))}}if(t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&i)for(let l=0;l<t.program.customUniforms.length;++l){const p=t.program.customUniforms[l],g=t.customUniformLocations[l],v=i[l];if("float"===p.type)n.gl.uniform1fv(g,v);else if("vec2"===p.type)n.gl.uniform2fv(g,v);else if("vec3"===p.type)n.gl.uniform3fv(g,v);else if("vec4"===p.type)n.gl.uniform4fv(g,v);else if("int"===p.type)n.gl.uniform1iv(g,v);else if("ivec2"===p.type)n.gl.uniform2iv(g,v);else if("ivec3"===p.type)n.gl.uniform3iv(g,v);else{if("ivec4"!==p.type)throw Error(`uniform type ${p.type} is not supported yet.`);n.gl.uniform4iv(g,v)}}n.executeProgram()}(this.gpgpu,D,v,w,s),g.forEach($=>this.disposeIntermediateTensorInfo($)),O&&(k=this.endTimer(k),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(k)}));const L=Pt().get("WEBGL_FLUSH_THRESHOLD");if(L>0){const $=Fs();$-this.lastGlFlushTime>L&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=$)}if(!Pt().getBool("WEBGL_LAZILY_UNPACK")&&p.isPacked&&!1===a){const $=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),$}return l}compileAndRun(e,r,i,s,a=!1){return this.runWebGLProgram(e,r,i=i||r[0].dtype,s,a)}getAndSaveBinary(e,r){return e in this.binaryCache||(this.binaryCache[e]=r()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Pt().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Lt(()=>{if(!Pt().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Pt().getBool("DEBUG");Pt().set("DEBUG",!1);const r=this.abs(mr(1e-8)).dataSync()[0];if(Pt().set("DEBUG",e),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const r=this.texData.get(e),{shape:i,dtype:s,values:a,texture:o,usage:l,isPacked:p}=r;if(null!=o)return;const g=null!=this.activeTimers;let v;g&&(v=Fs());let w=r.texShape;if(null==w&&(w=B4(i,p),r.texShape=w),null!=a){const N=Rb(i);let D,O=w[1],k=w[0];const L=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(p||!L)&&([O,k]=Ay(w[0],w[1])),D=p?new rY(N,L):new J4(N,L);const $=L?[k,O]:w,U=this.makeTensorInfo($,s),V=this.texData.get(U.dataId);V.usage=L?fc.PIXELS:fc.UPLOAD,V.texShape=$,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(U.dataId),O,k,a);const ve=this.runWebGLProgram(D,[U],s,[[k,O]],!0),Ee=this.texData.get(ve.dataId);r.texShape=Ee.texShape,r.isPacked=Ee.isPacked,r.usage=Ee.usage,Pt().get("ENGINE_COMPILE_ONLY")?this.disposeData(ve.dataId):(r.texture=Ee.texture,r.values=null,this.texData.delete(ve.dataId)),this.disposeIntermediateTensorInfo(U),g&&(this.uploadWaitMs+=Fs()-v)}else{const N=this.acquireTexture(w,l,s,p);r.texture=N}}convertAndCacheOnCPU(e,r){const i=this.texData.get(e),{dtype:s}=i;return null!=r&&(i.values=function bZ(n,t){if("float32"===t||"complex64"===t)return n;if("int32"===t||"bool"===t){const e="int32"===t?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<e.length;++r)e[r]=Math.round(n[r]);return e}throw new Error(`Unknown dtype ${t}`)}(r,s)),i.values}acquireTexture(e,r,i,s){if(this.numBytesInGPU+=this.computeBytes(e,i),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const a=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,r,s)}computeBytes(e,r){return e[0]*e[1]*Zn(r)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){var e=this;return(0,Qe.Z)(function*(){const r=[];if(e.gpgpu.parallelCompilationExtension){for(const[,i]of Object.entries(e.binaryCache))r.push(e.checkCompletionAsync_(i));return Promise.all(r)}for(const[,i]of Object.entries(e.binaryCache)){const s=new Promise(a=>{try{e.checkCompletion_(i),a(!0)}catch(o){throw o}});r.push(s)}return Promise.all(r)})()}checkCompletionAsync_(e){var r=this;return(0,Qe.Z)(function*(){return r.gpgpu.gl.getProgramParameter(e.webGLProgram,r.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?r.checkCompletion_(e):(yield K1(),r.checkCompletionAsync_(e))})()}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(sF(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){const{variablesLocations:r,customUniformLocations:i,infLoc:s,nanLoc:a,outShapeLocation:o,outShapeStridesLocation:l,outTexShapeLocation:p}=Z4(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=r,e.customUniformLocations=i,e.infLoc=s,e.nanLoc=a,e.outShapeLocation=o,e.outShapeStridesLocation=l,e.outTexShapeLocation=p}}createTensorFromGPUData(e,r,i){e.channels=e.channels||"RGBA";const{texture:s,height:a,width:o,channels:l}=e,p=Zl().backend;if(!p.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const g=p.writeTexture(s,r,i,a,o,l);return Zl().makeTensorFromDataId(g,r,i,p)}}return n.nextDataId=0,n})();const Ez="4.4.0";function Iz(){Pt().set("WEBGL_FORCE_F16_TEXTURES",!0)}gh()&&Mg("webgl",()=>new Sz,2);const wZ={forceHalfFloat:Iz},xF="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class ky{constructor(t,e,r){this.variableNames=["A","B"],this.outputShape=$r(e,r),this.enableShapeUniforms=Xu(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const rg="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class kb{constructor(t,e,r,i=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=$r(e,r);const s=this.outputShape.length;this.enableShapeUniforms=Xu(s);let a="";if(i)if(0===s||1===ft(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(a=`\n          ${Bs(s)} coords = getOutputCoords();\n        `,1===s)a+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const l=hl("coords",s);a+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${l[s-2]} + 1) >= outShape[${s} - 2];\n            bool nextColOutOfBounds =\n              (${l[s-1]} + 1) >= outShape[${s} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${l[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${l[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `}}function hc(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const _Z={kernelName:va,backendName:"webgl",kernelFunc:hc};function Dd(n){const{inputs:t,backend:e}=n,{real:r,imag:i}=t,s=e.makeTensorInfo(r.shape,"complex64"),a=e.texData.get(s.dataId),o=hc({inputs:{x:r},backend:e}),l=hc({inputs:{x:i},backend:e});return a.complexTensorInfos={real:o,imag:l},s}const NZ={kernelName:Pl,backendName:"webgl",kernelFunc:Dd},Cz="return (a < 0.) ? b * a : a;",Az="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",EZ={kernelName:Yr,backendName:"webgl",kernelFunc:function SZ(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{alpha:s}=r,a=e.makeTensorInfo([],"float32",ji(s,"float32")),o=Pt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new kb(Az,i.shape,a.shape):new ky(Cz,i.shape,a.shape),l=e.runWebGLProgram(o,[i,a],"float32");return e.disposeIntermediateTensorInfo(a),l}},Tz="return (a < 0.) ? b * a : a;",Mz="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",CZ={kernelName:Ul,backendName:"webgl",kernelFunc:function IZ(n){const{inputs:t,backend:e}=n,{x:r,alpha:i}=t,s=Pt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new kb(Mz,r.shape,i.shape):new ky(Tz,r.shape,i.shape);return e.runWebGLProgram(s,[r,i],"float32")}},Py="if (isnan(x)) return x;";function rs({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:r}){return({inputs:i,backend:s})=>{const{x:a}=i,o=s,l=r||a.dtype;if(o.shouldExecuteOnCPU([a])&&null!=e){const v=o.texData.get(a.dataId),w=e(v.values,l);return o.makeTensorInfo(a.shape,l,w)}let g;return g=Pt().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new Rd(a.shape,t):new Uh(a.shape,n),o.runWebGLProgram(g,[a],l)}}function Iu({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:i,dtype:s}){return({inputs:a,backend:o})=>{const{a:l,b:p}=a,g=o;if(r&&"complex64"===l.dtype){const D=g.texData.get(l.dataId),O=g.texData.get(p.dataId),[k,L]=[[D.complexTensorInfos.real,O.complexTensorInfos.real],[D.complexTensorInfos.imag,O.complexTensorInfos.imag]].map(U=>{const[V,W]=U,ce={dataId:V.dataId,dtype:V.dtype,shape:l.shape},ve={dataId:W.dataId,dtype:W.dtype,shape:p.shape},Ee=new ky(n,l.shape,p.shape);return g.runWebGLProgram(Ee,[ce,ve],$u(V.dtype,W.dtype))}),$=Dd({inputs:{real:k,imag:L},backend:g});return g.disposeIntermediateTensorInfo(k),g.disposeIntermediateTensorInfo(L),$}const v=s||$u(l.dtype,p.dtype);if(("string"===l.dtype||"string"===p.dtype||g.shouldExecuteOnCPU([l,p]))&&null!=i){const D=g.texData.get(l.dataId).values,O=g.texData.get(p.dataId).values,k="string"===l.dtype?mf(D):D,L="string"===l.dtype?mf(O):O,[$,U]=i(l.shape,p.shape,k,L,v),V=g.makeTensorInfo(U,v);return g.texData.get(V.dataId).values=$,V}let N;return N=Pt().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new kb(t,l.shape,p.shape,e):new ky(n,l.shape,p.shape),g.runWebGLProgram(N,[l,p],v)}}function Pb(n,t=!1){if("linear"===n)return t?oZ:nZ;if("relu"===n)return t?lZ:iZ;if("elu"===n)return t?uZ:rZ;if("relu6"===n)return t?cZ:sZ;if("prelu"===n)return t?Mz:Tz;if("leakyrelu"===n)return t?Az:Cz;if("sigmoid"===n)return t?fZ:aZ;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class Rz{constructor(t,e,r,i=!1,s=!1,a=!1,o=null,l=!1,p=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=Xu(this.outputShape.length);const v=Math.ceil((i?t[1]:t[2])/2),w=i?"i * 2, rc.y":"rc.y, i * 2",N=s?"rc.z, i * 2":"i * 2, rc.z",D=i?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],O=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let k="",L="";o&&(k=l?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${o}\n        }`:p?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${o}\n        }`:`vec4 activation(vec4 x) {\n          ${o}\n        }`,L="result = activation(result);");const $=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),p&&this.variableNames.push("leakyreluAlpha");let U="rc.x",V="rc.x";t[0]<e[0]?U=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(V=`imod(rc.x, ${e[0]})`),this.userCode=`\n      ${k}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${v}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${U};\n        int batchB = ${V};\n        for (int i = 0; i < ${v}; i++) {\n          vec4 a = getMatrixA(batchA, ${w});\n          vec4 b = getMatrixB(batchB, ${N});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${D[0]} * ${O[0]});\n          result += (${D[1]} * ${O[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${$}\n\n        ${L}\n\n        setOutput(result);\n      }\n    `}}const Dz={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class Oz{constructor(t,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=$r(e,r),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const kz="return a * b;";function bF(n){const{inputs:t,backend:e}=n,{a:r,b:i}=t,s=$u(r.dtype,i.dtype);if("complex64"===r.dtype){const o=e.texData.get(r.dataId),l=e.texData.get(i.dataId),p=new Oz(Dz.REAL,r.shape,i.shape),g=new Oz(Dz.IMAG,r.shape,i.shape),v=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:r.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:i.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:i.shape}],w=e.runWebGLProgram(p,v,"float32"),N=e.runWebGLProgram(g,v,"float32"),D=Dd({inputs:{real:w,imag:N},backend:e});return e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(N),D}if(e.shouldExecuteOnCPU([r,i])){const o=e.texData.get(r.dataId),l=e.texData.get(i.dataId),[p,g]=EY(r.shape,i.shape,o.values,l.values,s),v=e.makeTensorInfo(g,s);return e.texData.get(v.dataId).values=p,v}let a;return a=Pt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new kb(kz,r.shape,i.shape):new ky(kz,r.shape,i.shape),e.runWebGLProgram(a,[r,i],s)}const AZ={kernelName:du,backendName:"webgl",kernelFunc:bF};function An(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{shape:s}=r,a=e,o=ft(i.shape),l=ls(s,o),p=ft(l);K(o===p,()=>`The new shape (${l}) has ${p} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const g=a.texData.get(i.dataId);return!g.isPacked||Db(i.shape,l)||null!==g.texture&&Db(g.shape,l)?(a.incRef(i.dataId),{dataId:i.dataId,shape:l,dtype:i.dtype}):function TZ(n,t,e){const r=[Qm(n.shape),...eg(n.shape)],i={dtype:n.dtype,shape:r,dataId:n.dataId},s=[Qm(t),...eg(t)],a=new xz(s,r),p=e.runWebGLProgram(a,[i],n.dtype,[r],!0);return{dataId:p.dataId,shape:t,dtype:p.dtype}}(i,l,a)}const MZ={kernelName:tl,backendName:"webgl",kernelFunc:An};class Pz{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:i,inSize:s,outSize:a}=t;this.outputShape=[i,a];const o=4*Math.floor(r/4),l=r%4;let p="sumValue += dot(values, ones);";if(null!=e){const v=1/e;p=`sumValue += dot(values * ${Pn(v)?v.toPrecision(2):v}, ones);`}let g="";s%r>0&&(g=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${g}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${p}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${p}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${p}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${p}\n        }\n        setOutput(sumValue);\n      }\n    `}}class RZ{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:i,inSize:s,outSize:a}=t;this.outputShape=[i,a];let o="0.0",l="";"prod"===e?o="1.0":"min"===e?(o="1.0 / 1e-20",l="min"):"max"===e&&(o="-1.0 / 1e-20",l="max");let p=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?p="sumValue":"prod"===e?p="prodValue":"all"===e?p="allValue":"any"===e&&(p="anyValue");const g=4*Math.floor(r/4),v=r%4;let w=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${l}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${l}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,N="vec4";"all"===e?(o="1.0",w="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",N="bvec4"):"any"===e&&(o="0.0",w="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",N="bvec4");let D="";s%r>0&&(D=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${o};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${D}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        vec4 minMaxValue = vec4(${o});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${g}; i += 4) {\n          int inIdx = inOffset + i;\n          ${N} values = ${N}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${w}\n        }\n\n        int inIdx = inOffset + ${g};\n        if (${1===v}) {\n          ${N} values = ${N}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${w}\n        } else if (${2===v}) {\n          ${N} values = ${N}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${w}\n        } else if (${3===v}) {\n          ${N} values = ${N}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${w}\n        }\n        setOutput(${p});\n      }\n    `}}function ig(n,t,e,r){const i=function DZ(n){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const e=t.length?t[t.length-1].outSize:n[1],r=Im(e);t.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return t}(n.shape);let s=n;for(let a=0;a<i.length;a++){const{inSize:o,windowSize:l,outSize:p}=i[a];let g,v;g="mean"===e?0===a?new Pz({windowSize:l,inSize:o,batchSize:n.shape[0],outSize:p},o):new Pz({windowSize:l,inSize:o,batchSize:n.shape[0],outSize:p}):new RZ({windowSize:l,inSize:o,batchSize:n.shape[0],outSize:p},e),v=s,s=r.runWebGLProgram(g,[s],t),v.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(v)}return s}class OZ{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let a=0;a<r.length;a++)r[a]=t[e[a]];this.outputShape=r,this.rank=r.length;const i=Bs(this.rank),s=function kZ(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let i=0;i<n.length;i++)r[n[i]]=e[i];return r.join()}(e);this.userCode=`\n    void main() {\n      ${i} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class PZ{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(t.length);for(let g=0;g<r.length;g++)r[g]=t[e[g]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const i=Bs(this.rank),s=vz("rc",this.rank),a=new Array(this.rank);for(let g=0;g<e.length;g++)a[e[g]]=s[g];const o=`vec2(${a.slice(-2).join()})`,l=`++${s[this.rank-1]} < ${r[this.rank-1]}`,p=`getChannel(getA(${a.join()}), ${o})`;this.userCode=`\n    void main() {\n      ${i} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${p};\n      if(${l}) {\n        result[1] = ${p};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${r[this.rank-2]}) {\n        result[2] = ${p};\n        if(${l}) {\n          result[3] = ${p};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function UC(n,t,e){const r=Pt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new PZ(n.shape,t):new OZ(n.shape,t);return e.runWebGLProgram(r,[n],n.dtype)}function VC(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:s,keepDims:a}=r;return function FZ(n,t,e,r){const s=n.shape.length,a=ar(t,n.shape);let o=a;const l=na(o,s),p=null!=l;let g=n;p&&(g=UC(n,l,r),o=ka(o.length,s)),Vo("sum",o,s);const[v,w]=ao(g.shape,o);let N=v;e&&(N=Oa(v,a));const D=ft(w),L=An({inputs:{x:g},attrs:{shape:[ft(n.shape)/D,D]},backend:r}),U=ig(L,bg(n.dtype),"sum",r),V=An({inputs:{x:U},attrs:{shape:N},backend:r});return r.disposeIntermediateTensorInfo(L),r.disposeIntermediateTensorInfo(U),p&&r.disposeIntermediateTensorInfo(g),V}(i,s,a,e)}const LZ={kernelName:ot,backendName:"webgl",kernelFunc:VC};function pl(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{perm:s}=r,a=e,l=new Array(i.shape.length);for(let g=0;g<l.length;g++)l[g]=i.shape[s[g]];let p;if(a.shouldExecuteOnCPU([i])){const v=a.texData.get(i.dataId).values,w=vF(v,i.shape,i.dtype,s,l);p=a.makeTensorInfo(l,i.dtype),a.texData.get(p.dataId).values=w}else p=UC(i,s,a);return p}const $Z={kernelName:Wl,backendName:"webgl",kernelFunc:pl},Fz=1e3;function GC({a:n,b:t,transposeA:e,transposeB:r,backend:i,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:l=null}){const p=n.shape.length,g=t.shape.length,v=e?n.shape[p-2]:n.shape[p-1],w=r?t.shape[g-1]:t.shape[g-2],N=e?n.shape[p-1]:n.shape[p-2],D=r?t.shape[g-2]:t.shape[g-1],O=n.shape.slice(0,-2),k=t.shape.slice(0,-2),L=ft(O),$=ft(k),V=$r(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([N,D]);K(v===w,()=>`Error in matMul: inner shapes (${v}) and (${w}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${r} must match.`);const W=e?[L,v,N]:[L,N,v],ce=r?[$,D,w]:[$,w,D],ve=An({inputs:{x:n},backend:i,attrs:{shape:W}}),Ee=An({inputs:{x:t},backend:i,attrs:{shape:ce}}),ge=[ve,Ee],it=Math.max(L,$),ut=e?ve.shape[1]:ve.shape[2],Mt=null!=s,Ot=null!=a,vt="leakyrelu"===l,Rt=null!=l?Pb(l,!0):null;let Ht;if((1===N||1===D)&&ut>Fz&&!1===(Mt||Ot||vt||null!=Rt)){let Wt=ve,ln=Ee;e&&(Wt=pl({inputs:{x:ve},backend:i,attrs:{perm:[0,2,1]}}),ge.push(Wt)),r&&(ln=pl({inputs:{x:Ee},backend:i,attrs:{perm:[0,2,1]}}),ge.push(ln));const xn=1===D;let rn=Wt;1!==D&&(rn=An({inputs:{x:Wt},backend:i,attrs:{shape:[it,ut,1]}}),ge.push(rn));const bn=1===D?2:1;let mn=ln;xn&&(mn=An({inputs:{x:ln},backend:i,attrs:{shape:[it,1,ut]}}),ge.push(mn));const Mn=bF({inputs:{a:rn,b:mn},backend:i});Ht=VC({inputs:{x:Mn},backend:i,attrs:{axis:bn,keepDims:!0}}),ge.push(Mn)}else{const Wt=$u(n.dtype,t.dtype),ln=new Rz(W,ce,[it,N,D],e,r,Mt,Rt,Ot,vt),cn=[ve,Ee];if(null!=s&&cn.push(s),Ot&&cn.push(a),vt){const xn=i.makeTensorInfo([],"float32",ji(o,"float32"));cn.push(xn),ge.push(xn)}Ht=i.runWebGLProgram(ln,cn,Wt)}const Bt=An({inputs:{x:Ht},backend:i,attrs:{shape:V}});ge.push(Ht);for(const Wt of ge)i.disposeIntermediateTensorInfo(Wt);return Bt}const zZ={kernelName:Qo,backendName:"webgl",kernelFunc:function BZ(n){const{inputs:t,backend:e,attrs:r}=n,{a:i,b:s,bias:a,preluActivationWeights:o}=t,{transposeA:l,transposeB:p,activation:g,leakyreluAlpha:v}=r;return GC({a:i,b:s,transposeA:l,transposeB:p,backend:e,bias:a,preluActivationWeights:o,leakyreluAlpha:v,activation:g})}},Lz="return abs(x);",VZ={kernelName:ga,backendName:"webgl",kernelFunc:function UZ(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const s=e.texData.get(r.dataId),a=gz(s.values);return e.makeTensorInfo(r.shape,r.dtype,a)}let i;return i=Pt().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Rd(r.shape,Lz):new Uh(r.shape,Lz),e.runWebGLProgram(i,[r],r.dtype)}},qZ=rs({opSnippet:Uc+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),WZ={kernelName:To,backendName:"webgl",kernelFunc:qZ},XZ=rs({opSnippet:Uc+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),KZ={kernelName:ml,backendName:"webgl",kernelFunc:XZ},$z="return a + b;",YZ=Iu({opSnippet:$z,packedOpSnippet:$z,supportsComplex:!0,cpuKernelImpl:sY}),ZZ={kernelName:Ju,backendName:"webgl",kernelFunc:YZ};class jZ{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((s,a)=>`T${a}`);const r=[];this.variableNames.forEach(s=>{r.push(`float v${s} = get${s}AtOutCoords();`)});const i=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        float result = ${i};\n        setOutput(result);\n      }\n    `}}class JZ{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((s,a)=>`T${a}`);const r=[];this.variableNames.forEach(s=>{r.push(`vec4 v${s} = get${s}AtOutCoords();`)});const i=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        vec4 result = ${i};\n        setOutput(result);\n      }\n    `}}const QZ={kernelName:kl,backendName:"webgl",kernelFunc:function qC(n){const{inputs:t,backend:e}=n,r=t;if(1===r.length)return hc({inputs:{x:r[0]},backend:e});if(r.length>Pt().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),p=qC({inputs:r.slice(0,l),backend:e}),g=qC({inputs:r.slice(l),backend:e});return qC({inputs:[p,g],backend:e})}const i=r.map(l=>l.dtype).reduce((l,p)=>$u(l,p)),s=r.map(l=>l.shape),o=Pt().getBool("WEBGL_PACK")?new JZ(r[0].shape,s):new jZ(r[0].shape,s);return e.runWebGLProgram(o,r,i)}},tj={kernelName:Vr,backendName:"webgl",kernelFunc:function ej(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:s,keepDims:a}=r,o=i.shape.length,l=ar(s,i.shape);let p=l;const g=na(p,o);let v=i;null!=g&&(v=pl({inputs:{x:i},backend:e,attrs:{perm:g}}),p=ka(p.length,o)),Vo("all",p,o);const[w,N]=ao(v.shape,p),O=An({inputs:{x:v},backend:e,attrs:{shape:[-1,ft(N)]}}),k=ig(O,O.dtype,"all",e);let L;return L=An(a?{inputs:{x:k},backend:e,attrs:{shape:Oa(w,l)}}:{inputs:{x:k},backend:e,attrs:{shape:w}}),e.disposeIntermediateTensorInfo(O),e.disposeIntermediateTensorInfo(k),null!=g&&e.disposeIntermediateTensorInfo(v),L}},rj={kernelName:Ks,backendName:"webgl",kernelFunc:function nj(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:s,keepDims:a}=r,o=i.shape.length,l=ar(s,i.shape);let p=l;const g=na(p,o);let v=i;null!=g&&(v=pl({inputs:{x:i},backend:e,attrs:{perm:g}}),p=ka(p.length,o)),Vo("any",p,o);const[w,N]=ao(v.shape,p),O=An({inputs:{x:v},backend:e,attrs:{shape:[-1,ft(N)]}}),k=ig(O,O.dtype,"any",e);let L;return L=An(a?{inputs:{x:k},backend:e,attrs:{shape:Oa(w,l)}}:{inputs:{x:k},backend:e,attrs:{shape:w}}),e.disposeIntermediateTensorInfo(O),e.disposeIntermediateTensorInfo(k),null!=g&&e.disposeIntermediateTensorInfo(v),L}};class ij{constructor(t,e,r){this.variableNames=["A"];const{windowSize:i,batchSize:s,outSize:a}=t;r||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${i};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${i}; i++) {\n          int inIdx = ${r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class sj{constructor(t,e,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,K(t.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const a=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),a>1&&this.outputShape.push(a),i||this.variableNames.push("bestIndicesA");const o=this.outputShape,l=o.length,p=Bs(l),g=hl("coords",l);let v,w;if(1===a){w=l+1;const Ee=Bs(w);v=`\n        ${Ee} sourceLocR = ${Ee}(${g.join()}, 0);\n        ++${g[l-1]};\n        ${Ee} sourceLocG = ${Ee}(${g.join()}, 0);\n        ++${g[l-2]};\n        ${Ee} sourceLocA = ${Ee}(${g.join()}, 0);\n        --${g[l-1]};\n        ${Ee} sourceLocB = ${Ee}(${g.join()}, 0);\n        --${g[l-2]};`}else w=l,v=`\n        ${p} sourceLocR = coords;\n        ++${g[l-1]};\n        ${p} sourceLocG = coords;\n        ++${g[l-2]};\n        ${p} sourceLocA = coords;\n        --${g[l-1]};\n        ${p} sourceLocB = coords;\n        --${g[l-2]};`;const N=["x","y","z","w","u","v"].slice(0,w),D="."+N[w-1],O=N.map(Ee=>"int "+Ee),k=hl("sourceLocR",w-1).concat("inIdx.r"),L=hl("sourceLocG",w-1).concat("inIdx.g"),$=hl("sourceLocB",w-1).concat("inIdx.b"),U=hl("sourceLocA",w-1).concat("inIdx.a"),V="max"===r?"greaterThan":"lessThan",W=i?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${k.join()}),\n                             getBestIndicesAChannel(${L.join()}),\n                             getBestIndicesAChannel(${$.join()}),\n                             getBestIndicesAChannel(${U.join()})));`,ce=`vec4(\n            getAChannel(${k.join()}),\n            hasNextCol ? getAChannel(${L.join()}) : 0.,\n            hasNextRow ? getAChannel(${$.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${U.join()}) : 0.)`,ve=i?"":`\n      float getBestIndicesAChannel(${O.join()}) {\n        return getChannel(getBestIndicesA(${N.join()}),\n                                          vec2(${N.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${O.join()}) {\n        return getChannel(getA(${N.join()}),\n                               vec2(${N.slice(-2).join()}));\n      }\n      ${ve}\n      void main() {\n        ${p} coords = getOutputCoords();\n        bool hasNextCol = ${g[l-1]} < ${o[l-1]-1};\n        bool hasNextRow = ${g[l-2]} < ${o[l-2]-1};\n        ${v}\n        ivec4 srcIdx = ivec4(sourceLocR${D}, sourceLocG${D},\n          sourceLocB${D}, sourceLocA${D}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${ce};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${W}\n          vec4 candidate = ${ce};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${V}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function Bz(n,t,e,r=null){let i=t.shape[0],s=t.shape[1];null!=r&&(i=r.shape[0],s=r.shape[1]);const a=Im(s),o={windowSize:a,inSize:s,batchSize:i,outSize:Math.ceil(s/a)},l=new ij(o,e,null==r),p=[t];null!=r&&p.push(r);const g=n.runWebGLProgram(l,p,"int32");if(1===g.shape[1])return g;const v=Bz(n,t,e,g);return n.disposeIntermediateTensorInfo(g),v}function zz(n,t,e,r=null){const i=null!=r?r.shape:t.shape,a=Im(i[i.length-1]),o=new sj(i,a,e,null==r),p=n.runWebGLProgram(o,null==r?[t]:[t,r],"int32");if(p.shape.length===t.shape.length){const g=zz(n,t,e,p);return n.disposeIntermediateTensorInfo(p),g}return p}function Uz(n,t,e,r){const i=[e];if(Vo("arg"+r.charAt(0).toUpperCase()+r.slice(1),i,t.shape.length),!Pt().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const s=[],a=n.texData.get(t.dataId);let l=t;null!==a&&a.isPacked&&(l=n.unpackTensor(t),s.push(l));const[p,g]=ao(l.shape,i),v=ft(g),w=An({inputs:{x:l},backend:n,attrs:{shape:[-1,v]}});s.push(w);const N=Bz(n,w,r);s.push(N);const D=An({inputs:{x:N},backend:n,attrs:{shape:p}});return s.forEach(O=>n.disposeIntermediateTensorInfo(O)),D}return zz(n,t,r)}const oj={kernelName:Ho,backendName:"webgl",kernelFunc:function aj(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:s}=r;let a=ar(s,i.shape);const o=na(a,i.shape.length);let l=i;const p=[];null!=o&&(l=pl({inputs:{x:i},backend:e,attrs:{perm:o}}),p.push(l),a=ka(a.length,l.shape.length)),Vo("argMax",[a[0]],l.shape.length);const g=Uz(e,l,a[0],"max");return p.forEach(v=>e.disposeIntermediateTensorInfo(v)),g}},lj={kernelName:Af,backendName:"webgl",kernelFunc:function uj(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:s}=r;let a=ar(s,i.shape);const o=na(a,i.shape.length);let l=i;const p=[];null!=o&&(l=pl({inputs:{x:i},backend:e,attrs:{perm:o}}),p.push(l),a=ka(a.length,l.shape.length)),Vo("argMin",[a[0]],l.shape.length);const g=Uz(e,l,a[0],"min");return p.forEach(v=>e.disposeIntermediateTensorInfo(v)),g}},fj=rs({opSnippet:Uc+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),hj={kernelName:Tf,backendName:"webgl",kernelFunc:fj},dj=rs({opSnippet:Uc+"return log(x + sqrt(x * x + 1.0));"}),mj={kernelName:Gr,backendName:"webgl",kernelFunc:dj},yj=rs({opSnippet:Uc+"\n  return atan(x);\n"}),vj={kernelName:ja,backendName:"webgl",kernelFunc:yj},wj=Iu({opSnippet:xF+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+rg+"\n  return result;\n"}),_j={kernelName:Yc,backendName:"webgl",kernelFunc:wj},Sj=rs({opSnippet:Uc+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),Ej={kernelName:jn,backendName:"webgl",kernelFunc:Sj};class Fb{constructor(t,e,r,i=!1,s=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const a=t.filterWidth,o=t.strideHeight,l=t.strideWidth,p=t.dilationHeight,g=t.dilationWidth,v=t.effectiveFilterHeight,w=t.effectiveFilterWidth,N=t.padInfo.top,D=t.padInfo.left;this.outputShape=t.outShape;const O="avg"===e;let $="0.0";if(O||($="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec2 strides = ivec2(${o}, ${l});\n        const ivec2 pads = ivec2(${N}, ${D});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${v};\n              wR += ${p}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w};\n                wC += ${g}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${i?s?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${w} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let V=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(V="avgValue / max(count, 1.0)");const W=4*Math.floor(a/4),ce=a%4,ve=`\n      if (${O}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${N}, ${D});\n      const float initializationValue = ${$};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${$});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${v};\n            wR += ${p}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${W}; wC += 4) {\n            int xC = xCCorner + wC * ${g};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${g}, d),\n              getValue(batch, xR, xC + 2 * ${g}, d),\n              getValue(batch, xR, xC + 3 * ${g}, d)\n            );\n\n            ${ve}\n          }\n\n          int xC = xCCorner + ${W};\n          if (${1===ce}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${ve}\n          } else if (${2===ce}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${g}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${ve}\n          } else if (${3===ce}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${g}, d),\n              getValue(batch, xR, xC + 2 * ${g}, d),\n              initializationValue\n            );\n\n            ${ve}\n          }\n        }\n        setOutput(${V});\n      }\n    `}}class wF{constructor(t,e,r,i=!1,s=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const a=t.filterWidth,o=t.strideDepth,l=t.strideHeight,p=t.strideWidth,g=t.dilationDepth,v=t.dilationHeight,w=t.dilationWidth,N=t.effectiveFilterDepth,D=t.effectiveFilterHeight,O=t.effectiveFilterWidth,k=t.padInfo.front,L=t.padInfo.top,$=t.padInfo.left;this.outputShape=t.outShape;const U="avg"===e;let V="0.0";if(U||(V="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${o}, ${l}, ${p});\n        const ivec3 pads = ivec3(${k}, ${L}, ${$});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${N};\n              wD += ${g}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${D};\n                wR += ${v}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${O};\n                  wC += ${w}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${i?s?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${D} * ${O} +\n                      wR * ${O} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let ce=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(ce="avgValue / max(count, 1.0)");const ve=4*Math.floor(a/4),Ee=a%4,ge=`\n      if (${U}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${o}, ${l}, ${p});\n      const ivec3 pads = ivec3(${k}, ${L}, ${$});\n      const float initializationValue = ${V};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${V});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${N};\n            wD += ${g}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${D};\n            wR += ${v}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${ve}; wC += 4) {\n              int xC = xCCorner + wC * ${w};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${w}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${w}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${w}, ch)\n              );\n\n              ${ge}\n            }\n\n            int xC = xCCorner + ${ve};\n            if (${1===Ee}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${ge}\n            } else if (${2===Ee}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${w}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${ge}\n            } else if (${3===Ee}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${w}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${w}, ch),\n                initializationValue\n              );\n\n              ${ge}\n            }\n          }\n        }\n        setOutput(${ce});\n      }\n    `}}const Cj={kernelName:Mr,backendName:"webgl",kernelFunc:function Ij(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t;Ty(i,"avgPool");const{filterSize:s,strides:a,pad:o,dimRoundingMode:l}=r;K(Uo(a,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`);const g=jl(i.shape,s,a,1,o,l);if(1===g.filterWidth&&1===g.filterHeight&&Kt(g.inShape,g.outShape))return hc({inputs:{x:i},backend:e});const v=new Fb(g,"avg",!1);return e.runWebGLProgram(v,[i],"float32")}},Tj={kernelName:hn,backendName:"webgl",kernelFunc:function Aj(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{filterSize:s,strides:a,pad:o,dimRoundingMode:l,dataFormat:p}=r,v=pf(i.shape,s,a,[1,1,1],o,l,p),w=new wF(v,"avg",!1);return e.runWebGLProgram(w,[i],"float32")}};class Mj{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const l=t.effectiveFilterHeight,p=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${l-1-t.padInfo.top}, ${p-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${l};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${p};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Rj{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const v=t.effectiveFilterDepth,w=t.effectiveFilterHeight,N=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${v-1-t.padInfo.front}, ${w-1-t.padInfo.top}, ${N-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${v};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${w};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${N};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Oj={kernelName:Ys,backendName:"webgl",kernelFunc:function Dj(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,input:s}=t,a=s,{filterSize:o,strides:l,pad:p,dimRoundingMode:g}=r,w=pf(a.shape,o,l,[1,1,1],p,g),N=new Rj(w);return e.runWebGLProgram(N,[i],a.dtype)}},Pj={kernelName:Mf,backendName:"webgl",kernelFunc:function kj(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,input:s}=t,a=s;Ty([i,s],"avgPoolGrad");const{filterSize:o,strides:l,pad:p}=r,g=jl(a.shape,o,l,1,p),v=new Mj(g);return e.runWebGLProgram(v,[i],a.dtype)}},Lj={kernelName:fs,backendName:"webgl",kernelFunc:function Fj(n){const{inputs:t,backend:e,attrs:r}=n,{a:i,b:s}=t,{transposeA:a,transposeB:o}=r;return GC({a:i,b:s,transposeA:a,transposeB:o,backend:e})}};class $j{constructor(t,e,r,i,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],$r(t,e),$r(t,r);let o="0.0";null!=i&&($r(t,i),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="1.0";null!=s&&($r(t,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${o};\n        float scale = ${l};\n        float inv = scale * inversesqrt(variance + float(${a}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class Bj{constructor(t,e,r,i,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],$r(t,e),$r(t,r);let o="vec4(0.0)";null!=i&&($r(t,i),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="vec4(1.0)";null!=s&&($r(t,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${o};\n        vec4 scale = ${l};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${a}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const zj={kernelName:yc,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,mean:i,variance:s,offset:a,scale:o}=n;K(i.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),K(null==a||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),K(null==o||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;null==l&&(l=.001);const p=[r,i,s];let g=null;null!=a&&(g=a.shape,p.push(a));let v=null;null!=o&&(v=o.shape,p.push(o));const w=Pt().getBool("WEBGL_PACK_NORMALIZATION")?new Bj(r.shape,i.shape,s.shape,g,v,l):new $j(r.shape,i.shape,s.shape,g,v,l);return t.runWebGLProgram(w,p,p[0].dtype)}};class Uj{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=Bs(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=function Vj(n){if(1===n)return"sourceLoc";if(n<=6)return _F.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}(this.rank);let i;i=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((a,o)=>`sourceLoc.${_F[o]} = start[${o}] + coords.${_F[o]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${i}\n        setOutput(getSource(${r}));\n      }\n    `}}const _F=["x","y","z","w","u","v"];class Gj{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=Bs(this.rank),r=hl("coords",this.rank),i=hl("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${i.slice(-2).join()})`,a=`getChannel(getSource(${i.join()}), ${s})`,o=`\n      result.x = ${a};\n      if (++${r[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${i[this.rank-1]};\n        result.y = ${a};\n        --${i[this.rank-1]};\n      }\n    `,l=1===this.rank?"":`\n      --${r[this.rank-1]};\n      if (++${r[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${i[this.rank-2]};\n        result.z = ${a};\n        if (++${r[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${i[this.rank-1]};\n          result.w = ${a};\n        }\n      }\n    `,p=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((g,v)=>`start[${v}]`).join()});`:t.map((g,v)=>`${i[v]} = ${r[v]} + start[${v}];`).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${p}\n        vec4 result = vec4(0.);\n        ${o}\n        ${l}\n        setOutput(result);\n      }\n    `}}function Fy(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{begin:s,size:a}=r,[o,l]=Bg(i,s,a);if($g(i,o,l),0===ft(l))return e.makeTensorInfo(l,i.dtype,[]);if(e.shouldExecuteOnCPU([i])||"string"===i.dtype){const v=e.texData.get(i.dataId),w=FY(v.values,o,l,i.shape,i.dtype);return e.makeTensorInfo(l,i.dtype,w)}const{isPacked:p}=e.texData.get(i.dataId),g=Mv(i.shape,o,l);if(p||!g){const v=Pt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Gj(l):new Uj(l);return e.runWebGLProgram(v,[i],i.dtype,[o])}return e.uploadToGPU(i.dataId),function qj(n,t,e,r){const i=r.texData.get(n.dataId),s=r.makeTensorInfo(e,n.dtype),a=r.texData.get(s.dataId);Object.assign(a,i),a.refCount=1,a.shape=e,a.dtype=n.dtype;let o=Rv(t,zn(n.shape));i.slice&&(o+=i.slice.flatOffset),a.slice={flatOffset:o,origDataId:i.slice&&i.slice.origDataId||n.dataId};const l=r.dataRefCount.get(a.slice.origDataId)||1;return r.dataRefCount.set(a.slice.origDataId,l+1),s}(i,o,l,e)}const Wj={kernelName:po,backendName:"webgl",kernelFunc:Fy},Hj={kernelName:Ja,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{blockShape:s,crops:a}=r;K(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=s.reduce(($,U)=>$*U),l=Cm(i.shape,s,o),p=pd(l.length,s.length),g=Am(i.shape,s,o),v=Q1(a,s.length),w=D0(g,a,s.length),N=[],D=An({inputs:{x:i},backend:e,attrs:{shape:l}}),O=pl({inputs:{x:D},backend:e,attrs:{perm:p}}),k=An({inputs:{x:O},backend:e,attrs:{shape:g}}),L=Fy({inputs:{x:k},backend:e,attrs:{begin:v,size:w}});return N.push(D),N.push(O),N.push(k),N.forEach($=>e.disposeIntermediateTensorInfo($)),L}},Kj={kernelName:mc,backendName:"webgl",kernelFunc:function Xj(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,weights:s}=t,{size:a}=r,o=e.readSync(i.dataId),l=e.readSync(s.dataId),p=mz(o,l,s.dtype,s.shape,a);return e.makeTensorInfo([a],s.dtype,p)}},Zj={kernelName:en,backendName:"webgl",kernelFunc:function Yj(n){const{inputs:t,backend:e}=n,{s0:r,s1:i}=t,s=e.readSync(r.dataId),a=e.readSync(i.dataId),o=$r(Array.from(s),Array.from(a));return e.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},Vz=Iu({opSnippet:"return float(a != b);",cpuKernelImpl:CY,dtype:"bool"}),jj={kernelName:qs,backendName:"webgl",kernelFunc:Vz};function Lb(n){const{inputs:t,backend:e}=n,{input:r}=t;return hc({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.real},backend:e})}const Jj={kernelName:xc,backendName:"webgl",kernelFunc:Lb},tJ={kernelName:rr,backendName:"webgl",kernelFunc:function NF(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===i.dtype)return hc({inputs:{x:i},backend:e});const a=Wa(i.shape),o=NF({inputs:{x:i},backend:e,attrs:{dtype:"float32"}}),l=Dd({inputs:{real:o,imag:a},backend:e});return a.dispose(),e.disposeIntermediateTensorInfo(o),l}if("complex64"===i.dtype){const a=Lb({inputs:{input:i},backend:e}),o=NF({inputs:{x:a},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(a),o}if(!co(i.dtype,s)){const a=hc({inputs:{x:i},backend:e});return{dataId:a.dataId,shape:a.shape,dtype:s}}if(e.shouldExecuteOnCPU([i])){const a=e.texData.get(i.dataId).values,[o,l,p]=oY(a,i.shape,i.dtype,s);return e.makeTensorInfo(o,l,p)}if("int32"===s)return function eJ(n,t){const e=new Uh(n.shape,"return float(int(x));"),r=t.runWebGLProgram(e,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(i,e);if("bool"===s){const a=e.makeTensorInfo([],"bool",hi("bool",1)),l=Vz({inputs:{a:i,b:a},backend:e});return e.disposeIntermediateTensorInfo(a),l}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${s}`)}},Gz="return ceil(x);",nJ=rs({opSnippet:Gz,packedOpSnippet:Gz,cpuKernelImpl:uY}),rJ={kernelName:As,backendName:"webgl",kernelFunc:nJ};class iJ{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class sJ{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const oJ={kernelName:Qa,backendName:"webgl",kernelFunc:function aJ(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{clipValueMin:s,clipValueMax:a}=r;let o;return o=Pt().getBool("WEBGL_PACK_CLIP")?new sJ(i.shape):new iJ(i.shape),e.runWebGLProgram(o,[i],i.dtype,[[s],[a]])}};class uJ{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function qz(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}const cJ={kernelName:Zi,backendName:"webgl",kernelFunc:function lJ(n){const{inputs:t,backend:e}=n,{x:r}=t,i=e.texData.get(r.dataId),s=new uJ(r.shape),a=[qz(r,i.complexTensorInfos.real),qz(r,i.complexTensorInfos.imag)];return e.runWebGLProgram(s,a,a[0].dtype)}};class fJ{constructor(t){this.outputShape=[],this.outputShape=tc(t,1),this.variableNames=t.map((a,o)=>`T${o}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let a=1;a<e.length;a++)e[a]=e[a-1]+t[a][1];const r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<e.length;a++)r.push(`else if (yC < ${e[a]}) setOutput(getT${a}(yR, yC-${e[a-1]}));`);r.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${r.join("\n        ")}\n      }\n    `}}class hJ{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=tc(t,e);const r=this.outputShape,i=r.length,s=Bs(i),a=hl("coords",i),o=["x","y","z","w","u","v"].slice(0,i);this.variableNames=t.map((O,k)=>`T${k}`);const l=new Array(t.length-1);l[0]=t[0][e];for(let O=1;O<l.length;O++)l[O]=l[O-1]+t[O][e];const p=o[e],g=o.slice(-2),v=o.join();let w=`if (${p} < ${l[0]}) {\n        return getChannel(\n            getT0(${v}), vec2(${g.join()}));\n        }`;for(let O=1;O<l.length;O++){const k=l[O-1];w+=`\n        if (${p} < ${l[O]}  && ${p} >= ${l[O-1]}) {\n          return getChannel(\n            getT${O}(${WC(o,p,k)}),\n            vec2(${WC(g,p,k)}));\n        }`}const D=l[l.length-1];w+=`\n        return getChannel(\n          getT${l.length}(${WC(o,p,D)}),\n          vec2(${WC(g,p,D)}));`,this.userCode=`\n      float getValue(${o.map(O=>"int "+O)}) {\n        ${w}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n        ${a[i-1]} = ${a[i-1]} + 1;\n        if (${a[i-1]} < ${r[i-1]}) {\n          result.g = getValue(${a});\n        }\n\n        ${a[i-2]} = ${a[i-2]} + 1;\n        if (${a[i-2]} < ${r[i-2]}) {\n          result.a = getValue(${a});\n        }\n\n        ${a[i-1]} = ${a[i-1]} - 1;\n        if (${a[i-2]} < ${r[i-2]} &&\n            ${a[i-1]} < ${r[i-1]}) {\n          result.b = getValue(${a});\n        }\n        setOutput(result);\n      }\n    `}}function WC(n,t,e){const r=n.indexOf(t);return n.map((s,a)=>a===r?`${s} - ${e}`:s).join()}function HC(n){const{inputs:t,backend:e}=n,{input:r}=t;return hc({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.imag},backend:e})}const pJ={kernelName:vl,backendName:"webgl",kernelFunc:HC};function $b(n,t,e){const r=n[0].dtype;if("complex64"===r){const N=n.map($=>Lb({inputs:{input:$},backend:e})),D=n.map($=>HC({inputs:{input:$},backend:e})),O=$b(N,t,e),k=$b(D,t,e),L=Dd({inputs:{real:O,imag:k},backend:e});return N.forEach($=>e.disposeIntermediateTensorInfo($)),D.forEach($=>e.disposeIntermediateTensorInfo($)),e.disposeIntermediateTensorInfo(O),e.disposeIntermediateTensorInfo(k),L}let i=e.shouldExecuteOnCPU(n);if("string"===r&&(i=!0),i){const N=n.map(V=>{const ce=[-1,ft(V.shape.slice(t))];return An({inputs:{x:V},backend:e,attrs:{shape:ce}})}),D=N.map(V=>({vals:e.readSync(V.dataId),shape:V.shape})),O=tc(N.map(V=>V.shape),1),L=lY(D,O,r,1===N[0].shape[0]),$=tc(n.map(V=>V.shape),t),U=e.makeTensorInfo($,r,L);return N.forEach(V=>e.disposeIntermediateTensorInfo(V)),U}const s=n.filter(N=>ft(N.shape)>0),a=Pt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(1===s.length){const N=a?new Uh(n[0].shape,Md):new Rd(n[0].shape,Md);return e.runWebGLProgram(N,n,r)}const o=Pt().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){const N=[];for(let O=0;O<s.length;O+=o){const k=s.slice(O,O+o);N.push($b(k,t,e))}const D=$b(N,t,e);for(const O of N)e.disposeIntermediateTensorInfo(O);return D}if(a){const N=new hJ(s.map(D=>D.shape),t);return e.runWebGLProgram(N,s,r)}const{tensors2D:l,outShape:p}=function dJ(n,t,e){const r=tc(n.map(s=>s.shape),t);return{tensors2D:n.map(s=>An({inputs:{x:s},attrs:{shape:[-1,ft(s.shape.slice(t))]},backend:e})),outShape:r}}(s,t,e),g=new fJ(l.map(N=>N.shape)),v=e.runWebGLProgram(g,l,r);l.forEach(N=>e.disposeIntermediateTensorInfo(N));const w=An({inputs:{x:v},attrs:{shape:p},backend:e});return e.disposeIntermediateTensorInfo(v),w}function Wz(n){const{inputs:t,backend:e,attrs:r}=n,{axis:i}=r,s=ar(i,t[0].shape)[0];Y1(t.map(p=>p.shape),s);const o=tc(t.map(p=>p.shape),s);if(0===ft(o))return e.makeTensorInfo(o,t[0].dtype,[]);const l=t.filter(p=>ft(p.shape)>0);return 1===l.length?hc({inputs:{x:l[0]},backend:e}):$b(l,s,e)}const mJ={kernelName:ci,backendName:"webgl",kernelFunc:Wz};class Hz{constructor(t,e=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const a=t.padInfo.top,o=t.padInfo.left,l=t.strideHeight,p=t.strideWidth,g=t.dilationHeight,v=t.dilationWidth,w=t.filterHeight,N=t.filterWidth,D=4*Math.floor(t.inChannels/4),O=t.inChannels%4,k="channelsLast"===t.dataFormat,L=k?1:2,$=k?2:3,U=k?3:1;let V="",W="";r&&(V=i?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,W="result = activation(result);");const ce=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${V}\n\n      const ivec2 strides = ivec2(${l}, ${p});\n      const ivec2 pads = ivec2(${a}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${U}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${L}], coords[${$}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${w}; wR++) {\n          int xR = xRCorner + wR * ${g};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${N}; wC++) {\n            int xC = xCCorner + wC * ${v};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${D}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${k}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===O}) {\n\n              if (${k}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${D}) *\n                    getW(wR, wC, ${D}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${D}, xR, xC) *\n                    getW(wR, wC, ${D}, d2);\n              }\n\n            } else if (${2===O}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${D}, d2),\n                getW(wR, wC, ${D} + 1, d2)\n              );\n\n              if (${k}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${D}),\n                  getX(batch, xR, xC, ${D} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${D}, xR, xC),\n                  getX(batch, ${D} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===O}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${D}, d2),\n                getW(wR, wC, ${D} + 1, d2),\n                getW(wR, wC, ${D} + 2, d2)\n              );\n\n              if (${k}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${D}),\n                  getX(batch, xR, xC, ${D} + 1),\n                  getX(batch, xR, xC, ${D} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${D}, xR, xC),\n                  getX(batch, ${D} + 1, xR, xC),\n                  getX(batch, ${D} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${ce}\n        ${W}\n        setOutput(result);\n      }\n    `}}class gJ{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,r=t.padInfo.top,i=t.padInfo.left,s=t.strideDepth,a=t.strideHeight,o=t.strideWidth,l=t.dilationDepth,p=t.dilationHeight,g=t.dilationWidth,v=t.filterDepth,w=t.filterHeight,N=t.filterWidth,D=4*Math.floor(t.inChannels/4),O=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${a}, ${o});\n      const ivec3 pads = ivec3(${e}, ${r}, ${i});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${v}; wF++) {\n          int xF = xFCorner + wF * ${l};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${w}; wR++) {\n            int xR = xRCorner + wR * ${p};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${N}; wC++) {\n              int xC = xCCorner + wC * ${g};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${D}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===O}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${D}) *\n                  getW(wF, wR, wC, ${D}, d2);\n              } else if (${2===O}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${D}),\n                  getX(batch, xF, xR, xC, ${D} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${D}, d2),\n                  getW(wF, wR, wC, ${D} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===O}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${D}),\n                  getX(batch, xF, xR, xC, ${D} + 1),\n                  getX(batch, xF, xR, xC, ${D} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${D}, d2),\n                  getW(wF, wR, wC, ${D} + 1, d2),\n                  getW(wF, wR, wC, ${D} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Xz{constructor(t,e=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Xu(this.outputShape.length);const a=t.padInfo.left,o=t.strideWidth,l=t.dilationWidth,p=t.filterHeight,g=t.filterWidth,v=g;let w="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let k=0;k<g;k++)w+=`\n           vec4 xTexelC${2*k};\n           int xTexelC${2*k}Ready;\n           vec4 xTexelC${2*k+1};\n           int xTexelC${2*k+1}Ready;\n           vec4 xC${k};`;w+=`\n     for (int r = 0; r < ${p}; r++) {\n      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {\n       `;for(let k=0;k<g;k++)w+=`\n           xTexelC${2*k} = vec4(0.0);\n           xTexelC${2*k}Ready = 0;\n           xTexelC${2*k+1} = vec4(0.0);\n           xTexelC${2*k+1}Ready = 0;\n           xC${k} = vec4(0.0);`;w+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let k=0;k<(v+1)/2;k++){const L=2*k;if(w+=`\n           xC = xCCorner + ${L*l};\n           `,1===o){if(L<g&&(a%2==1?(w+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${L}Ready == 0) {\n                   xTexelC${L} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${L}.zw = vec2(0.0);\n                   }\n                   xTexelC${L}Ready = 1;\n                 }\n               `,w+=1===l&&L>0?`\n                 xC${L} = vec4(xTexelC${L-2}.zw, xTexelC${L}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${L} = vec4(previous.zw, xTexelC${L}.xy);\n                   } else {\n                     xC${L} = vec4(0.0, 0.0, xTexelC${L}.xy);\n                   }\n                   `):w+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${L}Ready == 0) {\n                   xTexelC${L} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${L}.zw = vec2(0.0);\n                   }\n                   xTexelC${L}Ready = 1;\n                 }\n\n                 xC${L} = xTexelC${L};\n                 `,L+1<g)){const $=a%2==0?De(l):l;l%2==0&&a%2==1||l%2!=0&&a%2!=1?(w+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${$};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${L+1}Ready == 0) {\n                     xTexelC${L+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${L+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${L+1}Ready = 1;\n                   }\n                   `,w+=l>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${L+1} = vec4(previous.zw, xTexelC${L+1}.xy);\n                     } else {\n                      xC${L+1} = vec4(0.0, 0.0, xTexelC${L+1}.xy);\n                     }\n                     `:`\n                     xC${L+1} = vec4(xTexelC${L}.zw, xTexelC${L+1}.xy);\n                     `):w+=1===$?`\n                     xC${L+1} = xTexelC${L};\n                     `:`\n                     xCOffset = xC + ${$};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${L+1}Ready == 0) {\n                       xTexelC${L+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${L+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${L+1}Ready = 1;\n                     }\n\n                     xC${L+1} = xTexelC${L+1};\n                     `}}else L<g&&(a%2==1?(w+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${L}Ready == 0) {\n                   xTexelC${L} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${L}.zw = vec2(0.0);\n                   }\n                   xTexelC${L}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${L+1}Ready == 0) {\n                   xTexelC${L+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${L+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${L+1}Ready = 1;\n                 }\n\n                 xC${L} = vec4(xTexelC${L}.zw, xTexelC${L+1}.zw);\n               `,L+1<g&&(w+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${L+1} = vec4(xTexelC${L+1}.xy, final.xy);\n                 `)):(w+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${L}Ready == 0) {\n                   xTexelC${L} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${L}.zw = vec2(0.0);\n                   }\n                   xTexelC${L}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${L+1}Ready == 0) {\n                   xTexelC${L+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${L+1}.zw = vec2(0.);\n                   }\n                   xTexelC${L+1}Ready = 1;\n                 }\n\n                 xC${L} = vec4(\n                   xTexelC${L}.xy, xTexelC${L+1}.xy);\n               `,L+1<g&&(w+=`\n                   xC${L+1} = vec4(xTexelC${L}.zw, xTexelC${L+1}.zw);\n                 `)));L<g&&(w+=`\n             wTexel = getW(r, ${L}, d1, d2);\n             dotProd += xC${L}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${t.inChannels}) {\n               dotProd += xC${L}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,L+1<g&&(w+=`\n               wTexel = getW(r, ${L+1}, d1, d2);\n               dotProd += xC${L+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${t.inChannels}) {\n                 dotProd += xC${L+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}w+="\n     }\n   ",w+="\n     }\n   ",w+="\n     }\n   ";let N="",D="";r&&(N=i?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${r}\n         }`:s?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${r}\n         }`:`vec4 activation(vec4 x) {\n           ${r}\n         }`,D="result = activation(result);");const O=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${N}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${w}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${O}\n         ${D}\n         setOutput(result);\n       }\n     `}}class yJ{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=Xu(this.outputShape.length);const{dataFormat:r}=e,i=fl(),s="channelsLast"===r,a=s?1:2,o=s?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let p="";for(let g=0;g<=1;g++)for(let v=0;v<=1;v++)p+=`\n          blockIndex = rc.z + ${v};\n          pos = rc.y + ${g};\n\n          ${l}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${a}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${o}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${s}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*g+v}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*g+v}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${p}\n\n        ${i.output} = result;\n      }\n    `}}function XC(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&1===e&&n[0]>1?[n[0],1]:null}function Kz({x:n,filter:t,convInfo:e,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:o=null}){const l=n.shape,p=r.texData.get(n.dataId),g=e.inChannels,v=l[0]*l[1]*l[2],w=e.outChannels,N="channelsLast"===e.dataFormat;let k;const L=[];if(null!=s){const V=XC(s.shape,N);null!=V&&(s=An({inputs:{x:s},backend:r,attrs:{shape:V}}),L.push(s))}if(null!=i){const V=XC(i.shape,N);null!=V&&(i=An({inputs:{x:i},backend:r,attrs:{shape:V}}),L.push(i))}if((1!==v&&1!==w||!(g>Fz))&&p.isPacked&&N&&null!=p.texture&&l[2]%2!=0&&Kt(p.shape.slice(-3),l.slice(-3))){const W={dataId:n.dataId,shape:[1,l[0]*l[1]*(l[2]+1),e.inChannels],dtype:n.dtype},ce=p.shape;p.shape=p.shape.slice(),p.shape[p.shape.length-2]++,K(Db(p.shape,W.shape),()=>`packed reshape ${p.shape} to ${W.shape} isn't free`);const ve=An({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}});L.push(ve);const Ee=GC({a:W,b:ve,backend:r,transposeA:!1,transposeB:!1,bias:i,activation:o,preluActivationWeights:s,leakyreluAlpha:a}),ge=r.texData.get(Ee.dataId);K(ge.isPacked,()=>"batchMatMul result is expected to be packed"),p.shape=ce,ge.shape=e.outShape,k=hc({inputs:{x:Ee},backend:r}),k.shape=e.outShape,L.push(Ee)}else{const V=e.outHeight*e.outWidth,W=An({inputs:{x:n},backend:r,attrs:{shape:N?[e.batchSize,V,e.inChannels]:[e.batchSize,e.inChannels,V]}}),ce=An({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}}),ve=GC({a:N?W:ce,b:N?ce:W,transposeA:!N,transposeB:!1,backend:r,bias:i,activation:o,preluActivationWeights:s,leakyreluAlpha:a});k=An({inputs:{x:ve},backend:r,attrs:{shape:e.outShape}}),L.push(W),L.push(ce),L.push(ve)}for(const V of L)r.disposeIntermediateTensorInfo(V);return k}function Yz({x:n,filter:t,convInfo:e,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:o=null}){const{filterWidth:l,filterHeight:p,inChannels:g,outWidth:v,outHeight:w,dataFormat:N}=e,D="channelsLast"===N,O=l*p*g,k=w*v,L=[e.batchSize,O,k],V=[];if(null!=s){const Bt=XC(s.shape,D);null!=Bt&&(s=An({inputs:{x:s},backend:r,attrs:{shape:Bt}}),V.push(s))}if(null!=i){const Bt=XC(i.shape,D);null!=Bt&&(i=An({inputs:{x:i},backend:r,attrs:{shape:Bt}}),V.push(i))}const W=An({inputs:{x:t},backend:r,attrs:{shape:[1,O,ft(t.shape)/O]}});V.push(W);const ce=new yJ(L,e),Ee=r.runWebGLProgram(ce,[n],"float32",[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]]),ge=An({inputs:{x:Ee},backend:r,attrs:{shape:L}});V.push(Ee),V.push(ge);const it=null!=i,ut=null!=s,Mt="leakyrelu"===o,Ot=o?Pb(o,!0):null,vt=new Rz(D?ge.shape:W.shape,D?W.shape:ge.shape,D?[e.batchSize,k,e.outChannels]:[e.batchSize,e.outChannels,k],!0,!1,it,Ot,ut,Mt),Rt=D?[ge,W]:[W,ge];if(i&&Rt.push(i),ut&&Rt.push(s),Mt){const Bt=r.makeTensorInfo([],"float32",ji(a,"float32"));Rt.push(Bt),V.push(Bt)}const Dt=r.runWebGLProgram(vt,Rt,"float32"),Ht=An({inputs:{x:Dt},backend:r,attrs:{shape:e.outShape}});V.push(Dt);for(const Bt of V)r.disposeIntermediateTensorInfo(Bt);return Ht}const xJ={kernelName:kr,backendName:"webgl",kernelFunc:function vJ(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,filter:s}=t,{strides:a,pad:o,dataFormat:l,dilations:p,dimRoundingMode:g}=r,v=Hf(l),w=vo(i.shape,s.shape,a,p,o,g,!1,v);let N;if(1!==w.filterHeight||1!==w.filterWidth||1!==w.dilationHeight||1!==w.dilationWidth||1!==w.strideHeight||1!==w.strideWidth||"SAME"!==w.padInfo.type&&"VALID"!==w.padInfo.type)if(w.strideWidth<=2&&"channelsLast"===v&&Pt().getBool("WEBGL_EXP_CONV")){const O=new Xz(w);N=e.runWebGLProgram(O,[i,s],"float32",[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]])}else if(Pt().getBool("WEBGL_CONV_IM2COL"))N=Yz({x:i,filter:s,convInfo:w,backend:e});else{const O=new Hz(w);N=e.runWebGLProgram(O,[i,s],"float32")}else N=Kz({x:i,filter:s,convInfo:w,backend:e});const D=An({inputs:{x:N},backend:e,attrs:{shape:w.outShape}});return e.disposeIntermediateTensorInfo(N),D}};class bJ{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              ${"channelsLast"===t.dataFormat?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class wJ{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,a="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${a?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${a?1:2}], coords[${a?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${a}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class _J{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class NJ{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,r=t.filterHeight,i=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${r-1-t.padInfo.top}, ${i-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${r}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${r} - 1 - wR;\n\n            for (int wC = 0; wC < ${i}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${i} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const EJ={kernelName:ys,backendName:"webgl",kernelFunc:function SJ(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,dy:s}=t,{strides:a,pad:o,dataFormat:l,dimRoundingMode:p,filterShape:g}=r,v=Hf(l),w=vo(i.shape,g,a,1,o,p,!1,v),N=new bJ(w);return e.runWebGLProgram(N,[i,s],"float32")}};class IJ{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=Xu(this.outputShape.length);const e=t.filterHeight,r=t.filterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            int wCPerm = ${r} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const AJ={kernelName:uh,backendName:"webgl",kernelFunc:function CJ(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,filter:s}=t,{inputShape:a,strides:o,pad:l,dataFormat:p,dimRoundingMode:g}=r,v=Hf(p),w=vo(a,s.shape,o,1,l,g,!1,v);if(Pt().getBool("WEBGL_PACK")&&"channelsLast"===v){const N=[[w.strideHeight,w.strideWidth]],D=new IJ(w);return e.runWebGLProgram(D,[i,s],"float32",N)}{const N=new wJ(w);return e.runWebGLProgram(N,[i,s],"float32")}}},MJ={kernelName:lh,backendName:"webgl",kernelFunc:function TJ(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,filter:s}=t,{strides:a,pad:o,dilations:l}=r,p=_h(i.shape,s.shape,a,l,o),g=new gJ(p);return e.runWebGLProgram(g,[i,s],"float32")}},DJ={kernelName:Ca,backendName:"webgl",kernelFunc:function RJ(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,dy:s}=t,{strides:a,pad:o,filterShape:l}=r,p=_h(i.shape,l,a,1,o),g=new _J(p);return e.runWebGLProgram(g,[i,s],"float32")}},kJ={kernelName:hu,backendName:"webgl",kernelFunc:function OJ(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,filter:s}=t,{pad:a,strides:o,inputShape:l}=r,p=_h(l,s.shape,o,1,a),g=new NJ(p);return e.runWebGLProgram(g,[i,s],"float32")}},LJ=rs({opSnippet:Py+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${rg}\n  return result;\n`}),$J={kernelName:eo,backendName:"webgl",kernelFunc:LJ},BJ=rs({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),zJ={kernelName:Jr,backendName:"webgl",kernelFunc:BJ};class UJ{constructor(t,e,r,i,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,o,l,p]=t,[g]=e,[v,w]=r;this.outputShape=[g,v,w,p];const N="bilinear"===i?1:0,[D,O]=[o-1+".0",l-1+".0"],[k,L,$]=v>1?[""+(o-1)/(v-1),"(y2-y1) * height_ratio",`y1*${D} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${D}`],[U,V,W]=w>1?[""+(l-1)/(w-1),"(x2-x1) * width_ratio",`x1*${O} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${O}`];this.userCode=`\n      const float height_ratio = float(${k});\n      const float width_ratio = float(${U});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${a}) {\n          return;\n        }\n\n        float height_scale = ${L};\n        float width_scale = ${V};\n\n        float in_y = ${$};\n        if( in_y < 0.0 || in_y > ${D} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${W};\n        if( in_x < 0.0 || in_x > ${O} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${N} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const VJ={kernelName:gl,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{image:i,boxes:s,boxInd:a}=t,{cropSize:o,method:l,extrapolationValue:p}=r,g=new UJ(i.shape,s.shape,o,l,p);return e.runWebGLProgram(g,[i,s,a],"float32")}};var Ly=(()=>{return(n=Ly||(Ly={})).Prod="*",n.Sum="+",Ly;var n})();class Zz{constructor(t,e,r,i){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,o=r?this.op===Ly.Prod?"1.0":"0.0":`getX(${jz(s,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let p="",g="";r?(p=i?"end != "+(l-1):"end != 0",g=i?"end + 1":"end - 1"):(p=i?`end + pow2 < ${l}`:"end >= pow2",g=i?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${Bs(s)} coords = getOutputCoords();\n        int end = ${Jz(s,"coords",this.op)};\n        float val = ${o};\n        int pow2 = int(pow(2.0, index));\n        if (${p}) {\n          int idx = ${g};\n          ${Jz(s,"coords",this.op)} = idx;\n          val ${this.op}= getX(${jz(s,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function jz(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.x, ${t}.y`;if(3===n)return`${t}.x, ${t}.y, ${t}.z`;if(4===n)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function Jz(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.y`;if(3===n)return`${t}.z`;if(4===n)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function Qz(n,t,e,r,i,s){const a=t.shape.length,o=na([r],a);let l=t;null!=o&&(l=pl({inputs:{x:t},backend:e,attrs:{perm:o}}));const p=ka(1,a)[0];if(p!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const g=l.shape[p];let v=hc({inputs:{x:l},backend:e});for(let w=0;w<=Math.ceil(Math.log2(g))-1;w++){const N=new Zz(n,l.shape,!1,s),O=v;v=e.runWebGLProgram(N,[v],v.dtype,[[w]]),e.disposeIntermediateTensorInfo(O)}if(i){const w=new Zz(n,l.shape,i,s),N=v;v=e.runWebGLProgram(w,[v],v.dtype),e.disposeIntermediateTensorInfo(N)}if(null!=o){const N=pl({inputs:{x:v},backend:e,attrs:{perm:Ch(o)}});return e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(l),N}return v}const qJ={kernelName:Zc,backendName:"webgl",kernelFunc:function GJ(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:s,exclusive:a,reverse:o}=r;return Qz(Ly.Prod,i,e,s,a,o)}},HJ={kernelName:Zs,backendName:"webgl",kernelFunc:function WJ(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:s,exclusive:a,reverse:o}=r;return Qz(Ly.Sum,i,e,s,a,o)}},KJ={kernelName:Qu,backendName:"webgl",kernelFunc:function XJ(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,weights:s}=t,{size:a,binaryOutput:o}=r;if(1===i.shape.length){const l=e.readSync(i.dataId),p=e.readSync(s.dataId),g=mz(l,p,s.dtype,s.shape,a);return e.makeTensorInfo([a],s.dtype,g)}if(2===i.shape.length){const l=e.bufferSync(i),p=e.bufferSync(s),g=aY(l,p,a,o);return e.makeTensorInfo(g.shape,s.dtype,g.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}};class YJ{constructor(t,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=r,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const jJ={kernelName:Qi,backendName:"webgl",kernelFunc:function ZJ(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{blockSize:s,dataFormat:a}=r,o=i.shape[0],v=("NHWC"===a?i.shape[1]:i.shape[2])*s,w=("NHWC"===a?i.shape[2]:i.shape[3])*s,N=("NHWC"===a?i.shape[3]:i.shape[1])/(s*s),O=new YJ("NHWC"===a?[o,v,w,N]:[o,N,v,w],s,a);return e.runWebGLProgram(O,[i],i.dtype)}};class eU{constructor(t,e=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Xu(this.outputShape.length);const a=t.filterHeight,o=t.filterWidth,l=t.outChannels/t.inChannels;let p="",g="";r&&(p=i?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,g="result = activation(result);");const v=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${l};\n        int q = d2 - d1 * ${l};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${a}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${v}\n        ${g}\n        setOutput(result);\n      }\n    `}}class tU{constructor(t,e=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Xu(this.outputShape.length);const a=t.outChannels/t.inChannels,o=t.padInfo.left,l=t.strideWidth,p=t.dilationWidth,g=t.filterHeight,v=t.filterWidth,w=v;let N="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let L=0;L<v;L++)N+=`\n          vec4 xTexelC${2*L};\n          int xTexelC${2*L}Ready;\n          vec4 xTexelC${2*L+1};\n          int xTexelC${2*L+1}Ready;\n          vec4 xC${L};`;N+=`\n    for (int r = 0; r < ${g}; r++) {\n      `;for(let L=0;L<v;L++)N+=`\n          xTexelC${2*L} = vec4(0.0);\n          xTexelC${2*L}Ready = 0;\n          xTexelC${2*L+1} = vec4(0.0);\n          xTexelC${2*L+1}Ready = 0;\n          xC${L} = vec4(0.0);`;N+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let L=0;L<(w+1)/2;L++){const $=2*L;if(N+=`\n          xC = xCCorner + ${$*p};\n          `,1===l){if($<v&&(o%2==1?(N+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$}Ready == 0) {\n                  xTexelC${$} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${$}.zw = vec2(0.0);\n                  }\n                  xTexelC${$}Ready = 1;\n                }\n              `,N+=1===p&&$>0?`\n                xC${$} = vec4(xTexelC${$-2}.zw, xTexelC${$}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${$} = vec4(previous.zw, xTexelC${$}.xy);\n                  } else {\n                    xC${$} = vec4(0.0, 0.0, xTexelC${$}.xy);\n                  }\n                  `):N+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${$}Ready == 0) {\n                  xTexelC${$} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${$}.zw = vec2(0.0);\n                  }\n                  xTexelC${$}Ready = 1;\n                }\n\n                xC${$} = xTexelC${$};\n                `,$+1<v)){const U=o%2==0?De(p):p;p%2==0&&o%2==1||p%2!=0&&o%2!=1?(N+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${U};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {\n                    xTexelC${$+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${$+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${$+1}Ready = 1;\n                  }\n                  `,N+=p>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${$+1} = vec4(previous.zw, xTexelC${$+1}.xy);\n                    } else {\n                     xC${$+1} = vec4(0.0, 0.0, xTexelC${$+1}.xy);\n                    }\n                    `:`\n                    xC${$+1} = vec4(xTexelC${$}.zw, xTexelC${$+1}.xy);\n                    `):N+=1===U?`\n                    xC${$+1} = xTexelC${$};\n                    `:`\n                    xCOffset = xC + ${U};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {\n                      xTexelC${$+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${$+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${$+1}Ready = 1;\n                    }\n\n                    xC${$+1} = xTexelC${$+1};\n                    `}}else $<v&&(o%2==1?(N+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$}Ready == 0) {\n                  xTexelC${$} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${$}.zw = vec2(0.0);\n                  }\n                  xTexelC${$}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${$+1}Ready == 0) {\n                  xTexelC${$+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${$+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${$+1}Ready = 1;\n                }\n\n                xC${$} = vec4(xTexelC${$}.zw, xTexelC${$+1}.zw);\n              `,$+1<v&&(N+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${$+1} = vec4(xTexelC${$+1}.xy, final.xy);\n                `)):(N+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${$}Ready == 0) {\n                  xTexelC${$} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${$}.zw = vec2(0.0);\n                  }\n                  xTexelC${$}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {\n                  xTexelC${$+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${$+1}.zw = vec2(0.);\n                  }\n                  xTexelC${$+1}Ready = 1;\n                }\n\n                xC${$} = vec4(\n                  xTexelC${$}.xy, xTexelC${$+1}.xy);\n              `,$+1<v&&(N+=`\n                  xC${$+1} = vec4(xTexelC${$}.zw, xTexelC${$+1}.zw);\n                `)));$<v&&(N+=`\n            wTexel = getW(r, ${$}, d1, q);\n            dotProd += xC${$} * vec4(wTexel.xz, wTexel.xz);\n          `,$+1<v&&(N+=`\n              wTexel = getW(r, ${$+1}, d1, q);\n              dotProd += xC${$+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}N+="\n    }\n  ",N+="\n      }\n    ";let D="",O="";r&&(D=i?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:s?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`vec4 activation(vec4 x) {\n          ${r}\n        }`,O="result = activation(result);");const k=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${D}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${a};\n        int q = d2 - d1 * ${a};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${N}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${k}\n        ${O}\n        setOutput(result);\n      }\n    `}}const QJ={kernelName:la,backendName:"webgl",kernelFunc:function JJ(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,filter:s}=t,{strides:a,pad:o,dilations:l,dimRoundingMode:p}=r;let g=l;null==g&&(g=[1,1]),K(Uo(a,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${g}'`);const v=vo(i.shape,s.shape,a,g,o,p,!0);let w;return w=Pt().getBool("WEBGL_PACK_DEPTHWISECONV")&&v.strideWidth<=2&&v.outChannels/v.inChannels==1?new tU(v):new eU(v),e.runWebGLProgram(w,[i,s],"float32",[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]])}};class eQ{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class tQ{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,l=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${l}; dm++) {\n              int d2 = d1 * ${l} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const rQ={kernelName:Fl,backendName:"webgl",kernelFunc:function nQ(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,dy:s}=t,{strides:a,dilations:o,pad:l,dimRoundingMode:p,filterShape:g}=r,v=vo(i.shape,g,a,o,l,p,!0),w=new eQ(v);return e.runWebGLProgram(w,[i,s],"float32")}},sQ={kernelName:Mo,backendName:"webgl",kernelFunc:function iQ(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,filter:s}=t,{strides:a,dilations:o,pad:l,dimRoundingMode:p,inputShape:g}=r,v=vo(g,s.shape,a,o,l,p,!0),w=new tQ(v);return e.runWebGLProgram(w,[i,s],"float32")}};class aQ{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const uQ={kernelName:Tu,backendName:"webgl",kernelFunc:function oQ(n){const{inputs:t,backend:e}=n,{x:r}=t,i=[...r.shape,...r.shape],s=ft(r.shape),a=An({inputs:{x:r},backend:e,attrs:{shape:[s]}}),o=new aQ(s),l=e.runWebGLProgram(o,[a],a.dtype),p=An({inputs:{x:l},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),p}};class lQ{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:r,padInfo:i,strideHeight:s,strideWidth:a,filterHeight:o,filterWidth:l,dilationHeight:p,dilationWidth:g}=t,{top:v,left:w}=i;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${a});\n      const ivec2 pads = ivec2(${v}, ${w});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${o}; h++) {\n          int hIn = hBeg + h * ${p};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${l}; w++) {\n              int wIn = wBeg + w * ${g};\n\n              if (wIn >= 0 && wIn < ${r}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const fQ={kernelName:Mu,backendName:"webgl",kernelFunc:function cQ(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,filter:s}=t,{strides:a,pad:o,dilations:l}=r,p=lm(i.shape,s.shape,a,o,"NHWC",l);let g;const v=new lQ(p);g=e.runWebGLProgram(v,[i,s],"float32");const w=An({inputs:{x:g},backend:e,attrs:{shape:p.outShape}});return e.disposeIntermediateTensorInfo(g),w}},pQ={kernelName:Ro,backendName:"webgl",kernelFunc:function hQ(n){const{inputs:t,backend:e,attrs:r}=n,{equation:i}=r,s=t,{allDims:a,summedDims:o,idDims:l}=ox(i,s.length);ux(a.length,l,s);const{path:p,steps:g}=lx(o,l),v=g.length;let w=null,N=a.length;const D=[];for(let O=0;O<v;++O){for(const k of g[O]){const{permutationIndices:L,expandDims:$}=F0(N,l[k]);let U;L0(L)?U=s[k]:(U=pl({inputs:{x:s[k]},backend:e,attrs:{perm:L}}),D.push(U));const V=U.shape.slice();for(let W=0;W<$.length;++W)V.splice($[W],0,1);Kt(U.shape,V)||(U=An({inputs:{x:U},backend:e,attrs:{shape:V}}),D.push(U)),null===w?w=U:(w=bF({inputs:{a:U,b:w},backend:e}),D.push(w))}O<v-1&&(p[O]>=0&&(w=VC({inputs:{x:w},backend:e,attrs:{axis:p[O]-(a.length-N),keepDims:!1}}),D.push(w)),N--)}for(const O of D)O!==w&&e.disposeIntermediateTensorInfo(O);return w}},dQ=rs({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),mQ={kernelName:hs,backendName:"webgl",kernelFunc:dQ},vQ={kernelName:Gs,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e}=n,{dy:r,y:i}=t,s=Pt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new kb("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,i.shape):new ky("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,i.shape);return e.runWebGLProgram(s,[r,i],r.dtype)}},xQ=Iu({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:cY}),bQ={kernelName:Hh,backendName:"webgl",kernelFunc:xQ},_Q=rs({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${P0};\n  float a1 = ${ex};\n  float a2 = ${tx};\n  float a3 = ${nx};\n  float a4 = ${rx};\n  float a5 = ${ix};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),NQ={kernelName:gc,backendName:"webgl",kernelFunc:_Q},nU=rs({opSnippet:Py+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:fY,dtype:"float32"}),EQ={kernelName:yl,backendName:"webgl",kernelFunc:nU};function SF(n){const{inputs:t,attrs:e,backend:r}=n,{dim:i}=e,{input:s}=t,a=s.shape.length,o=s.shape.slice();let l=i;return i<0&&(K(-(a+1)<=i,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+i+1),o.splice(l,0,1),An({inputs:{x:s},backend:r,attrs:{shape:o}})}const IQ={kernelName:ch,backendName:"webgl",kernelFunc:SF},rU="return exp(x) - 1.0;",CQ=rs({opSnippet:rU,packedOpSnippet:rU,cpuKernelImpl:hY}),AQ={kernelName:Df,backendName:"webgl",kernelFunc:CQ};class iU{constructor(t,e,r){this.variableNames=["real","imag"];const i=e[1];this.outputShape=e;const s=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=r?`${i}.0`:"1.0";let o;if("real"===t)o="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);o="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${o}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${i});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${i}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${a};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function sU(n,t,e){const r=e.texData.get(n.dataId),i=ft(n.shape),s=n.shape[n.shape.length-1],o=An({inputs:{x:n},backend:e,attrs:{shape:[i/s,s]}}),l=o.shape,p=new iU("real",l,t),g=new iU("imag",l,t),v=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],w=e.runWebGLProgram(p,v,"float32"),N=e.runWebGLProgram(g,v,"float32"),D=Dd({inputs:{real:w,imag:N},backend:e});e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(N);const O=An({inputs:{x:D},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(D),O}const MQ={kernelName:Aa,backendName:"webgl",kernelFunc:function TQ(n){const{inputs:t,backend:e}=n,{input:r}=t;return sU(r,!1,e)}};class RQ{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Bb(n){const{backend:t,attrs:e}=n,{shape:r,value:i}=e;let{dtype:s}=e;if(s=s||Hc(i),"string"===s){const a=Dr(s,ft(r));return a.fill(i),t.makeTensorInfo(r,s,a)}{const a=new RQ(r,i);return t.runWebGLProgram(a,[],s,[[i]])}}const DQ={kernelName:Ru,backendName:"webgl",kernelFunc:Bb};class OQ{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const kQ={kernelName:ya,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,r=t,i=new OQ(e.shape);return r.runWebGLProgram(i,[e],e.dtype)}},aU="return floor(x);",PQ=rs({opSnippet:aU,packedOpSnippet:aU,cpuKernelImpl:pY}),FQ={kernelName:el,backendName:"webgl",kernelFunc:PQ},LQ=Iu({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),$Q={kernelName:Do,backendName:"webgl",kernelFunc:LQ};class BQ{constructor(t){this.variableNames=["A"];const e=fl(),[r,i]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}.0, ${r}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class zQ{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=fl(),[r,i]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${i}.0, ${r}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const UQ={kernelName:Bo,backendName:"webgl",kernelFunc:function VQ(n){const{inputs:t,backend:e,attrs:r}=n;let{pixels:i}=t;const{numChannels:s}=r,a=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,[l,p]=a?[i.videoWidth,i.videoHeight]:[i.width,i.height],g=[p,l],v=[p,l,s];if(o||a){const O=Pt().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==$y||O!==EF)&&(EF=O,$y=document.createElement("canvas").getContext("2d",{willReadFrequently:EF})),$y.canvas.width=l,$y.canvas.height=p,$y.drawImage(i,0,0,l,p),i=$y.canvas}const w=e.makeTensorInfo(g,"int32");e.texData.get(w.dataId).usage=fc.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(w.dataId),i);const N=Pt().getBool("WEBGL_PACK")?new zQ(v):new BQ(v),D=e.runWebGLProgram(N,[w],"int32");return e.disposeData(w.dataId),D}};let $y,EF=Pt().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const qQ={kernelName:Xl,backendName:"webgl",kernelFunc:function GQ(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,filter:s,bias:a,preluActivationWeights:o}=t,{strides:l,pad:p,dataFormat:g,dilations:v,dimRoundingMode:w,activation:N,leakyreluAlpha:D}=r,O=Hf(g),k=vo(i.shape,s.shape,l,v,p,w,!1,O);let L;const $=[],U=null!=a,V=null!=o,W="leakyrelu"===N,ce=()=>{const Ee=[i,s],ge=(it,ut)=>{if("NCHW"===ut&&1===it.shape.length&&1!==it.shape[0]){const Mt=An({inputs:{x:it},backend:e,attrs:{shape:[it.shape[0],1,1]}});return $.push(Mt),Mt}return it};if(U&&Ee.push(ge(a,g)),V&&Ee.push(ge(o,g)),W){const it=e.makeTensorInfo([],"float32",ji(D,"float32"));Ee.push(it),$.push(it)}return Ee};if(1!==k.filterHeight||1!==k.filterWidth||1!==k.dilationHeight||1!==k.dilationWidth||1!==k.strideHeight||1!==k.strideWidth||"SAME"!==k.padInfo.type&&"VALID"!==k.padInfo.type)if(k.strideWidth<=2&&"channelsLast"===O&&Pt().getBool("WEBGL_EXP_CONV")){const Ee=N?Pb(N,!0):null,ge=new Xz(k,U,Ee,V,W),it=[[k.padInfo.top,k.padInfo.left],[k.strideHeight,k.strideWidth],[k.dilationHeight,k.dilationWidth],[k.inHeight,k.inWidth]],ut=ce();L=e.runWebGLProgram(ge,ut,"float32",it)}else if(Pt().getBool("WEBGL_CONV_IM2COL"))L=Yz({x:i,filter:s,convInfo:k,backend:e,bias:a,activation:N,preluActivationWeights:o,leakyreluAlpha:D});else{const Ee=N?Pb(N,!1):null,ge=new Hz(k,U,Ee,V,W),it=ce();L=e.runWebGLProgram(ge,it,"float32")}else L=Kz({x:i,filter:s,convInfo:k,backend:e,bias:a,activation:N,preluActivationWeights:o,leakyreluAlpha:D});const ve=An({inputs:{x:L},backend:e,attrs:{shape:k.outShape}});return $.push(L),$.forEach(Ee=>e.disposeIntermediateTensorInfo(Ee)),ve}},HQ={kernelName:Nl,backendName:"webgl",kernelFunc:function WQ(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,filter:s,bias:a,preluActivationWeights:o}=t,{strides:l,pad:p,dilations:g,dimRoundingMode:v,activation:w,leakyreluAlpha:N}=r,D=[];let O=g;null==O&&(O=[1,1]),K(Uo(l,O),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${O}'`);const k=vo(i.shape,s.shape,l,O,p,v,!0),L=Pt().getBool("WEBGL_PACK_DEPTHWISECONV")&&k.strideWidth<=2&&k.outChannels/k.inChannels==1,$=w?Pb(w,L):null,U=[i,s],V=null!=a,W=null!=o,ce="leakyrelu"===w;if(V&&U.push(a),W&&U.push(o),ce){const it=e.makeTensorInfo([],"float32",ji(N,"float32"));U.push(it),D.push(it)}let ve;ve=L?new tU(k,V,$,W,ce):new eU(k,V,$,W,ce);const ge=e.runWebGLProgram(ve,U,"float32",[[k.padInfo.top,k.padInfo.left],[k.strideHeight,k.strideWidth],[k.dilationHeight,k.dilationWidth],[k.inHeight,k.inWidth]]);return D.forEach(it=>e.disposeIntermediateTensorInfo(it)),ge}};class XQ{constructor(t,e,r,i){this.sliceDim=t,this.strides=e,this.paramsShape=i,this.variableNames=["x","indices"],this.outputShape=r;const s=Bs(r.length);let a="\n    int index;";for(let o=0;o<this.sliceDim;o++)a+=`\n          index = round(getIndices(coords[0], ${o}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};\n          flattenIndex += index * ${this.strides[o]};`;this.userCode=`\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${a}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const YQ={kernelName:Wn,backendName:"webgl",kernelFunc:function KQ(n){const{inputs:t,backend:e}=n,{params:r,indices:i}=t,s=i.shape,a=s[s.length-1],o=ft(r.shape),[l,p,g,v]=sm(r,i),w=An({inputs:{x:i},backend:e,attrs:{shape:[p,a]}}),N=An({inputs:{x:r},backend:e,attrs:{shape:[ft(r.shape)/g,g]}});if(e.shouldExecuteOnCPU([r,i])||"string"===r.dtype){const L=e.readSync(i.dataId),$=e.bufferSync(r),U=dY(L,$,r.dtype,p,a,g,v,r.shape,o);return e.makeTensorInfo(l,r.dtype,U.values)}const D=new XQ(a,v,[p,g],r.shape),O=e.runWebGLProgram(D,[N,w],N.dtype),k=An({inputs:{x:O},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(O),k}};class ZQ{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const r=Bs(this.rank),i=function jQ(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let i=0;i<n.length;i++)r.push(2===i?"index":`${e[i]}`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${i}));\n      }\n    `}}function oU(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,indices:s}=t,{axis:a,batchDims:o}=r,l=ar(a,i.shape)[0];if(Pt().get("DEBUG")){const $=e.readSync(s.dataId),U=i.shape[l];for(let V=0;V<$.length;++V){const W=$[V];K(W<=U-1&&W>=0,()=>`GatherV2: the index value ${W} is not in [0, ${U-1}]`)}}const p=gx(i,s,l,o),g=ft(s.shape),v=[],w=An({inputs:{x:i},backend:e,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),N=An({inputs:{x:s},backend:e,attrs:{shape:[p.batchSize,g/p.batchSize]}});v.push(w),v.push(N);const D=[p.batchSize,p.outerSize,g/p.batchSize,p.sliceSize];if(e.shouldExecuteOnCPU([i,s])||"string"===i.dtype){const $=e.bufferSync(N),U=e.bufferSync(w),V=mY(U,$,D);return v.forEach(W=>e.disposeIntermediateTensorInfo(W)),e.makeTensorInfo(p.outputShape,V.dtype,V.values)}const O=new ZQ(w.shape,D),k=e.runWebGLProgram(O,[w,N],w.dtype);v.push(k);const L=An({inputs:{x:k},backend:e,attrs:{shape:p.outputShape}});return v.forEach($=>e.disposeIntermediateTensorInfo($)),L}const JQ={kernelName:ss,backendName:"webgl",kernelFunc:oU},QQ=Iu({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:gY,dtype:"bool"}),eee={kernelName:fh,backendName:"webgl",kernelFunc:QQ},tee=Iu({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:yY}),nee={kernelName:$l,backendName:"webgl",kernelFunc:tee},iee={kernelName:Xo,backendName:"webgl",kernelFunc:function ree(n){const{inputs:t,backend:e}=n,{input:r}=t;return sU(r,!0,e)}},see=rs({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),aee={kernelName:Bl,backendName:"webgl",kernelFunc:see},oee=rs({opSnippet:"return float(isinf(x));",dtype:"bool"}),uee={kernelName:jc,backendName:"webgl",kernelFunc:oee},lee=rs({opSnippet:"return float(isnan(x));",dtype:"bool"}),cee={kernelName:Of,backendName:"webgl",kernelFunc:lee},fee=Iu({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:vY,dtype:"bool"}),hee={kernelName:pu,backendName:"webgl",kernelFunc:fee},pee=Iu({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:xY,dtype:"bool"}),dee={kernelName:as,backendName:"webgl",kernelFunc:pee},gee={kernelName:Jc,backendName:"webgl",kernelFunc:function mee(n){const{backend:t,attrs:e}=n,{start:r,stop:i,num:s}=e,a=bY(r,i,s);return t.makeTensorInfo([a.length],"float32",a)}},vee=rs({opSnippet:Py+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:wY}),xee={kernelName:Ta,backendName:"webgl",kernelFunc:vee},wee=rs({opSnippet:Py+"\n  return log(1.0 + x);\n"}),_ee={kernelName:kf,backendName:"webgl",kernelFunc:wee},Nee=Iu({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),See={kernelName:Fr,backendName:"webgl",kernelFunc:Nee},Eee=rs({opSnippet:"return float(!(x >= 1.0));"}),Iee={kernelName:xl,backendName:"webgl",kernelFunc:Eee},Cee=Iu({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),Aee={kernelName:Hi,backendName:"webgl",kernelFunc:Cee};class Tee{constructor(t,e,r,i,s){this.variableNames=["x"],this.outputShape=[];const a=e,o=t[3]-1;let l;this.outputShape=t;const p=`float(${r}) + float(${i}) * sum`;l=.5===s?`inversesqrt(${p})`:1===s?`1.0/(${p})`:`exp(log(${p}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${a}; j <= ${a}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${o}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${l};\n        setOutput(val);\n      }\n    `}}class Mee{constructor(t,e,r,i,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=e,o=t[3]-1;let l;this.outputShape=t;const p=`float(${r}) + float(${i}) * sum`;l=.5===s?`inversesqrt(${p})`:1===s?`1.0/(${p})`:`exp(log(${p}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${a};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${a}; j <= ${a}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${l};\n        setOutput(result);\n      }\n    `}}const Ree={kernelName:vc,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{depthRadius:s,bias:a,alpha:o,beta:l}=r,p=Pt().getBool("WEBGL_PACK_NORMALIZATION")?new Mee(i.shape,s,a,o,l):new Tee(i.shape,s,a,o,l);return e.runWebGLProgram(p,[i],i.dtype)}};class Dee{constructor(t,e,r,i,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=r,this.alpha=i,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${i}) * norm + float(${r});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${i})\n                * float(${s})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const Oee={kernelName:Qr,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:i,y:s,dy:a}=t,{depthRadius:o,bias:l,alpha:p,beta:g}=r,v=new Dee(i.shape,o,l,p,g);return e.runWebGLProgram(v,[i,s,a],i.dtype)}};function uU(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{reductionIndices:s,keepDims:a}=r,o=i.shape.length,l=ar(s,i.shape);let p=l;const g=na(p,o),v=null!=g,w=e.shouldExecuteOnCPU([i]);let N=i;if(v){if(w){const U=e.texData.get(N.dataId).values,V=new Array(o);for(let ve=0;ve<V.length;ve++)V[ve]=i.shape[g[ve]];const W=vF(U,i.shape,i.dtype,g,V);N=e.makeTensorInfo(V,i.dtype),e.texData.get(N.dataId).values=W}else N=UC(i,g,e);p=ka(p.length,o)}Vo("max",p,o);const[D,O]=ao(N.shape,p);let L,k=D;if(a&&(k=Oa(D,l)),w){const U=e.texData.get(N.dataId).values,V=_Y(U,ft(O),k,i.dtype);L=e.makeTensorInfo(k,i.dtype),e.texData.get(L.dataId).values=V}else L=function kee(n,t,e,r){const i=ft(t),o=An({inputs:{x:n},attrs:{shape:[ft(n.shape)/i,i]},backend:r}),l=ig(o,n.dtype,"max",r),p=An({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(l),p}(N,O,k,e);return v&&e.disposeIntermediateTensorInfo(N),L}const Pee={kernelName:Ps,backendName:"webgl",kernelFunc:uU},$ee=Iu({opSnippet:xF+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+rg+"\n  return result;\n",cpuKernelImpl:NY}),Bee={kernelName:Ko,backendName:"webgl",kernelFunc:$ee},Uee={kernelName:no,backendName:"webgl",kernelFunc:function zee(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t;Ty(i,"maxPool");const{filterSize:s,strides:a,pad:o,dimRoundingMode:l}=r;K(Uo(a,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`);const g=jl(i.shape,s,a,1,o,l);if(1===g.filterWidth&&1===g.filterHeight&&Kt(g.inShape,g.outShape))return hc({inputs:{x:i},backend:e});const v=new Fb(g,"max",!1);return e.runWebGLProgram(v,[i],i.dtype)}},Gee={kernelName:_r,backendName:"webgl",kernelFunc:function Vee(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{filterSize:s,strides:a,pad:o,dataFormat:l,dimRoundingMode:p}=r,v=pf(i.shape,s,a,[1,1,1],o,p,l),w=new wF(v,"max",!1);return e.runWebGLProgram(w,[i],i.dtype)}};class qee{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const s=t.effectiveFilterHeight,a=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${s-1-t.padInfo.top}, ${a-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${s*a-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${a} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Wee{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const l=t.effectiveFilterDepth,p=t.effectiveFilterHeight,g=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${l-1-t.padInfo.front}, ${p-1-t.padInfo.top}, ${g-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${l};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${p};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${g};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${l*p*g-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${p} * ${g} +\n                  wR * ${g} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Xee={kernelName:Cr,backendName:"webgl",kernelFunc:function Hee(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,input:s}=t,a=s,{filterSize:o,strides:l,pad:p,dimRoundingMode:g}=r,w=pf(a.shape,o,l,[1,1,1],p,g),N=new wF(w,"max",!0),D=e.runWebGLProgram(N,[a],a.dtype),O=new Wee(w),k=e.runWebGLProgram(O,[i,D],a.dtype);return e.disposeIntermediateTensorInfo(D),k}},Yee={kernelName:os,backendName:"webgl",kernelFunc:function Kee(n){const{inputs:t,backend:e,attrs:r}=n,{dy:i,input:s,output:a}=t,o=s;Ty([s,a],"maxPoolGrad");const{filterSize:l,strides:p,pad:g,dimRoundingMode:v}=r,w=jl(o.shape,l,p,1,g,v),D=new Fb(w,"max",!0),O=e.runWebGLProgram(D,[o],o.dtype),k=new qee(w),L=e.runWebGLProgram(k,[i,O],o.dtype);return e.disposeIntermediateTensorInfo(O),L}},jee={kernelName:Qc,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:i,strides:s,pad:a,includeBatchInIndex:o}=t,l=e;K(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const p=[1,1];K(Uo(s,p),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${p}'`);const g=jl(r.shape,i,s,p,a),[v,w]=function Zee(n,t,e,r){let i=new Fb(e,"max",!1);const s=r.runWebGLProgram(i,[n],"float32");return i=new Fb(e,"max",!0,!0,t),[s,r.runWebGLProgram(i,[n],"float32")]}(r,o,g,l);return[v,w]}},Qee={kernelName:Oo,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{keepDims:i,axis:s}=t,a=e,o=r.shape.length,l=ar(s,r.shape);let p=l;const g=na(p,o),v=null!=g,w=a.shouldExecuteOnCPU([r]),N=[];let D=r;if(v){if(w){const V=a.texData.get(D.dataId).values,W=new Array(o);for(let Ee=0;Ee<W.length;Ee++)W[Ee]=r.shape[g[Ee]];const ce=vF(V,r.shape,r.dtype,g,W);D=a.makeTensorInfo(W,r.dtype),a.texData.get(D.dataId).values=ce}else D=UC(r,g,a);N.push(D),p=ka(p.length,o)}Vo("sum",p,o);const[O,k]=ao(D.shape,p);let L=O;i&&(L=Oa(O,l));const $=function Jee(n,t,e,r){const i=ft(t),o=An({inputs:{x:n},attrs:{shape:[ft(n.shape)/i,i]},backend:r}),l=ig(o,"float32","mean",r),p=An({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(l),p}(D,k,L,a);for(const U of N)a.disposeIntermediateTensorInfo(U);return $}},tte={kernelName:js,backendName:"webgl",kernelFunc:function ete(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:s,keepDims:a}=r,o=i.shape.length,l=ar(s,i.shape);let p=l;const g=na(p,o);let v=i;null!=g&&(v=pl({inputs:{x:i},backend:e,attrs:{perm:g}}),p=ka(p.length,i.shape.length)),Vo("min",p,o);const[w,N]=ao(v.shape,p),O=An({inputs:{x:v},backend:e,attrs:{shape:[-1,ft(N)]}}),k=ig(O,O.dtype,"min",e);let L;return L=An(a?{inputs:{x:k},backend:e,attrs:{shape:Oa(w,l)}}:{inputs:{x:k},backend:e,attrs:{shape:w}}),e.disposeIntermediateTensorInfo(O),e.disposeIntermediateTensorInfo(k),null!=g&&e.disposeIntermediateTensorInfo(v),L}},ite=Iu({opSnippet:xF+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+rg+"\n  return result;\n",cpuKernelImpl:SY}),ste={kernelName:Yo,backendName:"webgl",kernelFunc:ite};class ate{constructor(t,e,r){this.variableNames=["x"],this.outputShape=e.map((g,v)=>g[0]+t[v]+g[1]);const i=t.length,s=Bs(i),a=e.map(g=>g[0]).join(","),o=e.map((g,v)=>g[0]+t[v]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i),p="reflect"===r?0:1;this.userCode=1!==i?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${o});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        for (int i = 0; i < ${i}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${p};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${p};\n          }\n        }\n        ${s} coords = outC - start;\n        setOutput(getX(${l}));\n      }\n    `:`\n        int start = ${a};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${p};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${p};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class ote{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((D,O)=>D[0]+t[O]+D[1]);const i=t.length,s=Bs(i),a=e.map(D=>D[0]).join(","),o=e.map((D,O)=>D[0]+t[O]).join(","),l=hl("rc",i),p=hl("source",i),g=`${l[i-1]} < ${this.outputShape[i-1]}`,v=1===i?"source":`vec2(${p.slice(-2).join()})`,w="reflect"===r?0:1;let N="";if(1===i){const D=`\n        ${s} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${w};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${w};\n        }\n        source -= start;\n      `;N=`\n        ${s} rc = outputLoc;\n        ${D}\n        result[0] = getChannel(getX(${p.join()}), ${v});\n        ${l[i-1]} += 1;\n        if(${g}) {\n          ${D}\n          result[1] = getChannel(getX(${p.join()}), ${v});\n        }\n      `}else{const D=`\n        ${s} source = rc;\n        ${s} lt = ${s}(lessThan(source, start));\n        ${s} gte = ${s}(greaterThanEqual(source, end));\n        ${s} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${w}) +\n                gte * ((end - 1) * 2 - source + ${w});\n        source -= start;\n      `;N=`\n        ${s} rc = outputLoc;\n        ${D}\n        result[0] = getChannel(getX(${p.join()}), ${v});\n        ${l[i-1]} += 1;\n        if(${g}) {\n          ${D}\n          result[1] = getChannel(getX(${p.join()}), ${v});\n        }\n        rc = outputLoc;\n        ${l[i-2]} += 1;\n        if(${l[i-2]} < ${this.outputShape[i-2]}) {\n          ${D}\n          result[2] = getChannel(getX(${p.join()}), ${v});\n          ${l[i-1]} += 1;\n          if(${g}) {\n            ${D}\n            result[3] = getChannel(getX(${p.join()}), ${v});\n          }\n        }\n      `}this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${o});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${N}\n        setOutput(result);\n      }\n    `}}const ute={kernelName:Js,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r}=n,{paddings:i,mode:s}=e,a=Pt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ote(r.shape,i,s):new ate(r.shape,i,s);return t.runWebGLProgram(a,[r],r.dtype)}},fte=Iu({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+rg+"\n  return result;\n"}),hte={kernelName:fo,backendName:"webgl",kernelFunc:fte};class pte{constructor(t,e,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,r],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const lU=Iu({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),dte={kernelName:Rf,backendName:"webgl",kernelFunc:lU},cU="return a - b;",fU=Iu({opSnippet:cU,packedOpSnippet:cU,supportsComplex:!0,cpuKernelImpl:WY}),mte={kernelName:il,backendName:"webgl",kernelFunc:fU};function hU(n){const{inputs:t,backend:e,attrs:r}=n,{logits:i}=t,{dim:s}=r,a=ar([s],i.shape),o=uU({inputs:{x:i},backend:e,attrs:{reductionIndices:a,keepDims:!1}}),l=Oa(o.shape,a),p=An({inputs:{x:o},backend:e,attrs:{shape:l}}),g=fU({inputs:{a:i,b:p},backend:e}),v=nU({inputs:{x:g},backend:e}),w=VC({inputs:{x:v},backend:e,attrs:{axis:a,keepDims:!1}}),N=An({inputs:{x:w},backend:e,attrs:{shape:l}}),D=lU({inputs:{a:v,b:N},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(N),D}const gte={kernelName:za,backendName:"webgl",kernelFunc:hU},vte={kernelName:Zo,backendName:"webgl",kernelFunc:function yte(n){const{inputs:t,backend:e,attrs:r}=n,{logits:i}=t,{numSamples:s,seed:a,normalized:o}=r,l=o?i:hU({inputs:{logits:i},backend:e,attrs:{dim:i.shape.length-1}}),v=new pte(l.shape[0],l.shape[1],s),N=e.runWebGLProgram(v,[l],"int32",[[a]]);return o||e.disposeIntermediateTensorInfo(l),N}},xte=Uc+"\n  return -x;\n",_te={kernelName:mu,backendName:"webgl",kernelFunc:function wte(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])){const s=e.texData.get(r.dataId),[a,o]=IY(s.values,r.shape,r.dtype);return e.makeTensorInfo(o,r.dtype,a)}let i;return i=Pt().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Rd(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new Uh(r.shape,xte),e.runWebGLProgram(i,[r],r.dtype)}},Nte=A0,Ete={kernelName:Kh,backendName:"webgl",kernelFunc:function Ste(n){eu("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:i,scores:s}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=r,p=e.readSync(i.dataId),g=e.readSync(s.dataId),{selectedIndices:v}=Nte(p,g,a,o,l);return e.makeTensorInfo([v.length],"int32",new Int32Array(v))}},Ite=Em,Ate={kernelName:Pf,backendName:"webgl",kernelFunc:function Cte(n){eu("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:i,scores:s}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:p}=r,g=e.readSync(i.dataId),v=e.readSync(s.dataId),{selectedIndices:w,validOutputs:N}=Ite(g,v,a,o,l,p);return[e.makeTensorInfo([w.length],"int32",new Int32Array(w)),e.makeTensorInfo([],"int32",new Int32Array([N]))]}},Tte=T0,Rte={kernelName:xa,backendName:"webgl",kernelFunc:function Mte(n){eu("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:i,scores:s}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:p}=r,g=e.readSync(i.dataId),v=e.readSync(s.dataId),w=a,N=o,D=l,O=p,{selectedIndices:k,selectedScores:L}=Tte(g,v,w,N,D,O);return[e.makeTensorInfo([k.length],"int32",new Int32Array(k)),e.makeTensorInfo([L.length],"float32",new Float32Array(L))]}};class Dte{constructor(t,e,r,i){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${i}), float(${r}),\n                      float(index == coords.y)));\n      }\n    `}}const Ote={kernelName:ko,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{indices:i}=t,{dtype:s,depth:a,onValue:o,offValue:l}=r,p=ft(i.shape),g=new Dte(p,a,o,l),v=An({inputs:{x:i},backend:e,attrs:{shape:[p]}}),w=e.runWebGLProgram(g,[v],s);e.disposeIntermediateTensorInfo(v);const D=An({inputs:{x:w},backend:e,attrs:{shape:[...i.shape,a]}});return e.disposeIntermediateTensorInfo(w),D}};function KC(n){const{inputs:t,backend:e}=n,{x:r}=t;if("complex64"===r.dtype){const i=Lb({inputs:{input:r},backend:e}),s=KC({inputs:{x:i},backend:e}),a=HC({inputs:{input:r},backend:e}),o=KC({inputs:{x:a},backend:e}),l=Dd({inputs:{real:s,imag:o},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(o),l}return Bb({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:e})}const kte={kernelName:mh,backendName:"webgl",kernelFunc:KC},Pte={kernelName:Du,backendName:"webgl",kernelFunc:function pU(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const i=Lb({inputs:{input:r},backend:e}),s=pU({inputs:{x:i},backend:e}),a=HC({inputs:{input:r},backend:e}),o=KC({inputs:{x:a},backend:e}),l=Dd({inputs:{real:s,imag:o},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(o),l}return Bb({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:e})}},Lte={kernelName:hh,backendName:"webgl",kernelFunc:function Fte(n){const{inputs:t,backend:e,attrs:r}=n,{axis:i}=r;if(1===t.length)return SF({inputs:{input:t[0]},backend:e,attrs:{dim:i}});const s=t[0].shape,a=t[0].dtype;t.forEach(g=>{xt(s,g.shape,"All tensors passed to stack must have matching shapes"),K(a===g.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],p=Wz({inputs:t.map(g=>{const v=SF({inputs:{input:g},backend:e,attrs:{dim:i}});return o.push(v),v}),backend:e,attrs:{axis:i}});return o.forEach(g=>e.disposeIntermediateTensorInfo(g)),p}};class $te{constructor(t,e,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((p,g)=>p[0]+t[g]+p[1]);const i=t.length,s=Bs(i),a=e.map(p=>p[0]).join(","),o=e.map((p,g)=>p[0]+t[g]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i);this.userCode=1!==i?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${o});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${l}));\n        }\n      }\n    `:`\n        int start = ${a};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class Bte{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((O,k)=>O[0]+t[k]+O[1]);const i=t.length,s=Bs(i),a=e.map(O=>O[0]).join(","),o=e.map((O,k)=>O[0]+t[k]).join(","),l=hl("rc",i),p=hl("source",i),g=`${l[i-1]} < ${this.outputShape[i-1]}`,v=1===i?"source":`vec2(${p.slice(-2).join()})`,w=[`${s} rc = outputLoc;`,`${l[i-1]} += 1;\n       if(${g}) {\n      `,1===i?"":`}\n       rc = outputLoc;\n       ${l[i-2]} += 1;\n       if(${l[i-2]} < ${this.outputShape[i-2]}) {`,1===i?"":`  ${l[i-1]} += 1;\n         if(${g}) {`],N=1===i?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let D="";for(let O=0,k=1===i?2:4;O<k;O++)D+=`\n        ${w[O]}\n        if (${N}) {\n          result[${O}] = float(value);\n        } else {\n          ${s} source = rc - start;\n          result[${O}] = getChannel(getX(${p.join()}), ${v});\n        }\n      `;D+=1===i?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${o});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${D}\n        setOutput(result);\n      }\n    `}}const dU=n=>{const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{paddings:s,constantValue:a}=r;if(0===ft(i.shape))return Bb({backend:e,attrs:{shape:s.map((g,v)=>g[0]+i.shape[v]+g[1]),value:a,dtype:i.dtype}});const o=Pt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Bte(i.shape,s,a):new $te(i.shape,s,a);return e.runWebGLProgram(o,[i],i.dtype,[[a]])},zte={kernelName:ba,backendName:"webgl",kernelFunc:dU},Gte=Iu({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+rg+"\n  return result;\n"}),qte={kernelName:zl,backendName:"webgl",kernelFunc:Gte},Hte={kernelName:ph,backendName:"webgl",kernelFunc:function Wte(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{axis:s,keepDims:a}=r,o=i.shape.length,l=[],p=ar(s,i.shape);let g=p;const v=na(g,o);let N,w=i;if(null!=v&&(w=pl({inputs:{x:i},backend:e,attrs:{perm:v}}),g=ka(g.length,o),l.push(w)),Vo("prod",g,o),e.shouldExecuteOnCPU([w])){const D=e.texData.get(w.dataId).values,{outVals:O,outShape:k,outDtype:L}=AY(w.shape,w.dtype,D,g);N=e.makeTensorInfo(k,L,O)}else{const[D,O]=ao(w.shape,g),k=ft(O),L=An({inputs:{x:w},backend:e,attrs:{shape:[-1,k]}}),U=ig(L,bg(i.dtype),"prod",e);N=An({inputs:{x:U},backend:e,attrs:{shape:D}}),l.push(L),l.push(U)}if(a){l.push(N);const D=Oa(N.shape,p);N=An({inputs:{x:N},backend:e,attrs:{shape:D}})}return l.forEach(D=>e.disposeIntermediateTensorInfo(D)),N}},Kte={kernelName:Yh,backendName:"webgl",kernelFunc:function Xte(n){const{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:i,paramsDenseValues:s,indices:a}=t,{outputRaggedRank:o}=r,l=i.map(L=>e.readSync(L.dataId)),p=i.map(L=>L.shape),g=e.readSync(s.dataId),v=e.readSync(a.dataId),[w,N,D]=TY(l,p,g,s.shape,s.dtype,v,a.shape,o),O=w.map(L=>e.makeTensorInfo([L.length],"int32",L)),k=e.makeTensorInfo(D,s.dtype,N);return O.concat([k])}},Zte={kernelName:Vl,backendName:"webgl",kernelFunc:function Yte(n){const{inputs:t,backend:e}=n,{starts:r,limits:i,deltas:s}=t,a=e.readSync(r.dataId),o=e.readSync(i.dataId),l=e.readSync(s.dataId),[p,g]=MY(a,r.shape,r.dtype,o,i.shape,l,s.shape);return[e.makeTensorInfo([p.length],"int32",p),e.makeTensorInfo([g.length],r.dtype,g)]}},Jte={kernelName:jo,backendName:"webgl",kernelFunc:function jte(n){const{inputs:t,backend:e,attrs:r}=n,{shape:i,values:s,defaultValue:a,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,p=e.readSync(i.dataId),g=e.readSync(s.dataId),v=e.readSync(a.dataId),w=o.map(k=>e.readSync(k.dataId)),N=o.map(k=>k.shape),[D,O]=RY(p,i.shape,g,s.shape,s.dtype,v,a.shape,w,N,l);return e.makeTensorInfo(D,s.dtype,O)}},mU=n=>{const{backend:t,attrs:e}=n,{start:r,stop:i,step:s,dtype:a}=e,o=DY(r,i,s,a);return t.makeTensorInfo([o.length],a,o)},Qte={kernelName:Qs,backendName:"webgl",kernelFunc:mU},ene=rs({opSnippet:"return 1.0 / x;"}),tne={kernelName:ea,backendName:"webgl",kernelFunc:ene},rne=rs({opSnippet:Uc+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),ine={kernelName:Po,backendName:"webgl",kernelFunc:rne},ane=rs({opSnippet:Uc+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),one={kernelName:Ss,backendName:"webgl",kernelFunc:ane};class une{constructor(t,e,r,i,s){this.variableNames=["A"],this.outputShape=[];const[a,o,l,p]=t;this.outputShape=[a,e,r,p];const g=[i&&e>1?o-1:o,i&&r>1?l-1:l],v=[i&&e>1?e-1:e,i&&r>1?r-1:r];let w;w=s?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${g[0]/v[0]},\n          ${g[1]/v[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${w};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class lne{constructor(t,e,r,i,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,o,l,p]=t;this.outputShape=[a,e,r,p];const g=[i&&e>1?o-1:o,i&&r>1?l-1:l],v=[i&&e>1?e-1:e,i&&r>1?r-1:r];let w;w=s?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${g[0]/v[0]},\n          ${g[1]/v[1]},\n          ${g[1]/v[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${w};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${p-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const fne={kernelName:ir,backendName:"webgl",kernelFunc:function cne(n){const{inputs:t,backend:e,attrs:r}=n,{images:i}=t,{alignCorners:s,halfPixelCenters:a,size:o}=r,[l,p]=o,g=Pt().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new lne(i.shape,l,p,s,a):new une(i.shape,l,p,s,a);return e.runWebGLProgram(g,[i],"float32")}};class hne{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,i,s]=e,[,a,o]=t,l=[r&&a>1?i-1:i,r&&o>1?s-1:s],p=[r&&a>1?a-1:a,r&&o>1?o-1:o],g=l[0]/p[0],v=l[1]/p[1],w=1/g,N=1/v,D=2*Math.ceil(w)+2,O=2*Math.ceil(N)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${g});\n        const float widthScale = float(${v});\n\n        const float invHeightScale = float(${w});\n        const float invWidthScale = float(${N});\n\n        const int winHeight = int(${D});\n        const int winWidth = int(${O});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${i-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const dne={kernelName:Ou,backendName:"webgl",kernelFunc:function pne(n){const{inputs:t,backend:e,attrs:r}=n,{images:i,dy:s}=t,{alignCorners:a}=r,o=new hne(s.shape,i.shape,a);return e.runWebGLProgram(o,[s],s.dtype)}};class mne{constructor(t,e,r,i,s){this.variableNames=["A"],this.outputShape=[];const[a,o,l,p]=t;this.outputShape=[a,e,r,p];const g=[i&&e>1?o-1:o,i&&r>1?l-1:l],v=[i&&e>1?e-1:e,i&&r>1?r-1:r];let N;N=s?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${g[0]/v[0]},\n          ${g[1]/v[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${N};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${i?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class gne{constructor(t,e,r,i,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,o,l,p]=t;this.outputShape=[a,e,r,p];const g=[i&&e>1?o-1:o,i&&r>1?l-1:l],v=[i&&e>1?e-1:e,i&&r>1?r-1:r];let N;N=s?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${g[0]/v[0]},\n          ${g[1]/v[1]},\n          ${g[1]/v[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${N};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${i?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${p-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const vne={kernelName:ef,backendName:"webgl",kernelFunc:function yne(n){const{inputs:t,backend:e,attrs:r}=n,{images:i}=t,{alignCorners:s,halfPixelCenters:a,size:o}=r,[l,p]=o,g=Pt().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new gne(i.shape,l,p,s,a):new mne(i.shape,l,p,s,a);return e.runWebGLProgram(g,[i],i.dtype)}};class xne{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,i,s]=e,[,a,o]=t,l=[r&&a>1?i-1:i,r&&o>1?s-1:s],p=[r&&a>1?a-1:a,r&&o>1?o-1:o],g=l[0]/p[0],v=l[1]/p[1],w=1/g,N=1/v,D=2*Math.ceil(w)+2,O=2*Math.ceil(N)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${g});\n        const float widthScale = float(${v});\n\n        const float invHeightScale = float(${w});\n        const float invWidthScale = float(${N});\n\n        const int winHeight = int(${D});\n        const int winWidth = int(${O});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${l[0]}) *\n                (float(dyR) / float(${p[0]}));\n\n            float sourceFracCol =\n                float(${l[1]}) *\n                  (float(dyC) / float(${p[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${i}) - 1),\n                ${r} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${r} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const wne={kernelName:es,backendName:"webgl",kernelFunc:function bne(n){const{inputs:t,backend:e,attrs:r}=n,{images:i,dy:s}=t,{alignCorners:a}=r,o=new xne(s.shape,i.shape,a);return e.runWebGLProgram(o,[s],s.dtype)}};class _ne{constructor(t,e){this.variableNames=["x"];const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=t,1===r)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const s=t.map((o,l)=>(o=>-1!==e.indexOf(o)&&1!==t[o]?`${t[o]} - coords[${o}] - 1`:`coords[${o}]`)(l)).join(","),a=Bs(r);this.userCode=`\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${s}));\n      }\n    `}}class Nne{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=t;const i=hl("rc",r),s=`${i[r-1]} + 1 < ${this.outputShape[r-1]}`,a=`${i[r-2]} + 1 < ${this.outputShape[r-2]}`,o=Bs(r);function w(D){const O=t.map(($,U)=>function N(D,O){return-1!==e.indexOf(D)&&1!==t[D]?`${t[D]} - ${O[D]} - 1`:`${O[D]}`}(U,D));return`getChannel(getX(${O.join(",")}), vec2(${O.slice(-2).join(",")}))`}this.userCode=1===r?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${o} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function l(D){return w(D)}(i.slice())};\n          if(${s}){\n            result.g = ${function p(D){return D[r-1]="("+D[r-1]+" + 1)",w(D)}(i.slice())};\n          }\n          if(${a}) {\n            result.b = ${function g(D){return D[r-2]="("+D[r-2]+" + 1)",w(D)}(i.slice())};\n            if(${s}) {\n              result.a = ${function v(D){return D[r-1]="("+D[r-1]+" + 1)",D[r-2]="("+D[r-2]+" + 1)",w(D)}(i.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const Ene={kernelName:ho,backendName:"webgl",kernelFunc:function Sne(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{dims:s}=r,a=i.shape.length,o=ar(s,i.shape);if(0===a)return hc({inputs:{x:i},backend:e});const l=Pt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Nne(i.shape,o):new _ne(i.shape,o);return e.runWebGLProgram(l,[i],i.dtype)}};class Ine{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=t[1],i=t[2];this.outputShape=t;let s="";s="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${s}\n          if(coordX >= 0 && coordX < ${i} && coordY >= 0 && coordY < ${r}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Cne={kernelName:Op,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:i,fillValue:s,center:a}=t,o=e,l=new Ine(r.shape,s),[p,g]=J1(a,r.shape[1],r.shape[2]),v=[[p,g,Math.sin(i),Math.cos(i)]];return o.runWebGLProgram(l,[r],r.dtype,v)}},Ane=rs({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),Tne={kernelName:Ms,backendName:"webgl",kernelFunc:Ane},Mne=rs({opSnippet:"return inversesqrt(x);",cpuKernelImpl:OY}),Rne={kernelName:dh,backendName:"webgl",kernelFunc:Mne};class IF{constructor(t,e,r,i,s,a,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const p=Bs(s.length),g=Bs(a.length);let v="";1===r?v="i":2===r&&(v="i, j");let N="";1===i?N="i":2===i&&(N="i, coords[1]");let O="";l&&(O="coords[0], coords[1]"),this.userCode=`\n        ${p} strides = ${p}(${s});\n\n        void main() {\n          ${g} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${v}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${N});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(${O}), sum, float(found)));\n        }\n      `}}class Dne{constructor(t,e,r,i,s,a,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const p=Bs(s.length),g=Bs(a.length);let v="";1===r?v="i":2===r&&(v="i, j");let N="";1===i?N="i":2===i&&(N="i, coords[1]");let O="";l&&(O="coords[0], coords[1]"),this.userCode=`\n        ${p} strides = ${p}(${s});\n\n        void main() {\n          ${g} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${t}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${e}; j+=2) {\n              ivec4 index = round(getIndices(${v}));\n              flattenedIndex += index.xz * ${e>1?"strides[j]":"strides"};\n              if (j + 1 < ${e}) {\n                flattenedIndex += index.yw * ${e>1?"strides[j + 1]":"strides"};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = getUpdates(${N});\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(getDefaultValue(${O}), sum, found));\n        }\n      `}}const kne={kernelName:ku,backendName:"webgl",kernelFunc:function One(n){const{inputs:t,backend:e,attrs:r}=n,{indices:i,updates:s}=t,{shape:a}=r,{sliceRank:o,numUpdates:l,sliceSize:p,strides:g,outputSize:v}=Wf(0,i,a),w=[v/p,p];if(0===v)return e.makeTensorInfo(a,i.dtype);const N=An({inputs:{x:i},backend:e,attrs:{shape:[l,o]}}),D=An({inputs:{x:s},backend:e,attrs:{shape:[l,p]}}),O=e.makeTensorInfo([],"float32",new Float32Array([0]));let k;k=Pt().getBool("WEBGL_PACK")?new Dne(l,o,N.shape.length,D.shape.length,g,w):new IF(l,o,N.shape.length,D.shape.length,g,w);const L=e.runWebGLProgram(k,[D,N,O],D.dtype),$=An({inputs:{x:L},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(D),e.disposeIntermediateTensorInfo(L),e.disposeIntermediateTensorInfo(O),$}};class Pne{constructor(t,e,r,i){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,r];const a=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,o=2===Pt().getNumber("WEBGL_VERSION")?"while (left < right) {":a;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${o}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===i?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const Lne={kernelName:ca,backendName:"webgl",kernelFunc:function Fne(n){const{inputs:t,backend:e,attrs:r}=n,{sortedSequence:i,values:s}=t,{side:a}=r,o=new Pne(i.shape[0],i.shape[1],s.shape[1],a);return e.runWebGLProgram(o,[i,s],"int32",[[i.shape[1]]])}};class $ne{constructor(t,e,r){let i,s;if(this.variableNames=["c","a","b"],this.outputShape=e,r>4)throw Error(`Where for rank ${r} is not yet supported`);if(1===r)s="resRC",i="resRC";else{const o=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],p=[];for(let g=0;g<e.length;g++)p.push(`${o[g]}`),g<t&&l.push(`${o[g]}`);i=l.join(),s=p.join()}const a=Bs(r);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${i});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}const zne={kernelName:ta,backendName:"webgl",kernelFunc:function Bne(n){const{inputs:t,backend:e}=n,{condition:r,t:i,e:s}=t,a=new $ne(r.shape.length,i.shape,i.shape.length);return e.runWebGLProgram(a,[r,i,s],$u(i.dtype,s.dtype))}},Vne=rs({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${O0};\n  float scale = ${k0};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),Gne={kernelName:Pr,backendName:"webgl",kernelFunc:Vne},Wne=rs({opSnippet:Py+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:PY}),Hne={kernelName:wa,backendName:"webgl",kernelFunc:Wne},Xne=rs({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),Kne={kernelName:Fu,backendName:"webgl",kernelFunc:Xne},jne=rs({opSnippet:Py+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${rg}\n  return result;\n`}),Jne={kernelName:wc,backendName:"webgl",kernelFunc:jne},Qne=rs({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),ere={kernelName:Pu,backendName:"webgl",kernelFunc:Qne},tre=rs({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),nre={kernelName:Ff,backendName:"webgl",kernelFunc:tre},rre={kernelName:Fo,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{blockShape:s,paddings:a}=r;K(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=s.reduce((L,$)=>L*$),l=[[0,0]];l.push(...a);for(let L=1+s.length;L<i.shape.length;++L)l.push([0,0]);const p=[],g=dU({inputs:{x:i},backend:e,attrs:{paddings:l,constantValue:0}}),v=Cm(g.shape,s,o,!1),w=pd(v.length,s.length,!1),N=Am(g.shape,s,o,!1),D=An({inputs:{x:g},backend:e,attrs:{shape:v}}),O=pl({inputs:{x:D},backend:e,attrs:{perm:w}}),k=An({inputs:{x:O},backend:e,attrs:{shape:N}});return p.push(g),p.push(D),p.push(O),p.forEach(L=>e.disposeIntermediateTensorInfo(L)),k}},sre={kernelName:wl,backendName:"webgl",kernelFunc:function ire(n){const{inputs:t,backend:e}=n,{indices:r,values:i,denseShape:s,defaultValue:a}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==i.shape.length)throw new Error(`Values must be a vector, saw:\n         ${i.shape}`);if(0!==a.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${a.shape}`);const o=e.readSync(r.dataId),l=e.readSync(i.dataId),p=e.readSync(s.dataId),g=e.readSync(a.dataId)[0],[v,w,N,D,O]=LY(o,r.shape,r.dtype,l,i.dtype,p,g);return[e.makeTensorInfo(w,r.dtype,v),e.makeTensorInfo([w[0]],i.dtype,N),e.makeTensorInfo([D.length],"bool",new Uint8Array(D.map(k=>Number(k)))),e.makeTensorInfo([O.length],r.dtype,new Int32Array(O))]}},ore={kernelName:Gl,backendName:"webgl",kernelFunc:function are(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:i,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==i.shape.length)throw new Error(`Input shape should be a vector but received shape ${i.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const a=Array.from(e.readSync(i.dataId)),o=e.readSync(r.dataId),l=Array.from(e.readSync(s.dataId)),[p,g,v]=$Y(o,r.shape,r.dtype,a,l);return[e.makeTensorInfo(g,r.dtype,p),e.makeTensorInfo([v.length],s.dtype,new Int32Array(v))]}},lre={kernelName:Jo,backendName:"webgl",kernelFunc:function ure(n){const{inputs:t,backend:e}=n,{data:r,indices:i,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${i.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);const a=e.readSync(r.dataId),o=e.readSync(i.dataId),l=e.readSync(s.dataId),[p,g]=yz(a,r.shape,r.dtype,o,l,!0);return e.makeTensorInfo(g,r.dtype,p)}},fre={kernelName:ql,backendName:"webgl",kernelFunc:function cre(n){const{inputs:t,backend:e}=n,{data:r,indices:i,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${i.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);const a=e.readSync(r.dataId),o=e.readSync(i.dataId),l=e.readSync(s.dataId),[p,g]=yz(a,r.shape,r.dtype,o,l);return e.makeTensorInfo(g,r.dtype,p)}},pre={kernelName:Ma,backendName:"webgl",kernelFunc:function hre(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:i,sparseValues:s,defaultValue:a}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:p,sliceSize:g,strides:v,outputSize:w}=Wf(0,i,o);if("string"===s.dtype){const L=e.bufferSync(i),$=e.bufferSync(s),U=Va(e.readSync(a.dataId)[0]),V=kY(L,$,o,w,g,p,l,v,U,!1);return e.makeTensorInfo(o,V.dtype,V.values)}const D=new IF(p,l,i.shape.length,s.shape.length,v,[w,1],!1),O=e.runWebGLProgram(D,[s,i,a],s.dtype),k=An({inputs:{x:O},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(O),k}},mre={kernelName:Ws,backendName:"webgl",kernelFunc:function dre(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{numOrSizeSplits:s,axis:a}=r,o=ar(a,i.shape)[0],l=cx(i,s,o),g=new Array(i.shape.length).fill(0),v=i.shape.slice();return l.map(w=>{const N=[...v];N[o]=w;const D=Fy({inputs:{x:i},backend:e,attrs:{begin:g,size:N}});return g[o]+=w,D})}},gU="return sqrt(x);",gre=rs({opSnippet:gU,packedOpSnippet:gU,cpuKernelImpl:BY}),yre={kernelName:Rs,backendName:"webgl",kernelFunc:gre},vre=rs({opSnippet:"return x * x;"}),xre={kernelName:Zr,backendName:"webgl",kernelFunc:vre},yU="return (a - b) * (a - b);",bre=Iu({opSnippet:yU,packedOpSnippet:yU}),wre={kernelName:Lo,backendName:"webgl",kernelFunc:bre},Nre={kernelName:Qn,backendName:"webgl",kernelFunc:function _re(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");const a=mf(e.readSync(i.dataId)),o=zY(a,"string",r);return e.makeTensorInfo(i.shape,"string",o)}},Ere={kernelName:Hl,backendName:"webgl",kernelFunc:function Sre({inputs:n,attrs:t,backend:e}){const{x:r}=n,s=new Uh(r.shape,Uc+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return e.runWebGLProgram(s,[r],r.dtype)}};class Ire{constructor(t,e,r){this.variableNames=["x"],this.outputShape=r;const i=r.length,s=Bs(r.length),a=Bs(r.length);let o="";if(1===i)o="coords * strides + begin";else{let l=0;o=r.map((p,g)=>(l++,1===r.length?`coords * strides[${g}] + begin[${g}]`:`coords[${l-1}] * strides[${g}] + begin[${g}]`)).join(",")}this.userCode=`\n      ${s} begin = ${s}(${t});\n      ${s} strides = ${s}(${e});\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}const Are={kernelName:nl,backendName:"webgl",kernelFunc:function Cre(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{begin:s,end:a,strides:o,beginMask:l,endMask:p,ellipsisMask:g,newAxisMask:v,shrinkAxisMask:w}=r,{finalShapeSparse:N,finalShape:D,isIdentity:O,sliceDim0:k,isSimpleSlice:L,begin:$,end:U,strides:V}=Dv(i.shape,s,a,o,l,p,g,v,w);let W;if(O)W=An({inputs:{x:i},backend:e,attrs:{shape:D}});else if(k||L){K(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const ve=Av($,U,V),Ee=Fy({inputs:{x:i},backend:e,attrs:{begin:$,size:ve}});W=An({inputs:{x:Ee},backend:e,attrs:{shape:D}}),e.disposeIntermediateTensorInfo(Ee)}else if(e.shouldExecuteOnCPU([i])){const Ee=e.readSync(i.dataId),ge=zr(i.shape,i.dtype,Ee),it=UY(N,ge,V,$);W=e.makeTensorInfo(D,i.dtype,it.values)}else{const Ee=new Ire($,V,N);W=e.runWebGLProgram(Ee,[i],i.dtype)}const ce=An({inputs:{x:W},backend:e,attrs:{shape:D}});return e.disposeIntermediateTensorInfo(W),ce}},Mre={kernelName:_a,backendName:"webgl",kernelFunc:function Tre(n){const{inputs:t,backend:e,attrs:r}=n,{separator:i,nGramWidths:s,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:p}=r,{data:g,dataSplits:v}=t,w=e.readSync(g.dataId),N=e.readSync(v.dataId),[D,O]=VY(w,N,i,s,a,o,l,p);return[e.makeTensorInfo([D.length],"string",D),e.makeTensorInfo(v.shape,"int32",O)]}},Dre={kernelName:rl,backendName:"webgl",kernelFunc:function Rre(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:i}=r,{input:s,delimiter:a}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==a.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=e.readSync(s.dataId),l=e.readSync(a.dataId)[0],[p,g,v]=GY(o,l,i),w=g.length;return[e.makeTensorInfo([w,2],"int32",p),e.makeTensorInfo([w],"string",g),e.makeTensorInfo([2],"int32",new Int32Array(v))]}},kre={kernelName:Lf,backendName:"webgl",kernelFunc:function Ore(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:i}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const a=e.readSync(s.dataId),o=qY(a,i);return e.makeTensorInfo(s.shape,"int32",o)}},Pre=rs({opSnippet:"return tan(x);"}),Fre={kernelName:gu,backendName:"webgl",kernelFunc:Pre},Lre=rs({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),$re={kernelName:vs,backendName:"webgl",kernelFunc:Lre},zre={kernelName:bc,backendName:"webgl",kernelFunc:function Bre(n){const{inputs:t,backend:e}=n,{tensor:i,indices:s,updates:a}=t,{sliceRank:o,numUpdates:l,sliceSize:p,strides:g,outputSize:v}=Wf(0,s,i.shape),w=[v/p,p];if(0===v)return e.makeTensorInfo(i.shape,s.dtype);const N=An({inputs:{x:s},backend:e,attrs:{shape:[l,o]}}),D=An({inputs:{x:a},backend:e,attrs:{shape:[l,p]}}),O=An({inputs:{x:i},backend:e,attrs:{shape:w}}),k=new IF(l,o,N.shape.length,D.shape.length,g,w,!1,!0),L=e.runWebGLProgram(k,[D,N,O],O.dtype),$=An({inputs:{x:L},backend:e,attrs:{shape:i.shape}});return e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(D),e.disposeIntermediateTensorInfo(O),e.disposeIntermediateTensorInfo(L),$}};class Ure{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let a=0;a<r.length;a++)r[a]=t[a]*e[a];this.outputShape=r,this.rank=r.length;const i=Bs(this.rank),s=function Vre(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let i=0;i<n.length;i++)r.push(`imod(${e[i]}, ${n[i]})`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}function vU(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{reps:s}=r;if("string"===i.dtype||i.shape.length>5){const l=e.readSync(i.dataId),p="string"===i.dtype?l.map(w=>Va(w)):l,g=zr(i.shape,i.dtype,p),v=HY(g,s);return e.makeTensorInfo(v.shape,v.dtype,v.values)}const a=new Ure(i.shape,s);return e.runWebGLProgram(a,[i],i.dtype)}const Gre={kernelName:ps,backendName:"webgl",kernelFunc:vU};class qre{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class Wre{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function sg(n,t){null!==t&&n.disposeIntermediateTensorInfo(t)}function xU(n){let t=1;for(;t<n;)t*=2;return t}const Xre={kernelName:_l,backendName:"webgl",kernelFunc:function Hre(n){const{inputs:t,backend:e,attrs:r}=n,{x:i}=t,{k:s,sorted:a}=r,o=Pt().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Pt().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),p=i.shape,g=p[p.length-1];if(e.shouldExecuteOnCPU([i])||g<o||s>l){const it=e.readSync(i.dataId),[ut,Mt]=XY(it,p,i.dtype,s,a);return[e.makeTensorInfo(ut.shape,ut.dtype,ut.values),e.makeTensorInfo(Mt.shape,Mt.dtype,Mt.values)]}if(0===s)return p[p.length-1]=0,[e.makeTensorInfo(p,i.dtype,[]),e.makeTensorInfo(p,"int32",[])];if(1===g)return[i,Bb({attrs:{shape:p,dtype:"int32",value:0},backend:e})];const v=e.texData.get(i.dataId),w=null!==v&&v.isPacked,N=w?e.unpackTensor(i):i,O=ft(p)/g,k=An({inputs:{x:N},attrs:{shape:[O,g]},backend:e});w&&sg(e,N);const L=xU(s),$=xU(g);let U=null;const V=()=>null===U?[k,k]:[k,U],W=(it,ut,Mt)=>{const Ot=V(),vt=new qre(Mt),Ht=U;U=e.runWebGLProgram(vt,Ot,"int32",[[g],[null===U?1:0],[Number.NEGATIVE_INFINITY],[it],[ut]]),sg(e,Ht)};for(let it=1;it<L;it*=2){const ut=2*it;for(let Mt=it;Mt>=1;Mt/=2)W(ut,Mt,[O,$])}for(let it=$;it>L;it/=2){const ut=V(),Mt=new Wre([O,it/2]),Rt=U;U=e.runWebGLProgram(Mt,ut,"int32",[[g],[null===U?1:0],[L]]),sg(e,Rt);const Dt=L/2,Ht=2*Dt;for(let Bt=Dt;Bt>=1;Bt/=2)W(Ht,Bt,U.shape)}let ce=U;U=Fy({inputs:{x:U},backend:e,attrs:{begin:0,size:[O,s]}}),sg(e,ce);let ve=oU({inputs:{x:k,indices:U},backend:e,attrs:{axis:1,batchDims:1}});sg(e,k);const Ee=p.slice(0,-1);Ee.push(s),ce=U,U=An({inputs:{x:U},attrs:{shape:Ee},backend:e}),sg(e,ce);const ge=ve;return ve=An({inputs:{x:ve},attrs:{shape:Ee},backend:e}),sg(e,ge),[ve,U]}};class Kre{constructor(t,e,r,i,s,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const o="nearest"===r?1:2;let l;switch(i){case"constant":default:l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${l} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${s});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${s});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${o} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const Zre={kernelName:Ua,backendName:"webgl",kernelFunc:function Yre(n){const{inputs:t,backend:e,attrs:r}=n,{image:i,transforms:s}=t,{interpolation:a,fillMode:o,fillValue:l,outputShape:p}=r,[g,v,w,N]=i.shape,[D,O]=p??[v,w],L=new Kre(v,w,a,o,l,[g,D,O,N]);return e.runWebGLProgram(L,[i,s],"float32")}},Jre={kernelName:tf,backendName:"webgl",kernelFunc:function jre(n){const{inputs:t,attrs:e,backend:r}=n,{axis:i}=e,{x:s}=t;Ty(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=r.readSync(s.dataId),{outputValues:o,outputShape:l,indices:p}=KY(a,i,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([p.length],"int32",p)]}},eie={kernelName:Hs,backendName:"webgl",kernelFunc:function Qre(n){const{inputs:t,backend:e,attrs:r}=n,{value:i}=t;let{axis:s}=r;s<0&&(s+=i.shape.length);const a=i,o=a.shape.length,l=i.shape[s],p=new Array(o-1);let g=0;for(let O=0;O<o;O++)O!==s&&(p[g++]=a.shape[O]);const v=[],w=new Array(o).fill(0),N=a.shape.slice();N[s]=1;const D=new Array(l);for(let O=0;O<D.length;O++){w[s]=O;const k=Fy({inputs:{x:a},backend:e,attrs:{begin:w,size:N}}),L=An({inputs:{x:k},backend:e,attrs:{shape:p}});D[O]=L,v.push(k)}return v.forEach(O=>e.disposeIntermediateTensorInfo(O)),D}};class tie{constructor(t,e){this.variableNames=["x","segmentIds"];const r=t.windowSize,i=t.batchSize,s=t.inSize,a=t.numSegments,o=a*Math.ceil(s/r);this.outputShape=[i,o];const g=4*Math.floor(r/4),v=r%4,w="\n        sumValue += dot(values, segFilter);\n    ";let N="";s%r>0&&(N=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let D="";s%r>0&&(D=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${N}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${D}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${a})) * float(${r}));\n        int currentSeg = int(mod(float(outIdx), float(${a})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${g}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${w}\n        }\n\n        int inIdx = inOffset + ${g};\n        if (${1===v}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${w}\n        } else if (${2===v}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${w}\n        } else if (${3===v}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${w}\n        }\n        setOutput(sumValue);\n      }\n    `}}const iie=[zZ,VZ,WZ,KZ,ZZ,QZ,tj,rj,oj,lj,hj,mj,vj,_j,Ej,Cj,Tj,Oj,Pj,Lj,zj,Hj,Kj,Zj,tJ,rJ,oJ,NZ,cJ,mJ,xJ,EJ,AJ,MJ,DJ,kJ,$J,zJ,VJ,qJ,HJ,KJ,jJ,QJ,rQ,sQ,uQ,fQ,pQ,mQ,vQ,bQ,NQ,EQ,IQ,AQ,MQ,DQ,kQ,FQ,$Q,UQ,qQ,HQ,YQ,JQ,eee,nee,_Z,iee,pJ,aee,uee,cee,EZ,hee,dee,gee,xee,_ee,See,Iee,Aee,Ree,Oee,Pee,Bee,Uee,Gee,Xee,Yee,jee,Qee,tte,ste,ute,hte,vte,AZ,_te,Ete,Ate,Rte,jj,Ote,Pte,Lte,zte,qte,CZ,Hte,Kte,Zte,Jte,Qte,Jj,dte,tne,ine,one,MZ,fne,dne,vne,wne,Ene,Cne,Tne,Rne,kne,Lne,zne,Gne,Hne,Kne,Jne,ere,Wj,gte,nre,rre,sre,ore,lre,fre,pre,mre,yre,xre,wre,Nre,Ere,Are,Mre,Dre,kre,mte,LZ,Fre,$re,zre,Gre,Xre,Zre,$Z,Jre,eie,{kernelName:nf,backendName:"webgl",kernelFunc:function nie(n){const{inputs:t,backend:e,attrs:r}=n,{x:i,segmentIds:s}=t,{numSegments:a}=r,o=i.shape.length,l=[];let p=0;const g=na([p],o);let v=i;null!=g&&(v=pl({inputs:{x:i},backend:e,attrs:{perm:g}}),l.push(v),p=ka(1,o)[0]);const w=GS(v.shape,p,a),N=ft([v.shape[p]]),D=An({inputs:{x:v},backend:e,attrs:{shape:[-1,N]}});l.push(D);const O=bg(i.dtype),k=(V,W,ce,ve,Ee)=>{const ge=V.shape[0],it=V.shape[1],ut=mx(it,Ee),Ot=new tie({windowSize:ut,inSize:it,batchSize:ge,numSegments:Ee},W),vt=e.compileAndRun(Ot,[V,ce],ve);if(l.push(vt),vt.shape[1]===Ee)return vt;const Rt=mU({backend:e,attrs:{start:0,stop:Ee,step:1,dtype:"float32"}}),Dt=vU({inputs:{x:Rt},backend:e,attrs:{reps:[it/ut]}});return l.push(Rt),l.push(Dt),k(vt,W,Dt,ve,Ee)},$=An({inputs:{x:k(D,"unsortedSegmentSum",s,O,a)},backend:e,attrs:{shape:w}});let U=$;if(null!=g){l.push($);const V=Ch(g);U=pl({inputs:{x:U},backend:e,attrs:{perm:V}})}return l.forEach(V=>e.disposeIntermediateTensorInfo(V)),U}},kte];for(const n of iie)sl(n);const aie={"tfjs-core":x_,"tfjs-backend-cpu":n4,"tfjs-backend-webgl":Ez,"tfjs-data":rB,"tfjs-layers":Ux,"tfjs-converter":L$,tfjs:"4.4.0"};var zb=(()=>{return(n=zb||(zb={}))[n.Complete=0]="Complete",n[n.Progess=1]="Progess",n[n.Error=2]="Error",zb;var n})();function Cp(n,t,e){void 0===e&&(e={});var r={type:"Feature"};return(0===e.id||e.id)&&(r.id=e.id),e.bbox&&(r.bbox=e.bbox),r.properties=t||{},r.geometry=n,r}function YC(n,t,e){if(void 0===e&&(e={}),!n)throw new Error("coordinates is required");if(!Array.isArray(n))throw new Error("coordinates must be an Array");if(n.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!TF(n[0])||!TF(n[1]))throw new Error("coordinates must contain numbers");return Cp({type:"Point",coordinates:n},t,e)}function ZC(n,t,e){void 0===e&&(e={});for(var r=0,i=n;r<i.length;r++){var s=i[r];if(s.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");for(var a=0;a<s[s.length-1].length;a++)if(s[s.length-1][a]!==s[0][a])throw new Error("First and last Position are not equivalent.")}return Cp({type:"Polygon",coordinates:n},t,e)}function TF(n){return!isNaN(n)&&null!==n&&!Array.isArray(n)}function Ub(n,t,e){if(null!==n)for(var r,i,s,a,o,l,p,w,g=0,v=0,N=n.type,D="FeatureCollection"===N,O="Feature"===N,k=D?n.features.length:1,L=0;L<k;L++){o=(w=!!(p=D?n.features[L].geometry:O?n.geometry:n)&&"GeometryCollection"===p.type)?p.geometries.length:1;for(var $=0;$<o;$++){var U=0,V=0;if(null!==(a=w?p.geometries[$]:p)){l=a.coordinates;var W=a.type;switch(g=!e||"Polygon"!==W&&"MultiPolygon"!==W?0:1,W){case null:break;case"Point":if(!1===t(l,v,L,U,V))return!1;v++,U++;break;case"LineString":case"MultiPoint":for(r=0;r<l.length;r++){if(!1===t(l[r],v,L,U,V))return!1;v++,"MultiPoint"===W&&U++}"LineString"===W&&U++;break;case"Polygon":case"MultiLineString":for(r=0;r<l.length;r++){for(i=0;i<l[r].length-g;i++){if(!1===t(l[r][i],v,L,U,V))return!1;v++}"MultiLineString"===W&&U++,"Polygon"===W&&V++}"Polygon"===W&&U++;break;case"MultiPolygon":for(r=0;r<l.length;r++){for(V=0,i=0;i<l[r].length;i++){for(s=0;s<l[r][i].length-g;s++){if(!1===t(l[r][i][s],v,L,U,V))return!1;v++}V++}U++}break;case"GeometryCollection":for(r=0;r<a.geometries.length;r++)if(!1===Ub(a.geometries[r],t,e))return!1;break;default:throw new Error("Unknown Geometry Type")}}}}}function jC(n,t){!function SU(n,t){var e,r,i,s,a,o,l,p,g,v,w=0,N="FeatureCollection"===n.type,D="Feature"===n.type,O=N?n.features.length:1;for(e=0;e<O;e++){for(p=N?n.features[e].properties:D?n.properties:{},g=N?n.features[e].bbox:D?n.bbox:void 0,v=N?n.features[e].id:D?n.id:void 0,a=(l=!!(o=N?n.features[e].geometry:D?n.geometry:n)&&"GeometryCollection"===o.type)?o.geometries.length:1,i=0;i<a;i++)if(null!==(s=l?o.geometries[i]:o))switch(s.type){case"Point":case"LineString":case"MultiPoint":case"Polygon":case"MultiLineString":case"MultiPolygon":if(!1===t(s,w,p,g,v))return!1;break;case"GeometryCollection":for(r=0;r<s.geometries.length;r++)if(!1===t(s.geometries[r],w,p,g,v))return!1;break;default:throw new Error("Unknown Geometry Type")}else if(!1===t(null,w,p,g,v))return!1;w++}}(n,function(e,r,i,s,a){var l,o=null===e?null:e.type;switch(o){case null:case"Point":case"LineString":case"Polygon":return!1!==t(Cp(e,i,{bbox:s,id:a}),r,0)&&void 0}switch(o){case"MultiPoint":l="Point";break;case"MultiLineString":l="LineString";break;case"MultiPolygon":l="Polygon"}for(var p=0;p<e.coordinates.length;p++)if(!1===t(Cp({type:l,coordinates:e.coordinates[p]},i),r,p))return!1})}function MF(n){var t=[1/0,1/0,-1/0,-1/0];return Ub(n,function(e){t[0]>e[0]&&(t[0]=e[0]),t[1]>e[1]&&(t[1]=e[1]),t[2]<e[0]&&(t[2]=e[0]),t[3]<e[1]&&(t[3]=e[1])}),t}MF.default=MF;const gie=MF;function AU(n,t,e){if(void 0===e&&(e={}),!n)throw new Error("point is required");if(!t)throw new Error("polygon is required");var r=function yie(n){if(!n)throw new Error("coord is required");if(!Array.isArray(n)){if("Feature"===n.type&&null!==n.geometry&&"Point"===n.geometry.type)return n.geometry.coordinates;if("Point"===n.type)return n.coordinates}if(Array.isArray(n)&&n.length>=2&&!Array.isArray(n[0])&&!Array.isArray(n[1]))return n;throw new Error("coord must be GeoJSON Point or an Array of numbers")}(n),i=function bie(n){return"Feature"===n.type?n.geometry:n}(t),s=i.type,a=t.bbox,o=i.coordinates;if(a&&!1===function Mie(n,t){return t[0]<=n[0]&&t[1]<=n[1]&&t[2]>=n[0]&&t[3]>=n[1]}(r,a))return!1;"Polygon"===s&&(o=[o]);for(var l=!1,p=0;p<o.length&&!l;p++)if(TU(r,o[p][0],e.ignoreBoundary)){for(var g=!1,v=1;v<o[p].length&&!g;)TU(r,o[p][v],!e.ignoreBoundary)&&(g=!0),v++;g||(l=!0)}return l}function TU(n,t,e){var r=!1;t[0][0]===t[t.length-1][0]&&t[0][1]===t[t.length-1][1]&&(t=t.slice(0,t.length-1));for(var i=0,s=t.length-1;i<t.length;s=i++){var a=t[i][0],o=t[i][1],l=t[s][0],p=t[s][1];if(n[1]*(a-l)+o*(l-n[0])+p*(n[0]-a)==0&&(a-n[0])*(l-n[0])<=0&&(o-n[1])*(p-n[1])<=0)return!e;o>n[1]!=p>n[1]&&n[0]<(l-a)*(n[1]-o)/(p-o)+a&&(r=!r)}return r}nn(5943),nn(1335);var RU=new ArrayBuffer(16);new Float64Array(RU),new Uint32Array(RU),nn(3544),function(){function n(t){this.points=t.points||[],this.duration=t.duration||1e4,this.sharpness=t.sharpness||.85,this.centers=[],this.controls=[],this.stepLength=t.stepLength||60,this.length=this.points.length,this.delay=0;for(var e=0;e<this.length;e++)this.points[e].z=this.points[e].z||0;for(e=0;e<this.length-1;e++){var r=this.points[e],i=this.points[e+1];this.centers.push({x:(r.x+i.x)/2,y:(r.y+i.y)/2,z:(r.z+i.z)/2})}for(this.controls.push([this.points[0],this.points[0]]),e=0;e<this.centers.length-1;e++){var s=this.points[e+1].x-(this.centers[e].x+this.centers[e+1].x)/2,a=this.points[e+1].y-(this.centers[e].y+this.centers[e+1].y)/2,o=this.points[e+1].z-(this.centers[e].y+this.centers[e+1].z)/2;this.controls.push([{x:(1-this.sharpness)*this.points[e+1].x+this.sharpness*(this.centers[e].x+s),y:(1-this.sharpness)*this.points[e+1].y+this.sharpness*(this.centers[e].y+a),z:(1-this.sharpness)*this.points[e+1].z+this.sharpness*(this.centers[e].z+o)},{x:(1-this.sharpness)*this.points[e+1].x+this.sharpness*(this.centers[e+1].x+s),y:(1-this.sharpness)*this.points[e+1].y+this.sharpness*(this.centers[e+1].y+a),z:(1-this.sharpness)*this.points[e+1].z+this.sharpness*(this.centers[e+1].z+o)}])}return this.controls.push([this.points[this.length-1],this.points[this.length-1]]),this.steps=this.cacheSteps(this.stepLength),this}n.prototype.cacheSteps=function(t){var e=[],r=this.pos(0);e.push(0);for(var i=0;i<this.duration;i+=10){var s=this.pos(i);Math.sqrt((s.x-r.x)*(s.x-r.x)+(s.y-r.y)*(s.y-r.y)+(s.z-r.z)*(s.z-r.z))>t&&(e.push(i),r=s)}return e},n.prototype.vector=function(t){var e=this.pos(t+10),r=this.pos(t-10);return{angle:180*Math.atan2(e.y-r.y,e.x-r.x)/3.14,speed:Math.sqrt((r.x-e.x)*(r.x-e.x)+(r.y-e.y)*(r.y-e.y)+(r.z-e.z)*(r.z-e.z))}},n.prototype.pos=function(t){var e=t-this.delay;e<0&&(e=0),e>this.duration&&(e=this.duration-1);var r=e/this.duration;if(r>=1)return this.points[this.length-1];var i=Math.floor((this.points.length-1)*r);return function Hie(n,t,e,r,i){var s=function Xie(n){var t=n*n;return[t*n,3*t*(1-n),3*n*(1-n)*(1-n),(1-n)*(1-n)*(1-n)]}(n);return{x:i.x*s[0]+r.x*s[1]+e.x*s[2]+t.x*s[3],y:i.y*s[0]+r.y*s[1]+e.y*s[2]+t.y*s[3],z:i.z*s[0]+r.z*s[1]+e.z*s[2]+t.z*s[3]}}((this.length-1)*r-i,this.points[i],this.controls[i][1],this.controls[i+1][0],this.points[i+1])}}();nn(5469),nn(5406);var KU=Math.PI/180,YU=180/Math.PI,qb=function(n,t){this.lon=n,this.lat=t,this.x=KU*n,this.y=KU*t};qb.prototype.view=function(){return String(this.lon).slice(0,4)+","+String(this.lat).slice(0,4)},qb.prototype.antipode=function(){return new qb(this.lon<0?180+this.lon:-1*(180-this.lon),-1*this.lat)};var ZU=function(){this.coords=[],this.length=0};ZU.prototype.move_to=function(n){this.length++,this.coords.push(n)};var $F=function(n){this.properties=n||{},this.geometries=[]};$F.prototype.json=function(){if(this.geometries.length<=0)return{geometry:{type:"LineString",coordinates:null},type:"Feature",properties:this.properties};if(1===this.geometries.length)return{geometry:{type:"LineString",coordinates:this.geometries[0].coords},type:"Feature",properties:this.properties};for(var n=[],t=0;t<this.geometries.length;t++)n.push(this.geometries[t].coords);return{geometry:{type:"MultiLineString",coordinates:n},type:"Feature",properties:this.properties}},$F.prototype.wkt=function(){for(var n="",t="LINESTRING(",e=function(s){t+=s[0]+" "+s[1]+","},r=0;r<this.geometries.length;r++){if(0===this.geometries[r].coords.length)return"LINESTRING(empty)";this.geometries[r].coords.forEach(e),n+=t.substring(0,t.length-1)+")"}return n};var BF=function(n,t,e){if(!n||void 0===n.x||void 0===n.y)throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");if(!t||void 0===t.x||void 0===t.y)throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");this.start=new qb(n.x,n.y),this.end=new qb(t.x,t.y),this.properties=e||{};var r=this.start.x-this.end.x,s=Math.pow(Math.sin((this.start.y-this.end.y)/2),2)+Math.cos(this.start.y)*Math.cos(this.end.y)*Math.pow(Math.sin(r/2),2);if(this.g=2*Math.asin(Math.sqrt(s)),this.g===Math.PI)throw new Error("it appears "+n.view()+" and "+t.view()+" are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite");if(isNaN(this.g))throw new Error("could not calculate great circle between "+n+" and "+t)};BF.prototype.interpolate=function(n){var t=Math.sin((1-n)*this.g)/Math.sin(this.g),e=Math.sin(n*this.g)/Math.sin(this.g),r=t*Math.cos(this.start.y)*Math.cos(this.start.x)+e*Math.cos(this.end.y)*Math.cos(this.end.x),i=t*Math.cos(this.start.y)*Math.sin(this.start.x)+e*Math.cos(this.end.y)*Math.sin(this.end.x),s=t*Math.sin(this.start.y)+e*Math.sin(this.end.y),a=YU*Math.atan2(s,Math.sqrt(Math.pow(r,2)+Math.pow(i,2)));return[YU*Math.atan2(i,r),a]},BF.prototype.Arc=function(n,t){var e=[];if(!n||n<=2)e.push([this.start.lon,this.start.lat]),e.push([this.end.lon,this.end.lat]);else for(var r=1/(n-1),i=0;i<n;++i){var a=this.interpolate(r*i);e.push(a)}for(var o=!1,l=0,p=t&&t.offset?t.offset:10,g=180-p,v=-180+p,w=360-p,N=1;N<e.length;++N){var D=e[N-1][0],O=e[N][0],k=Math.abs(O-D);k>w&&(O>g&&D<v||D>g&&O<v)?o=!0:k>l&&(l=k)}var L=[];if(o&&l<p){var $=[];L.push($);for(var U=0;U<e.length;++U){var V=parseFloat(e[U][0]);if(U>0&&Math.abs(V-e[U-1][0])>w){var W=parseFloat(e[U-1][0]),ce=parseFloat(e[U-1][1]),ve=parseFloat(e[U][0]),Ee=parseFloat(e[U][1]);if(W>-180&&W<v&&180===ve&&U+1<e.length&&e[U-1][0]>-180&&e[U-1][0]<v){$.push([-180,e[U][1]]),U++,$.push([e[U][0],e[U][1]]);continue}if(W>g&&W<180&&-180===ve&&U+1<e.length&&e[U-1][0]>g&&e[U-1][0]<180){$.push([180,e[U][1]]),U++,$.push([e[U][0],e[U][1]]);continue}if(W<v&&ve>g){var ge=W;W=ve,ve=ge;var it=ce;ce=Ee,Ee=it}if(W>g&&ve<v&&(ve+=360),W<=180&&ve>=180&&W<ve){var ut=(180-W)/(ve-W),Mt=ut*Ee+(1-ut)*ce;$.push([e[U-1][0]>g?180:-180,Mt]),($=[]).push([e[U-1][0]>g?-180:180,Mt]),L.push($)}else L.push($=[]);$.push([V,e[U][1]])}else $.push([e[U][0],e[U][1]])}}else{var Ot=[];L.push(Ot);for(var vt=0;vt<e.length;++vt)Ot.push([e[vt][0],e[vt][1]])}for(var Rt=new $F(this.properties),Dt=0;Dt<L.length;++Dt){var Ht=new ZU;Rt.geometries.push(Ht);for(var Bt=L[Dt],Wt=0;Wt<Bt.length;++Wt)Ht.move_to(Bt[Wt])}return Rt},nn(6952);var gi=[],yi=[],vi=[],xi=[],bi=[],wi=[],_i=[],Ni=[],Si=[],Ei=[],Ii=[],Ci=[],Ai=[],Ti=[],Mi=[],Ri=[],Di=[],Oi=[],ki=[],Pi=[],Fi=[],Li=[],$i=[],Bi=[];_i[85]=Ei[85]=-1,Ni[85]=Ii[85]=0,Si[85]=Ci[85]=1,ki[85]=Li[85]=1,Pi[85]=$i[85]=0,Fi[85]=Bi[85]=1,gi[85]=xi[85]=0,yi[85]=bi[85]=-1,vi[85]=Mi[85]=0,Ri[85]=Ai[85]=0,Di[85]=Ti[85]=1,wi[85]=Oi[85]=1,Li[1]=Li[169]=0,$i[1]=$i[169]=-1,Bi[1]=Bi[169]=0,Ai[1]=Ai[169]=-1,Ti[1]=Ti[169]=0,Mi[1]=Mi[169]=0,Ei[4]=Ei[166]=0,Ii[4]=Ii[166]=-1,Ci[4]=Ci[166]=1,Ri[4]=Ri[166]=1,Di[4]=Di[166]=0,Oi[4]=Oi[166]=0,_i[16]=_i[154]=0,Ni[16]=Ni[154]=1,Si[16]=Si[154]=1,xi[16]=xi[154]=1,bi[16]=bi[154]=0,wi[16]=wi[154]=1,ki[64]=ki[106]=0,Pi[64]=Pi[106]=1,Fi[64]=Fi[106]=0,gi[64]=gi[106]=-1,yi[64]=yi[106]=0,vi[64]=vi[106]=1,ki[2]=ki[168]=0,Pi[2]=Pi[168]=-1,Fi[2]=Fi[168]=1,Li[2]=Li[168]=0,$i[2]=$i[168]=-1,Bi[2]=Bi[168]=0,Ai[2]=Ai[168]=-1,Ti[2]=Ti[168]=0,Mi[2]=Mi[168]=0,Ri[2]=Ri[168]=-1,Di[2]=Di[168]=0,Oi[2]=Oi[168]=1,_i[8]=_i[162]=0,Ni[8]=Ni[162]=-1,Si[8]=Si[162]=0,Ei[8]=Ei[162]=0,Ii[8]=Ii[162]=-1,Ci[8]=Ci[162]=1,Ai[8]=Ai[162]=1,Ti[8]=Ti[162]=0,Mi[8]=Mi[162]=1,Ri[8]=Ri[162]=1,Di[8]=Di[162]=0,Oi[8]=Oi[162]=0,_i[32]=_i[138]=0,Ni[32]=Ni[138]=1,Si[32]=Si[138]=1,Ei[32]=Ei[138]=0,Ii[32]=Ii[138]=1,Ci[32]=Ci[138]=0,gi[32]=gi[138]=1,yi[32]=yi[138]=0,vi[32]=vi[138]=0,xi[32]=xi[138]=1,bi[32]=bi[138]=0,wi[32]=wi[138]=1,Li[128]=Li[42]=0,$i[128]=$i[42]=1,Bi[128]=Bi[42]=1,ki[128]=ki[42]=0,Pi[128]=Pi[42]=1,Fi[128]=Fi[42]=0,gi[128]=gi[42]=-1,yi[128]=yi[42]=0,vi[128]=vi[42]=1,xi[128]=xi[42]=-1,bi[128]=bi[42]=0,wi[128]=wi[42]=0,Ei[5]=Ei[165]=-1,Ii[5]=Ii[165]=0,Ci[5]=Ci[165]=0,Li[5]=Li[165]=1,$i[5]=$i[165]=0,Bi[5]=Bi[165]=0,Ri[20]=Ri[150]=0,Di[20]=Di[150]=1,Oi[20]=Oi[150]=1,xi[20]=xi[150]=0,bi[20]=bi[150]=-1,wi[20]=wi[150]=1,_i[80]=_i[90]=-1,Ni[80]=Ni[90]=0,Si[80]=Si[90]=1,ki[80]=ki[90]=1,Pi[80]=Pi[90]=0,Fi[80]=Fi[90]=1,Ai[65]=Ai[105]=0,Ti[65]=Ti[105]=1,Mi[65]=Mi[105]=0,gi[65]=gi[105]=0,yi[65]=yi[105]=-1,vi[65]=vi[105]=0,_i[160]=_i[10]=-1,Ni[160]=Ni[10]=0,Si[160]=Si[10]=1,Ei[160]=Ei[10]=-1,Ii[160]=Ii[10]=0,Ci[160]=Ci[10]=0,Li[160]=Li[10]=1,$i[160]=$i[10]=0,Bi[160]=Bi[10]=0,ki[160]=ki[10]=1,Pi[160]=Pi[10]=0,Fi[160]=Fi[10]=1,Ri[130]=Ri[40]=0,Di[130]=Di[40]=1,Oi[130]=Oi[40]=1,Ai[130]=Ai[40]=0,Ti[130]=Ti[40]=1,Mi[130]=Mi[40]=0,gi[130]=gi[40]=0,yi[130]=yi[40]=-1,vi[130]=vi[40]=0,xi[130]=xi[40]=0,bi[130]=bi[40]=-1,wi[130]=wi[40]=1,Ei[37]=Ei[133]=0,Ii[37]=Ii[133]=1,Ci[37]=Ci[133]=1,Li[37]=Li[133]=0,$i[37]=$i[133]=1,Bi[37]=Bi[133]=0,gi[37]=gi[133]=-1,yi[37]=yi[133]=0,vi[37]=vi[133]=0,xi[37]=xi[133]=1,bi[37]=bi[133]=0,wi[37]=wi[133]=0,Ri[148]=Ri[22]=-1,Di[148]=Di[22]=0,Oi[148]=Oi[22]=0,Li[148]=Li[22]=0,$i[148]=$i[22]=-1,Bi[148]=Bi[22]=1,ki[148]=ki[22]=0,Pi[148]=Pi[22]=1,Fi[148]=Fi[22]=1,xi[148]=xi[22]=-1,bi[148]=bi[22]=0,wi[148]=wi[22]=1,_i[82]=_i[88]=0,Ni[82]=Ni[88]=-1,Si[82]=Si[88]=1,Ri[82]=Ri[88]=1,Di[82]=Di[88]=0,Oi[82]=Oi[88]=1,Ai[82]=Ai[88]=-1,Ti[82]=Ti[88]=0,Mi[82]=Mi[88]=1,ki[82]=ki[88]=0,Pi[82]=Pi[88]=-1,Fi[82]=Fi[88]=0,_i[73]=_i[97]=0,Ni[73]=Ni[97]=1,Si[73]=Si[97]=0,Ei[73]=Ei[97]=0,Ii[73]=Ii[97]=-1,Ci[73]=Ci[97]=0,Ai[73]=Ai[97]=1,Ti[73]=Ti[97]=0,Mi[73]=Mi[97]=0,gi[73]=gi[97]=1,yi[73]=yi[97]=0,vi[73]=vi[97]=1,_i[145]=_i[25]=0,Ni[145]=Ni[25]=-1,Si[145]=Si[25]=0,Ai[145]=Ai[25]=1,Ti[145]=Ti[25]=0,Mi[145]=Mi[25]=1,Li[145]=Li[25]=0,$i[145]=$i[25]=1,Bi[145]=Bi[25]=1,xi[145]=xi[25]=-1,bi[145]=bi[25]=0,wi[145]=wi[25]=0,Ei[70]=Ei[100]=0,Ii[70]=Ii[100]=1,Ci[70]=Ci[100]=0,Ri[70]=Ri[100]=-1,Di[70]=Di[100]=0,Oi[70]=Oi[100]=1,ki[70]=ki[100]=0,Pi[70]=Pi[100]=-1,Fi[70]=Fi[100]=1,gi[70]=gi[100]=1,yi[70]=yi[100]=0,vi[70]=vi[100]=0,Ei[101]=Ei[69]=0,Ii[101]=Ii[69]=1,Ci[101]=Ci[69]=0,gi[101]=gi[69]=1,yi[101]=yi[69]=0,vi[101]=vi[69]=0,Li[149]=Li[21]=0,$i[149]=$i[21]=1,Bi[149]=Bi[21]=1,xi[149]=xi[21]=-1,bi[149]=bi[21]=0,wi[149]=wi[21]=0,Ri[86]=Ri[84]=-1,Di[86]=Di[84]=0,Oi[86]=Oi[84]=1,ki[86]=ki[84]=0,Pi[86]=Pi[84]=-1,Fi[86]=Fi[84]=1,_i[89]=_i[81]=0,Ni[89]=Ni[81]=-1,Si[89]=Si[81]=0,Ai[89]=Ai[81]=1,Ti[89]=Ti[81]=0,Mi[89]=Mi[81]=1,_i[96]=_i[74]=0,Ni[96]=Ni[74]=1,Si[96]=Si[74]=0,Ei[96]=Ei[74]=-1,Ii[96]=Ii[74]=0,Ci[96]=Ci[74]=1,ki[96]=ki[74]=1,Pi[96]=Pi[74]=0,Fi[96]=Fi[74]=0,gi[96]=gi[74]=1,yi[96]=yi[74]=0,vi[96]=vi[74]=1,_i[24]=_i[146]=0,Ni[24]=Ni[146]=-1,Si[24]=Si[146]=1,Ri[24]=Ri[146]=1,Di[24]=Di[146]=0,Oi[24]=Oi[146]=1,Ai[24]=Ai[146]=0,Ti[24]=Ti[146]=1,Mi[24]=Mi[146]=1,xi[24]=xi[146]=0,bi[24]=bi[146]=-1,wi[24]=wi[146]=0,Ei[6]=Ei[164]=-1,Ii[6]=Ii[164]=0,Ci[6]=Ci[164]=1,Ri[6]=Ri[164]=-1,Di[6]=Di[164]=0,Oi[6]=Oi[164]=0,Li[6]=Li[164]=0,$i[6]=$i[164]=-1,Bi[6]=Bi[164]=1,ki[6]=ki[164]=1,Pi[6]=Pi[164]=0,Fi[6]=Fi[164]=0,Ai[129]=Ai[41]=0,Ti[129]=Ti[41]=1,Mi[129]=Mi[41]=1,Li[129]=Li[41]=0,$i[129]=$i[41]=1,Bi[129]=Bi[41]=0,gi[129]=gi[41]=-1,yi[129]=yi[41]=0,vi[129]=vi[41]=0,xi[129]=xi[41]=0,bi[129]=bi[41]=-1,wi[129]=wi[41]=0,Ri[66]=Ri[104]=0,Di[66]=Di[104]=1,Oi[66]=Oi[104]=0,Ai[66]=Ai[104]=-1,Ti[66]=Ti[104]=0,Mi[66]=Mi[104]=1,ki[66]=ki[104]=0,Pi[66]=Pi[104]=-1,Fi[66]=Fi[104]=0,gi[66]=gi[104]=0,yi[66]=yi[104]=-1,vi[66]=vi[104]=1,_i[144]=_i[26]=-1,Ni[144]=Ni[26]=0,Si[144]=Si[26]=0,Li[144]=Li[26]=1,$i[144]=$i[26]=0,Bi[144]=Bi[26]=1,ki[144]=ki[26]=0,Pi[144]=Pi[26]=1,Fi[144]=Fi[26]=1,xi[144]=xi[26]=-1,bi[144]=bi[26]=0,wi[144]=wi[26]=1,Ei[36]=Ei[134]=0,Ii[36]=Ii[134]=1,Ci[36]=Ci[134]=1,Ri[36]=Ri[134]=0,Di[36]=Di[134]=1,Oi[36]=Oi[134]=0,gi[36]=gi[134]=0,yi[36]=yi[134]=-1,vi[36]=vi[134]=1,xi[36]=xi[134]=1,bi[36]=bi[134]=0,wi[36]=wi[134]=0,_i[9]=_i[161]=-1,Ni[9]=Ni[161]=0,Si[9]=Si[161]=0,Ei[9]=Ei[161]=0,Ii[9]=Ii[161]=-1,Ci[9]=Ci[161]=0,Ai[9]=Ai[161]=1,Ti[9]=Ti[161]=0,Mi[9]=Mi[161]=0,Li[9]=Li[161]=1,$i[9]=$i[161]=0,Bi[9]=Bi[161]=1,_i[136]=0,Ni[136]=1,Si[136]=1,Ei[136]=0,Ii[136]=1,Ci[136]=0,Ri[136]=-1,Di[136]=0,Oi[136]=1,Ai[136]=-1,Ti[136]=0,Mi[136]=0,Li[136]=0,$i[136]=-1,Bi[136]=0,ki[136]=0,Pi[136]=-1,Fi[136]=1,gi[136]=1,yi[136]=0,vi[136]=0,xi[136]=1,bi[136]=0,wi[136]=1,_i[34]=0,Ni[34]=-1,Si[34]=0,Ei[34]=0,Ii[34]=-1,Ci[34]=1,Ri[34]=1,Di[34]=0,Oi[34]=0,Ai[34]=1,Ti[34]=0,Mi[34]=1,Li[34]=0,$i[34]=1,Bi[34]=1,ki[34]=0,Pi[34]=1,Fi[34]=0,gi[34]=-1,yi[34]=0,vi[34]=1,xi[34]=-1,bi[34]=0,wi[34]=0,_i[35]=0,Ni[35]=1,Si[35]=1,Ei[35]=0,Ii[35]=-1,Ci[35]=1,Ri[35]=1,Di[35]=0,Oi[35]=0,Ai[35]=-1,Ti[35]=0,Mi[35]=0,Li[35]=0,$i[35]=-1,Bi[35]=0,ki[35]=0,Pi[35]=1,Fi[35]=0,gi[35]=-1,yi[35]=0,vi[35]=1,xi[35]=1,bi[35]=0,wi[35]=1,_i[153]=0,Ni[153]=1,Si[153]=1,Ai[153]=-1,Ti[153]=0,Mi[153]=0,Li[153]=0,$i[153]=-1,Bi[153]=0,xi[153]=1,bi[153]=0,wi[153]=1,Ei[102]=0,Ii[102]=-1,Ci[102]=1,Ri[102]=1,Di[102]=0,Oi[102]=0,ki[102]=0,Pi[102]=1,Fi[102]=0,gi[102]=-1,yi[102]=0,vi[102]=1,_i[155]=0,Ni[155]=-1,Si[155]=0,Ai[155]=1,Ti[155]=0,Mi[155]=1,Li[155]=0,$i[155]=1,Bi[155]=1,xi[155]=-1,bi[155]=0,wi[155]=0,Ei[103]=0,Ii[103]=1,Ci[103]=0,Ri[103]=-1,Di[103]=0,Oi[103]=1,ki[103]=0,Pi[103]=-1,Fi[103]=1,gi[103]=1,yi[103]=0,vi[103]=0,_i[152]=0,Ni[152]=1,Si[152]=1,Ri[152]=-1,Di[152]=0,Oi[152]=1,Ai[152]=-1,Ti[152]=0,Mi[152]=0,Li[152]=0,$i[152]=-1,Bi[152]=0,ki[152]=0,Pi[152]=-1,Fi[152]=1,xi[152]=1,bi[152]=0,wi[152]=1,_i[156]=0,Ni[156]=-1,Si[156]=1,Ri[156]=1,Di[156]=0,Oi[156]=1,Ai[156]=-1,Ti[156]=0,Mi[156]=0,Li[156]=0,$i[156]=-1,Bi[156]=0,ki[156]=0,Pi[156]=1,Fi[156]=1,xi[156]=-1,bi[156]=0,wi[156]=1,_i[137]=0,Ni[137]=1,Si[137]=1,Ei[137]=0,Ii[137]=1,Ci[137]=0,Ai[137]=-1,Ti[137]=0,Mi[137]=0,Li[137]=0,$i[137]=-1,Bi[137]=0,gi[137]=1,yi[137]=0,vi[137]=0,xi[137]=1,bi[137]=0,wi[137]=1,_i[139]=0,Ni[139]=1,Si[139]=1,Ei[139]=0,Ii[139]=-1,Ci[139]=0,Ai[139]=1,Ti[139]=0,Mi[139]=0,Li[139]=0,$i[139]=1,Bi[139]=0,gi[139]=-1,yi[139]=0,vi[139]=0,xi[139]=1,bi[139]=0,wi[139]=1,_i[98]=0,Ni[98]=-1,Si[98]=0,Ei[98]=0,Ii[98]=-1,Ci[98]=1,Ri[98]=1,Di[98]=0,Oi[98]=0,Ai[98]=1,Ti[98]=0,Mi[98]=1,ki[98]=0,Pi[98]=1,Fi[98]=0,gi[98]=-1,yi[98]=0,vi[98]=1,_i[99]=0,Ni[99]=1,Si[99]=0,Ei[99]=0,Ii[99]=-1,Ci[99]=1,Ri[99]=1,Di[99]=0,Oi[99]=0,Ai[99]=-1,Ti[99]=0,Mi[99]=1,ki[99]=0,Pi[99]=-1,Fi[99]=0,gi[99]=1,yi[99]=0,vi[99]=1,Ei[38]=0,Ii[38]=-1,Ci[38]=1,Ri[38]=1,Di[38]=0,Oi[38]=0,Li[38]=0,$i[38]=1,Bi[38]=1,ki[38]=0,Pi[38]=1,Fi[38]=0,gi[38]=-1,yi[38]=0,vi[38]=1,xi[38]=-1,bi[38]=0,wi[38]=0,Ei[39]=0,Ii[39]=1,Ci[39]=1,Ri[39]=-1,Di[39]=0,Oi[39]=0,Li[39]=0,$i[39]=-1,Bi[39]=1,ki[39]=0,Pi[39]=1,Fi[39]=0,gi[39]=-1,yi[39]=0,vi[39]=1,xi[39]=1,bi[39]=0,wi[39]=0;var GF=function(n){return[[n.bottomleft,0],[0,0],[0,n.leftbottom]]},qF=function(n){return[[1,n.rightbottom],[1,0],[n.bottomright,0]]},WF=function(n){return[[n.topright,1],[1,1],[1,n.righttop]]},HF=function(n){return[[0,n.lefttop],[0,1],[n.topleft,1]]},XF=function(n){return[[n.bottomright,0],[n.bottomleft,0],[0,n.leftbottom],[0,n.lefttop]]},KF=function(n){return[[n.bottomright,0],[n.bottomleft,0],[1,n.righttop],[1,n.rightbottom]]},YF=function(n){return[[1,n.righttop],[1,n.rightbottom],[n.topleft,1],[n.topright,1]]},ZF=function(n){return[[0,n.leftbottom],[0,n.lefttop],[n.topleft,1],[n.topright,1]]},Kn=[],Un=[],gr=[],cr=[],Tr=[],Er=[],zi=[],Ui=[];cr[1]=Tr[1]=18,cr[169]=Tr[169]=18,gr[4]=Un[4]=12,gr[166]=Un[166]=12,Kn[16]=Ui[16]=4,Kn[154]=Ui[154]=4,Er[64]=zi[64]=22,Er[106]=zi[106]=22,gr[2]=Er[2]=17,cr[2]=Tr[2]=18,gr[168]=Er[168]=17,cr[168]=Tr[168]=18,Kn[8]=cr[8]=9,Un[8]=gr[8]=12,Kn[162]=cr[162]=9,Un[162]=gr[162]=12,Kn[32]=Ui[32]=4,Un[32]=zi[32]=1,Kn[138]=Ui[138]=4,Un[138]=zi[138]=1,Tr[128]=Ui[128]=21,Er[128]=zi[128]=22,Tr[42]=Ui[42]=21,Er[42]=zi[42]=22,Un[5]=Tr[5]=14,Un[165]=Tr[165]=14,gr[20]=Ui[20]=6,gr[150]=Ui[150]=6,Kn[80]=Er[80]=11,Kn[90]=Er[90]=11,cr[65]=zi[65]=3,cr[105]=zi[105]=3,Kn[160]=Er[160]=11,Un[160]=Tr[160]=14,Kn[10]=Er[10]=11,Un[10]=Tr[10]=14,gr[130]=Ui[130]=6,cr[130]=zi[130]=3,gr[40]=Ui[40]=6,cr[40]=zi[40]=3,Un[101]=zi[101]=1,Un[69]=zi[69]=1,Tr[149]=Ui[149]=21,Tr[21]=Ui[21]=21,gr[86]=Er[86]=17,gr[84]=Er[84]=17,Kn[89]=cr[89]=9,Kn[81]=cr[81]=9,Kn[96]=zi[96]=0,Un[96]=Er[96]=15,Kn[74]=zi[74]=0,Un[74]=Er[74]=15,Kn[24]=gr[24]=8,cr[24]=Ui[24]=7,Kn[146]=gr[146]=8,cr[146]=Ui[146]=7,Un[6]=Er[6]=15,gr[6]=Tr[6]=16,Un[164]=Er[164]=15,gr[164]=Tr[164]=16,cr[129]=Ui[129]=7,Tr[129]=zi[129]=20,cr[41]=Ui[41]=7,Tr[41]=zi[41]=20,gr[66]=zi[66]=2,cr[66]=Er[66]=19,gr[104]=zi[104]=2,cr[104]=Er[104]=19,Kn[144]=Tr[144]=10,Er[144]=Ui[144]=23,Kn[26]=Tr[26]=10,Er[26]=Ui[26]=23,Un[36]=Ui[36]=5,gr[36]=zi[36]=2,Un[134]=Ui[134]=5,gr[134]=zi[134]=2,Kn[9]=Tr[9]=10,Un[9]=cr[9]=13,Kn[161]=Tr[161]=10,Un[161]=cr[161]=13,Un[37]=Ui[37]=5,Tr[37]=zi[37]=20,Un[133]=Ui[133]=5,Tr[133]=zi[133]=20,gr[148]=Tr[148]=16,Er[148]=Ui[148]=23,gr[22]=Tr[22]=16,Er[22]=Ui[22]=23,Kn[82]=gr[82]=8,cr[82]=Er[82]=19,Kn[88]=gr[88]=8,cr[88]=Er[88]=19,Kn[73]=zi[73]=0,Un[73]=cr[73]=13,Kn[97]=zi[97]=0,Un[97]=cr[97]=13,Kn[145]=cr[145]=9,Tr[145]=Ui[145]=21,Kn[25]=cr[25]=9,Tr[25]=Ui[25]=21,Un[70]=zi[70]=1,gr[70]=Er[70]=17,Un[100]=zi[100]=1,gr[100]=Er[100]=17,Kn[34]=cr[34]=9,Un[34]=gr[34]=12,Tr[34]=Ui[34]=21,Er[34]=zi[34]=22,Kn[136]=Ui[136]=4,Un[136]=zi[136]=1,gr[136]=Er[136]=17,cr[136]=Tr[136]=18,Kn[35]=Ui[35]=4,Un[35]=gr[35]=12,cr[35]=Tr[35]=18,Er[35]=zi[35]=22,Kn[153]=Ui[153]=4,cr[153]=Tr[153]=18,Un[102]=gr[102]=12,Er[102]=zi[102]=22,Kn[155]=cr[155]=9,Tr[155]=Ui[155]=23,Un[103]=zi[103]=1,gr[103]=Er[103]=17,Kn[152]=Ui[152]=4,gr[152]=Er[152]=17,cr[152]=Tr[152]=18,Kn[156]=gr[156]=8,cr[156]=Tr[156]=18,Er[156]=Ui[156]=23,Kn[137]=Ui[137]=4,Un[137]=zi[137]=1,cr[137]=Tr[137]=18,Kn[139]=Ui[139]=4,Un[139]=cr[139]=13,Tr[139]=zi[139]=20,Kn[98]=cr[98]=9,Un[98]=gr[98]=12,Er[98]=zi[98]=22,Kn[99]=zi[99]=0,Un[99]=gr[99]=12,cr[99]=Er[99]=19,Un[38]=gr[38]=12,Tr[38]=Ui[38]=21,Er[38]=zi[38]=22,Un[39]=Ui[39]=5,gr[39]=Tr[39]=16,Er[39]=zi[39]=22;var Tn=[];function QF(n,t,e){return function Pae(n){return(n>0)-(n<0)||+n}((t[0]-n[0])*(e[1]-t[1])-(e[0]-t[0])*(t[1]-n[1]))}function h5(n,t){return t.geometry.coordinates[0].every(function(e){return AU(YC(e),n)})}Tn[1]=Tn[169]=GF,Tn[4]=Tn[166]=qF,Tn[16]=Tn[154]=WF,Tn[64]=Tn[106]=HF,Tn[168]=Tn[2]=XF,Tn[162]=Tn[8]=KF,Tn[138]=Tn[32]=YF,Tn[42]=Tn[128]=ZF,Tn[5]=Tn[165]=function(n){return[[0,0],[0,n.leftbottom],[1,n.rightbottom],[1,0]]},Tn[20]=Tn[150]=function(n){return[[1,0],[n.bottomright,0],[n.topright,1],[1,1]]},Tn[80]=Tn[90]=function(n){return[[1,1],[1,n.righttop],[0,n.lefttop],[0,1]]},Tn[65]=Tn[105]=function(n){return[[n.bottomleft,0],[0,0],[0,1],[n.topleft,1]]},Tn[160]=Tn[10]=function(n){return[[1,n.righttop],[1,n.rightbottom],[0,n.leftbottom],[0,n.lefttop]]},Tn[130]=Tn[40]=function(n){return[[n.topleft,1],[n.topright,1],[n.bottomright,0],[n.bottomleft,0]]},Tn[85]=function(){return[[0,0],[0,1],[1,1],[1,0]]},Tn[101]=Tn[69]=function(n){return[[1,n.rightbottom],[1,0],[0,0],[0,1],[n.topleft,1]]},Tn[149]=Tn[21]=function(n){return[[n.topright,1],[1,1],[1,0],[0,0],[0,n.leftbottom]]},Tn[86]=Tn[84]=function(n){return[[1,0],[n.bottomright,0],[0,n.lefttop],[0,1],[1,1]]},Tn[89]=Tn[81]=function(n){return[[1,1],[1,n.righttop],[n.bottomleft,0],[0,0],[0,1]]},Tn[96]=Tn[74]=function(n){return[[1,n.righttop],[1,n.rightbottom],[0,n.lefttop],[0,1],[n.topleft,1]]},Tn[24]=Tn[146]=function(n){return[[1,1],[1,n.righttop],[n.bottomright,0],[n.bottomleft,0],[n.topright,1]]},Tn[6]=Tn[164]=function(n){return[[1,n.rightbottom],[1,0],[n.bottomright,0],[0,n.leftbottom],[0,n.lefttop]]},Tn[129]=Tn[41]=function(n){return[[n.topright,1],[n.bottomleft,0],[0,0],[0,n.leftbottom],[n.topleft,1]]},Tn[66]=Tn[104]=function(n){return[[n.bottomright,0],[n.bottomleft,0],[0,n.lefttop],[0,1],[n.topleft,1]]},Tn[144]=Tn[26]=function(n){return[[1,1],[1,n.righttop],[0,n.leftbottom],[0,n.lefttop],[n.topright,1]]},Tn[36]=Tn[134]=function(n){return[[1,n.rightbottom],[1,0],[n.bottomright,0],[n.topleft,1],[n.topright,1]]},Tn[9]=Tn[161]=function(n){return[[1,n.righttop],[1,n.rightbottom],[n.bottomleft,0],[0,0],[0,n.leftbottom]]},Tn[37]=Tn[133]=function(n){return[[1,n.rightbottom],[1,0],[0,0],[0,n.leftbottom],[n.topleft,1],[n.topright,1]]},Tn[148]=Tn[22]=function(n){return[[1,1],[1,0],[n.bottomright,0],[0,n.leftbottom],[0,n.lefttop],[n.topright,1]]},Tn[82]=Tn[88]=function(n){return[[1,1],[1,n.righttop],[n.bottomright,0],[n.bottomleft,0],[0,n.lefttop],[0,1]]},Tn[73]=Tn[97]=function(n){return[[1,n.righttop],[1,n.rightbottom],[n.bottomleft,0],[0,0],[0,1],[n.topleft,1]]},Tn[145]=Tn[25]=function(n){return[[1,1],[1,n.righttop],[n.bottomleft,0],[0,0],[0,n.leftbottom],[n.topright,1]]},Tn[70]=Tn[100]=function(n){return[[1,n.rightbottom],[1,0],[n.bottomright,0],[0,n.lefttop],[0,1],[n.topleft,1]]},Tn[34]=function(n){return[ZF(n),KF(n)]},Tn[35]=function(n){return[[1,n.righttop],[1,n.rightbottom],[n.bottomright,0],[n.bottomleft,0],[0,n.leftbottom],[0,n.lefttop],[n.topleft,1],[n.topright,1]]},Tn[136]=function(n){return[YF(n),XF(n)]},Tn[153]=function(n){return[WF(n),GF(n)]},Tn[102]=function(n){return[qF(n),HF(n)]},Tn[155]=function(n){return[[1,1],[1,n.righttop],[n.bottomleft,0],[0,0],[0,n.leftbottom],[n.topright,1]]},Tn[103]=function(n){return[[1,n.rightbottom],[1,0],[n.bottomright,0],[0,n.lefttop],[0,1],[n.topleft,1]]},Tn[152]=function(n){return[WF(n),XF(n)]},Tn[156]=function(n){return[[1,1],[1,n.righttop],[n.bottomright,0],[n.bottomleft,0],[0,n.leftbottom],[0,n.lefttop],[n.topright,1]]},Tn[137]=function(n){return[YF(n),GF(n)]},Tn[139]=function(n){return[[1,n.righttop],[1,n.rightbottom],[n.bottomleft,0],[0,0],[0,n.leftbottom],[n.topleft,1],[n.topright,1]]},Tn[98]=function(n){return[KF(n),HF(n)]},Tn[99]=function(n){return[[1,n.righttop],[1,n.rightbottom],[n.bottomright,0],[n.bottomleft,0],[0,n.lefttop],[0,1],[n.topleft,1]]},Tn[38]=function(n){return[qF(n),ZF(n)]},Tn[39]=function(n){return[[1,n.rightbottom],[1,0],[n.bottomright,0],[0,n.leftbottom],[0,n.lefttop],[n.topleft,1],[n.topright,1]]};const p5=function(){function n(t){this.id=n.buildId(t),this.coordinates=t,this.innerEdges=[],this.outerEdges=[],this.outerEdgesSorted=!1}return n.buildId=function(t){return t.join(",")},n.prototype.removeInnerEdge=function(t){this.innerEdges=this.innerEdges.filter(function(e){return e.from.id!==t.from.id})},n.prototype.removeOuterEdge=function(t){this.outerEdges=this.outerEdges.filter(function(e){return e.to.id!==t.to.id})},n.prototype.addOuterEdge=function(t){this.outerEdges.push(t),this.outerEdgesSorted=!1},n.prototype.sortOuterEdges=function(){var t=this;this.outerEdgesSorted||(this.outerEdges.sort(function(e,r){var i=e.to,s=r.to;if(i.coordinates[0]-t.coordinates[0]>=0&&s.coordinates[0]-t.coordinates[0]<0)return 1;if(i.coordinates[0]-t.coordinates[0]<0&&s.coordinates[0]-t.coordinates[0]>=0)return-1;if(i.coordinates[0]-t.coordinates[0]==0&&s.coordinates[0]-t.coordinates[0]==0)return i.coordinates[1]-t.coordinates[1]>=0||s.coordinates[1]-t.coordinates[1]>=0?i.coordinates[1]-s.coordinates[1]:s.coordinates[1]-i.coordinates[1];var a=QF(t.coordinates,i.coordinates,s.coordinates);return a<0?1:a>0?-1:Math.pow(i.coordinates[0]-t.coordinates[0],2)+Math.pow(i.coordinates[1]-t.coordinates[1],2)-(Math.pow(s.coordinates[0]-t.coordinates[0],2)+Math.pow(s.coordinates[1]-t.coordinates[1],2))}),this.outerEdgesSorted=!0)},n.prototype.getOuterEdges=function(){return this.sortOuterEdges(),this.outerEdges},n.prototype.getOuterEdge=function(t){return this.sortOuterEdges(),this.outerEdges[t]},n.prototype.addInnerEdge=function(t){this.innerEdges.push(t)},n}(),zae=function(){function n(t,e){this.from=t,this.to=e,this.next=void 0,this.label=void 0,this.symetric=void 0,this.ring=void 0,this.from.addOuterEdge(this),this.to.addInnerEdge(this)}return n.prototype.getSymetric=function(){return this.symetric||(this.symetric=new n(this.to,this.from),this.symetric.symetric=this),this.symetric},n.prototype.deleteEdge=function(){this.from.removeOuterEdge(this),this.to.removeInnerEdge(this)},n.prototype.isEqual=function(t){return this.from.id===t.from.id&&this.to.id===t.to.id},n.prototype.toString=function(){return"Edge { "+this.from.id+" -> "+this.to.id+" }"},n.prototype.toLineString=function(){return function CF(n,t,e){if(void 0===e&&(e={}),n.length<2)throw new Error("coordinates must be an array of two or more positions");return Cp({type:"LineString",coordinates:n},t,e)}([this.from.coordinates,this.to.coordinates])},n.prototype.compareTo=function(t){return QF(t.from.coordinates,t.to.coordinates,this.to.coordinates)},n}(),Vae=function(){function n(){this.edges=[],this.polygon=void 0,this.envelope=void 0}return n.prototype.push=function(t){this.edges.push(t),this.polygon=this.envelope=void 0},n.prototype.get=function(t){return this.edges[t]},Object.defineProperty(n.prototype,"length",{get:function(){return this.edges.length},enumerable:!0,configurable:!0}),n.prototype.forEach=function(t){this.edges.forEach(t)},n.prototype.map=function(t){return this.edges.map(t)},n.prototype.some=function(t){return this.edges.some(t)},n.prototype.isValid=function(){return!0},n.prototype.isHole=function(){var t=this,e=this.edges.reduce(function(a,o,l){return o.from.coordinates[1]>t.edges[a].from.coordinates[1]&&(a=l),a},0),r=(0===e?this.length:e)-1,i=(e+1)%this.length,s=QF(this.edges[r].from.coordinates,this.edges[e].from.coordinates,this.edges[i].from.coordinates);return 0===s?this.edges[r].from.coordinates[0]>this.edges[i].from.coordinates[0]:s>0},n.prototype.toMultiPoint=function(){return function _U(n,t,e){return void 0===e&&(e={}),Cp({type:"MultiPoint",coordinates:n},t,e)}(this.edges.map(function(t){return t.from.coordinates}))},n.prototype.toPolygon=function(){if(this.polygon)return this.polygon;var t=this.edges.map(function(e){return e.from.coordinates});return t.push(this.edges[0].from.coordinates),this.polygon=ZC([t])},n.prototype.getEnvelope=function(){return this.envelope?this.envelope:this.envelope=function Zie(n){return function Yie(n,t){void 0===t&&(t={});var e=Number(n[0]),r=Number(n[1]),i=Number(n[2]),s=Number(n[3]);if(6===n.length)throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");var a=[e,r];return ZC([[a,[i,r],[i,s],[e,s],a]],t.properties,{bbox:n,id:t.id})}(gie(n))}(this.toPolygon())},n.findEdgeRingContaining=function(t,e){var i,s,r=t.getEnvelope();return e.forEach(function(a){var o=a.getEnvelope();if(s&&(i=s.getEnvelope()),!function Fae(n,t){var e=n.geometry.coordinates[0].map(function(a){return a[0]}),r=n.geometry.coordinates[0].map(function(a){return a[1]}),i=t.geometry.coordinates[0].map(function(a){return a[0]}),s=t.geometry.coordinates[0].map(function(a){return a[1]});return Math.max.apply(null,e)===Math.max.apply(null,i)&&Math.max.apply(null,r)===Math.max.apply(null,s)&&Math.min.apply(null,e)===Math.min.apply(null,i)&&Math.min.apply(null,r)===Math.min.apply(null,s)}(o,r)&&h5(o,r)){for(var l=t.map(function(D){return D.from.coordinates}),p=void 0,g=function(D){a.some(function(O){return function Lae(n,t){return n[0]===t[0]&&n[1]===t[1]}(D,O.from.coordinates)})||(p=D)},v=0,w=l;v<w.length;v++)g(w[v]);p&&a.inside(YC(p))&&(!s||h5(i,o))&&(s=a)}}),s},n.prototype.inside=function(t){return AU(t,this.toPolygon())},n}();function _5(n){for(var t=n,e=[];t.parent;)e.unshift(t),t=t.parent;return e}!function(){function n(){this.edges=[],this.nodes={}}n.fromGeoJson=function(t){!function Gae(n){if(!n)throw new Error("No geojson passed");if("FeatureCollection"!==n.type&&"GeometryCollection"!==n.type&&"MultiLineString"!==n.type&&"LineString"!==n.type&&"Feature"!==n.type)throw new Error("Invalid input type '"+n.type+"'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature")}(t);var e=new n;return jC(t,function(r){(function xie(n,t,e){if(!n)throw new Error("No feature passed");if(!e)throw new Error(".featureOf() requires a name");if(!n||"Feature"!==n.type||!n.geometry)throw new Error("Invalid input to "+e+", Feature with geometry required");if(!n.geometry||n.geometry.type!==t)throw new Error("Invalid input to "+e+": must be a "+t+", given "+n.geometry.type)})(r,"LineString","Graph::fromGeoJson"),function fie(n,t,e,r){var i=e;Ub(n,function(s,a,o,l,p){i=0===a&&void 0===e?s:t(i,s,a,o,l,p)},r)}(r,function(i,s){if(i){var a=e.getNode(i),o=e.getNode(s);e.addEdge(a,o)}return s})}),e},n.prototype.getNode=function(t){var e=p5.buildId(t),r=this.nodes[e];return r||(r=this.nodes[e]=new p5(t)),r},n.prototype.addEdge=function(t,e){var r=new zae(t,e),i=r.getSymetric();this.edges.push(r),this.edges.push(i)},n.prototype.deleteDangles=function(){var t=this;Object.keys(this.nodes).map(function(e){return t.nodes[e]}).forEach(function(e){return t._removeIfDangle(e)})},n.prototype._removeIfDangle=function(t){var e=this;if(t.innerEdges.length<=1){var r=t.getOuterEdges().map(function(i){return i.to});this.removeNode(t),r.forEach(function(i){return e._removeIfDangle(i)})}},n.prototype.deleteCutEdges=function(){var t=this;this._computeNextCWEdges(),this._findLabeledEdgeRings(),this.edges.forEach(function(e){e.label===e.symetric.label&&(t.removeEdge(e.symetric),t.removeEdge(e))})},n.prototype._computeNextCWEdges=function(t){var e=this;typeof t>"u"?Object.keys(this.nodes).forEach(function(r){return e._computeNextCWEdges(e.nodes[r])}):t.getOuterEdges().forEach(function(r,i){t.getOuterEdge((0===i?t.getOuterEdges().length:i)-1).symetric.next=r})},n.prototype._computeNextCCWEdges=function(t,e){for(var i,s,r=t.getOuterEdges(),a=r.length-1;a>=0;--a){var o=r[a],l=o.symetric,p=void 0,g=void 0;o.label===e&&(p=o),l.label===e&&(g=l),p&&g&&(g&&(s=g),p&&(s&&(s.next=p,s=void 0),i||(i=p)))}s&&(s.next=i)},n.prototype._findLabeledEdgeRings=function(){var t=[],e=0;return this.edges.forEach(function(r){if(!(r.label>=0)){t.push(r);var i=r;do{i.label=e,i=i.next}while(!r.isEqual(i));e++}}),t},n.prototype.getEdgeRings=function(){var t=this;this._computeNextCWEdges(),this.edges.forEach(function(r){r.label=void 0}),this._findLabeledEdgeRings().forEach(function(r){t._findIntersectionNodes(r).forEach(function(i){t._computeNextCCWEdges(i,r.label)})});var e=[];return this.edges.forEach(function(r){r.ring||e.push(t._findEdgeRing(r))}),e},n.prototype._findIntersectionNodes=function(t){var e=[],r=t,i=function(){var s=0;r.from.getOuterEdges().forEach(function(a){a.label===t.label&&++s}),s>1&&e.push(r.from),r=r.next};do{i()}while(!t.isEqual(r));return e},n.prototype._findEdgeRing=function(t){var e=t,r=new Vae;do{r.push(e),e.ring=r,e=e.next}while(!t.isEqual(e));return r},n.prototype.removeNode=function(t){var e=this;t.getOuterEdges().forEach(function(r){return e.removeEdge(r)}),t.innerEdges.forEach(function(r){return e.removeEdge(r)}),delete this.nodes[t.id]},n.prototype.removeEdge=function(t){this.edges=this.edges.filter(function(e){return!e.isEqual(t)}),t.deleteEdge()}}(),nn(5013),nn(7470),nn(5331);var i2={search:function(n,t,e,r){n.cleanDirty();var i=(r=r||{}).heuristic||i2.heuristics.manhattan,s=r.closest||!1,a=function soe(){return new N5(function(n){return n.f})}(),o=t;for(t.h=i(t,e),a.push(t);a.size()>0;){var l=a.pop();if(l===e)return _5(l);l.closed=!0;for(var p=n.neighbors(l),g=0,v=p.length;g<v;++g){var w=p[g];if(!w.closed&&!w.isWall()){var N=l.g+w.getCost(l),D=w.visited;(!D||N<w.g)&&(w.visited=!0,w.parent=l,w.h=w.h||i(w,e),w.g=N,w.f=w.g+w.h,n.markDirty(w),s&&(w.h<o.h||w.h===o.h&&w.g<o.g)&&(o=w),D?a.rescoreElement(w):a.push(w))}}}return s?_5(o):[]},heuristics:{manhattan:function(n,t){return Math.abs(t.x-n.x)+Math.abs(t.y-n.y)},diagonal:function(n,t){var r=Math.sqrt(2),i=Math.abs(t.x-n.x),s=Math.abs(t.y-n.y);return 1*(i+s)+(r-2)*Math.min(i,s)}},cleanNode:function(n){n.f=0,n.g=0,n.h=0,n.visited=!1,n.closed=!1,n.parent=null}};function zy(n,t){t=t||{},this.nodes=[],this.diagonal=!!t.diagonal,this.grid=[];for(var e=0;e<n.length;e++){this.grid[e]=[];for(var r=0,i=n[e];r<i.length;r++){var s=new s2(e,r,i[r]);this.grid[e][r]=s,this.nodes.push(s)}}this.init()}function s2(n,t,e){this.x=n,this.y=t,this.weight=e}function N5(n){this.content=[],this.scoreFunction=n}function tL(){this._=null}function a2(n){n.U=n.C=n.L=n.R=n.P=n.N=null}function Hb(n,t){var e=t,r=t.R,i=e.U;i?i.L===e?i.L=r:i.R=r:n._=r,r.U=i,e.U=r,e.R=r.L,e.R&&(e.R.U=e),r.L=e}function Xb(n,t){var e=t,r=t.L,i=e.U;i?i.L===e?i.L=r:i.R=r:n._=r,r.U=i,e.U=r,e.L=r.R,e.L&&(e.L.U=e),r.R=e}function S5(n){for(;n.L;)n=n.L;return n}zy.prototype.init=function(){this.dirtyNodes=[];for(var n=0;n<this.nodes.length;n++)i2.cleanNode(this.nodes[n])},zy.prototype.cleanDirty=function(){for(var n=0;n<this.dirtyNodes.length;n++)i2.cleanNode(this.dirtyNodes[n]);this.dirtyNodes=[]},zy.prototype.markDirty=function(n){this.dirtyNodes.push(n)},zy.prototype.neighbors=function(n){var t=[],e=n.x,r=n.y,i=this.grid;return i[e-1]&&i[e-1][r]&&t.push(i[e-1][r]),i[e+1]&&i[e+1][r]&&t.push(i[e+1][r]),i[e]&&i[e][r-1]&&t.push(i[e][r-1]),i[e]&&i[e][r+1]&&t.push(i[e][r+1]),this.diagonal&&(i[e-1]&&i[e-1][r-1]&&t.push(i[e-1][r-1]),i[e+1]&&i[e+1][r-1]&&t.push(i[e+1][r-1]),i[e-1]&&i[e-1][r+1]&&t.push(i[e-1][r+1]),i[e+1]&&i[e+1][r+1]&&t.push(i[e+1][r+1])),t},zy.prototype.toString=function(){for(var e,r,i,s,n=[],t=this.grid,a=0,o=t.length;a<o;a++){for(e=[],i=0,s=(r=t[a]).length;i<s;i++)e.push(r[i].weight);n.push(e.join(" "))}return n.join("\n")},s2.prototype.toString=function(){return"["+this.x+" "+this.y+"]"},s2.prototype.getCost=function(n){return n&&n.x!==this.x&&n.y!==this.y?1.41421*this.weight:this.weight},s2.prototype.isWall=function(){return 0===this.weight},N5.prototype={push:function(n){this.content.push(n),this.sinkDown(this.content.length-1)},pop:function(){var n=this.content[0],t=this.content.pop();return this.content.length>0&&(this.content[0]=t,this.bubbleUp(0)),n},remove:function(n){var t=this.content.indexOf(n),e=this.content.pop();t!==this.content.length-1&&(this.content[t]=e,this.scoreFunction(e)<this.scoreFunction(n)?this.sinkDown(t):this.bubbleUp(t))},size:function(){return this.content.length},rescoreElement:function(n){this.sinkDown(this.content.indexOf(n))},sinkDown:function(n){for(var t=this.content[n];n>0;){var e=(n+1>>1)-1,r=this.content[e];if(!(this.scoreFunction(t)<this.scoreFunction(r)))break;this.content[e]=t,this.content[n]=r,n=e}},bubbleUp:function(n){for(var t=this.content.length,e=this.content[n],r=this.scoreFunction(e);;){var o,i=n+1<<1,s=i-1,a=null;if(s<t&&(o=this.scoreFunction(this.content[s]))<r&&(a=s),i<t&&this.scoreFunction(this.content[i])<(null===a?r:o)&&(a=i),null===a)break;this.content[n]=this.content[a],this.content[a]=e,n=a}}},tL.prototype={constructor:tL,insert:function(n,t){var e,r,i;if(n){if(t.P=n,t.N=n.N,n.N&&(n.N.P=t),n.N=t,n.R){for(n=n.R;n.L;)n=n.L;n.L=t}else n.R=t;e=n}else this._?(n=S5(this._),t.P=null,t.N=n,n.P=n.L=t,e=n):(t.P=t.N=null,this._=t,e=null);for(t.L=t.R=null,t.U=e,t.C=!0,n=t;e&&e.C;)e===(r=e.U).L?(i=r.R)&&i.C?(e.C=i.C=!1,r.C=!0,n=r):(n===e.R&&(Hb(this,e),e=(n=e).U),e.C=!1,r.C=!0,Xb(this,r)):(i=r.L)&&i.C?(e.C=i.C=!1,r.C=!0,n=r):(n===e.L&&(Xb(this,e),e=(n=e).U),e.C=!1,r.C=!0,Hb(this,r)),e=n.U;this._.C=!1},remove:function(n){n.N&&(n.N.P=n.P),n.P&&(n.P.N=n.N),n.N=n.P=null;var e,s,a,t=n.U,r=n.L,i=n.R;if(s=r?i?S5(i):r:i,t?t.L===n?t.L=s:t.R=s:this._=s,r&&i?(a=s.C,s.C=n.C,s.L=r,r.U=s,s!==i?(t=s.U,s.U=n.U,t.L=n=s.R,s.R=i,i.U=s):(s.U=t,t=s,n=s.R)):(a=n.C,n=s),n&&(n.U=t),!a){if(n&&n.C)return void(n.C=!1);do{if(n===this._)break;if(n===t.L){if((e=t.R).C&&(e.C=!1,t.C=!0,Hb(this,t),e=t.R),e.L&&e.L.C||e.R&&e.R.C){(!e.R||!e.R.C)&&(e.L.C=!1,e.C=!0,Xb(this,e),e=t.R),e.C=t.C,t.C=e.R.C=!1,Hb(this,t),n=this._;break}}else if((e=t.L).C&&(e.C=!1,t.C=!0,Xb(this,t),e=t.L),e.L&&e.L.C||e.R&&e.R.C){(!e.L||!e.L.C)&&(e.R.C=!1,e.C=!0,Hb(this,e),e=t.L),e.C=t.C,t.C=e.L.C=!1,Xb(this,t),n=this._;break}e.C=!0,n=t,t=t.U}while(!n.C);n&&(n.C=!1)}}};const E5=tL;function Kb(n,t,e,r){var i=[null,null],s=dl.push(i)-1;return i.left=n,i.right=t,e&&o2(i,n,t,e),r&&o2(i,t,n,r),Vc[n.index].halfedges.push(s),Vc[t.index].halfedges.push(s),i}function Yb(n,t,e){var r=[t,e];return r.left=n,r}function o2(n,t,e,r){n[0]||n[1]?n.left===e?n[1]=r:n[0]=r:(n[0]=r,n.left=t,n.right=e)}function ooe(n,t,e,r,i){var O,s=n[0],a=n[1],o=s[0],l=s[1],v=0,w=1,N=a[0]-o,D=a[1]-l;if(O=t-o,N||!(O>0)){if(O/=N,N<0){if(O<v)return;O<w&&(w=O)}else if(N>0){if(O>w)return;O>v&&(v=O)}if(O=r-o,N||!(O<0)){if(O/=N,N<0){if(O>w)return;O>v&&(v=O)}else if(N>0){if(O<v)return;O<w&&(w=O)}if(O=e-l,D||!(O>0)){if(O/=D,D<0){if(O<v)return;O<w&&(w=O)}else if(D>0){if(O>w)return;O>v&&(v=O)}if(O=i-l,D||!(O<0)){if(O/=D,D<0){if(O>w)return;O>v&&(v=O)}else if(D>0){if(O<v)return;O<w&&(w=O)}return!(v>0)&&!(w<1)||(v>0&&(n[0]=[o+v*N,l+v*D]),w<1&&(n[1]=[o+w*N,l+w*D])),!0}}}}}function uoe(n,t,e,r,i){var s=n[1];if(s)return!0;var O,k,a=n[0],o=n.left,l=n.right,p=o[0],g=o[1],v=l[0],w=l[1],N=(p+v)/2;if(w===g){if(N<t||N>=r)return;if(p>v){if(a){if(a[1]>=i)return}else a=[N,e];s=[N,i]}else{if(a){if(a[1]<e)return}else a=[N,i];s=[N,e]}}else if(k=(g+w)/2-(O=(p-v)/(w-g))*N,O<-1||O>1)if(p>v){if(a){if(a[1]>=i)return}else a=[(e-k)/O,e];s=[(i-k)/O,i]}else{if(a){if(a[1]<e)return}else a=[(i-k)/O,i];s=[(e-k)/O,e]}else if(g<w){if(a){if(a[0]>=r)return}else a=[t,O*t+k];s=[r,O*r+k]}else{if(a){if(a[0]<t)return}else a=[r,O*r+k];s=[t,O*t+k]}return n[0]=a,n[1]=s,!0}function foe(n,t){var e=n.site,r=t.left,i=t.right;return e===i&&(i=r,r=e),i?Math.atan2(i[1]-r[1],i[0]-r[0]):(e===r?(r=t[1],i=t[0]):(r=t[0],i=t[1]),Math.atan2(r[0]-i[0],i[1]-r[1]))}function I5(n,t){return t[+(t.left!==n.site)]}function hoe(n,t){return t[+(t.left===n.site)]}var nL,C5=[];function moe(){a2(this),this.x=this.y=this.arc=this.site=this.cy=null}function Uy(n){var t=n.P,e=n.N;if(t&&e){var r=t.site,i=n.site,s=e.site;if(r!==s){var a=i[0],o=i[1],l=r[0]-a,p=r[1]-o,g=s[0]-a,v=s[1]-o,w=2*(l*v-p*g);if(!(w>=-boe)){var N=l*l+p*p,D=g*g+v*v,O=(v*N-p*D)/w,k=(l*D-g*N)/w,L=C5.pop()||new moe;L.arc=n,L.site=i,L.x=O+a,L.y=(L.cy=k+o)+Math.sqrt(O*O+k*k),n.circle=L;for(var $=null,U=Zb._;U;)if(L.y<U.y||L.y===U.y&&L.x<=U.x){if(!U.L){$=U.P;break}U=U.L}else{if(!U.R){$=U;break}U=U.R}Zb.insert($,L),$||(nL=L)}}}}function Vy(n){var t=n.circle;t&&(t.P||(nL=t.N),Zb.remove(t),C5.push(t),a2(t),n.circle=null)}var A5=[];function goe(){a2(this),this.edge=this.site=this.circle=null}function T5(n){var t=A5.pop()||new goe;return t.site=n,t}function rL(n){Vy(n),Gy.remove(n),A5.push(n),a2(n)}function yoe(n){var t=n.circle,e=t.x,r=t.cy,i=[e,r],s=n.P,a=n.N,o=[n];rL(n);for(var l=s;l.circle&&Math.abs(e-l.circle.x)<La&&Math.abs(r-l.circle.cy)<La;)s=l.P,o.unshift(l),rL(l),l=s;o.unshift(l),Vy(l);for(var p=a;p.circle&&Math.abs(e-p.circle.x)<La&&Math.abs(r-p.circle.cy)<La;)a=p.N,o.push(p),rL(p),p=a;o.push(p),Vy(p);var v,g=o.length;for(v=1;v<g;++v)o2((p=o[v]).edge,(l=o[v-1]).site,p.site,i);(p=o[g-1]).edge=Kb((l=o[0]).site,p.site,null,i),Uy(l),Uy(p)}function voe(n){for(var r,i,s,a,t=n[0],e=n[1],o=Gy._;o;)if((s=M5(o,e)-t)>La)o=o.L;else{if(!((a=t-xoe(o,e))>La)){s>-La?(r=o.P,i=o):a>-La?(r=o,i=o.N):r=i=o;break}if(!o.R){r=o;break}o=o.R}!function coe(n){Vc[n.index]={site:n,halfedges:[]}}(n);var l=T5(n);if(Gy.insert(r,l),r||i){if(r===i)return Vy(r),i=T5(r.site),Gy.insert(l,i),l.edge=i.edge=Kb(r.site,l.site),Uy(r),void Uy(i);if(!i)return void(l.edge=Kb(r.site,l.site));Vy(r),Vy(i);var p=r.site,g=p[0],v=p[1],w=n[0]-g,N=n[1]-v,D=i.site,O=D[0]-g,k=D[1]-v,L=2*(w*k-N*O),$=w*w+N*N,U=O*O+k*k,V=[(k*$-N*U)/L+g,(w*U-O*$)/L+v];o2(i.edge,p,D,V),l.edge=Kb(p,n,null,V),i.edge=Kb(n,D,null,V),Uy(r),Uy(i)}}function M5(n,t){var e=n.site,r=e[0],i=e[1],s=i-t;if(!s)return r;var a=n.P;if(!a)return-1/0;var o=(e=a.site)[0],l=e[1],p=l-t;if(!p)return o;var g=o-r,v=1/s-1/p,w=g/p;return v?(-w+Math.sqrt(w*w-2*v*(g*g/(-2*p)-l+p/2+i-s/2)))/v+r:(r+o)/2}function xoe(n,t){var e=n.N;if(e)return M5(e,t);var r=n.site;return r[1]===t?r[0]:1/0}var Gy,Vc,Zb,dl,La=1e-6,boe=1e-12;function woe(n,t,e){return(n[0]-e[0])*(t[1]-n[1])-(n[0]-t[0])*(e[1]-n[1])}function _oe(n,t){return t[1]-n[1]||t[0]-n[0]}function R5(n,t){var r,i,s,e=n.sort(_oe).pop();for(dl=[],Vc=new Array(n.length),Gy=new E5,Zb=new E5;;)if(s=nL,e&&(!s||e[1]<s.y||e[1]===s.y&&e[0]<s.x))(e[0]!==r||e[1]!==i)&&(voe(e),r=e[0],i=e[1]),e=n.pop();else{if(!s)break;yoe(s.arc)}if(function poe(){for(var e,r,i,s,n=0,t=Vc.length;n<t;++n)if((e=Vc[n])&&(s=(r=e.halfedges).length)){var a=new Array(s),o=new Array(s);for(i=0;i<s;++i)a[i]=i,o[i]=foe(e,dl[r[i]]);for(a.sort(function(l,p){return o[p]-o[l]}),i=0;i<s;++i)o[i]=r[a[i]];for(i=0;i<s;++i)r[i]=o[i]}}(),t){var a=+t[0][0],o=+t[0][1],l=+t[1][0],p=+t[1][1];(function loe(n,t,e,r){for(var s,i=dl.length;i--;)uoe(s=dl[i],n,t,e,r)&&ooe(s,n,t,e,r)&&(Math.abs(s[0][0]-s[1][0])>La||Math.abs(s[0][1]-s[1][1])>La)||delete dl[i]})(a,o,l,p),function doe(n,t,e,r){var s,a,o,l,p,g,v,w,N,D,O,k,i=Vc.length,L=!0;for(s=0;s<i;++s)if(a=Vc[s]){for(o=a.site,l=(p=a.halfedges).length;l--;)dl[p[l]]||p.splice(l,1);for(l=0,g=p.length;l<g;)O=(D=hoe(a,dl[p[l]]))[0],k=D[1],w=(v=I5(a,dl[p[++l%g]]))[0],N=v[1],(Math.abs(O-w)>La||Math.abs(k-N)>La)&&(p.splice(l,0,dl.push(Yb(o,D,Math.abs(O-n)<La&&r-k>La?[n,Math.abs(w-n)<La?N:r]:Math.abs(k-r)<La&&e-O>La?[Math.abs(N-r)<La?w:e,r]:Math.abs(O-e)<La&&k-t>La?[e,Math.abs(w-e)<La?N:t]:Math.abs(k-t)<La&&O-n>La?[Math.abs(N-t)<La?w:n,t]:null))-1),++g);g&&(L=!1)}if(L){var $,U,V,W=1/0;for(s=0,L=null;s<i;++s)(a=Vc[s])&&(V=($=(o=a.site)[0]-n)*$+(U=o[1]-t)*U)<W&&(W=V,L=a);if(L){var ce=[n,t],ve=[n,r],Ee=[e,r],ge=[e,t];L.halfedges.push(dl.push(Yb(o=L.site,ce,ve))-1,dl.push(Yb(o,ve,Ee))-1,dl.push(Yb(o,Ee,ge))-1,dl.push(Yb(o,ge,ce))-1)}}for(s=0;s<i;++s)(a=Vc[s])&&(a.halfedges.length||delete Vc[s])}(a,o,l,p)}this.edges=dl,this.cells=Vc,Gy=Zb=dl=Vc=null}function Od(){return new u2}function u2(){this.reset()}R5.prototype={constructor:R5,polygons:function(){var n=this.edges;return this.cells.map(function(t){var e=t.halfedges.map(function(r){return I5(t,n[r])});return e.data=t.site.data,e})},triangles:function(){var n=[],t=this.edges;return this.cells.forEach(function(e,r){if(o=(s=e.halfedges).length)for(var s,o,l,i=e.site,a=-1,p=t[s[o-1]],g=p.left===i?p.right:p.left;++a<o;)l=g,g=(p=t[s[a]]).left===i?p.right:p.left,l&&g&&r<l.index&&r<g.index&&woe(i,l,g)<0&&n.push([i.data,l.data,g.data])}),n},links:function(){return this.edges.filter(function(n){return n.right}).map(function(n){return{source:n.left.data,target:n.right.data}})},find:function(n,t,e){for(var i,o,r=this,s=r._found||0,a=r.cells.length;!(o=r.cells[s]);)if(++s>=a)return null;var l=n-o.site[0],p=t-o.site[1],g=l*l+p*p;do{o=r.cells[i=s],s=null,o.halfedges.forEach(function(v){var w=r.edges[v],N=w.left;if(N!==o.site&&N||(N=w.right)){var D=n-N[0],O=t-N[1],k=D*D+O*O;k<g&&(g=k,s=N.index)}})}while(null!==s);return r._found=i,null==e||g<=e*e?o.site:null}},nn(9855),nn(770),u2.prototype={constructor:u2,reset:function(){this.s=this.t=0},add:function(n){V5(l2,n,this.t),V5(this,l2.s,this.s),this.s?this.t+=l2.t:this.s=l2.t},valueOf:function(){return this.s}};var l2=new u2;function V5(n,t,e){var r=n.s=t+e,i=r-t;n.t=t-(r-i)+(e-i)}var Ka=Math.PI,pc=Ka/2,qy=2*Ka,Na=Ka/180,jb=(Math,Math.atan),Wy=Math.atan2,gs=Math.cos,Vi=(Math,Math,Math,Math,Math,Math.sin),Ap=(Math,Math.sqrt);Math;function Hy(n){return n>1?pc:n<-1?-pc:Math.asin(n)}function yL(n,t){return[n>Ka?n-qy:n<-Ka?n+qy:n,t]}function m6(n,t){return n<t?-1:n>t?1:n>=t?0:NaN}Od(),Od(),Od(),yL.invert=yL,function eue(n){1===n.length&&(n=function tue(n){return function(t,e){return m6(n(t),e)}}(n))}(m6),Math.sqrt(50),Math.sqrt(10),Math.sqrt(2);Od();function FL(){}function U6(n){return function(t,e){var r=gs(t),i=gs(e),s=n(r*i);return[s*i*Vi(t),s*Vi(e)]}}function ow(n){return function(t,e){var r=Ap(t*t+e*e),i=n(r),s=Vi(i),a=gs(i);return[Wy(t*s,r*a),Hy(r&&e*s/r)]}}function $L(n,t){return[n,t]}Od(),Od(),Od(),Od(),function $6(n){return"m0,"+n+"a"+n+","+n+" 0 1,1 0,"+-2*n+"a"+n+","+n+" 0 1,1 0,"+2*n+"z"}(4.5),FL.prototype={constructor:FL,point:function(n,t){this.stream.point(n,t)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}},gs(30*Na),function B6(n){return function(t){var e=new FL;for(var r in n)e[r]=n[r];return e.stream=t,e}}({point:function(n,t){this.stream.point(n*Na,t*Na)}}),U6(function(n){return Ap(2/(1+n))}).invert=ow(function(n){return 2*Hy(n/2)}),U6(function(n){return(n=function Foe(n){return n>1?0:n<-1?Ka:Math.acos(n)}(n))&&n/Vi(n)}).invert=ow(function(n){return n}),$L.invert=$L,ow(jb),ow(Hy),ow(function(n){return 2*jb(n)}),addEventListener("message",({data:n})=>{(0,$n.setBackend)(qn);let t=function jue(n,t){try{return new $n.KMeans({nClusters:n,randomState:0}).fitPredict(t).arraySync()}catch(e){return console.warn(e),null}}(n.k,n.patientLocations);const e={labels:t};let r={};null!=t?(r.status=zb.Complete,r.data=e):(r.status=zb.Error,r.message="K means failed!"),postMessage(r)})})()})();